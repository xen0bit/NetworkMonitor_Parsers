//#  (c) 2009 CodePlex Foundation
//#
//#  Title:                  Object Linking & Embedding (OLE) Automation Protocol
//#
//#  Details:                
//#
//#  Microsoft References:   [MS-OAUT]: OLE Automation Protocol Specification
//#
//#  Comments:               
//#
//#  Revision Class and Date:Minor, 3/2/2010
//#
//####

//
//	TODO: Add entry in DCOM
//
Protocol OLEAUT = (MSRPCptype == 0x00) ? FormatString("%s(%s)", OLEAUTGlobalMethodTable(MSRPCIfUuid, MSRPCopnum), Local.DecomParameters) :
										 FormatString("%s = %s", OLEAUTGlobalMethodTable(MSRPCIfUuid, MSRPCopnum), RAPRDecomResult)
{
	[Local.DecomParameters = ""]
	switch (Property.MSRPCIfUuid)
	{
		case "{00020400-0000-0000-C000-000000000046}":
		_struct IDispatch
		{
			switch (Property.MSRPCopnum)
			{
				case 0x03:
					_struct GetTypeInfoCount
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												UINT32 pctInfo;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}
				case 0x04:
					_struct GetTypeInfo
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												UINT32 iTInfo;
												OLEAUTLCID Lcid;
											}
									}

								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												NdrPtr pTInfo;
												switch
												{
													case pTInfo.ReferentID:
														DCOMMInterfacePointer TInfo;
												}
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}
				case 0x05:
					_struct GetIDsOfNames
					{
						switch (Property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												OLEAUTRefIId riid;
												NdrConformant NamesCount;
												OLEAUTLPOLESTR(NamesCount.MaxCount) rgszNames;
												Align4 pad;
												UINT32 cNames;
												OLEAUTLCID lcid;
											}
									}

								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												NdrConformant prgDispId;
												OLEAUTDISPID rgDispId[prgDispId.MaxCount];
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}
				case 0x06:
				_struct Invoke
				{
					switch (Property.MSRPCptype)
					{
						case 0x00:
						_struct Request
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										OLEAUTDISPID dispIdMember;
										OLEAUTRefIId riid;
										OLEAUTLCID lcid;
										switch( Property.MSRPCByteOrder )
										{
											case LittleEndian:
												_struct LittleEndian
												{
													UINT32 dwFlags
													{
														[Local.InvocationType = this ? "Method" : Local.InvocationType]
														UINT32 Method:1 = FormatString("        (%s) %s", this.ToBitString, this ? "Invoked as a method" : "Not invoked as a method");
														[Local.InvocationType = this ? "PropertyGet" : Local.InvocationType]
														UINT32 PropertyGet:1 = FormatString("   (%s) %s", this.ToBitString, this ? "Retrieved as a property or data membe" : "Not retrieved as a property or data membe");
														[Local.InvocationType = this ? "PropertyPut" : Local.InvocationType]
														UINT32 PropertyPut:1 = FormatString("   (%s) %s", this.ToBitString, this ? "Changed as a property or data member" : "Not changed as a property or data member");
														[Local.InvocationType = this ? "PropertyPutRef" : Local.InvocationType]
														UINT32 PropertyPutRef:1 = FormatString("(%s) %s", this.ToBitString, this ? "Changed by a reference assignment" : "Not changed by a value assignment");
														UINT32 Reserved1:13 = FormatString("     (%s)", this.ToBitString);
														UINT32 ZeroVarResult:1 = FormatString(" (%s) %s", this.ToBitString, this ? "Not interested in the actual pVarResult argument" : "Interested in the actual pVarResult argument");
														UINT32 ZeroExcepInfo:1 = FormatString(" (%s) %s", this.ToBitString, this ? "Not interested in the actual pExcepInfo argument" : "Interested in the actual pExcepInfo argument");
														UINT32 ZeroArgErr:1 = FormatString("    (%s) %s", this.ToBitString, this ? "Not interested in the actual pArgerr argument" : "Interested in the actual pArgerr argument");
														UINT32 Reserved2:12 = FormatString("     (%s)", this.ToBitString);
													}
												}
											default:
												_struct BigEndian
												{
													UINT32 dwFlags
													{
														UINT32 Reserved2:12 = FormatString("     (%s)", this.ToBitString);
														UINT32 ZeroArgErr:1 = FormatString("    (%s) %s", this.ToBitString, this ? "Not interested in the actual pArgerr argument" : "Interested in the actual pArgerr argument");
														UINT32 ZeroExcepInfo:1 = FormatString(" (%s) %s", this.ToBitString, this ? "Not interested in the actual pExcepInfo argument" : "Interested in the actual pExcepInfo argument");
														UINT32 ZeroVarResult:1 = FormatString(" (%s) %s", this.ToBitString, this ? "Not interested in the actual pVarResult argument" : "Interested in the actual pVarResult argument");
														UINT32 Reserved1:13 = FormatString("     (%s)", this.ToBitString);
														[Local.InvocationType = this ? "PropertyPutRef" : Local.InvocationType]
														UINT32 PropertyPutRef:1 = FormatString("(%s) %s", this.ToBitString, this ? "Changed by a reference assignment" : "changed by a value assignment");
														[Local.InvocationType = this ? "PropertyPut" : Local.InvocationType]
														UINT32 PropertyPut:1 = FormatString("   (%s) %s", this.ToBitString, this ? "Changed as a property or data member" : "Not changed as a property or data member");
														[Local.InvocationType = this ? "PropertyGet" : Local.InvocationType]
														UINT32 PropertyGet:1 = FormatString("   (%s) %s", this.ToBitString, this ? "Retrieved as a property or data membe" : "Not retrieved as a property or data membe");
														[Local.InvocationType = this ? "Method" : Local.InvocationType]
														UINT32 Method:1 = FormatString("        (%s) %s", this.ToBitString, this ? "Invoked as a method" : "Not invoked as a method");
													}
												}
										}
										[Local.DecomParameters = FormatString("dispIdMemeber = %s, InvocationType = %s", dispIdMember.ToString, Local.InvocationType)]
										OLEAUTDISPPARAMS DispParams;
										UINT32 cVarRef;
										NdrConformant VarRefIdxConformant;
										UINT32 rgVarRefIdx[VarRefIdxConformant.MaxCount];
										OLEAUTSafeArrVariant VarRef;
									}
							}
						}
						case 0x02:
						_struct Response
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										OLEAUTVariant VarResult;
										NdrAlign pad;
										OLEAUTExcepInfo ExcepInfo;
										UINT32 Argerr;
										OLEAUTSafeArrVariant rgVarRef;
										Align4 padding;
										[RAPRDecomResult = HResult.ToString]
										HRESULT HResult;
									}
							}
						}
					}
				}
			}
		}

		case "{00020404-0000-0000-C000-000000000046}":
		_struct IEnumVARIANT
		{
			switch (Property.MSRPCopnum)
			{
				case 0x03:
				_struct Next
				{
					switch (Property.MSRPCptype)
					{
						case 0x00:
						_struct Request
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										[Local.DecomParameters = FormatString("celt = %d", celt)]
										UINT32 celt;
									}
							}

						}
						case 0x02:
						_struct Response
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										NdrConformantVarying VarCount;
										NdrPtr ReferentId[VarCount.ActualCount];
										OLEAUTWireVariant rgVar[VarCount.ActualCount];
										Align4 Align;
										UINT32 CeltFetched;
										[RAPRDecomResult = HResult.ToString]
										HRESULT HResult;
									}
							}

						}
					}
				}
				case 0x04:
				_struct Skip
				{
					switch (Property.MSRPCptype)
					{
						case 0x00:
						_struct Request
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										[Local.DecomParameters = FormatString("celt = %d", celt)]
										UINT32 celt;
									}
							}

						}
						case 0x02:
						_struct Response
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										[RAPRDecomResult = HResult.ToString]
										HRESULT HResult;
									}
							}

						}
					}
				}
				case 0x05:
				_struct Reset
				{
					switch (Property.MSRPCptype)
					{
						case 0x00:
						_struct Request
						{
						}
						case 0x02:
						_struct Response
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										[RAPRDecomResult = HResult.ToString]
										HRESULT HResult;
									}
							}

						}
					}
				}
				case 0x06:
				_struct Clone
				{
					switch (Property.MSRPCptype)
					{
						case 0x00:
						_struct Request
						{
						}
						case 0x02:
						_struct Response
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										[Property.OLEAUTCustomObjectType = "IEnumVARIANT"]
										DCOMMInterfacePointerPtr ppEnum;
										Align4 Pad;
										[RAPRDecomResult = HResult.ToString]
										HRESULT HResult;
									}
							}
						}
					}
				}
			}
		}

		case "{00020403-0000-0000-C000-000000000046}":
		_struct ITypeComp
		{
			switch(property.MSRPCOpnum)
			{
				case 3:
					_struct Bind
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												NdrWideString szName;
												Align4 Pad;
												UINT32 lHashVal;
												UINT16 wFlags = OLEAUTInvokeKindTable(this);
											}
									}

								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												DCOMMInterfacePointerPtr ppTInfo;
												NdrV1Enum(4) pDescKind = OLEAUTDescKindTable(this);
												NdrPtr PtrFuncDesc;
												switch
												{
													case PtrFuncDesc.ReferentID:
													struct
													{
														NdrAlign Pad;
														OLEAUTFuncDesc FuncDesc;
													}
												}
												NdrPtr PtrVarDesc;
												switch
												{
													case PtrVarDesc.ReferentID:
														switch(pDescKind)
														{
															case 0x00000002:
															case 0x00000004:
															struct	
																{
																	NdrAlign Pad;
																	OLEAUTVarDesc VarDesc;
																}
														}
												}
												NdrPtr PtrTypeComp;
												switch
												{
													case PtrTypeComp.ReferentID:
														DCOMMInterfacePointer TypeComp;
												}
												Align4 Align;
												UINT32 pReserved;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}
								}
						}
					}
				case 4:
					_struct BindType
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												NdrWideString szName;
												Align4 Pad;
												UINT32 lHashVal;
											}
									}
								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												DCOMMInterfacePointerPtr ppTInfo;
												Align4 Align;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}
								}
						}
					}
			}
		}

		// ITypeInfo
		case "{00020401-0000-0000-C000-000000000046}":
		_struct ITypeInfo
		{
			switch(property.MSRPCOpnum)
			{
				case 3:
					_struct GetTypeAttr
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												NdrPtr PtrTypeAttr;
												switch
												{
													case PtrTypeAttr.ReferentID:
													struct
													{
														NdrAlign Pad;
														OLEAUTTypeAttr ppTypeAttr;
													}
												}
												ALIGN4 Padding;
												UINT32 pReserved;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}
				case 4:
					_struct GetTypeComp
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												DCOMMInterfacePointerPtr ppTComp;
												Align4 pad;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}
								}
						}
					}
				case 5:
					_struct GetFuncDesc
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												UINT32 index;
											}
									}
								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												NdrPtr PtrFuncDesc;
												switch
												{
													case PtrFuncDesc.ReferentID:struct
													{
														NdrAlign Pad;
														OLEAUTFuncDesc FuncDesc;
													}
												}
												ALIGN4 Padding;
												UINT32 pReserved;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}
								}
						}
					}
				case 6:
					_struct GetVarDesc
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												UINT32 index;
											}
									}
								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												NdrPtr PtrVarDesc;
												switch
												{
													case PtrVarDesc.ReferentID:
													struct	
													{
														NdrAlign Pad;
														OLEAUTVarDesc VarDesc;
													}
												}
												Align4 Padding;
												UINT32 pReserved;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}
								}
						}
					}
				case 7:
					_struct GetNames
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												OLEAUTDISPID memid;
												UINT32 cMaxNames;
											}
									}
								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												OLEAUTSafeArrBstrConformantVarying BstrArray;
												ALIGN4 Pad;
												UINT32 pcNames;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}
								}
						}
					}
				case 8:
					_struct GetRefTypeOfImplType
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												UINT32 index;
											}
									}
								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												UINT32 pRefType;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}
								}
						}
					}
				case 9:
					_struct GetImplTypeFlags
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												UINT32 index;
											}
									}
								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												UINT32 pImplTypeFlags
												{
													UINT32 FDEFAULT:1 = FormatString("      (%s) %s", this.ToBitString, this? "[default] attribute": "");
													UINT32 FSOURCE:1 = FormatString("       (%s) %s", this.ToBitString, this? "[source] or [defaultvtable] attributes": "");
													UINT32 FRESTRICTED:1 = FormatString("   (%s) %s", this.ToBitString, this? "[restricted] attribute": "");
													UINT32 FDEFAULTVTABLE:1 = FormatString("(%s) %s", this.ToBitString, this? "[defaultvtable] attribute": "");
													UINT32 Reserved:28 = FormatString("      (%s)", this.ToBitString);
												}
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}
								}
						}
					}
				case 12:
					_struct GetDocumentation
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												OLEAUTDISPID memid;
												UINT32 refPtrFlags
												{
													UINT32 NameArg:1 = FormatString("       (%s) %s", this.ToBitString, this? "pBstrName [out] argument": "");
													UINT32 DocStringArg:1 = FormatString("  (%s) %s", this.ToBitString, this? "pBstrDocString [out] argument": "");
													UINT32 HelpContextArg:1 = FormatString("(%s) %s", this.ToBitString, this? "pdwHelpContext [out] argument": "");
													UINT32 HelpFileArg:1 = FormatString("   (%s) %s", this.ToBitString, this? "pBstrHelpFile [out] argument": "");
													UINT32 Reserved:28 = FormatString("      (%s)", this.ToBitString);
												};
											}
									}
								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												BSTR pBstrName;
												BSTR pBstrDocString;
												Align4 pad1;
												UINT32 pdwHelpContext;
												BSTR pBstrHelpFile;
												Align4	Pad2;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}
				case 13:
					_struct GetDllEntry
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												OLEAUTDISPID memid;
												UINT32 InvokeKind = OLEAUTInvokeKindTable(this);
												UINT32 refPtrFlags
												{
													UINT32 DLLNameArg:1 = FormatString("(%s) %s", this.ToBitString, this? "pBstrDllName [out] argument": "");
													UINT32 NameArg:1 = FormatString("(%s) %s", this.ToBitString, this? "pBstrName [out] argument": "");
													UINT32 OrdinalArg:1 = FormatString("(%s) %s", this.ToBitString, this? "pwOrdinal [out] argument": "");
													UINT32 Reserved:29 = FormatString("(%s)", this.ToBitString);
												};
											}
									}

								}
							case 0x02:
								_struct Resposne
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												BSTR pBstrDllName;
												BSTR pBstrName;
												UINT16 pwOrdinal;
												Align4 Pad;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}
								}
						}
					}
				case 14:
					_struct GetRefTypeInfo
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												UINT32 pRefType;
											}
									}

								}
							case 0x02:
								_struct Resposne
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												DCOMMInterfacePointerPtr ppTInfo;
												Align4 pad;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}
								}
						}
					}
				case 16:
					_struct CreateInstance
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												OLEAUTREFIID riid;
											}
									}

								}
							case 0x02:
								_struct Resposne
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												// not sure...
												DCOMMInterfacePointerPtr IUnknown;
												Align4 Pad;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}
								}
						}
					}
				case 17:
					_struct GetMops
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												OLEAUTDISPID memid;
											}
									}

								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												BSTR pBstrMops;
												Align4 Pad;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}
				case 18:
					_struct GetContainingTypeLib
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												DCOMMInterfacePointerPtr ppTLib;
												Align4 pad;
												UINT32 pIndex;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}
				//10,11,15,19~21 
				case 10:
				case 11:
				case 15:
				case 19:
				case 20:
				case 21:
					struct NotUsedOnWire
					{
						Switch (property.MSRPCPType)
						{
					// REQUEST
							case 0x00:
							[post.Description = "OPNUM:" + Property.MSRPCOpnum + " request is Not used on wire"]
							struct Request 
							{
								ReportParserWarning("OAUT", "Invalid oaut method, Opnum:" + Property.MSRPCOpnum) ProtocolWarning;
								Blob(FrameLength - Offset) PayloadData;
							}

					// RESPONSE
							case 0x02:
							[post.Description = "OPNUM:" + Property.MSRPCOpnum + " response is Not used on wire"]
							struct Response
							{
								ReportParserWarning("OAUT", "Invalid oaut method, Opnum:" + Property.MSRPCOpnum) ProtocolWarning;
								Blob(FrameLength - Offset) PayloadData;					
							}
						}
					}
			}
		}
		// ITypeInfo2
		case "{00020412-0000-0000-C000-000000000046}":
		_struct ITypeInfo2
		{
			switch(property.MSRPCOpnum)
			{
				case 3:
					_struct GetTypeAttr
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												NdrPtr PtrTypeAttr;
												switch
												{
													case PtrTypeAttr.ReferentID:
													struct
													{
														NdrAlign Pad;
														OLEAUTTypeAttr ppTypeAttr;
													}
												}
												ALIGN4 Padding;
												UINT32 pReserved;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}
				case 4:
					_struct GetTypeComp
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												DCOMMInterfacePointerPtr ppTComp;
												Align4 pad;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}
				case 5:
					_struct GetFuncDesc
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												UINT32 index;
											}
									}

								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												NdrPtr PtrFuncDesc;
												switch
												{
													case PtrFuncDesc.ReferentID:struct
													{
														NdrAlign Pad;
														OLEAUTFuncDesc FuncDesc;
													}
												}
												ALIGN4 Padding;
												UINT32 pReserved;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}
				case 6:
					_struct GetVarDesc
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												UINT32 index;
											}
									}

								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												NdrPtr PtrVarDesc;
												switch
												{
													case PtrVarDesc.ReferentID:
													struct	
													{
														NdrAlign Pad;
														OLEAUTVarDesc VarDesc;
													}
												}
												Align4 Padding;
												UINT32 pReserved;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}
				case 7:
					_struct GetNames
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												OLEAUTDISPID memid;
												UINT32 cMaxNames;
											}
									}

								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												OLEAUTSafeArrBstrConformantVarying BstrArray;
												ALIGN4 Pad;
												UINT32 pcNames;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}
				case 8:
					_struct GetRefTypeOfImplType
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												UINT32 index;
											}
									}

								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												UINT32 pRefType;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}
				case 9:
					_struct GetImplTypeFlags
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												UINT32 index;
											}
									}

								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												UINT32 pImplTypeFlags
												{
													UINT32 FDEFAULT:1 = FormatString("      (%s) %s", this.ToBitString, this? "[default] attribute": "");
													UINT32 FSOURCE:1 = FormatString("       (%s) %s", this.ToBitString, this? "[source] or [defaultvtable] attributes": "");
													UINT32 FRESTRICTED:1 = FormatString("   (%s) %s", this.ToBitString, this? "[restricted] attribute": "");
													UINT32 FDEFAULTVTABLE:1 = FormatString("(%s) %s", this.ToBitString, this? "[defaultvtable] attribute": "");
													UINT32 Reserved:28 = FormatString("      (%s)", this.ToBitString);
												}
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}
				case 12:
					_struct GetDocumentation
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												OLEAUTDISPID memid;
												UINT32 refPtrFlags
												{
													UINT32 NameArg:1 = FormatString("       (%s) %s", this.ToBitString, this? "pBstrName [out] argument": "");
													UINT32 DocStringArg:1 = FormatString("  (%s) %s", this.ToBitString, this? "pBstrDocString [out] argument": "");
													UINT32 HelpContextArg:1 = FormatString("(%s) %s", this.ToBitString, this? "pdwHelpContext [out] argument": "");
													UINT32 HelpFileArg:1 = FormatString("   (%s) %s", this.ToBitString, this? "pBstrHelpFile [out] argument": "");
													UINT32 Reserved:28 = FormatString("      (%s)", this.ToBitString);
												};
											}
									}

								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												BSTR pBstrName;
												BSTR pBstrDocString;
												Align4 pad1;
												UINT32 pdwHelpContext;
												BSTR pBstrHelpFile;
												Align4	Pad2;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}
				case 13:
					_struct GetDllEntry
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												OLEAUTDISPID memid;
												UINT32 InvokeKind = OLEAUTInvokeKindTable(this);
												UINT32 refPtrFlags
												{
													UINT32 DLLNameArg:1 = FormatString("(%s) %s", this.ToBitString, this? "pBstrDllName [out] argument": "");
													UINT32 NameArg:1 = FormatString("(%s) %s", this.ToBitString, this? "pBstrName [out] argument": "");
													UINT32 OrdinalArg:1 = FormatString("(%s) %s", this.ToBitString, this? "pwOrdinal [out] argument": "");
													UINT32 Reserved:29 = FormatString("(%s)", this.ToBitString);
												};
											}
									}

								}
							case 0x02:
								_struct Resposne
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												BSTR pBstrDllName;
												BSTR pBstrName;
												UINT16 pwOrdinal;
												Align4 Pad;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}
								}
						}
					}
				case 14:
					_struct GetRefTypeInfo
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												UINT32 pRefType;
											}
									}

								}
							case 0x02:
								_struct Resposne
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												DCOMMInterfacePointerPtr ppTInfo;
												Align4 pad;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}
								}
						}
					}
				case 16:
					_struct CreateInstance
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												OLEAUTREFIID riid;
											}
									}

								}
							case 0x02:
								_struct Resposne
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												// not sure...
												DCOMMInterfacePointerPtr IUnknown;
												Align4 Pad;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}
								}
						}
					}
				case 17:
					_struct GetMops
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												OLEAUTDISPID memid;
											}
									}

								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												BSTR pBstrMops;
												Align4 Pad;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}
				case 18:
					_struct GetContainingTypeLib
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												DCOMMInterfacePointerPtr ppTLib;
												Align4 pad;
												UINT32 pIndex;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}

				// ITypeInfo2 Method
				case 22:
					_struct GetTypeKind
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												NdrV1Enum(4) pTypeKind = OLEAUTTypeKindTable(this);
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}
				case 23:
					_struct GetTypeFlags
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												UINT32 pTypeFlags
												{
													UINT32 FAPPOBJECT:1 = FormatString("    (%s) %s", this.ToBitString, this? "[appobject] attribute": "");
													UINT32 FCANCREATE:1 = FormatString("    (%s) %s", this.ToBitString, this? "[noncreatable] attribute": "");
													UINT32 FLICENSED:1 = FormatString("     (%s) %s", this.ToBitString, this? "[licensed] attribute": "");
													UINT32 FPREDECLID:1 = FormatString("    (%s) %s", this.ToBitString, this? "[predeclid] or [appobject] attributes": "");
													UINT32 FHIDDEN:1 = FormatString("       (%s) %s", this.ToBitString, this? "[hidden] attribute": "");
													UINT32 FCONTROL:1 = FormatString("      (%s) %s", this.ToBitString, this? "[control] attribute": "");
													UINT32 FDUAL:1 = FormatString("         (%s) %s", this.ToBitString, this? "[dual] attribute": "");
													UINT32 FNONEXTENSIBLE:1 = FormatString("(%s) %s", this.ToBitString, this? "[nonextensible] attribute": "");
													UINT32 FOLEAUTOMATION:1 = FormatString("(%s) %s", this.ToBitString, this? "[oleautomation] or [dual] attributes": "");
													UINT32 FRESTRICTED:1 = FormatString("   (%s) %s", this.ToBitString, this? "[restricted] attribute": "");
													UINT32 FAGGREGATABLE:1 = FormatString(" (%s) %s", this.ToBitString, this? "[aggregatable] attribute": "");
													UINT32 FREPLACEABLE:1 = FormatString("  (%s) %s", this.ToBitString, this? "[replaceable] attribute": "");
													UINT32 FDISPATCHABLE:1 = FormatString(" (%s) %s", this.ToBitString, this? "Derives from IDispatch": "");
													UINT32 FPROXY:1 = FormatString("        (%s) %s", this.ToBitString, this? "[proxy] attribute": "");
													UINT32 Reserved:18 = FormatString("      (%s)", this.ToBitString);
												};
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}
				case 24:
					_struct GetFuncIndexOfMemId
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												OLEAUTDISPID memid;
												UINT32 InvKind = OLEAUTInvokeKindTable(this);
											}
									}
								}
							case 0x02:
								_struct Respone
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												UINT32 pFuncIndex;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}
								}
						}
					}
				case 25:
					_struct GetVarIndexOfMemId
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												OLEAUTDISPID memid;
											}
									}

								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												UINT32 pVarIndex;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}
				case 26:
					_struct GetCustData
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												GUID(true) Guid;
											}
									}

								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												OLEAUTVariant pVarVal;
												ALIGN4 Pad;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}
				case 27:
					_struct GetFuncCustData
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												UINT32 index;
												GUID(true) Guid;
											}
									}
								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												OLEAUTVariant pVarVal;
												Align4 pad;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}
								}
						}
					}
				case 28:
					_struct GetParamCustData
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												UINT32 indexFunc;
												UINT32 indexParam;
												GUID(true) Guid;
											}
									}
								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												OLEAUTVariant pVarVal;
												Align4 pad;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}
								}
						}
					}
				case 29:
					_struct GetVarCustData
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												UINT32 idnex;
												GUID(true) Guid;
											}
									}
								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												OLEAUTVariant pVarVal;
												Align4 pad;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}
								}
						}
					}
				case 30:
					_struct GetImplTypeCustData
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												UINT32 index;
												GUID(true) Guid;
											}
									}
								}
							case 0x02:
								_struct Resposne
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												OLEAUTVariant pVarVal;
												Align4 pad;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}
								}
						}
					}
				case 31:
					_struct GetDocumentation2
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												OLEAUTDISPID memid;
												OLEAUTLCID Lcid;
												UINT32 refPtrFlags
												{
													UINT32 HelpStringArg:1 = FormatString("(%s) %s", this.ToBitString, this? "pBstrHelpString [out] argument": "");
													UINT32 HelpStringContextArg:1 = FormatString("(%s) %s", this.ToBitString, this? "pdwHelpStringContext [out] argument": "");
													UINT32 HelpStringDllArg:1 = FormatString("(%s) %s", this.ToBitString, this? "pBstrHelpStringDll [out] argument": "");
													UINT32 Reserved:29 = FormatString("(%s)", this.ToBitString);
												};
											}
									}
								}
							case 0x02:
								_struct Resposne
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												BSTR pbstrHelpString;
												Align4 pad1;
												UINT32 pdwHelpStringContext;
												BSTR pbstrHelpStringDll;
												Align4 Pad;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}
								}
						}
					}
				case 32:
					_struct GetAllCustData
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												OLEAUTCustData pCustData;
												ALIGN4 Pad;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}
								}
						}
					}
				case 33:
					_struct GetAllFuncCustData
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												UINT32 index;
											}
									}
								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												OLEAUTCustData pCustData;
												Align4 pad;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}
								}
						}
					}
				case 34:
					_struct GetAllParamCustData
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												UINT32 indexFunc;
												UINT32 indexParam;
											}
									}
								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												OLEAUTCustData pCustData;
												Align4 pad;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}
								}
						}
					}
				case 35:
					_struct GetAllVarCustData
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												UINT32 index;
											}
									}
								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												OLEAUTCustData pCustData;
												Align4 pad;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}
								}
						}
					}
				case 36:
					_struct GetAllImplTypeCustData
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												UINT32 index;
											}
									}
								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												OLEAUTCustData pCustData;
												Align4 pad;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}
				//10,11,15,19~21 
				case 10:
				case 11:
				case 15:
				case 19:
				case 20:
				case 21:
					struct NotUsedOnWire
					{
						Switch (property.MSRPCPType)
						{
					// REQUEST
							case 0x00:
							[post.Description = "OPNUM:" + Property.MSRPCOpnum + " request is Not used on wire"]
							struct Request 
							{
								ReportParserWarning("OAUT", "Invalid oaut method, Opnum:" + Property.MSRPCOpnum) ProtocolWarning;
								Blob(FrameLength - Offset) PayloadData;
							}

					// RESPONSE
							case 0x02:
							[post.Description = "OPNUM:" + Property.MSRPCOpnum + " response is Not used on wire"]
							struct Response
							{
								ReportParserWarning("OAUT", "Invalid oaut method, Opnum:" + Property.MSRPCOpnum) ProtocolWarning;
								Blob(FrameLength - Offset) PayloadData;					
							}
						}
					}
			}
		}
		// ITypeLib
		case "{00020402-0000-0000-C000-000000000046}":
		_struct ITypeLib
		{
			switch(property.MSRPCOpnum)
			{
				case 3:
					_struct GetTypeInfoCount
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												UINT32 pcTInfo;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}
				case 4:
					_struct GetTypeInfo
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												UINT32 index;
											}
									}

								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												DCOMMInterfacePointerPtr ppTInfo;
												Align4 Pad;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}
				case 5:
					_struct GetTypeInfoType
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												UINT32 index;
											}
									}

								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												NdrV1Enum(4) typeKind = OLEAUTTypeKindTable(this);
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}
				case 6:
					_struct GetTypeInfoOfGuid
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												GUID(true) Guid;
											}
									}

								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												DCOMMInterfacePointerPtr ppTInfo;
												Align4 Pad;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}
				case 7:
					_struct GetLibAttr
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												NdrPtr PtrTlibAttr;
												switch
												{
													case PtrTlibAttr.ReferentID:
														OLEAUTTlibAttr TlibAttr;
												}
												Align4 Pad;
												UINT32 pReserved;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}
				case 8:
					_struct GetTypeComp
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												DCOMMInterfacePointerPtr ppTComp;
												Align4 pad;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}
				case 9:
					_struct GetDocumentation
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												INT32 index;
												UINT32 refPtrFlags
												{
													UINT32 NameArg:1 = FormatString("       (%s) %s", this.ToBitString, this? "pBstrName [out] argument": "");
													UINT32 DocStringArg:1 = FormatString("  (%s) %s", this.ToBitString, this? "pBstrDocString [out] argument": "");
													UINT32 HelpContextArg:1 = FormatString("(%s) %s", this.ToBitString, this? "pdwHelpContext [out] argument": "");
													UINT32 HelpFileArg:1 = FormatString("   (%s) %s", this.ToBitString, this? "pBstrHelpFile [out] argument": "");
													UINT32 Reserved:28 = FormatString("      (%s)", this.ToBitString);
												};
											}
									}

								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												BSTR pBstrName;
												BSTR pBstrDocString;
												Align4 Padding;
												UINT32 pdwHelpContext;
												BSTR pBstrHelpFile;
												Align4 Pad;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}
				case 10:
					_struct IsName
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												NdrWideString szNameBuf;
												Align4 Pad;
												UINT32 lHashVal;
											}
									}

								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												BOOL lHashVal;
												BSTR pBstrNameInLibrary;
												Align4 Pad;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}
				case 11:
					_struct FindName
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												NdrWideString szNameBuf;
												Align4 Pad1;
												UINT32 lHashVal;
												UINT16 pcFound;
											}
									}

								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												DCOMPMInterfacePointerArray ppTInfo;
												OLEAUTDISPIDArray rgMemId;
												UINT16 pcFound;
												ALIGN4 Pad1;
												BSTR pBstrNameInLibrary;
												Align4 Pad;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}
				case 12:
					struct NotUsedOnWire
					{
						Switch (property.MSRPCPType)
						{
					// REQUEST
							case 0x00:
							[post.Description = "OPNUM:" + Property.MSRPCOpnum + " request is Not used on wire"]
							struct Request 
							{
								ReportParserWarning("OAUT", "Invalid oaut method, Opnum:" + Property.MSRPCOpnum) ProtocolWarning;
								Blob(FrameLength - Offset) PayloadData;
							}

					// RESPONSE
							case 0x02:
							[post.Description = "OPNUM:" + Property.MSRPCOpnum + " response is Not used on wire"]
							struct Response
							{
								ReportParserWarning("OAUT", "Invalid oaut method, Opnum:" + Property.MSRPCOpnum) ProtocolWarning;
								Blob(FrameLength - Offset) PayloadData;					
							}
						}
					}
			}
		}
		// ITypeLib2
		case "{00020411-0000-0000-C000-000000000046}":
		_struct ITypeLib2
		{
			switch(property.MSRPCOpnum)
			{
				case 3:
					_struct GetTypeInfoCount
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												UINT32 pcTInfo;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}
				case 4:
					_struct GetTypeInfo
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												UINT32 index;
											}
									}

								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												DCOMMInterfacePointerPtr ppTInfo;
												Align4 Pad;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}
				case 5:
					_struct GetTypeInfoType
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												UINT32 index;
											}
									}

								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												NdrV1Enum(4) typeKind = OLEAUTTypeKindTable(this);
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}
				case 6:
					_struct GetTypeInfoOfGuid
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												GUID(true) Guid;
											}
									}

								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												DCOMMInterfacePointerPtr ppTInfo;
												Align4 Pad;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}
				case 7:
					_struct GetLibAttr
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												NdrPtr PtrTlibAttr;
												switch
												{
													case PtrTlibAttr.ReferentID:
														OLEAUTTlibAttr TlibAttr;
												}
												Align4 Pad;
												UINT32 pReserved;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}
				case 8:
					_struct GetTypeComp
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												DCOMMInterfacePointerPtr ppTComp;
												Align4 pad;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}
				case 9:
					_struct GetDocumentation
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												INT32 index;
												UINT32 refPtrFlags
												{
													UINT32 NameArg:1 = FormatString("       (%s) %s", this.ToBitString, this? "pBstrName [out] argument": "");
													UINT32 DocStringArg:1 = FormatString("  (%s) %s", this.ToBitString, this? "pBstrDocString [out] argument": "");
													UINT32 HelpContextArg:1 = FormatString("(%s) %s", this.ToBitString, this? "pdwHelpContext [out] argument": "");
													UINT32 HelpFileArg:1 = FormatString("   (%s) %s", this.ToBitString, this? "pBstrHelpFile [out] argument": "");
													UINT32 Reserved:28 = FormatString("      (%s)", this.ToBitString);
												};
											}
									}

								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												BSTR pBstrName;
												BSTR pBstrDocString;
												Align4 Padding;
												UINT32 pdwHelpContext;
												BSTR pBstrHelpFile;
												Align4 Pad;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}
				case 10:
					_struct IsName
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												NdrWideString szNameBuf;
												Align4 Pad;
												UINT32 lHashVal;
											}
									}

								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												BOOL lHashVal;
												BSTR pBstrNameInLibrary;
												Align4 Pad;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}
				case 11:
					_struct FindName
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												NdrWideString szNameBuf;
												Align4 Pad1;
												UINT32 lHashVal;
												UINT16 pcFound;
											}
									}

								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												DCOMPMInterfacePointerArray ppTInfo;
												OLEAUTDISPIDArray rgMemId;
												UINT16 pcFound;
												ALIGN4 Pad1;
												BSTR pBstrNameInLibrary;
												Align4 Pad;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}
				case 13:
					_struct GetCustData
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												GUID(true) Guid;
											}
									}

								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												OLEAUTVariant pVarVal;
												ALIGN4 Pad;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}
				case 14:
					_struct GetLibStatistics
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
								}
							case 0x02:
								_struct Resposne
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												UINT32 pcUniqueNames;
												UINT32 pcchUniqueNames;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}
								}
						}
					}
				case 15:
					_struct GetDocumentation2
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												INT32 index;
												OLEAUTLcid Lcid;
												UINT32 refPtrFlags
												{
													UINT32 HelpStringArg:1 = FormatString(" (%s), %s", this.ToBitString, this? "pBstrHelpString [out] argument": "");
													UINT32 HelpContextArg:1 = FormatString("(%s), %s", this.ToBitString, this? "pdwHelpStringContext [out] argument": "");
													UINT32 HelpFileArg:1 = FormatString("   (%s), %s", this.ToBitString, this? "pBstrHelpStringDll [out] argument": "");
													UINT32 Reserved:29 = FormatString("      (%s)", this.ToBitString);
												};
											}
									}

								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												BSTR pbstrHelpString;
												Align4 pad1;
												UINT32 pdwHelpStringContext;
												BSTR pbstrHelpStringDll;
												Align4 Pad;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}
				case 16:
					_struct GetAllCustData
					{
						switch(property.MSRPCptype)
						{
							case 0x00:
								_struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
									}
								}
							case 0x02:
								_struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												OLEAUTCustData pCustData;
												ALIGN4 Pad;
												[RAPRDecomResult = HResult.ToString]
												HRESULT HResult;
											}
									}

								}
						}
					}
				case 12:
					struct NotUsedOnWire
					{
						Switch (property.MSRPCPType)
						{
					// REQUEST
							case 0x00:
							[post.Description = "OPNUM:" + Property.MSRPCOpnum + " request is Not used on wire"]
							struct Request 
							{
								ReportParserWarning("OAUT", "Invalid oaut method, Opnum:" + Property.MSRPCOpnum) ProtocolWarning;
								Blob(FrameLength - Offset) PayloadData;
							}

					// RESPONSE
							case 0x02:
							[post.Description = "OPNUM:" + Property.MSRPCOpnum + " response is Not used on wire"]
							struct Response
							{
								ReportParserWarning("OAUT", "Invalid oaut method, Opnum:" + Property.MSRPCOpnum) ProtocolWarning;
								Blob(FrameLength - Offset) PayloadData;					
							}
						}
					}
			}
		}
	}
}

Table OLEAUTIRecordInfoMethodTable(value)
{
	switch (value)
	{
		//#? Not implemented
		default: "Undefined value: " + FormatString("%d", value);
	}
}

Table OLEAUTIDispatchMethodTable(value)
{
	switch (value)
	{
		case 3: "GetTypeInfoCount";
		case 4: "GetTypeInfo";
		case 5: "GetIDsOfNames";
		case 6: "Invoke";
		default: "Undefined value: " + FormatString("%d", value);
	}
}

Table OLEAUTIUnknownMethodTable(value)
{
	switch (value)
	{
		//#? Not implemented
		default: "Undefined value: " + FormatString("%d", value);
	}
}

Table OLEAUTIEnumVARIANTMethodTable(value)
{
	switch (value)
	{
		case 0x03: "Next";
		case 0x04: "Skip";
		case 0x05: "Reset";
		case 0x06: "Clone";
		default: "Undefined value: " + FormatString("%d", value);
	}
}

table OLEAUTITypeCompMethodTable(value)
{
	switch(value)
	{
		case 3: "Bind";
		case 4: "BindType";
		default:
			FormatString("Unknwon value: %d", value);
	}
}

table OLEAUTITypeInfoMethodTable(value)
{
	switch(value)
	{
		case 3: "GetTypeAttr";
		case 4: "GetTypeComp";
		case 5: "GetFuncDesc";
		case 6: "GetVarDesc";
		case 7: "GetNames";
		case 8: "GetRefTypeOfImplType";
		case 9: "GetImplTypeFlags";
		case 12: "GetDocumentation";
		case 13: "GetDllEntry";
		case 14: "GetRefTypeInfo";
		case 16: "CreateInstance";
		case 17: "GetMops";
		case 18: "GetContainingTypeLib";
		//ITypeInfo2
		case 22: "GetTypeKind";
		case 23: "GetTypeFlags";
		case 24: "GetFuncIndexOfMemId";
		case 25: "GetVarIndexOfMemId";
		case 26: "GetCustData";
		case 27: "GetFuncCustData";
		case 28: "GetParamCustData";
		case 29: "GetVarCustData";
		case 30: "GetImplTypeCustData";
		case 31: "GetDocumentation2";
		case 32: "GetAllCustData";
		case 33: "GetAllFuncCustData";
		case 34: "GetAllParamCustData";
		case 35: "GetAllVarCustData";
		case 36: "GetAllImplTypeCustData";
		default:
			FormatString("Unknown value: %d", value);
	}
}

table OLEAUTITypeLibMethodTable(value)
{
	switch(value)
	{
		case 3: "GetTypeInfoCount";
		case 4: "GetTypeInfo";
		case 5: "GetTypeInfoType";
		case 6: "GetTypeInfoOfGuid";
		case 7: "GetLibAttr";
		case 8: "GetTypeComp";
		case 9: "GetDocumentation";
		case 10: "IsName";
		case 11: "FindName";
		// ITypeLib2
		case 13: "GetCustData";
		case 14: "GetLibStatistics";
		case 15: "GetDocumentation2";
		case 16: "GetAllCustData";
		default:
			FormatString("Unknown value: %d", value);
	}
}

Table OLEAUTGlobalMethodTable(uuid, opnum)
{
	switch (uuid)
	{
		case "{0000002F-0000-0000-C000-000000000046}" : "IRecordInfo." + OLEAUTIRecordInfoMethodTable(opnum);
		case "{00020400-0000-0000-C000-000000000046}" : "IDispatch." + OLEAUTIDispatchMethodTable(opnum);
		case "{00000000-0000-0000-C000-000000000046}" : "IUnknown." + OLEAUTIUnknownMethodTable(opnum);
		case "{00020404-0000-0000-C000-000000000046}" : "IEnumVARIANT." + OLEAUTIEnumVARIANTMethodTable(opnum);
		case "{00020403-0000-0000-C000-000000000046}" : "ITypeComp." + OLEAUTITypeCompMethodTable(opnum);
		case "{00020401-0000-0000-C000-000000000046}" : "ITypeInfo." + OLEAUTITypeInfoMethodTable(opnum);
		case "{00020412-0000-0000-C000-000000000046}" : "ITypeInfo2." + OLEAUTITypeInfoMethodTable(opnum);
		case "{00020402-0000-0000-C000-000000000046}" : "ITypeLib." + OLEAUTITypeLibMethodTable(opnum);
		case "{00020411-0000-0000-C000-000000000046}" : "ITypeLib2." + OLEAUTITypeLibMethodTable(opnum);
	}
}

struct OLEAUTIId = IId.ToString
{
	GUID(TRUE) IId;
}

struct OLEAUTRefIId = IId.ToString
{
	OLEAUTIId IId;
}

struct OLEAUTLCID = LCID.ToString
{
	UINT32 LCID;
}

Table OLEAUTDISPIDTable(code)
{
	switch (code)
	{
		case 0x00000000: "DISPID_VALUE";
		case 0xFFFFFFFF: "DISPID_UNKNOWN";
		case 0xFFFFFFFD: "DISPID_PROPERTYPUT";
		case 0xFFFFFFFC: "DISPID_NEWENUM";
		default: FormatString("%d (0x%X)", code, code);
	}
}

struct OLEAUTDISPIDArray
{
	NdrConformantVarying Length;
	switch
	{
		case Length.ActualCount:
			INT32 DISPID = OLEAUTDISPIDTable(this);
	}
}

struct OLEAUTDISPID = DISPID.ToString
{
	INT32 DISPID = OLEAUTDISPIDTable(this);
}

struct OLEAUTLPOLESTR(Count)
{
	[PtrCount = Count, StringCount = 0]

	while [PtrCount > 0]
	{
		[PtrCount = PtrCount - 1]
		NdrPtr Pointer;
		switch
		{
			case Pointer.ReferentId:
				[StringCount = StringCount + 1]
				_struct NotNull{};
		}
	}
	NdrWideString string[StringCount];
}

//
//	DISPPARAMS
// Alignment:None
//
struct OLEAUTDISPPARAMS
{
	[Local.ArgRef = this.ReferentId]
	NdrPtr prgvarg;
	[Local.NamedArgRef = this.ReferentId]
	NdrPtr prgdispidNamedArgs;
	UINT32 cArgs;
	UINT32 cNamedArgs;
	switch
	{
		case Local.ArgRef:
			OLEAUTSafeArrVariant rgvarg;
	}
	switch
	{
		case Local.NamedArgRef:
		_struct NamedArgs
		{
			NdrConformant NamedArgsConformant;
			OLEAUTDISPID NamedArgs[NamedArgsConformant.MaxCount];
		}
	}
}

//
// _FLAGGED_WORD_BLOB
// Alignment:None
//
struct OLEAUTFlaggedWordBlob = ArrayData.ToString
{
	NdrConformant Size;
	UINT32 CBytes;
	UINT32 CSize;
	[DataFieldByteOrder = LittleEndian]
	UnicodeString( Size.Maxcount ) ArrayData = UINT16( FrameData, FrameOffset ) ? UnicodeString( FrameData, FrameOffset, Size.Maxcount ) : "<Empty>";
}

struct OLEAUTExcepInfo = scode.ToString
{
	UINT16 wCode;
	UINT16 wReserved;
	[Local.SourceRefId = this.ReferentId]
	NdrPtr pbstrSource;
	[Local.DescriptionRefId = this.ReferentId]
	NdrPtr pbstrDescription;
	[Local.HelpFileRefId = this.ReferentId]
	NdrPtr pbstrHelpFile;
	UINT32 dwHelpContext;
	NdrPtr pvReserved;
	NdrPtr pfnDeferredFillIn;
	HRESULT scode;
	Switch
	{
		case Property.MSRPCNdr64:
		Align8 pad;
	}
	switch
	{
		case Local.SourceRefId:
			OLEAUTFlaggedWordBlob bstrSource;
	}
	switch
	{
		case Local.DescriptionRefId:
			OLEAUTFlaggedWordBlob bstrDescription;
	}
	switch
	{
		case Local.HelpFileRefId:
			OLEAUTFlaggedWordBlob bstrHelpFile;
	}
}


struct OLEAUTRecordInfo = FormatString("recGuid = %s", recGuid.ToString)
{
	[OLEAUTRecordScopeGuid = scopeGuid.ToString]
	GUID(true) scopeGuid;
	[OLEAUTRecordVerMajor]
	UINT32 verMajor;
	[OLEAUTRecordrecGuid = recGuid.ToString]
	GUID(true) recGuid;
	[OLEAUTRecordVerMinor]
	UINT32 verMinor;
	[OLEAUTRecordLcid]
	UINT32 Lcid;
}


struct OLEAUTBRECORD = Pointer.ReferentId ? "Not NULL" : "NULL"
{
	NdrPtr Pointer;
	switch
	{
		case Pointer.ReferentId:
			OLEAUTWireBRECORD Record;
	}
}

//
//	_wireBRECORD
//	Alignment:None
//
struct OLEAUTWireBRECORD = ""
{
	NdrAlign Pad;
	UINT32 fFlags = this ? "pRecord is not NULL" : "pRecord is NULL";
	UINT32 clSize;
	NdrPtr pRecInfo;
	NdrPtr pRecord;
	switch
	{
		case pRecInfo.ReferentId:
			_struct NotNullRecInfo
			{
				DCOMMInterfacePointer RecInfo;
			}
	}
	switch
	{
		case pRecord.ReferentId:
			_struct NotNullRec
			{
				NdrConformant ByteCount;
				[DataFieldFrameLength = FrameOffset + ByteCount.MaxCount]
				switch
				{
					default:
						BLOB(ByteCount.MaxCount) Record;
				}
			}
	}
}

//
//	[MS-OAUT] SAFEARR_BSTR	
//	Alignment: None
//
struct OLEAUTSafeArrBstrConformant
{
	NdrConformant ArraySize;
	[PtrCount = ArraySize.MaxCount, StringCount = 0]
	while [PtrCount > 0]
	{
		[PtrCount = PtrCount - 1]
		NdrPtr Pointer;
		switch
		{
			case Pointer.ReferentId:
				[StringCount = StringCount + 1]
				_struct NotNull{};
		}
	}
	OLEAUTFlaggedWordBlob string[StringCount];
}
struct OLEAUTSafeArrBstrConformantVarying
{
	NdrConformantVarying ArraySize;
	[PtrCount = ArraySize.ActualCount, StringCount = 0]
	while [PtrCount > 0]
	{
		[PtrCount = PtrCount - 1]
		NdrPtr Pointer;
		switch
		{
			case Pointer.ReferentId:
				[StringCount = StringCount + 1]
				_struct NotNull{};
		}
	}
	OLEAUTFlaggedWordBlob string[StringCount];
}

//
//	[MS-OAUT] SAFEARR_UNKNOWN SAFEARR_DISPATCH SAFEARR_HAVEIID
//	Alignment: None
//
struct OLEAUTSafeArrArray
{
	NdrConformant ArraySize;
	[Local.PtrCount = ArraySize.MaxCount, Local.InterfaceCount = 0]
	while [Local.PtrCount > 0]
	{
		[Local.PtrCount = Local.PtrCount - 1]
		NdrPtr Pointer;
		switch
		{
			case Pointer.ReferentId:
				[Local.InterfaceCount = Local.InterfaceCount + 1]
				_struct NotNull{};
		}
	}
	DCOMMInterfacePointer apUnknown[Local.InterfaceCount];
}

//
//	[MS-OAUT] SAFEARR_VARIANT
//	Alignment: None
//
struct OLEAUTSafeArrVariant
{
	NdrConformant ArraySize;
	[Local.PtrCount = ArraySize.MaxCount, Local.VariantCount = 0]
	while [Local.PtrCount > 0]
	{
		[Local.PtrCount = Local.PtrCount - 1]
		NdrPtr Pointer;
		switch
		{
			case Pointer.ReferentId:
				[Local.VariantCount = Local.VariantCount + 1]
				_struct NotNull{};
		}
	}
	OLEAUTWireVariant aVariant[Local.VariantCount];
}

//
//	[MS-OAUT] SAFEARR_BRECORD
//	Alignment: None
//
struct OLEAUTSafeArrBrecord
{
	NdrConformant ArraySize;
	[Local.PtrCount = ArraySize.MaxCount, Local.RecordCount = 0]
	while [Local.PtrCount > 0]
	{
		[Local.PtrCount = Local.PtrCount - 1]
		NdrPtr Pointer;
		switch
		{
			case Pointer.ReferentId:
				[Local.RecordCount = Local.RecordCount + 1]
				_struct NotNull{};
		}
	}
	OLEAUTWireBrecord aRecord[Local.RecordCount];
}

//
//	[MS-OAUT] BYTE_SIZEDARR
//	Alignment: None
//
struct OLEAUTByteSizedArr
{
	NdrConformant ArraySize;
	UINT8 pData[ArraySize.MaxCount];
	Switch
	{
		case Property.MSRPCNdr64:
		Align8 pad;
	}
}

//
//	[MS-0AUT] WORD_SIZEDARR
//	Alignment: None
//
struct OLEAUTWordSizedArr
{
	NdrConformant ArraySize;
	UINT16 pData[ArraySize.MaxCount];
}

//
//	[MS-0AUT] DWORD_SIZEDARR
//	Alignment: None
//
struct OLEAUTDWordSizedArr
{
	NdrConformant ArraySize;
	UINT32 pData[ArraySize.MaxCount];
}

//
//	[MS-0AUT] HYPER_SIZEDARR
//	Alignment: None
//
struct OLEAUTHyperSizedArr
{
	NdrConformant ArraySize;
	Align8 Pad;
	UINT64 pData[ArraySize.MaxCount];
}

Table SafeArrayFeatureTable(value)
{
	switch (value)
	{
		case 0x00000002: "SF_I2";
		case 0x00000003: "SF_I4";
		case 0x00000008: "SF_BSTR";
		case 0x00000009: "SF_DISPATCH";
		case 0x0000000A: "SF_ERROR";
		case 0x0000000C: "SF_VARIANT";
		case 0x0000000D: "SF_UNKNOWN";
		case 0x00000010: "SF_I1";
		case 0x00000014: "SF_I8";
		case 0x00000024: "SF_RECORD";
		case 0X0000800D: "SF_HAVEIID";
		default: FormatString("Undefined Value(%d)", value);
	}
}

struct OLEAUTSafeArray = ReferentId.ReferentId ? SafeArray.ToString : "NULL"
{
	NdrPtr ReferentId;
	switch
	{
		case ReferentId.ReferentId:
			OLEAUTWireSafeArray SafeArray;
	}
}

//
//	[MS-OAUT] SAFEARRAY
//	Alignment:None
//
struct OLEAUTWireSafeArray = FormatString("%d Dimensions", cDims)
{
	NdrConformant MaxBoundCount;
	switch
	{
			case Property.MSRPCNdr64: Align8 padStruct;
		}
	UINT16 cDims;
	switch( Property.MSRPCByteOrder )
	{
		case LittleEndian:
			_struct LittleEndian
			{
				UINT16 fFeatures
				{
					UINT16 Auto:1 = FormatString("       (%s) %s", this.ToBitString, this ? "Allocated on the stack" : "Not allocated on the stack");
					UINT16 Static:1 = FormatString("     (%s) %s", this.ToBitString, this ? "Statically allocated" : "Not statically allocated");
					UINT16 Embedded:1 = FormatString("   (%s) %s", this.ToBitString, this ? "Embedded in a structure" : "Not embedded in a structure");
					UINT16 Reserved:1 = FormatString("   (%s)", this.ToBitString);
					UINT16 Fixedsize:1 = FormatString("  (%s) %s", this.ToBitString, this ? "Cannot be resized or reallocated" : "Can be resized or reallocated");
					UINT16 Record:1 = FormatString("     (%s) %s", this.ToBitString, this ? "User-defined type" : "Not user-defined type");
					UINT16 Haveiid:1 = FormatString("    (%s) %s", this.ToBitString, this ? "MInterfacePointers" : "Not MInterfacePointers");
					[Local.Havevartype]
					UINT16 Havevartype:1 = FormatString("(%s) %s", this.ToBitString, this ? "High word of the cLocks MUST contain a VARIANT type" : "High word of the cLocks may not contain a VARIANT type");
					UINT16 Bstr:1 = FormatString("       (%s) %s", this.ToBitString, this ? "BSTR" : "Not BSTR");
					UINT16 Unknown:1 = FormatString("    (%s) %s", this.ToBitString, this ? "IUnknown pointer" : "Not IUnknown pointer");
					UINT16 Dispatch:1 = FormatString("   (%s) %s", this.ToBitString, this ? "IDispatch pointer" : "Not IDispatch pointer");
					UINT16 Variant:1 = FormatString("    (%s) %s", this.ToBitString, this ? "VARIANT" : "Not VARIANT");
				}
			}
		default:
			_struct BigEndian
			{
				UINT16 fFeatures
				{
					UINT16 Variant:1 = FormatString("    (%s) %s", this.ToBitString, this ? "VARIANT" : "Not VARIANT");
					UINT16 Dispatch:1 = FormatString("   (%s) %s", this.ToBitString, this ? "IDispatch pointer" : "Not IDispatch pointer");
					UINT16 Unknown:1 = FormatString("    (%s) %s", this.ToBitString, this ? "IUnknown pointer" : "Not IUnknown pointer");
					UINT16 Bstr:1 = FormatString("       (%s) %s", this.ToBitString, this ? "BSTR" : "Not BSTR");
					[Local.Havevartype]
					UINT16 Havevartype:1 = FormatString("(%s) %s", this.ToBitString, this ? "High word of the cLocks MUST contain a VARIANT type" : "High word of the cLocks may not contain a VARIANT type");
					UINT16 Haveiid:1 = FormatString("    (%s) %s", this.ToBitString, this ? "MInterfacePointers" : "Not MInterfacePointers");
					UINT16 Record:1 = FormatString("     (%s) %s", this.ToBitString, this ? "User-defined type" : "Not user-defined type");
					UINT16 Fixedsize:1 = FormatString("  (%s) %s", this.ToBitString, this ? "Cannot be resized or reallocated" : "Can be resized or reallocated");
					UINT16 Reserved:1 = FormatString("   (%s)", this.ToBitString);
					UINT16 Embedded:1 = FormatString("   (%s) %s", this.ToBitString, this ? "Embedded in a structure" : "Not embedded in a structure");
					UINT16 Static:1 = FormatString("     (%s) %s", this.ToBitString, this ? "Statically allocated" : "Not statically allocated");
					UINT16 Auto:1 = FormatString("       (%s) %s", this.ToBitString, this ? "Allocated on the stack" : "Not allocated on the stack");
				}
			}
	}
	UINT32 cbElements;
	UINT32 cLocks = Local.Havevartype ? OLEAUTVariantVarTypeTable((this >> 16) & 0xFFFF) : "MUST be ignored upon receipt";
	struct SAFEARRAYUNION
	{
		switch
		{
			case Property.MSRPCNdr64: Align8 padunion;
		}
		[ DataFieldByteOrder = LittleEndian ]
		UINT32 sfType = SafeArrayFeatureTable(this);
		switch
		{
			case Property.MSRPCNdr64: Align8 padunion;
		}		
		UINT32 Size;
		NdrPtr ReferentToArray;
		switch (sfType)
		{
			case 0x0000800D:
				OLEAUTIID IId;
		}
		switch
		{
			case Property.MSRPCNdr64: Align8 padtrailinggap;
		}
		OLEAUTSafeArrayBound Bound[cDims];
		switch
		{
			case ReferentToArray.ReferentID > 0 :
				switch (sfType)
				{
					case 0x00000002: //SF_I2
						OLEAUTWordSizedarr WordStr;
					case 0x00000003: //SF_I4
						OLEAUTDwordSizedarr LongStr;
					case 0x00000008: //SF_BSTR
						OLEAUTSafeArrBstrConformant BstrStr;
					case 0x00000009: //SF_DISPATCH
						OLEAUTSafeArrArray DispatchStr;
					case 0x0000000C: //SF_VARIANT
						OLEAUTSafeArrVariant VariantStr;
					case 0x0000000D: //SF_UNKNOWN
						OLEAUTSafeArrArray UnknownStr;
					case 0x00000010: //SF_I1
						OLEAUTByteSizedArr ByteStr;
					case 0x00000014: //SF_I8
						OLEAUTHyperSizedArr HyperStr;
					case 0x00000024: //SF_RECORD
						OLEAUTSafeArrBrecord RecordStr;
					case 0x0000800D: //SF_HAVEIID
						OLEAUTSafeArrArray HaveIidStr;
				}
		}
	}
}

//
//	[MS-OAUT] SAFEARRAYBOUND
//	Alignment: None
//
Struct OLEAUTSafeArrayBound = FormatString("[%d..%d]", iLbound, iLbound + cElements - 1)
{
	Align4 Align;
	UINT32 cElements;
	INT32 iLbound;
}

struct OLEAUTPSAFEARRAY = Pointer.ReferentId ? SafeArray.ToString : "NULL"
{
	NdrPtr Pointer;
	switch
	{
		case Pointer.ReferentId:
			OLEAUTSafeArray SafeArray;
	}
}

struct OLEAUTDecimal
{
	UINT16 wReserved;
	UINT8 scale;
	UINT8 sign;
	UINT32 Hi32;
	UINT64 Lo64;
}

struct OLEAUTCurrency = FormatString("%I64d.%I64d", Value/10000, Value - Value/10000*10000)
{
	INT64 Value;
}

struct OLEAUTDate
{
	double Value;
}

Table OLEAUTVariantVarTypeTable(value)
{
	switch (value & 0xFF)
	{
		case 0x00000000: "VT_EMPTY";
		case 0x00000001: "VT_NULL";
		case 0x00000002: "VT_I2";
		case 0x00000003: "VT_I4";
		case 0x00000004: "VT_R4";
		case 0x00000005: "VT_R8";
		case 0x00000006: "VT_CY";
		case 0x00000007: "VT_DATE";
		case 0x00000008: "VT_BSTR";
		case 0x00000009: "VT_DISPATCH";
		case 0x0000000A: "VT_ERROR";
		case 0x0000000B: "VT_BOOL";
		case 0x0000000C: "VT_VARIANT";
		case 0x0000000D: "VT_UNKNOWN";
		case 0x0000000E: "VT_DECIMAL";
		case 0x00000010: "VT_I1";
		case 0x00000011: "VT_UI1";
		case 0x00000012: "VT_UI2";
		case 0x00000013: "VT_UI4";
		case 0x00000014: "VT_I8";
		case 0x00000015: "VT_UI8";
		case 0x00000016: "VT_INT";
		case 0x00000017: "VT_UINT";
		case 0x00000018: "VT_VOID";
		case 0x00000019: "VT_HRESULT";
		case 0x0000001A: "VT_PTR";
		case 0x0000001B: "VT_SAFEARRAY";
		case 0x0000001C: "VT_CARRAY";
		case 0x0000001D: "VT_USERDEFINED";
		case 0x0000001E: "VT_LPSTR";
		case 0x0000001F: "VT_LPWSTR";
		case 0x00000024: "VT_RECORD";
		case 0x00000025: "VT_INT_PTR";
		case 0x00000026: "VT_UINT_PTR";
//		case 0x00002000: "VT_ARRAY";
//		case 0x00004000: "VT_BYREF";
		default: FormatString("UnknownValue(%d)", value);
	}
}

//
//	[MS-OAUT] VARIANT
//	Alignment: None
//
struct OLEAUTVariant = (ReferentId.ReferentId != 0 )? Variant.ToString : "NULL"
{
	NdrPtr ReferentId;
	switch
	{
		case ReferentId.ReferentId:
			OLEAUTWireVariant Variant;
	}
}

//
//	[MS-OAUT] _wireVARIANT
//	Alignment:None
//
struct OLEAUTWireVariant = Local.VariantValue.Contains("Type =") ? FormatString("Type = %s", vt.ToString) : FormatString("Type = %s, Value = %s", vt.ToString, Local.VariantValue)
{
	Align8 Pad;
	[Local.VariantBaseOffset = FrameOffset]
	[Local.VariantValue = "NULL"]
	UINT32 clSize;
	UINT32 rpcReserved;
	UINT16 vt = OLEAUTVariantVarTypeTable(this) + (((this & 0x2000) == 0x2000) ? " | VT_ARRAY" : "") + (((this & 0x4000) == 0x4000) ? " | VT_BYREF" : "");
	UINT16 Reserved1;
	UINT16 Reserved2;
	UINT16 Reserved3;
	Switch
	{
		case Property.MSRPCNdr64:
		Align8 pad1;
	}
	UINT32 varType = ((this & 0x00002000) == 0x00002000) ? "VT_ARRAY" : (OLEAUTVariantVarTypeTable(this) + (((this & 0x4000) == 0x4000) ? " | VT_BYREF" : ""));
	Switch
	{
		case Property.MSRPCNdr64:
		Align8 pad;
	}
	switch( varType )
	{
		case 20: // VT_I8
			_struct llVal
			{
				Align8 Align;
				[Local.VariantValue = llVal.ToString]
				INT64 llVal;
			}
		case 3: // VT_I4
			struct
			{
				Align4 Pad;
				[Local.VariantValue = lVal.ToString]
				INT32 lVal;
				Switch
				{
					case Property.MSRPCNdr64:
					Align8 pad;
				}
			}
		case 17: // VT_UI1
			Struct
			{
				[Local.VariantValue = bVal.ToString]
				UINT8 bVal;
				Switch
				{
					case Property.MSRPCNdr64:
					Align8 pad;
				}
			}
			
		case 2:	// VT_I2
			Struct
			{
				[Local.VariantValue = iVal.ToString]
				INT16 iVal;
				Switch
				{
					case Property.MSRPCNdr64:
					Align8 pad;
				}
			}
			
		case 4:	// VT_R4
			struct
			{
				Align4 Pad;
				[Local.VariantValue = fltVal.ToString]
				float fltVal;
				Switch
				{
					case Property.MSRPCNdr64:
					Align8 pad;
				}
			}
		case 5:	// VT_R8
			_struct dblVal
			{
				Align8 Align;
				[Local.VariantValue = dblVal.ToString]
				double dblVal;
			}
		case 11: // VT_BOOL
			Struct
			{
				[Local.VariantValue = boolVal.ToString]
				INT16 boolVal;
				Switch
				{
					case Property.MSRPCNdr64:
					Align8 pad;
				}
			}
			
		case 10: // VT_ERROR
			struct
			{
				Align4 Pad;
				[Local.VariantValue = scode.ToString]
				HRESULT scode;
				Switch
				{
					case Property.MSRPCNdr64:
					Align8 pad;
				}
			}
		case 6:	// VT_CY
			struct
			{
				Align8 Pad;
				[Local.VariantValue = cyVal.ToString]
				OLEAUTCurrency cyVal;
			}
		case 7:	// VT_DATE
		struct
			{
				Align8 Pad;
				[Local.VariantValue = date.ToString]
				OLEAUTDate date;
			}
		case 8:	// VT_BSTR
			[Local.VariantValue = bstrVal.ToString]
			BSTR bstrVal;
		case 13: // VT_UNKNOWN
			[Local.VariantValue = punkVal.ToString]
			DCOMMInterfacePointerPtr punkVal;
		case 9:	// VT_DISPATCH
			[Local.VariantValue = pdispVal.ToString]
			DCOMMInterfacePointerPtr pdispVal;
		case 0x2000: // VT_ARRAY
			[Local.VariantValue = parray.ToString]
			OLEAUTPSafeArray parray;
		case 36: // VT_RECORD
		case 36 | 0x4000: // VT_RECORD|VT_BYREF
			[Local.VariantValue = brecVal.ToString]
			OLEAUTBRECORD brecVal;
		case 17 | 0x4000: // VT_UI1|VT_BYREF
			_struct RefUI1
			{
				NdrPtr pbVal;
				switch
				{
					case pbVal.ReferentId:
						[Local.VariantValue = bVal.ToString]
						UINT8 bVal;
				}
			}
		case 2 | 0x4000: // VT_I2|VT_BYREF
			_struct RefI2
			{
				NdrPtr piVal;
				switch
				{
					case piVal.ReferentId:
						[Local.VariantValue = iVal.ToString]
						INT16 iVal;
				}
			}
		case 3 | 0x4000: // VT_I4|VT_BYREF
			_struct RefI4
			{
				NdrPtr plVal;
				switch
				{
					case plVal.ReferentId:
						[Local.VariantValue = lVal.ToString]
						INT32 lVal;
				}
			}
		case 20 | 0x4000: // VT_I8|VT_BYREF
			_struct RefI8
			{
				NdrPtr pllVal;
				switch
				{
					case pllVal.ReferentId:
						_struct llVal
						{
							Align8 Align;
							[Local.VariantValue = llVal.ToString]
							INT64 llVal;
						}
				}
			}
		case 4 | 0x4000: // VT_R4|VT_BYREF
			_struct RefR4
			{
				NdrPtr pfltVal;
				switch
				{
					case pfltVal.ReferentId:
						[Local.VariantValue = fltVal.ToString]
						float fltVal;
				}
			}
		case 5 | 0x4000: // VT_R8|VT_BYREF
			_struct RefR8
			{
				NdrPtr pdblVal;
				switch
				{
					case pdblVal.ReferentId:
						_struct dblVal
						{
							Align8 Align;
							[Local.VariantValue = dblVal.ToString]
							double dblVal;
						}
				}
			}
		case 11 | 0x4000: // VT_BOOL|VT_BYREF
			_struct RefBOOL
			{
				NdrPtr pboolVal;
				switch
				{
					case pboolVal.ReferentId:
						[Local.VariantValue = boolVal.ToString]
						INT16 boolVal;
				}
			}
		case 10 | 0x4000: // VT_ERROR|VT_BYREF
			_struct RefERROR
			{
				NdrPtr pscode;
				switch
				{
					case pscode.ReferentId:
						[Local.VariantValue = scode.ToString]
						HRESULT scode;
				}
			}
		case 6 | 0x4000: // VT_CY|VT_BYREF
			_struct RefCY
			{
				NdrPtr pcyVal;
				switch
				{
					case pcyVal.ReferentId:
						[Local.VariantValue = cyVal.ToString]
						OLEAUTCurrency cyVal;
				}
			}
		case 7 | 0x4000: // VT_DATE|VT_BYREF
			_struct RefDATE
			{
				NdrPtr pdate;
				switch
				{
					case pdate.ReferentId:
						[Local.VariantValue = date.ToString]
						OLEAUTDate date;
				}
			}
		case 8 | 0x4000: // VT_BSTR|VT_BYREF
			_struct RefBSTR
			{
				NdrPtr pbstrVal;
				switch
				{
					case pbstrVal.ReferentId:
						[Local.VariantValue = bstrVal.ToString]
						BSTR bstrVal;
				}
			}
		case 13 | 0x4000: // VT_UNKNOWN|VT_BYREF
			_struct RefUNKNOWN
			{
				NdrPtr ppunkVal;
				switch
				{
					case ppunkVal.ReferentId:
						[Local.VariantValue = punkVal.ToString]
						DCOMMInterfacePointerPtr punkVal;
				}
			}
		case 9 | 0x4000: // VT_DISPATCH|VT_BYREF
			_struct RefDISPATCH
			{
				NdrPtr ppdispVal;
				switch
				{
					case ppdispVal.ReferentId:
						[Local.VariantValue = pdispVal.ToString]
						DCOMMInterfacePointerPtr pdispVal;
				}
			}
		case 0x2000 | 0x4000: // VT_ARRAY|VT_BYREF
			_struct RefARRAY
			{
				NdrPtr pparray;
				switch
				{
					case pparray.ReferentId:
						[Local.VariantValue = parray.ToString]
						OLEAUTPSafeArray parray;
				}
			}
		case 12 | 0x4000: // VT_VARIANT|VT_BYREF
			_struct RefVARIANT
			{
				NdrPtr pvarVal;
				switch
				{
					case pvarVal.ReferentId:
						[Local.VariantValue = varVal.ToString]
						OLEAUTVariant varVal;
				}
			}
		case 16: // VT_I1
			Struct
			{
				[Local.VariantValue = cVal.ToString]
				char cVal;
				Switch
				{
					case Property.MSRPCNdr64:
					Align8 pad;
				}
			}
		case 18: // VT_UI2
			Struct
			{
				[Local.VariantValue = uiVal.ToString]
				UINT16 uiVal;
				Switch
				{
					case Property.MSRPCNdr64:
					Align8 pad;
				}
			}
			
		case 19: // VT_UI4
			struct
			{
				Align4 Pad;
				[Local.VariantValue = ulVal.ToString]
				UINT32 ulVal;
				Switch
				{
					case Property.MSRPCNdr64:
					Align8 pad;
				}
			}
		case 21: // VT_UI8
		struct
			{
				Align8 Pad;
				[Local.VariantValue = ullVal.ToString]
				UINT64 ullVal;
			}
		case 22: // VT_INT
		struct
			{
				Align4 Pad;
				[Local.VariantValue = intVal.ToString]
				INT32 intVal;
				Switch
				{
					case Property.MSRPCNdr64:
					Align8 pad;
				}
			}
		case 23: // VT_UINT
		struct
			{
				Align4 Pad;
				[Local.VariantValue = uintVal.ToString]
				UINT32 uintVal;
				Switch
				{
					case Property.MSRPCNdr64:
					Align8 pad;
				}
			}
		case 14: // VT_DECIMAL
		struct
			{
				Align8 Align;
				[Local.VariantValue = decVal.ToString]
				OLEAUTDecimal decVal;
			}
		case 16 | 0x4000: // VT_I1|VT_BYREF
			_struct RefI1
			{
				NdrPtr pcVal;
				switch
				{
					case pcVal.ReferentId:
						[Local.VariantValue = cVal.ToString]
						char cVal;
				}
			}
		case 18 | 0x4000: // VT_UI2|VT_BYREF
			_struct RefUI2
			{
				NdrPtr puiVal;
				switch
				{
					case puiVal.ReferentId:
						[Local.VariantValue = ulVal.ToString]
						UINT16 ulVal;
				}
			}
		case 19 | 0x4000: // VT_UI4|VT_BYREF
			_struct RefUI4
			{
				NdrPtr pulVal;
				switch
				{
					case pulVal.ReferentId:
						[Local.VariantValue = ulVal.ToString]
						UINT32 ulVal;
				}
			}
		case 21 | 0x4000: // VT_UI8|VT_BYREF
			_struct RefUI8
			{
				NdrPtr pullVal;
				switch
				{
					case pullVal.ReferentId:
						_struct ullVal
						{
							Align8 Align;
							[Local.VariantValue = ullVal.ToString]
							UINT64 ullVal;
						}
				}
			}
		case 22 | 0x4000: // VT_INT|VT_BYREF
			_struct RefINT
			{
				NdrPtr pintVal;
				switch
				{
					case pintVal.ReferentId:
						[Local.VariantValue = intVal.ToString]
						INT32 intVal;
				}
			}
		case 23 | 0x4000: // VT_UINT|VT_BYREF
			_struct RefUINT
			{
				NdrPtr puintVal;
				switch
				{
					case puintVal.ReferentId:
						[Local.VariantValue = uintVal.ToString]
						UINT32 uintVal;
				}
			}
		case 14 | 0x4000: // VT_DECIMAL|VT_BYREF
			_struct RefDECIMAL
			{
				NdrPtr pdecVal;
				switch
				{
					case pdecVal.ReferentId:
					struct
					{
						Align8 Align;
						[Local.VariantValue = decVal.ToString]
						OLEAUTDecimal decVal;
						
					}
				}
			}
	}
}


table OLEAUTSysKindTable(value)
{
	switch(value)
	{
		case 0x00000001: "SYS_WIN32";
		case 0x00000003: "SYS_WIN64";
		default:
			FormatString("Unknwon value: %d", value);
	}
}

struct OLEAUTTlibAttr
{
	GUID(true) Guid;
	OLEAUTLCID Lcid;
	NdrV1Enum(4) syskind = OLEAUTSysKindTable(this);
	UINT16 wMajorVerNum;
	UINT16 wMinorVerNum;
	NdrV1Enum(2) wLibFlags
	{
		NdrV1Enum(2) FRESTRICTED:1 = FormatString("(%s) %s", this.ToBitString, this? "[restricted] attribute": "");
		NdrV1Enum(2) FCONTROL:1 = FormatString("   (%s) %s", this.ToBitString, this? "[control] attribute": "");
		NdrV1Enum(2) FHIDDEN:1 = FormatString("    (%s) %s", this.ToBitString, this? "[hidden] attribute": "");
		NdrV1Enum(2) Reserved:13 = FormatString("   (%s)", this.ToBitString);
	};
}

struct OLEAUTCustDataItem = Guid.ToString
{
	GUID(true) Guid;
	NdrPtr Pointer;
}

struct OLEAUTCustData
{
	NdrAlign pad;
	UINT32 cCustData;
	NdrPtrToConformant CustDataCount;
	switch
	{
		case CustDataCount.MaxCount:
			struct CustDataItem
			{
				OLEAUTCustDataItem CustDataItem[CustDataCount.MaxCount];
				OLEAUTWireVariant CustDataItemTail[CustDataCount.MaxCount];
			}
	}
}

table OLEAUTTypeKindTable(value)
{
	switch(value)
	{
		case 0x00000000: "TKIND_ENUM";
		case 0x00000001: "TKIND_RECORD";
		case 0x00000002: "TKIND_MODULE";
		case 0x00000003: "TKIND_INTERFACE";
		case 0x00000004: "TKIND_DISPATCH";
		case 0x00000005: "TKIND_COCLASS";
		case 0x00000006: "TKIND_ALIAS";
		case 0x00000007: "TKIND_UNION";
		default:
			FormatString("Unknown value: %d", value);
	}
}

struct OLEAUTTypeAttr
{
	GUID(true) Guid;
	OLEAUTLCID Lcid;
	UINT32 dwReserved1;
	UINT32 dwReserved2;
	UINT32 dwReserved3;
	// must be NULL
	NdrPtr lpstrReserved4;
	UINT32 cbSizeInstance;
	NdrV1Enum(4) typeKind = OLEAUTTypeKindTable(this);
	UINT16 cFuncs;
	UINT16 cVars;
	UINT16 cImplTypes;
	UINT16 cbSizeVft;
	UINT16 cbAlignment;
	UINT16 wTypeFlags;
	UINT16 wMajorVerNum;
	UINT16 wMinorVerNum;
	NdrAlign pad;
	OLEAUTTypeDesc tdescAlias;
	UINT32 dwReserved5;
	UINT16 dwReserved6;
}

table OLEAUTVarKindTable(value)
{
	switch(value)
	{
		case 0x00000000: "VAR_PERINSTANCE";
		case 0x00000001: "VAR_STATIC";
		case 0x00000002: "VAR_CONST";
		case 0x00000003: "VAR_DISPATCH";
		default:
			FormatString("Unkwnon value: %d", value);
	}
}

struct OLEAUTVarDesc
{
	OLEAUTDISPID memid;
	NdrWIDESTRINGPtr lpstrReserved;
	Align4 Pad2;
	NdrV1Enum(4) vtVarKind = OLEAUTVarKindTable(this);
	switch(vtVarKind)
	{
		case 0x00000000:
		case 0x00000001:
		case 0x00000003:
			UINT32 oInst;
		case 0x00000002:
			[local.VarValue = lpVarValue.ReferentID]
			NdrPtr lpVarValue;

	}
	OLEAUTElemDesc elemdescVar;
	UINT16 wVarFlags
	{
		UINT16 FREADONLY:1 = FormatString("       (%s) %s", this.ToBitString, this? "[readonly] attribute": "");
		UINT16 FSOURCE:1 = FormatString("         (%s) %s", this.ToBitString, this? "[source] attribute": "");
		UINT16 FBINDABLE:1 = FormatString("       (%s) %s", this.ToBitString, this? "[bindable] attribute": "");
		UINT16 FREQUESTEDIT:1 = FormatString("    (%s) %s", this.ToBitString, this? "[requestedit] attribute": "");
		UINT16 FDISPLAYBIND:1 = FormatString("    (%s) %s", this.ToBitString, this? "[displaybind] attribute": "");
		UINT16 FDEFAULTBIND:1 = FormatString("    (%s) %s", this.ToBitString, this? "[defaultbind] attribute": "");
		UINT16 FHIDDEN:1 = FormatString("         (%s) %s", this.ToBitString, this? "[hidden] attribute": "");
		UINT16 FRESTRICTED:1 = FormatString("     (%s) %s", this.ToBitString, this? "[restriected] attribute": "");
		UINT16 FDEFAULTCOLLELEM:1 = FormatString("(%s) %s", this.ToBitString, this? "[defaultcollelem] attribute": "");
		UINT16 FUIDEFAULT:1 = FormatString("      (%s) %s", this.ToBitString, this? "[uidefault] attribute": "");
		UINT16 FNONBROWSABLE:1 = FormatString("   (%s) %s", this.ToBitString, this? "[nonbrowsable] attribute": "");
		UINT16 FREPLACEABLE:1 = FormatString("    (%s) %s", this.ToBitString, this? "[replaceable] attribute": "");
		UINT16 FIMMEDIATEBIND:1 = FormatString("  (%s) %s", this.ToBitString, this? "[immediatebind] attribute": "");
		UINT16 Reserved:3 = FormatString("        (%s)", this.ToBitString);
	}
	Align4 pad;
	NdrV1Enum(4) VarKind = OLEAUTVarKindTable(this);

	switch
	{
		case local.VarValue:
			OLEAUTVariant VarValue;
	}
}

struct OLEAUTParamDescEx
{
	UINT32 cBytes;
	OLEAUTVariant varDefaultValue;
}

struct OLEAUTParamDesc
{
	[property.OLEAUTParamDescExPtr = PtrParamDescEx.ReferentID]
	NdrPtr PtrParamDescEx;
	[
		property.OLEAUTElemParamDescBag$[property.OLEAUTElemCount] = PtrParamDescEx.ReferentID,
		property.OLEAUTElemCount = property.OLEAUTElemCount + 1
	]
	UINT16 wParamFlags
	{
		UINT16 FIN:1 = FormatString("         (%s) %s", this.ToBitString, this? "[in] attribute": "");
		UINT16 FOUT:1 = FormatString("        (%s) %s", this.ToBitString, this? "[out] attribute": "");
		UINT16 FLCID:1 = FormatString("       (%s) %s", this.ToBitString, this? "[lcid] attribute": "");
		UINT16 FRETVAL:1 = FormatString("     (%s) %s", this.ToBitstring, this? "[retval] attribute": "");
		UINT16 FOPT:1 = FormatString("        (%s) %s", this.ToBitString, this? "[optional] attribute": "");
		UINT16 FHASDEFAULT:1 = FormatString(" (%s) %s", this.ToBitString, this? "[defaultvalue] attribute": "");
		UINT16 FHASCUSTDATA:1 = FormatString("(%s) %s", this.ToBitString, this? "[custom] attribute": "");
		UINT16 Reserved:9 = FormatString("    (%s)", this.ToBitString);
	}
	switch
	{
		case PtrParamDescEx.ReferentID:
			[
				property.OLEAUTParamDescBag$[property.OLEAUTParamDescBagCount] = PtrParamDescEx.ReferentID,
				property.OLEAUTParamDescBagCount = property.OLEAUTParamDescBagCount + 1
			]
			_struct BlahBlah{};
	}
}

struct OLEAUTParamDescTail(Ptr)
{
	switch
	{
		case Ptr:
			OLEAUTParamDescEx ParamDescEx;
	}
}

struct OLEAUTArrayDesc = OLEAUTVariantVarTypeTable(local.vtType)
{
	NdrConformant DimCount;
	[local.vtType = TypeDesc.vtType]
	OLEAUTTypeDesc2 TypeDesc;
	UINT16 cDims;
	Switch
	{
		case Property.MSRPCNdr64:
		Align8 pad1;
	}
	switch
	{
		case cDims:
			OLEAUTSafeArrayBound Bound[cDims];
	}
	switch(local.vtType)
	{
		case 0x0000001A:
		case 0x0000001B:
			_struct
			{
				NdrAlign Pad;
				OLEAUTTypeDesc TypeDesc;
			}
	}

}

struct OLEAUTTypeDesc = OLEAUTVariantVarTypeTable(vtType)
{
	[property.OLEAUTvtType = vtType]
	UINT16 vtType = OLEAUTVariantVarTypeTable(this);
	[
		property.OLEAUTElemTypeDescBag$[property.OLEAUTElemCount] = vtType
	]
	switch(vtType)
	{
		case 0x0000001A:
		case 0x0000001B:
		case 0x0000001C:
			_struct
			{
				NdrPtr PtrType;
			}
		case 0x00000001D:
			_struct
			{
				Align4 Pad;
				UINT32 hreftype;
			}

	}
	UINT16 vt = OLEAUTVariantVarTypeTable(this);

	switch(vt)
	{
		case 0x0000001A:
		case 0x0000001B:
		case 0x0000001C:
			[
				property.OLEAUTTypeDescBag$[property.OLEAUTTypeDescBagCount] = vt,
				property.OLEAUTTypeDescBagCount = property.OLEAUTTypeDescBagCount + 1
			]
			_struct BlahBlah{};
	}
}

struct OLEAUTTypeDesc2 = OLEAUTVariantVarTypeTable(vtType)
{
	NdrAlign Pad;
	UINT16 vtType;
	Switch
	{
		case Property.MSRPCNdr64:
		Align8 pad1;
	}
	switch(vtType)
	{
		case 0x0000001A:
		case 0x0000001B:
		case 0x0000001C:
			_struct
			{
				NdrPtr PtrType;
			}
		case 0x00000001D:
			_struct
			{
				Align4 Pad;
				UINT32 hreftype;
			}

	}
	UINT16 vt;
	Switch
	{
		case Property.MSRPCNdr64:
		Align8 pad2;
	}
}

struct OLEAUTTypeDesc3
{
	NdrAlign Pad;
	UINT16 vtType = OLEAUTVariantVarTypeTable(this);
	switch(vtType)
	{
		case 0x0000001A:
		case 0x0000001B:
			_struct
			{
				NdrPtr PtrType;
				UINT16 vt = OLEAUTVariantVarTypeTable(this);
			}

		case 0x0000001C:
			_struct
			{
				NdrPtr PtrType;
				UINT16 vt = OLEAUTVariantVarTypeTable(this);
				NdrAlign Pad2;
				OLEAUTArrayDesc ArrayDesc;
			}
		case 0x0000001D:
			_struct
			{
				Align4 Pad;
				UINT32 hreftype;
				UINT16 vt = OLEAUTVariantVarTypeTable(this);
			}
		default:
			_struct
			{
				UINT16 vt = OLEAUTVariantVarTypeTable(this);
			}
	}

	switch(vtType)
	{
		case 0x0000001A:
		case 0x0000001B:
			[
				property.OLEAUTTypeDescBag$[property.OLEAUTTypeDescBagCount] = vtType,
				property.OLEAUTTypeDescBagCount = property.OLEAUTTypeDescBagCount + 1
			]
			_struct BlahBlah{};
	}
}

struct OLEAUTTypeDescTail(Type)
{
	switch(Type)
	{
		case 0x0000001A:
		case 0x0000001B:
			_struct
			{
				NdrAlign Pad;
				[local.vtType = TypeDesc.vtType]
				OLEAUTTypeDesc3 TypeDesc;
			}
		case 0x0000001C:
			_struct
			{
				NdrAlign Pad;
				[local.vtType = TypeDesc.vtType]
				OLEAUTArrayDesc ArrayDesc;
			}
	}
}


struct OLEAUTElemDesc = TypeDesc.ToString
{
	OLEAUTTypeDesc TypeDesc;
	OLEAUTParamDesc ParamDesc;
}

struct OLEAUTElemDescTail(MaxCount)
{
	[local.count = 0]
	[MaxLoopCount = MaxCount]
	while [local.count < MaxCount]
	{
		[local.vtType = property.OLEAUTElemTypeDescBag$[local.count]]
		switch(local.vtType)
		{
			case 0x0000001A:
			case 0x0000001B:
			case 0x0000001C:
				OLEAUTTypeDescTail(local.vtType) TypeDescTail;
		}
		[local.ParamPtr = property.OLEAUTElemParamDescBag$[local.count]]
		switch
		{
			case local.ParamPtr:
				OLEAUTParamDescTail(local.ParamPtr) ParamDescTail;
		}

		[local.count = local.count + 1]
		_struct BlahBlah{}
	}
}

struct OLEAUTFuncDesc
{
	OLEAUTDISPID memid;
	[local.ptrScode = PtrScodeCount.ReferentID]
	NdrPtr PtrScodeCount;
	[local.ptrParam = PtrParamCount.ReferentID]
	NdrPtr PtrParamCount;
	NdrV1Enum(4) FuncKind = OLEAUTFuncKindTable(this);
	NdrV1Enum(4) InvokeKind = OLEAUTInvokeKindTable(this);
	NdrV1Enum(4) CallConv = OLEAUTCallConvTable(this);
	UINT16 cParams;
	UINT16 cParamsOpt;
	UINT16 oVft;
	UINT16 cReserved2;
	[post.local.vtType = property.OLEAUTvtType, post.local.ParamPtr = property.OLEAUTParamDescExPtr]
	OLEAUTElemDesc ElemdescFunc;
	UINT16 wFuncFlags
	{
		UINT16 FRESTRICTED:1 = FormatString("      (%s) %s", this.ToBitString, this? "[restricted] attribute": "");
		UINT16 FSOURCE:1 = FormatString("          (%s) %s", this.ToBitString, this? "[source] attribute": "");
		UINT16 FBINDABLE:1 = FormatString("        (%s) %s", this.ToBitString, this? "[bindable] attribute": "");
		UINT16 FREQUESTEDIT:1 = FormatString("     (%s) %s", this.ToBitString, this? "[requestedit] attribute": "");
		UINT16 FDISPLAYBIND:1 = FormatString("     (%s) %s", this.ToBitString, this? "[displaybind] attribute": "");
		UINT16 FDEFAULTBIND:1 = FormatString("     (%s) %s", this.ToBitString, this? "[defaultbind] attribute": "");
		UINT16 FHIDDEN:1 = FormatString("          (%s) %s", this.ToBitString, this? "[hidden] attribute": "");
		UINT16 FUSESGETLASTERROR:1 = FormatString("(%s) %s", this.ToBitString, this? "[usesgetlasterror] attribute": "");
		UINT16 FDEFAULTCOLLELEM:1 = FormatString(" (%s) %s", this.ToBitString, this? "[defaultcollelem] attribute": "");
		UINT16 FUIDEFAULT:1 = FormatString("       (%s) %s", this.ToBitString, this? "[uidefault] attribute": "");
		UINT16 FNONBROWSABLE:1 = FormatString("    (%s) %s", this.ToBitString, this? "[nonbrowsable] attribute": "");
		UINT16 FREPLACEABLE:1 = FormatString("     (%s) %s", this.ToBitString, this? "[replaceable] attribute": "");
		UINT16 FIMMEDIATEBIND:1 = FormatString("   (%s) %s", this.ToBitString, this? "[immediatebind] attribute": "");
		UINT16 Reserved:3 = FormatString("         (%s)", this.ToBitString);
	}
	switch
	{
		case local.ptrScode:
			_struct
			{
				NdrConformant ScodeCount;
				UINT32 SCODE[ScodeCount.MaxCount];
			}
	}
	switch
	{
		case local.ptrParam:
			_struct
			{
				[property.OLEAUTParamDescBagCount = 0, property.OLEAUTTypeDescBagCount = 0, property.OLEAUTElemCount = 0]
				NdrConformant ParamCount;
				OLEAUTElemDesc ElemDesc[ParamCount.MaxCount];
				[property.tmpBagCount = property.OLEAUTTypeDescBagCount]
				OLEAUTElemDescTail(property.OLEAUTElemCount) ElemDescTail;
				while [property.tmpBagCount < property.OLEAUTTypeDescBagCount]
				{
					OLEAUTTypeDescLoop TypeDescTail[property.OLEAUTTypeDescBagCount - property.tmpBagCount];
				}
			}
	}
	switch(local.vtType)
	{
		case 0x0000001A:
		case 0x0000001B:
		case 0x0000001C:
			OLEAUTTypeDescTail(local.vtType) TypeDescTailElemFunc;
	}
	switch
	{
		case local.ParamPtr:
			OLEAUTParamDescEx ParamDescEx;
	}
}

struct OLEAUTTypeDescLoop
{
	[local.vtType = property.OLEAUTTypeDescBag$[property.tmpBagCount]]
	[property.tmpBagCount = property.tmpBagCount + 1]
	switch(local.vtType)
	{
		case 0x0000001A:
		case 0x0000001B:
			_struct
			{
				NdrAlign Pad;
				OLEAUTTypeDesc TypeDesc;
			}
//		case 0x0000001C:
//			_struct
//			{
//				NdrAlign Pad;
//				OLEAUTArrayDesc ArrayDesc;
//			}
	}
}

table OLEAUTCallConvTable(value)
{
	switch(value)
	{
		case 1: "CC_CDECL";
		case 2: "CC_PASCAL";
		case 4: "CC_STDCALL";
		default:
			FormatString("Unknwon value: %d", value);
	}
}

table OLEAUTFuncKindTable(value)
{
	switch(value)
	{
		case 0x00000001: "FUNC_PUREVIRTUAL";
		case 0x00000003: "FUNC_STATIC";
		case 0x00000004: "FUNC_DISPATCH";
		default:
			FormatString("UnKnown value: %d", value);
	}
}

table OLEAUTDescKindTable(value)
{
	switch(value)
	{
		case 0x00000000: "DESCKIND_NONE";
		case 0x00000001: "DESCKIND_FUNCDESC";
		case 0x00000002: "DESCKIND_VARDESC";
		case 0x00000003: "DESCKIND_TYPECOMP";
		case 0x00000004: "DESCKIND_IMPLICITAPPOBJ";
	 	default:
	 		FormatString("Unknown value: %d", value);
	}
}

table OLEAUTInvokeKindTable(value)
{
	switch(value)
	{
		case 0x00000001: "INVOKE_FUNC";
		case 0x00000002: "INVOKE_PROPERTYGET";
		case 0x00000004: "INVOKE_PROPERTYPUT";
		case 0x00000008: "INVOKE_PROPERTYPUTREF";
		default:
			FormatString("Unknown value: %d", value);
	}
}