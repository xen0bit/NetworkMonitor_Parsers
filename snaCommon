//#  (c) 2009 CodePlex Foundation
//#
//#  Title:                  Systems Network Architecture Protocol
//#
//#  Details:                
//#
//#  Public References:      RFC 1538
//#
//#  Comments:               
//#
//#  Revision Class and Date:Minor, 2/4/2010
//#
//####

//UnsignedNumber SessionAddress
//{
	//size = 8,
	//DisplayFormat = FormatString("%02X %02X %02X %02X %02X %02X %02X %02X",this[7],
								 //this[6],this[5],this[4],this[3],this[2],this[1],this[0]);
	////ByteOrder = LittleEndian
//}
Protocol SNA = FormatString("SNA Packet:%s:(%s)%s%s %s",
							Property.RRI ? "Res":"Req",
							SNARUTable(Property.RuCat),
							Property.SDI ? "(SD)":"",
							Property.LCCI ? "Compressed" : "",
							Property.FMHType ? Property.FMHType : "")
{
	SNATransmissionHeader TransmissionHeader;
	switch
	{
		case (Offset < FrameLength) && (UINT8( Framedata, Offset ) & 0x80) == 0x00: SNARequestHeader RequestHeader;
		case (Offset < FrameLength) && (UINT8( Framedata, Offset ) & 0x80) == 0x80: SNAResponseHeader ResponseHeader;
	}
	switch
	{
		case (Offset < FrameLength) && Property.RRI == 0: SNARU RequestUnit;
		case (Offset < FrameLength) && Property.RRI: SNARU ResponseUnit;
	}
}
/*---------------------merge liam's code of FMD-----------------------------------*/
Table SNAFMDNSHeaderTable(value)
{
	Switch(value)
	{
		case 0x010201:"CONTACT";
		case 0x010202:"DISCONTACT";
		case 0x010203:"IPLINIT";
		case 0x010204:"IPLTEXT";
		case 0x010205:"IPLFINAL";
		case 0x010206:"DUMPINIT";
		case 0x010207:"DUMPTEXT";
		case 0x010208:"DUMPFINAL";
		case 0x010209:"RPO";
		case 0x01020A:"ACTLINK";
		case 0x01020B:"DACTLINK";
		case 0x01020E:"CONNOUT";
		case 0x01020F:"ABCONN";
		case 0x010211:"SETCV (FMD NS(c))";
		case 0x010214:"ESLOW";
		case 0x010215:"EXSLOW";
		case 0x010216:"ACTCONNIN";
		case 0x010217:"DACTCONNIN";
		case 0x010218:"ABCONNOUT";
		case 0x010219:"ANA";
		case 0x01021A:"FNA";
		case 0x01021B:"REQDISCONT";
		case 0x010280:"CONTACTED";
		case 0x010281:"INOP";
		case 0x010284:"REQCONT";
		case 0x010285:"NS-LSA";
		case 0x010301:"EXECTEST";
		case 0x010302:"ACTTRACE";
		case 0x010303:"DACTTRACE";
		case 0x010311:"SETCV (FMD NS(ma))";
		case 0x010331:"DISPSTOR";
		case 0x010334:"RECSTOR";
		case 0x010381:"RECMS";
		case 0x010382:"RECTD";
		case 0x010383:"RECTRD";
		case 0x010604:"NSPE";
		case 0x010681:"INIT-SELF (Format 0)";
		case 0x010683:"TERM-SELF (Format 0)";
		case 0x410210:"RNAA";
		case 0x41021C:"DELETENR";
		case 0x41021D:"ER-INOP";
		case 0x41021E:"ADDLINK";
		case 0x410220:"NOTIFY (SSCP<--->PU)";
		case 0x410221:"ADDLINKSTA";
		case 0x410223:"VR-INOP";
		case 0x410235:"INITPROC";
		case 0x410236:"PROCSTAT";
		case 0x410237:"LDREQD";
		case 0x41023E:"REQACTPU";
		case 0x41023F:"REQDACTPU";
		case 0x410240:"REQACTLU";
		case 0x410243:"NS-IPL-INIT";
		case 0x410244:"NS-IPL-TEXT";
		case 0x410245:"NS-IPL-FINAL";
		case 0x410246:"NS-IPL-ABORT";
		case 0x410286:"REQFNA";
		case 0x410287:"LCP";
		case 0x410289:"ROUTE-INOP";
		case 0x41028A:"REQACTCDRM";
		case 0x410304:"REQMS";
		case 0x410305:"TESTMODE";
		case 0x410307:"ROUTE-TEST";
		case 0x410384:"RECFMS";
		case 0x410385:"RECTR";
		case 0x410386:"ER-TESTED";
		case 0x41038D:"NMVT";
		case 0x810387:"REQECHO";
		case 0x810389:"ECHOTEST";
		case 0x810601:"CINIT";
		case 0x810602:"CTERM";
		case 0x810620:"NOTIFY (SSCP<--->LU)";
		case 0x810629:"CLEANUP";
		case 0x810680:"INIT-OTHER";
		case 0x810681:"INIT-SELF (Format 1)";
		case 0x810682:"TERM-OTHER";
		case 0x810683:"TERM-SELF (Format 1)";
		case 0x810685:"BINDF";
		case 0x810686:"SESSST";
		case 0x810687:"UNBINDF";
		case 0x810688:"SESSEND";
		case 0x810810:"FORWARD (retired)";
		case 0x810812:"DELIVER (retired)";
		case 0x812601:"BFCINIT";
		case 0x812629:"BFCLEANUP";
		case 0x812681:"BFINIT";
		case 0x812683:"BFTERM";
		case 0x812686:"BFSESSST";
		case 0x812688:"BFSESSEND";
		case 0x81268C:"BFSESSINFO";
		case 0x818620:"NOTIFY (SSCP--->SSCP)";
		case 0x818627:"DSRLST";
		case 0x818640:"INIT-OTHER-CD";
		case 0x818641:"CDINIT";
		case 0x818643:"CDTERM";
		case 0x818645:"CDSESSSF";
		case 0x818646:"CDSESSST";
		case 0x818647:"CDSESSTF";
		case 0x818648:"CDSESSEND";
		case 0x818649:"CDTAKED";
		case 0x81864A:"CDTAKEDC";
		case 0x81864B:"CDCINIT";
		default      :FormatString("Undefined FMD Request Code(0x%06X)",value);
	}
}

Table SNANCRequestCodeTable( value )
{
	switch(value)
	{
		case 0x02:"NC-IPL-FINAL";
		case 0x03:"NC-IPL-INIT";
		case 0x04:"NC-IPL-TEXT";
		case 0x05:"LSA";
		case 0x06:"NC-ER-INOP";
		case 0x09:"NC-ER-TEST";
		case 0x0a:"NC-ER-TEST-REPLY";
		case 0x0b:"NC-ER-ACT";
		case 0x0c:"NC-ER-ACT-REPLY";
		case 0x0d:"NC-ACTVR";
		case 0x0e:"NC-DACTVR";
		case 0x0f:"NC-ER-OP";
		case 0x10:"ROUTE SETUP";
		case 0x46:"NC-IPL-ABORT";
		default  :FormatString("Undefined NC Request Code(0x%02X)",value);
	}
}

Table SNASCRequestCodeTable(value)
{
	switch(value)
	{
		case 0x0D:"ACTLU";
		case 0x0E:"DACTLU";
		case 0x11:"ACTPU";
		case 0x12:"DACTPU";
		case 0x14:"ACTCDRM";
		case 0x15:"DACTCDRM";
		case 0x31:"BIND";
		case 0x32:"UBIND";
		case 0x33:"SWITCH";
		case 0xA0:"SDT";
		case 0xA1:"CLEAR";
		case 0xA2:"STSN";
		case 0xA3:"RQR";
		case 0xC0:"CRV";
		default  :FormatString("Undefined SC Request Code(0x%02X)",value);
	}
}

Table SNADFCRequestCodeTable(value)
{
	switch(value)
	{
		case 0x03:"EXPD";
		case 0x04:"LUSTAT";
		case 0x05:"RTR";
		case 0x70:"BIS";
		case 0x71:"SBI";
		case 0x80:"QEC";
		case 0x81:"QC";
		case 0x82:"RELQ";
		case 0x83:"CANCEL";
		case 0x84:"CHASE";
		case 0xC0:"SHUTD";
		case 0xC1:"SHUTC";
		case 0xC2:"RSHUTD";
		case 0xC8:"BID";
		case 0xC9:"SIG";
		default  :FormatString("Undefined DFC Request Code(0x%02X)",value);
	}
}

Table SNARUResponseCodeTable(value)
{
	switch(value)
	{
		case 0x0D:"RSP(ACTLU)";
		case 0x11:"RSP(ACTPU)";
		case 0x31:"RSP(BIND)";
		case 0xa2:"RSP(STSN)";
		default  :FormatString("Undefined Response Code(0x%02X)",value);
	}
}

Table SNAEnqueueTypeTable(value)
{
	switch(value)
	{
		case  1:"Initiate only (I)";
		case  3:"Initiate/Enqueue";
		default:"Reserved";
	}
}

Table SNAInitOtherQueuingPositionTable(value)
{
	switch(value)
	{
		case  0:"Retired";
		case  1:"Enqueue this request FIFO";
		case  2:"Enqueue this request LIFO";
		case  3:"Reserved";
		default:FormatString("Undefined value (%d)", value);
	}
}

Table SNANMVYSequenceFieldTable(value)
{
	switch(value)
	{
		case 0x01:"Only NMVT for this PRID";
		case 0x02:"Last NMVT for this PRID";
		case 0x03:"First NMVT for this PRID";
		case 0x04:"Middle NMVT for this PRID";
		default:FormatString("%d(0x%X)",value,value);
	}
}

Table SNARECFMSCNMTargetIDDescriptorTable(value)
{
	switch(value)
	{
		case 0x01:"UINT8 4 contains a local address,UINT8 3 is reserved";
		case 0x02:"Bytes 3- 4   contain the element address of a link";
		default:FormatString("%d(0x%X)",value,value);
	}
}

/*------------------------------------------------------------------------------------------*/

Table SNASCBindTypeTable( type)
{
	switch( type )
	{
		case  0:"Negotiable";
		case  1:"Nonnegotiable";
		default:FormatString("%d",type);
	}
}

Table SNASCBindFMProfileTable( value )
{
	switch( value )
	{
		case 0x02:"FM profile 2";
		case 0x03:"FM profile 3";
		case 0x04:"FM profile 4";
		case 0x07:"FM profile 7";
		case 0x12:"FM profile 18";
		case 0x13:"FM profile 19";
		default  :FormatString("%d",value);
	}
}

Table SNASCBindTSProfileTable( value )
{
	switch( value )
	{
		case 0x02:"TS profile 2";
		case 0x03:"TS profile 3";
		case 0x04:"TS profile 4";
		case 0x07:"TS profile 7";
		default  :FormatString("%d",value);
	}
}

Table SNASCBindResponseTable( value )
{
	switch( value )
	{
		case  0:"No response";
		case  1:"Exception response";
		case  2:"Definite response";
		case  3:"Definite or exception response";
		default:FormatString("Undefined value (%d)", value);
	}
}


Table SNASCBindModeTable( value )
{
	switch( value )
	{
		case  0:"Full-duplex";
		case  1:"Half-duplex contention";
		case  2:"Half-duplex flip-flop";
		case  3:"Reserved";
		default: FormatString("Undefined value (%d)", value);
	}
}

Table SNASCBindLUTypeTable( value )
{
	switch( value )
	{
		case  0:"LU Type 0";
		case  1:"LU Type 1";
		case  2:"LU Type 2";
		case  3:"LU Type 3";
		case  4:"LU Type 4";
		case  6:"LU Type 6";
		case  7:"LU Type 7";
		default:FormatString("Undefined value (%d)",value);
	}
}

Table SNASCBindResponsibilityTable( value )
{
	switch( value )
	{
		case  0:"Operator controlled";
		case  1:"Primary half-session will reinitiate";
		case  2:"Secondary half-session will reinitiate";
		case  3:"Either may reinitiate";
		default:FormatString("Undefined value (%d)", value);
	}
}

Table SNASCBindCompressionTable( value )
{
	switch( value )
	{
		case  0:"No compression";
		case  1:"Compression supported by the PLU";
		case  2:"Reserved";
		case  3:"Compression requested by the PLU";
		default:FormatString("Undefined value (%d)", value);
	}
}

Table SNASCBindCryptoTable( value )
{
	switch( value )
	{
		case  0:"No session-level cryptography supported";
		case  1:"Session-level selective cryptography supported";
		case  2:"Reserved";
		case  3:"Session-level mandatory cryptography supported";
		default:FormatString("Undefined value (%d)", value);
	}
}

Table SNASCDACTLUTypeTable( value )
{
	switch( value )
	{
		case  1:"Normal deactivation";
		case  3:"Session-outage notification(SON)";
		default:FormatString("Undefined value (%d)", value);
	}
}

Table SNASCDACTLUCauseTable( value )
{
	switch(value)
	{
		case  7:"Virtual route inoperative";
		case  8:"Route extension inoperative";
		case  9:"Hierarchical reset";
		case 11:"Virtual route deactivated";
		case 12:"SSCP or LU failure unrecoverable";
		case 13:"Session override";
		case 14:"SSCP or LU failure recoverable";
		case 15:"Cleanup";
		default:FormatString("Undefined value (%d)", value);
	}
}

Table SNASCDACTPUTypeTable(value)
{
	switch(value)
	{
		case  1:"Final use, physical connection may be broken";
		case  2:"Not final use, physical connection should not be broken";
		case  3:"Session-outage notification (SON)";
		default:FormatString("Undefined value (%d)", value);
	}
}

Table SNASCDACTPUCauseTable( value )
{
	switch(value)
	{
		case  7:"Virtual route inoperative";
		case  8:"Route extension inoperative";
		case  9:"Hierarchical reset:";
		case 11:"Virtual route deactivated";
		case 12:"SSCP or PU failure unrecoverable";
		case 13:"Session override";
		case 14:"SSCP or PU failure recoverable";
		case 15:"Cleanup";
		case 16:"ALS reset";
		case 17:"Give-back";
		default:FormatString("Undefined value (%d)", value);
	}
}

Table SNAPSH10Table( value )
{
	switch( value )
	{
		case 0x05:"Prepare";
		case 0x06:"Request Commit";
		case 0x07:"Commited";
		case 0x08:"Forget";
		case 0x09:"Heuristic Mixed";
		case 0x0A:"New LUWID";
		default:FormatString("Undefined value (%d)", value);
	}
}

Table SNAFMH5CMDTable( value )
{
	switch( value )
	{
		case 0x202:"Attach transaction program";
		case 0x204:"Reset attached process";
		case 0x206:"Data descriptor";
		default:FormatString("Undefined value (%d)", value);
	}
}

Table SNAFH5SubFieldTable( value )
{
	switch( value )
	{
		case  0:"Profile";
		case  1:"Password";
		case  2:"User ID";
		default:FormatString("Undefined value (%d)", value);
	}
}

Table SNASyncLevelTable( value )
{
	switch( value )
	{
		case  0:"None";
		case  1:"Confirm";
		case  2:"Confirm,sync point,and backout";
		case  3:"Reserved";
		default:FormatString("Undefined value (%d)", value);
	}
}

Table SNAPVITable( value )
{
	switch( value )
	{
		case  0:"Persistent verification not supported or needed";
		case  1:"Sign-on requested";
		case  2:"Already signed on (Password subfield not included in this Attach)";
		case  3:"Reserved";
		default:FormatString("Undefined value (%d)", value);
	}
}

Table SNAF4RDESCRTable( value )
{
	switch( value )
	{
		case  0:"No logical record headers (LRHs) in transmission block";
		case  1:"LRHs present, with implicit lengths";
		default:FormatString("Reserved (%d)", value);
	}
}

Table SNAFMH4CMDTable( value )
{
	switch( value )
	{
		case 0x00:"CRT-NU-BLK";
		case 0x02:"CRT-SU-BLK";
		case 0x03:"CRT-SN-BLK";
		case 0x10:"CONT-NU-BLK";
		case 0x12:"CONT-SU-BLK";
		case 0x13:"CONT-SN-BLK";
		case 0x23:"DEL-SN-BLK";
		case 0x32:"UPD-SU-BLK";
		case 0x33:"UPD-SN-BLK";
		case 0x42:"RPL-SU-BLK";
		case 0x43:"RPL-SN-BLK";
		default:FormatString("Undefined value (%d)", value);
	}
}

Table SNAFMH4TT2Table( value )
{
	switch( value )
	{
		case 0x41:"FFR-FS record";
		case 0x42:"FFR-FS2 record";
		default:FormatString("Reserved (%d)", value);
	}
}

Table SNAFMH4TT1Table( value )
{
	switch( value )
	{
		case 0x00:"Inherit code (from MM-TT register)";
		case 0x40:"FFR-FNI record";
		case 0x41:"FFR-FS record";
		case 0x42:"FFR-FS2 record";
		default:FormatString("Reserved (%d)", value);
	}
}

Table SNAFMH3FunctionTable( value )
{
	switch( value )
	{
		case 0x02:"Compaction table";
		case 0x03:"Query for compaction table";
		case 0x04:"Prime FMH-1 SCB compression character";
		case 0x05:"Status";
		case 0x06:"Series ID";
		default  :FormatString("Undefined value(%d)",value);
	}
}

Table SNAFMH2FunctionTable( value )
{
	switch( value )
	{
		case 0x01:"Peripheral data information record (PDIR)";
		case 0x02:"Compaction table";
		case 0x04:"Prime FMH-1 SCB compression character";
		case 0x07:"Execute program offline";
		case 0x20:"Create data set";
		case 0x21:"Scratch data set";
		case 0x22:"Erase data set";
		case 0x23:"Password";
		case 0x24:"Add";
		case 0x25:"Replace";
		case 0x26:"Add replicate";
		case 0x27:"Replace replicate";
		case 0x28:"Query for data set";
		case 0x29:"Note";
		case 0X2B:"Record ID";
		case 0x2C:"Erase record";
		case 0x2D:"Scratch all data sets";
		case 0x2E:"Volume ID";
		case 0xAA:"Note reply (SRI is always on)";
		default:FormatString("Undefined value (%d)", value);
	}
}

Table SNAFMH1DSSELTable( value )
{
	switch( value )
	{
		case  0:"Resume";
		case  1:"End";
		case  2:"Begin";
		case  3:"Begin/End";
		case  4:"Suspend";
		case  5:"End-abort";
		case  6:"Continue";
		case  7:"Reserved";
		default:FormatString("Undefined value (%d)", value);
	}
}

Table SNAFMH1DSPTable( value )
{
	switch( value )
	{
		case  0:"Default (the DSP is implied by the Medium Select field)";
		case  1:"Base";
		case  2:"Gegeral";
		case  3:"Job";
		case  4:"WP raw-form text";
		case  5:"WP exchange diskette";
		case  7:"Office Information Interchange level 2";
		case 10:"Document interchange";
		case 11:"Structured field";
		default:FormatString("Reserved (%d)", value);
	}
}

Table SNAFMH1MediumTable( value )
{
	switch( value )
	{
		case  0:"Console";
		case  1:"Exchange";
		case  2:"Card";
		case  3:"Document";
		case  4:"Nonexchange disk";
		case  5:"Extended document";
		case  6:"Extender card";
		case  7:"Data set name select destination";
		case  8:"UINT16 processing media 1";
		case  9:"UINT16 processing media 2";
		case 10:"UINT16 processing media 3";
		case 12:"UINT16 processing media 4";
		default:FormatString("Undefined value (%d)", value);
	}
}

Table SNASDCategoryTable( value )
{
	switch( value )
	{
		case 0x00:"User Sense Data only";
		case 0x08:"Request Reject";
		case 0x10:"Request Error";
		case 0x20:"State Error";
		case 0x40:"Request Header (RH) Usage Error";
		case 0x80:"Path Error";
		case 0xA0:"Rapid Transport Protocol(RTP) Error";
		case 0xFF:"Set aside for implementation-specific use";
		default:FormatString("Undefined value (%d)", value);
	}
}

Table SNARUTable( value )
{
	switch( value )
	{
		case  0:"FM data";
		case  1:"Network control";
		case  2:"Data flow control";
		case  3:"Session control";
		default:FormatString("Undefined value (%d)", value);
	}
}

Table SNAVRSQTITable( value )
{
	switch( value )
	{
		case  0:"Nonsequenced, nonsupervisory (only value used for HPR FID4 THs).";
		case  1:"Nonsequenced, supervisory";
		case  2:"Singly sequenced";
		default:FormatString("Undefined value (%d)", value);
	}
}

Table SNATPFTable( value )
{
	switch( value )
	{
		case  0:"Low priority";
		case  1:"Medium priority";
		case  2:"High priority";
		default:FormatString("Undefined value (%d)", value);
	}
}

Table SNATGSFTable( value )
{
	switch( value )
	{
		case  0:"Not segmented";
		case  1:"Last segmented";
		case  2:"First segmented";
		case  3:"Middle segmented";
		default:FormatString("Undefined value (%d)", value);
	}
}

Table SNAPIUBFTable( value )
{
	switch( value )
	{
		case  0:"Single PIU frame";
		case  1:"Last PIU of a multiple PIU frame";
		case  2:"First PIU of a multiple PIU frame";
		case  3:"Middle PIU of a multiple PIU frame";
		default:FormatString("Undefined value (%d)", value);
	}
}

Table SNAMPFTable(value)
{
	switch(value)
	{
		case  0:"Middle segment of a BIU";
		case  1:"Last segment of a BIU";
		case  2:"First segment of a BIU";
		case  3:"Whole BIU";
		default:FormatString("Unknown BIU (%d)",value);
	}
}
Table SNAERITable(value)
{
	switch
	{
		case value == 0:
			"No response requested";
		case value == 0x10 ||
			value == 0x30 ||
			value == 0x90 ||
			value == 0xB0:
				"Exception response requested";
		case value == 0x20 ||
			value == 0x80 ||
			value == 0xC0:
				"Definite response requested";
		default:FormatString("Undefined request (%d)", value);
	}
}

Table SNARTITable(value)
{
	switch
	{
		case value == 0 || value == 0x10:"No response";
		case value == 0x20 || value == 0xA0:"CONFIRMED verb issued";
		case value == 0x30:"SEND_ERROR or no CONFIRMED verb issued";
		case value == 0x80:"Positive response";
		case value == 0x90:"Negative response";
		case value == 0xB0:"SEND_ERROR verb issued";
		default:FormatString("Undefined response (%d)", value);
	}
}

Table SNAChainIndicatoTable(value)
{
	switch(value)
	{
		case  0:"Middle RU in chain";
		case  1:"Last RU in chain";
		case  2:"First RU in chain";
		case  3:"Only RU in chain";
		default:FormatString("Undefined value (%d)", value);
	}
}
Table SNAFMHeader5LU62ResourceTypeTable(value)
{
	switch(value)
	{
		case 0xD0:"Half-duplex basic conversation";
		case 0xD1:"Half-duplex mapped conversation";
		case 0xD2:"Full-duplex basic conversation";
		case 0xD3:"Full-duplex mapped conversation";
		default:FormatString("Undefined value (%d)", value);
	}
}
Table SNAFMH5FXCTTable(value)
{
	switch(value)
	{
		case 0x00:"Reset attached process";
		case 0x02:"Attach transaction program, data descriptor";
		default:FormatString("Undefined value (%d)", value);
	}
}
Table SNASPCMODTable(value)
{
	switch(value)
	{
		case 0x0000:"The sender of FMH-10 does not care what RH settings are returned on the reply";
		case 0x0001:"The sender of FMH-10 requires an EB on the reply";
		case 0x0002:"The sender of FMH-10 requires a CD on the reply";
		default:FormatString("Undefined value (%d)", value);
	}
}

struct SNATransmissionHeader
{
	UINT8 FID2:4 = FormatString("(%s) %d", this.ToBitString, this);
	UINT8 MPF:2 = FormatString(" (%s) %s", this.ToBitString, SNAMPFTable(this));
	UINT8 ODAI:1 = FormatString("(%s) %s", this.ToBitString, this ? "Assignor Indicator Set" 
                                                                  : "Assignor Indicator Cleared");
	UINT8 EFI:1 = FormatString(" (%s) %s", this.ToBitString, this ? "Expedited Flow" 
                                                                 : "Normal Flow");
	UINT8 Reserved;
	UINT8 DestinationAddr;
	UINT8 OriginAddr;
	UINT16 SequenceNum;
}
//---------------------------------------------------------
//            bit 0    1    2    3    4    5    6    7
//     UINT8 0
//    Request     RRI |RU Cat   |r   |FI  |SDI |BCI |ECI
//    Response    RRI |RU Cat   |r   |FI  |SDI | 1  | 1
//     UINT8 1
//    Request     DR1I|LCCI|DR2I|ERI |r   |RLWI|QRI |PI
//    Response    DR1I|r   |DR2I|RTI |r   |r   |QRI |PI
//     UINT8 2
//    Request     BBI |EBI |CDI |r   |CSI |EDI |PDI |CEBI
//    Response    r   |r   |r   |r   |r   |r   |r   |r
//---------------------------------------------------------
struct SNARequestHeader
{
// UINT8 0
	UINT8 BYTE0
	{
		[RRI]
		UINT8 RRI:1 = FormatString("           (%s) %s", this.ToBitString, "Request");
		[RuCat]
		UINT8 RUCategory:2 = FormatString("    (%s) %s", this.ToBitString, SNARUTable(this));
		UINT8 Reserved1:1 = FormatString("     (%s)", this.ToBitString);
		[FI]
		UINT8 FI:1  = FormatString("            (%s) %s", this.ToBitString, this ? "FM or NS header" 
                                                                     : "No FM or NS header");
		[SDI]
		UINT8 SDI:1 = FormatString("           (%s) %s", this.ToBitString, this ? "Sense data included" 
                                                                     : "Sense data not included");
		UINT8 ChainIndicator:2 = FormatString("(%s) %s", this.ToBitString, SNAChainIndicatoTable(this));
	};
//UINT8 1
	switch(Property.RUcat)
	{
		case 0:
			_struct RHByte1
			{
				UINT8 BYTE1
				{
					UINT8 DR1I:1 = FormatString("     (%s) %s", this.ToBitString, this ? "DR1" : "-DR1");
					[LCCI]
					UINT8 LCCI:1 = FormatString("     (%s) %s", this.ToBitString, this ? "RU is compressed" 
                                                                                  : "RU is not compressed");
					UINT8 DR2I:1 = FormatString("     (%s) %s", this.ToBitString, this ? "DR2" : "-DR2");
					UINT8 ERI:1 = FormatString("      (%s) %s", this.ToBitString, SNAERITable(UINT8( Framedata, Offset ) & 0xB0));
					UINT8 Reserved2:1 = FormatString("(%s)", this.ToBitString);
					UINT8 RLWI:1 = FormatString("     (%s) %s", this.ToBitString, this ? "Larger pacing window requested"
                                                                                  : "Larger pacing window not requested");
					UINT8 QRI:1  = FormatString("      (%s) %s", this.ToBitString, this ? "Enqueue response in TC queues" 
                                                                                  : "Response bypasses TC queues");
					UINT8 PI:1   = FormatString("       (%s) %s", this.ToBitString, this ? "Pacing" : "No pacing");
				};
			};
		default:
			_struct RHByte1LCCIReserved
			{
				UINT8 BYTE1
				{
					UINT8 DR1I:1 = FormatString("     (%s) %s", this.ToBitString, this ? "DR1" : "-DR1");
					[LCCI=0]
					UINT8 LCCI:1= FormatString("     (%s) %s", this.ToBitString, "Reserved");
					UINT8 DR2I:1 = FormatString("     (%s) %s", this.ToBitString, this ? "DR2" : "-DR2");
					UINT8 ERI:1 = FormatString("      (%s) %s", this.ToBitString, SNAERITable(UINT8( Framedata, Offset ) & 0xB0));
					UINT8 Reserved2:1 = FormatString("(%s)", this.ToBitString);
					UINT8 RLWI:1 = FormatString("     (%s) %s", this.ToBitString, this ? "Larger pacing window requested" 
                                                                                  : "Larger pacing window not requested");
					UINT8 QRI:1  = FormatString("      (%s) %s", this.ToBitString, this ? "Enqueue response in TC queues" 
                                                                                  : "Response bypasses TC queues");
					UINT8 PI:1   = FormatString("       (%s) %s", this.ToBitString, this ? "Pacing" : "No pacing");
				};
			};
	}
//UINT8 2
	UINT8 BYTE2
	{
		UINT8 BBI:1  = FormatString("      (%s) %s", this.ToBitString, this ? "Begin Bracket" : "Not Begin Bracket");
		UINT8 EBI:1  = FormatString("      (%s) %s", this.ToBitString, this ? "End Bracket" : "Not End Bracket");
		UINT8 CDI:1  = FormatString("      (%s) %s", this.ToBitString, this ? "Change direction" 
                                                                      : "Do not change direction");
		UINT8 Reserved3:1 = FormatString("(%s)", this.ToBitString);
		UINT8 CSI:1  = FormatString("      (%s) %s", this.ToBitString, this ? "Code 1" : "Code 0");
		UINT8 EDI:1  = FormatString("      (%s) %s", this.ToBitString, this ? "RU is enciphered" : "RU is not enciphered");
		UINT8 PDI:1  = FormatString("      (%s) %s", this.ToBitString, this ? "RU is padded" : "RU is not padded");
		UINT8 CEBI:1 = FormatString("     (%s) %s", this.ToBitString, this ? "Conditional end bracket" 
                                                                      : "Not conditional end bracket");
	};
}

struct SNAResponseHeader
{
//UINT8 0
	UINT8 BYTE0
	{
		[RRI]
		UINT8 RRI:1 = FormatString("           (%s) %s", this.ToBitString, "Response");
		[RuCat]
		UINT8 RUCategory:2 = FormatString("    (%s) %s", this.ToBitString, SNARUTable(this));
		UINT8 Reserved1:1 = FormatString("     (%s)", this.ToBitString);
		[FI]
		UINT8 FI:1  = FormatString("            (%s) %s", this.ToBitString, this ? "FM or NS header" 
                                                                     : "No FM or NS header");
		[SDI]
		UINT8 SDI:1 = FormatString("           (%s) %s", this.ToBitString, this ? "Sence data included" 
                                                                     : "Sence data not included");
		UINT8 ChainIndicator:2 = FormatString("(%s) %s", this.ToBitString, SNAChainIndicatoTable(this));
	};
//UINT8 1
	UINT8 BYTE1
	{
		UINT8 DR1I:1 = FormatString("     (%s) %s", this.ToBitString, this ? "DR1" : "-DR1");
		UINT8 Reserved3:1 = FormatString("(%s)", this.ToBitString);
		UINT8 DR2I:1 = FormatString("     (%s) %s", this.ToBitString, this ? "DR2" : "-DR2");
		UINT8 RTI:1 = FormatString("      (%s) %s", this.ToBitString, SNARTITable(UINT8( Framedata, Offset ) & 0xB0));
		UINT8 Reserved2:2 = FormatString("(%s)", this.ToBitString);
		UINT8 QRI:1  = FormatString("      (%s) %s", this.ToBitString, this ? "Enqueue response in TC queues" 
                                                                      : "Response bypasses TC queues");
		UINT8 PI:1   = FormatString("       (%s) %s", this.ToBitString, this ? "Pacing" : "No pacing");
	};
//UINT8 2
	UINT8 Reserved4;
}

struct SNASenseData = SNASDCategoryTable(UINT8( Framedata, Offset ))
{
	UINT8 Category = SNASDCategoryTable(this)+FormatString(", %d(0x%X)",this,this);
	UINT8 Modifier;
	UINT16 SenseData;
}

struct SNAPIPGDSStruct = FormatString("%#X",GDSIndicator)
{
	UINT16 Length;
	UINT16 GDSIndicator;
	AsciiString(Length-4) Data;
}

struct SNAPIPGDSVariable = FormatString("%#X",GDSIndicator)
{
	[VariableEndOffset = offset + Length]
	UINT16 Length;
	UINT16 GDSIndicator;
	while condition[offset < Property.VariableEndOffset]
	{
		SNAPIPGDSStruct PIPGDSStruct;
	}
}

struct SNAFMHeader1
{
	UINT8 Length;
//UINT8 2
	UINT8 FMType
	{
		[FMHFollow]
		UINT8 FMH:1 = FormatString(" (%s) %s", this.ToBitString, this ? "Another FMH follows this FMH-1"
                                                                     : "No FMH follows this FMH-1");
		[FMHType = Property.FMHType ? Property.FMHType + FormatString("FMH-%d ",this)
									: FormatString("FMH-%d ",this)]
		UINT8 Type:7 = FormatString("(%s) %s", this.ToBitString, this);
	};
//UINT8 3
	switch
	{
		case (UINT8( Framedata, Offset + 2 ) & 0xE0)==0xA0 ||
			 (UINT8( Framedata, Offset + 2 ) & 0xE0)==0xC0 ||
			 (UINT8( Framedata, Offset + 2 ) & 0xE0)==0x80 ||
			 (UINT8( Framedata, Offset + 2 ) & 0xE0)==0x20:
				UINT8 Reserved;
		default:
			UINT8 BYTE3
			{
				[Medium]
				UINT8 Medium:4 = FormatString("        (%s) %s", this.ToBitString, SNAFMH1MediumTable(this));
				UINT8 LogicalSubAddr:4 = FormatString("(%s) %s", this.ToBitString, (this==0x0F) ? "Any device in medium class" 
                                                                                                : "Specific device in medium class");
			};
	}
//UINT8 4
	UINT8 BYTE4
	{
		UINT8 SRI:1 = FormatString("         (%s) %s", this.ToBitString, this ? "Stack to be used is the receiver's send stack" 
                                                                     : "stack to be used is the sender's send stack");
		UINT8 DemandSelect:1 = FormatString("(%s) %s", this.ToBitString, this ? "Receiver must direct data to specified medium/subaddress (spooling is prohibited)" 
                                               : "Receiver may direct data to alternate medium/subaddress");
		UINT8 Reserved:2 = FormatString("    (%s)", this.ToBitString);
		UINT8 DSP:4 = FormatString("         (%s) %s", this.ToBitString, SNAFMH1DSPTable(this));
	};
//UINT8 5
	switch
	{
		case (UINT8( Framedata, Offset ) & 0xE0) == 0x40 ||
			 (UINT8( Framedata, Offset ) & 0xE0) == 0x60 ||
			 (UINT8( Framedata, Offset ) & 0xE0) == 0xC0 :
				UINT8 BYTE5
				{
					UINT8 DSSEL:3 = FormatString("    (%s) %s", this.ToBitString, SNAFMH1DSSELTable(this));
					UINT8 DST:1 = FormatString("      (%s) %s", this.ToBitString, this ? "Basic exchange format" 
                                                                                 : "Transmission exchange format");
					UINT8 Reserved2:1 = FormatString("(%s)", this.ToBitString);
					UINT8 CMI:1 = FormatString("      (%s) %s", this.ToBitString, this ? "FMH-1 SCB compression" 
                                                                                 : "No FMH-1 SCB compression");
					UINT8 CPI:1 = FormatString("      (%s) %s", this.ToBitString, this ? "Compaction" : "No compaction");
					UINT8 Reserved1:1 = FormatString("(%s)", this.ToBitString);
				};
		default:
			_struct BYTE5CPICMIReserved
			{
				UINT8 BYTE5
				{
					UINT8 DSSEL:3 = FormatString("    (%s) %s", this.ToBitString, SNAFMH1DSSELTable(this));
					UINT8 DST:1 = FormatString("      (%s) %s", this.ToBitString, this ? "Basic exchange format" 
                                                                                 : "Transmission exchange format");
					UINT8 Reserved2:1 = FormatString("(%s)", this.ToBitString);
					UINT8 CMI:1 = FormatString("      (%s) %s", this.ToBitString, "Meaningless and Invalid");
					UINT8 CPI:1 = FormatString("      (%s) %s", this.ToBitString, "Meaningless and Invalid");
					UINT8 Reserved1:1 = FormatString("(%s)", this.ToBitString);
				};
			};
		}
//UINT8 6
	switch(Property.Medium)
	{
		//case UINT8( Framedata, FrameOffset - 1 ) & 0xE0 == 0x40 || UINT8( Framedata, FrameOffset - 1 ) & 0xE0 == 0x60 || UINT8( Framedata, FrameOffset - 1 ) & 0xE0 == 0xC0 :
		case 1: UINT8 ExchangeLength;
		case 2: UINT8 CardLength;
		default: UINT8 Reserved;
	}
//UINT8 7-8
	UINT16 Reserved4;
//UINT8 9
	UINT8 DSLEN;
//10 - end
	AsciiString(DSLEN) DSNAME;
}

struct SNAFMHeader2
{
	UINT8 Length;
//UINT8 2
	UINT8 FMType
	{
		[FMHFollow]
		UINT8 FMH:1 = FormatString(" (%s) %s", this.ToBitString, this ? "Another FMH follows this FMH-2" 
                                                                     : "No FMH follows this FMH-2");
		[FMHType = Property.FMHType ? Property.FMHType + FormatString("FMH-%d ",this)
									: FormatString("FMH-%d ",this)]
		UINT8 Type:7 = FormatString("(%s) %s", this.ToBitString, this);
	};
//UINT8 3
	UINT8 SRI:1 = FormatString("         (%s) %s", this.ToBitString, this ? "FMH-2 pertains to the active destination of the rece" 
                                                                 : "FMH-2 pertains to the active destination of the send");
	UINT8 FMH2Function:7 = FormatString("(%s) %s", this.ToBitString, SNAFMH2FunctionTable(UINT8( Framedata, Offset )));
	AsciiString(Length-3) Parameters = FormatString("%d bytes",Length-3);
}

struct SNAFMHeader3
{
	UINT8 Length;
//UINT8 2
	UINT8 FMType
	{
		[FMHFollow]
		UINT8 FMH:1 = FormatString(" (%s) %s", this.ToBitString, this ? "Another FMH follows this FMH-3" 
                                                                     : "No FMH follows this FMH-3");
		[FMHType = Property.FMHType ? Property.FMHType + FormatString("FMH-%d ",this)
									: FormatString("FMH-%d ",this)]
		UINT8 Type:7 = FormatString("(%s) %s", this.ToBitString, this);
	};
//UINT8 3
	UINT8 FMH3Function = SNAFMH3FunctionTable(this)+FormatString(", %d(0x%X)",this,this);
	AsciiString(Length-3) Parameters = FormatString("%d bytes",Length-3);
}

struct SNAFMHeader4
{
	UINT8 Length;
//UINT8 2
	UINT8 FMType
	{
		[FMHFollow = 0]
		UINT8 FMH:1 = FormatString(" (%s) %s", this.ToBitString, this ? "Another FMH follows this FMH-1"
                                                                     : "No FMH follows this FMH-1");
		[FMHType = Property.FMHType ? Property.FMHType + FormatString("FMH-%d ",this)
									: FormatString("FMH-%d ",this)]
		UINT8 Type:7 = FormatString("(%s) %s", this.ToBitString, this);
	};
	UINT8 FixedLengthParamLength;
	UINT8 BlockTransmissionType = SNAFMH4TT1Table(this)+FormatString(", %d(0x%X)",this,this);
	UINT8 BlockTransmissionRypeQualifier = SNAFMH4TT2Table(this)+FormatString(", %d(0x%X)",this,this);
	UINT8 Command = SNAFMH4CMDTable(this)+FormatString(", %d(0x%X)",this,this);
	UINT8 FMH4Flag
	{
		UINT8 Reserved2:2 = FormatString("             (%s)", this.ToBitString);
		UINT8 RecordDescriptorFlag:2 = FormatString("  (%s) %s", this.ToBitString, SNAF4RDESCRTable(this));
		UINT8 Reserved1:2 = FormatString("             (%s)", this.ToBitString);
		UINT8 BlockDataTransformFlag:1 = FormatString("(%s) %s", this.ToBitString, this ? "FMH4BDT present" : "FMH4BDT absent");
		UINT8 FMH4RDTF:1 = FormatString("              (%s) %s", this.ToBitString, this ? "FMH4RDTF" : "Not FMH4RDTF");
	};
	UINT8 BlockLength;
	AsciiString(BlockLength) BlockName;
	UINT8 BlockDataTransformLength;
	AsciiString(BlockDataTransformLength) BlockDataTransformField;
	UINT8 VersionIdentifierLength;
	AsciiString(VersionIdentifierLength) VersionIdentifier;
}

struct SNAFMHeader5LU62
{
	UINT8 Length;
//UINT8 2
	UINT8 FMType
	{
		[FMHFollow = 0]
		UINT8 Reserved:1 = FormatString("(%s)", this.ToBitString);
		[FMHType = Property.FMHType ? Property.FMHType + FormatString("FMH-%d ",this)
									: FormatString("FMH-%d ",this)]
		UINT8 Type:7 =  FormatString("    (%s) %d", this.ToBitString, this);
	};
	UINT16 CommandCode = FormatString("Attach, %d(0x%04X)",this,this);
//UINT8 5
	UINT8 BYTE5
	{
		UINT8 AVI:1 = FormatString("       (%s) %s", this.ToBitString, this ? "user ID is already verified" 
                                                                     : "user ID is not already verified");
		UINT8 PVI:2 = FormatString("       (%s) %s", this.ToBitString, SNAPVITable(this));
		UINT8 SPI:1 = FormatString("       (%s) %s", this.ToBitString, this ? "A Password subfield is present and contains a substituted password" 
                                                                     : "If a Password subfield is present in this Attach, the password is in the clear");
		[PIP]
		UINT8 PIP:1 = FormatString("       (%s) %s", this.ToBitString, this ? "PIP present following this FMH-5" 
                                                                     : "PIP not present following this FMH-5");
		UINT8 ExtendedAI:1 = FormatString("(%s) %s", this.ToBitString, this ? "Authentication Token Data GDS variable follows the FMH-5" 
                                                                            : "Authentication Token Data GDS variable doesn't follow the FMH-5");
		UINT8 Reserved1:2 = FormatString(" (%s) %s", this.ToBitString, "Reserved");
	};
//UINT8 6
	   UINT8 ParamLength;
	   UINT8 ResourceType=SNAFMHeader5LU62ResourceTypeTable(this)+FormatString(", %d(0x%X)",this,this);
	   UINT8 Reserved2;
//UINT8 9
	UINT8 BYTE9
	{
		UINT8 SyncLevel:2 = FormatString("(%s) %s", this.ToBitString, SNASyncLevelTable(this));
		UINT8 Reconnect:1 = FormatString("(%s) %s", this.ToBitString, this ? "yes" : "no");
		UINT8 Reserved3:5 = FormatString("(%s)", this.ToBitString);
	};
	UINT8 TransPrgNameLen;
	AsciiString(TransPrgNameLen) TransPrgName;
	[ASISEndOffset = offset + 1 + this]
	UINT8 AccessSecInfoLen;
	while condition[offset < Property.ASISEndOffset]
	{
		UINT8 ASISLength;
		UINT8 ASISType = SNAFH5SubFieldTable(this);
		AsciiString(ASISLength-1) ASI;
	};
	UINT8 LUWIDLen;
	UINT8 NQLUNameLen;
	AsciiString(NQLUNameLen) NQLUName;
	INT48 InstanceNum;
	UINT16 SeqNum;
	UINT8 ConvCorrelatorLen;
	AsciiString(ConvCorrelatorLen) ConvCorrelator;
	UINT8 AttachSNLen;
	switch
	{
		case AttachSNLen == 8:
			INT64 AttachSN;
		case AttachSNLen != 8 && AttachSNLen > 0:
			AsciiString(AttachSNLen) InvalidAttachSN = "Invalid length";
	}
}

struct SNAFMHeader5
{
	UINT8 Length;
	UINT8 FMType
	{
		[FMHFollow]
		UINT8 FMH:1 = FormatString(" (%s) %s", this.ToBitString, this ? "Another FMH follows this FMH-5" 
                                                                     : "No FMH follows this FMH-5");
		[FMHType = Property.FMHType ? Property.FMHType + FormatString("FMH-%d ",this)
									: FormatString("FMH-%d ",this)]
		UINT8 Type:7= FormatString("(%s) %d", this.ToBitString, this);
	};
	UINT16 CommandCode = SNAFMH5CMDTable(this)+FormatString(", %d(0x%X)",this,this);
	UINT8 Modifier;
	UINT8 FixedLengthParameters=SNAFMH5FXCTTable(this)+FormatString(", %d(0x%X)",this,this);
	UINT8 ATTDSP;
	UINT8 ATTDBA;
	AsciiString(Length - 8) ResourceNames;
}

Struct SNAFMH6Parameter
{
	Integer(LenOfParamLen + 1) FixedParamLength;
	AsciiString(FixedParamLength) FixedParameters;
}

struct SNAFMHeader6
{
	[FMEndOffset = offset + Length]
	UINT8 Length;
	UINT8 FMType
	{
		[FMHFollow]
		UINT8 FMH:1 = FormatString(" (%s) %s", this.ToBitString, this ? "Another FMH follows this FMH-6" 
                                                                     : "No FMH follows this FMH-6");
		[FMHType = Property.FMHType ? Property.FMHType + FormatString("FMH-%d ",this)
									: FormatString("FMH-%d ",this)]
		UINT8 Type:7 = FormatString("(%s) %s", this.ToBitString, this);
	};
	UINT16 CommandCode;
	UINT8 Modifier
	{
		[LenOfParamLen]
		UINT8 Length:1 = FormatString("  (%s) %s", this.ToBitString, this ? "2-UINT8 field" : "1-UINT8 field");
		UINT8 Reserved:7 = FormatString("(%s)", this.ToBitString);
	};
	while Parameters[ offset < Property.FMEndOffset ]
	{
		SNAFMH6Parameter Parameter;
	}
}

/*struct HexString = Property.OutputResult
{
	[OutputResult = "",DataCount = 0]struct{};
	while Length[offset + Property.DataCount < FrameLength && Property.LengthField > Property.DataCount]
	{
		[OutputResult = Property.OutputResult + FormatString("%02X ",UINT8( Framedata, Property.DataCount )struct{};
		[DataCount = Property.DataCount + 1]struct{};
	}
	AsciiString(Property.LengthField) Result = Property.OutputResult;
}*/

struct SNAFMHeader7LU62
{
	UINT8 Length;
//UINT8 2
	UINT8 FMType
	{
		[FMHFollow = 0]
		UINT8 Reserved:1 = FormatString("(%s)", this.ToBitString);
		[FMHType = Property.FMHType ? Property.FMHType + FormatString("FMH-%d ",this)
									: FormatString("FMH-%d ",this)]
		UINT8 Type:7 = FormatString("    (%s) %s", this.ToBitString, this);
	};
	SNASenseData SenseData;
	UINT8 ErrorLog
	{
		UINT8 ErrorLog:1 = FormatString("(%s) %s", this.ToBitString, this ? "Error log GDS variable follows this FMH-7" 
                                                                          : "No error log variable follows this FMH-7");
		UINT8 Reserved:7 = FormatString("(%s)", this.ToBitString);
	};
}

struct SNAFMHeader7
{
	UINT8 Length;
	UINT8 FMType
	{
		[FMHFollow = 0]
		UINT8 FMH:1 = FormatString(" (%s) %s", this.ToBitString, this ? "Reserved" : "No FMH follows this FMH-7");
		[FMHType = Property.FMHType ? Property.FMHType + FormatString("FMH-%d ",this)
									: FormatString("FMH-%d ",this)]
		UINT8 Type:7 = FormatString("(%s) %s", this.ToBitString, this);
	};
	SNASenseData SenseData;
	UINT16 RUSequenceNumber;
}

/* FM Header 8 , i did not find it's struct*/
struct SNAFMHeader8
{
	UINT8 Length;
	[FMHType = Property.FMHType ? Property.FMHType + FormatString("FMH-%d ",this)
								: FormatString("FMH-%d ",this) , FMHFollow = 0]
	UINT8 FMType;
	AsciiString(Length-2)  data;
}

struct SNAFMHeader10
{
	UINT8 Length;
	UINT8 FMType
	{
		[FMHFollow]
		UINT8 FMH:1 = FormatString(" (%s) %s", this.ToBitString, this ? "Another FMH follows this FMH-10" 
                                                                     : "No FMH follows this FMH-10");
		[FMHType = Property.FMHType ? Property.FMHType + FormatString("FMH-%d ",this)
									: FormatString("FMH-%d ",this)]
		UINT8 Type:7 = FormatString("(%s) %s", this.ToBitString, this);
	};
	UINT16 SyncPointCommand=(this==0x0202)?  "Prepare command " + FormatString(", %d(0x%X)",this,this)
										  : FormatString("%d(0x%X)",this,this);
	UINT16 SyncPointModifier=SNASPCMODTable(this)+FormatString(", %d(0x%X)",this,this);
}

struct SNAFMHeader12
{
	UINT8 Length;
	UINT8 FMType
	{
		[FMHFollow = 0]
		UINT8 Reserved:1 = FormatString("(%s)", this.ToBitString);
		[FMHType = Property.FMHType ? Property.FMHType + FormatString("FMH-%d ",this)
									: FormatString("FMH-%d ",this)]
		UINT8 Type:7 = FormatString("    (%s) %s", this.ToBitString, this);
	};
	INT64 AuthenticationData;
}

struct SNAPSHeader
{
	UINT8 Length;
	UINT8 PSType
	{
		UINT8 Reserved:1 = FormatString("(%s)", this.ToBitString);
		UINT8 Type:7 = FormatString("    (%s) %s", this.ToBitString, this);
	};
	UINT8 Flags;
	UINT8 CommandType = SNAPSH10Table(this)+FormatString(", %d(0x%X)",this,this);
	switch(CommandType)
	{
		case 0x05:
		case 0x06:
			_struct NextFlow
			{
				UINT16 Modifiers;
				UINT32 SendBytesNum;
				UINT32 ReceiveBytesNum;
			};
		case 0x0A:
			_struct NextTransaction
			{
				UINT8 LUWILen;
				UINT8 LUNameLen;
				AsciiString(LUNameLen) LUName;
				INT48 InstanceNum;
				UINT16 SeqNum;
			};
		default:
			AsciiString(Length-4) data;
	}
}
struct SNAFMDInitSelf0
{
	UINT24 FMDRequestCode = SNAFMDNSHeaderTable(this);
	UINT8 Flags
	{
		UINT8 InitiateEnqueue:1 = FormatString("      (%s) %s", this.ToBitString, this ? "initiate/enqueue (I/Q)" 
                                                                    : "initiate only (I)");
		UINT8 PLUOrSLUspecification:1 = FormatString("(%s) %s", this.ToBitString, this ? "DLU is SLU" 
                                                                                       : "DLU is PLU");
		UINT8 Reserved:2 = FormatString("             (%s)", this.ToBitString);
		UINT8 Format:4 = FormatString("               (%s) %s", this.ToBitString, this ? "" : "Format 0");
	};
	INT64 ModeName;
// # ? this is for consistent with netmon2
	AsciiString(FrameLength-offset) LeftFMDINITSELF0Data;
}

struct SNAFMDInitSelf1
{
	UINT24 FMDRequestCode = SNAFMDNSHeaderTable(this);
	UINT8 Flags1
	{
		UINT8 Reserved:4 = FormatString("(%s)", this.ToBitString);
		UINT8 Format:4 = FormatString("  (%s) %s", this.ToBitString, (this==0x01? "Format 1":""));
	};
	UINT8 Flags2
	{
		UINT8 Reserved2:1 = FormatString("            (%s)", this.ToBitString);
		UINT8 PLUOrSLUspecification:1 = FormatString("(%s) %s", this.ToBitString, this ? "DLU is SLU" 
                                                                                       : "DLU is PLU");
		UINT8 Reserved1:4 = FormatString("            (%s)", this.ToBitString);
		UINT8 EnqueueType:2 = FormatString("          (%s) %s", this.ToBitString, SNAEnqueueTypeTable(this));
	};
	UINT8 Flags3
	{
		UINT8 Reserved2:1 = FormatString("                    (%s)", this.ToBitString);
		UINT8 QueuingPosition:2 = FormatString("              (%s) %s", this.ToBitString, SNAInitOtherQueuingPositionTable(this));
		UINT8 Reserved1:3 = FormatString("                    (%s)", this.ToBitString);
		UINT8 EnqueueCompatibilityQualifier:1 = FormatString("(%s) %s", this.ToBitString, this ? "Enqueue if DLU is not currently able to comply with the PLU/SLU specification" 
                                                                                               : "Do not enqueue if DLU is not currently able to comply with the PLU/SLU specification");
		UINT8 EnqueueLimitQualifier:1 = FormatString("        (%s) %s", this.ToBitString, this ? "Enqueue if session limit exceeded" 
                                                                                       : "Do not enqueue if session limit exceeded");	
	};
	// # ? the Flags4 and Flags5 in netmon2 source are UINT8 Reserved[2]
	UINT8 Flags4
	{
		UINT8 Reserved2:4 = FormatString("    (%s)", this.ToBitString);
		UINT8 Retired1:1 = FormatString("     (%s) %s", this.ToBitString, this ? "Retired1" : "Not Retired1");
		UINT8 Reserved1:2 = FormatString("    (%s)", this.ToBitString);
		UINT8 BackupRequest:1 = FormatString("(%s) %s", this.ToBitString, this ? "Backup session is requested" 
                                                                               : "Backup session is not requested");
	};
	UINT8 Flags5
	{
		UINT8 Reserved:7 = FormatString("(%s)", this.ToBitString);
		UINT8 Retired2:1 = FormatString("(%s) %s", this.ToBitString, this ? "Retired2" : "Not Retired2");
	};
	INT64 ModeName;
// # ? this is for consistent with netmon2
	AsciiString(FrameLength-offset) LeftFMDINITSELF1Data;
}

struct SNAFMDNMVT
{
	UINT24 FMDRequestCode = SNAFMDNSHeaderTable(this)+FormatString(", %d(0x%X)",this,this);
	UINT16 Retired1;
	UINT16 PRID
	{
		UINT16 PRID:12 = FormatString("     (%s) %d", this.ToBitString, this);//page219,how to contain x'000'?
		UINT16 Retired2:2 = FormatString(" (%s) %d", this.ToBitString, this);
		UINT16 Reserved1:2 = FormatString("(%s)", this.ToBitString);
	};
	UINT8 Flags
	{
		UINT8 Reserved2:4 = FormatString("         (%s)", this.ToBitString);
		UINT8 SubvectorIndicator:1= FormatString("(%s) %s", this.ToBitString, this ? "MS major vector does not contain an SNA Address List subvector" 
                                                                                   : "MS major vector contains an SNA Address List subvector");
		UINT8 SequenceField:2 = FormatString("     (%s) %s", this.ToBitString, SNANMVYSequenceFieldTable(this));
		UINT8 Solicited:1 = FormatString("         (%s) %s", this.ToBitString, this ? "Solicited NMVT" 
                                                                           : "Unsolicited NMVT");
	};
// # ? this is for consistent with netmon2
	AsciiString(FrameLength - offset) LeftFMDNMVTData;
}
//struct SNASCACTPU
//{
	//UINT8 SCRequestCode = SNASCRequestCodeTable(this)+FormatString(", %d(0x%X)",this,this);
	//UINT8 ActType;
	//UINT8 Profile;
	//INT48 SSCPID;
//// # ? this is for consistent with netmon2
	//AsciiString(FrameLength-offset) LeftSCACTPUData;
//};
//
//struct SNASCBind
//{
	//UINT8 SCRequestCode = SNASCRequestCodeTable(this)+FormatString(", %d(0x%X)",this,this);
	//UINT8 Type
	//{
		//UINT8 Format:4 = FormatString("(%s) %d", this.ToBitString, this);
		//UINT8 Type:4 = FormatString("  (%s) %s", this.ToBitString, SNASCBindTypeTable(this));
	//};
	//UINT8 FMProfile = SNASCBindFMProfileTable(this)+FormatString(", %d(0x%X)",this,this);
	//UINT8 TSProfile = SNASCBindTSProfileTable(this)+FormatString(", %d(0x%X)",this,this);
	//UINT8 FMUsagePri
	//{
		//UINT8 Chaining:1 = FormatString("               (%s) %s", this.ToBitString, this ? "Multiple-RU chains allowed from primary LU half-session" 
                                                                          //: "Only single-RU chains allowed from primary LU half-session");
		//UINT8 RequestMode:1 = FormatString("            (%s) %s", this.ToBitString, this ? "Delayed request mode" 
                                                                             //: "Immediate request mode");
		//UINT8 Response:2 = FormatString("               (%s) %s", this.ToBitString, SNASCBindResponseTable(this));
		//UINT8 TwoPhaseCommit:1 = FormatString("         (%s) %s", this.ToBitString, this ? "2-phase commit supported" 
                                                                                //: "2-phase commit not supported");
		//UINT8 Reserved:1 = FormatString("               (%s)", this.ToBitString);
		//UINT8 SCBCompressionIndicator:1 = FormatString("(%s) %s", this.ToBitString, this ? "FMH-1 SCB compression may be used" 
                                                                                         //: "FMH-1 SCB compression will not be used on requests from primary");
		//UINT8 SendEndBracketIndicator:1 = FormatString("(%s) %s", this.ToBitString, this ? "Primary may send EB" 
                                                                                         //: "Primary will not send EB");
	//};
	//UINT8 FMUsageSec
	//{
		//UINT8 Chaining:1 = FormatString("               (%s) %s", this.ToBitString, this ? "Multiple-RU chains allowed from secondary LU half-session" 
                                                                          //: "Only single-RU chains allowed from secondary LU half-session");
		//UINT8 RequestMode:1 = FormatString("            (%s) %s", this.ToBitString, this ? "Delayed request mode" : "Immediate request mode");
		//UINT8 Response:2 = FormatString("               (%s) %s", this.ToBitString, SNASCBindResponseTable(this));
		//UINT8 TwoPhaseCommit:1 = FormatString("         (%s) %s", this.ToBitString, this ? "2-phase commit supported" 
                                                                                //: "2-phase commit not supported");
		//UINT8 Reserved:1 = FormatString("               (%s)", this.ToBitString);
		//UINT8 SCBCompressionIndicator:1 = FormatString("(%s) %s", this.ToBitString, this ? "FMH-1 SCB compression may be used" 
                                                                                         //: "FMH-1 SCB compression will not be used on requests from primary");
		//UINT8 SendEndBracketIndicator:1 = FormatString("(%s) %s", this.ToBitString, this ? "Secondary may send EB" : "Secondary will not send EB");
	//};
	//UINT8 FMUsageCommon
	//{
		//UINT8 WholeBIU:1 = FormatString("            (%s) %s", this.ToBitString, this ? "The sending node does not support receipt of segments on this session" 
                                                                          //: "The sending nide supports receipt of segments on this session");
		//UINT8 FMHeaderUsage:1 = FormatString("       (%s) %s", this.ToBitString, this ? "FM Headers allowed" : "FM Headers not allowed");
		//UINT8 BracketUsageAndState:1 = FormatString("(%s) %s", this.ToBitString, this ? "Brackets are used and bracket state managers' reset are BETB" 
                                                                                      //: "The value of this bit should be 0");
		//UINT8 RuleSelection:1 = FormatString("       (%s) %s", this.ToBitString, this ? "Rule 1 will be used during this session" 
                                                                               //: "Rule 2 will be used during this session");
		//UINT8 AlternateCode:1 = FormatString("       (%s) %s", this.ToBitString, this ? "Alternate code set may be used" 
                                                                               //: "Alternate code set will not be used");
		//UINT8 SequenceNumber:1 = FormatString("      (%s) %s", this.ToBitString, this ? "Sequence numbers available" 
                                                                                //: "Sequence numbers not available");
		//UINT8 BISSent:1 = FormatString("             (%s) %s", this.ToBitString, this ? "BIS Sent" : "BIS not Sent");
		//UINT8 BINDQueue:1 = FormatString("           (%s) %s", this.ToBitString, this ? "Bind may be queued" 
                                                                           //: "Bind cannot be queued");
	//};
	//UINT8 Flags1
	//{
		//UINT8 mode:2 = FormatString("                  (%s) %s", this.ToBitString, SNASCBindModeTable(this));
		//UINT8 RecoveryResponsibility:1 = FormatString("(%s) %s", this.ToBitString, this ? "Symmetric responsibility for recovery" 
                                                                                        //: "Contention loser responsible for recovery");
		//UINT8 ContentionWinnerLoser:1 = FormatString(" (%s) %s", this.ToBitString, this ? "Primary is contention winner and secondary is contention loser" 
                                                                                       //: "Secondary is contention winner and primary is contention loser");
		//UINT8 AlternateCode:2 = FormatString("         (%s) %s", this.ToBitString, this ? ( this == 0x01 ? "Process alternate code FMD RUs as ASCII-8": "") 
                                                                               //: "Process alternate code FMD RUs as ASCII-7");
		//UINT8 ControlVector:1 = FormatString("         (%s) %s", this.ToBitString, this ? "Control vectors are included after the SLU name" 
                                                                               //: "Control vectors are not included after the SLU name");
		//UINT8 HDXFFResetState:1 = FormatString("       (%s) %s", this.ToBitString, this ? "HDX-FF reset state is SEND for the primary and RECEIVE for the secondary" 
                                                                                 //: "HDX-FF reset state is RECEIVE for the primary and SEND for the secondary");
	//};
	//UINT8 SecSessSnd;
	//UINT8 SecSessRcv;
	//UINT8 RUSizeSec;
	//UINT8 RUSizePri;
	//UINT8 PriSessSnd;
	//UINT8 PriSessRcv;
	//UINT8 PSProfile
	//{
		//UINT8 PSUsageFormat:1 = FormatString("(%s) %s", this.ToBitString, this ? "" : "Basic format");
		//UINT8 LUType:7 = FormatString("       (%s) %s", this.ToBitString, SNASCBindLUTypeTable(this));
	//};
	//UINT8 LU6Level;
	//AsciiString(6) Reserved = "6 bytes reserved";
	//UINT8 ExtendedSecurity
	//{
		//UINT8 ExtendedSecuritySupport:1 = FormatString("(%s) %s", this.ToBitString, this ? "At least one extended security mechanism is supported" 
                                                                                         //: "Extended security mechanism is not supproted");
		//UINT8 SenseDataSupport:1 = FormatString("       (%s) %s", this.ToBitString, this ? "This RU sender supports receipt of sense data values in the range 0x080FFF00 to 0x080FFFFF" 
                                                                                  //: "This RU sender does not support receipt of sense data values in the range 0x080FFF00 to  0x080FFFFF");
		//UINT8 Reserved:6 = FormatString("               (%s)", this.ToBitString);
	//};
	//UINT8 SecuritySuptInd
	//{
		//UINT8 Retired:2 = FormatString("                         (%s) %s", this.ToBitString, this ? "Retired" : "Not Retired");
		//UINT8 PWDSubstitutionAlgorithm:1 = FormatString("        (%s) %s", this.ToBitString, this ? "SHA-1" : "DES");
		//UINT8 ConversationLevelSecuritySupport:1 = FormatString("(%s) %s", this.ToBitString, this ? "Access Security Information field will be accepted on incoming FMH-5s" 
                                                                                                  //: "Access Security Information field will not be accepted on incoming FMH-5s");
		//UINT8 LULUVerificationProtocolSupport:1 = FormatString(" (%s) %s", this.ToBitString, this ? "Enhanced verification protocol" 
                                                                                                 //: "Basic verification protocol");
		//UINT8 PWDSubstitutionSupport:1 = FormatString("          (%s) %s", this.ToBitString, this ? "Supported" : "Not supported");
		//UINT8 AlreadyVerifiedFuncSupport:1 = FormatString("      (%s) %s", this.ToBitString, this ? "Already-Verified indicator will be accepted on incoming FMH-5s" 
                                                                                            //: "Already-Verified indicator will not be accepted on incoiming FMH-5s");
		//UINT8 PersistentVerifyCapability:1 = FormatString("      (%s) %s", this.ToBitString, this ? "Persistent Verification indicator is supported on incoming FMH-5s" 
                                                                                            //: "Persistent Verification indicator is not supported on incoming FMH-5s");
	//};
	//UINT8 Flags2
	//{
		//UINT8 Reserved2:1 = FormatString("                           (%s)", this.ToBitString);
		//UINT8 SynchronizationLevel:2 = FormatString("                (%s) %s", this.ToBitString, ( this == 1 ? "Confirm is supported"
                                                                                             //: ( this == 2 ? "Confirm , sunc point , and backout are supported"
                                                                                                           //: "") ));
		//UINT8 Reserved1:1 = FormatString("                           (%s)", this.ToBitString);
		//UINT8 ResponsibilityForSessionReinitiation:2 = FormatString("(%s) %s", this.ToBitString, SNASCBindResponsibilityTable(this));
		//UINT8 ParallelSessionSupport:1 = FormatString("              (%s) %s", this.ToBitString, this ? "Supported" : "Not supported");
		//UINT8 ChangeGDSNumber:1 = FormatString("                     (%s) %s", this.ToBitString, this ? "Supported" : "Not supported");
	//};
	//UINT8 Flags3
	//{
		//UINT8 Reserved2:1 = FormatString("             (%s)", this.ToBitString);
		//UINT8 LimitedResourceSession:1 = FormatString("(%s) %s", this.ToBitString, this ? "A limited- resource session and thus the contention-winner LU will deactivate it when it is no longer busy" 
                                                                                        //: "Not a limited-resource session and thus the contention-winner LU will not deactivate it when it is no longer busy");
		//UINT8 NNS:1 = FormatString("                   (%s) %s", this.ToBitString, this ? "Yes-it is desired that the NNS send its BIND over the same TG" 
                                                                     //: "No - it is not desired that the NNS send its BIND over the same TG");
		//UINT8 Reserved1:3 = FormatString("             (%s)", this.ToBitString);
		//UINT8 compression:2 = FormatString("           (%s) %s", this.ToBitString, SNASCBindCompressionTable(this));
	//};
	//UINT8 CryptoFlags1
	//{
		//UINT8 PrivateCryptography:2 = FormatString("     (%s) %s", this.ToBitString, (this ? (this == 1 ? "Private cryptography supported" : "")
                                                                                      //: "No private cryptography supported"));
		//UINT8 SessionLevelCryptoOption:2 = FormatString("(%s) %s", this.ToBitString, SNASCBindCryptoTable(this));
		//UINT8 CryptoOptionLength:4 = FormatString("      (%s) %s", this.ToBitString, (this == 9 ? "Session-level cryptography specified;additional options follow in next nine bytes" 
                                                                                          //: ( this == 0 ? "No session-level cryptography specified" : "")));
	//};
	//UINT8 CryptoFlags2
	//{
		//UINT8 SessionCryptoKeyEnciphermentMethod:2 = FormatString("(%s) %s", this.ToBitString, this ? "" : "Using a seed value of 0 (only value defined");
		//UINT8 Reserved:3 = FormatString("                          (%s)", this.ToBitString);
		//UINT8 CryptoCipherMethod:3 = FormatString("                (%s) %s", this.ToBitString, (this ? ( this == 1 ? "Using the Triple Data Encryption Standard (Triple DES) algorithm" : "")
                                                                                     //: "Using the Data Encryption Standard (DES) algorithm"));
	//};
//// # ? the following code does not exist in netmon2 source code
	//AsciiString(CryptoFlags1.CryptoOptionLength) CryptoGraphyOption;
	//UINT8 PrimaryLUNameLength;
	//AsciiString(PrimaryLUNameLength) PrimaryLUName;
	//UINT8 UserDataLength;
	//AsciiString(UserDataLength) UserData;
	//UINT8 URCLength;
	//AsciiString(URCLength) URC;
	//UINT8 SecondaryLUNameLength;
	//AsciiString(SecondaryLUNameLength) SecondaryName;
////  # ? this is for consistent with netmon2
	//AsciiString(FrameLength - offset) LeftSCBindData;
//}
//
//
//struct SNASCDACTLU
//{
	//UINT8 SCRequestCode = SNASCRequestCodeTable(this)+FormatString(", %d(0x%X)",this,this);
	//UINT8 DeactType = SNASCDACTLUTypeTable(this)+FormatString(", %d(0x%X)",this,this);
	//UINT8 Cause = SNASCDACTLUCauseTable(this)+FormatString(", %d(0x%X)",this,this);
//// # ? this is for consistent with netmon2
	//AsciiString(FrameLength - offset) LeftSCDACTLUData;
//}
//
//struct SNASCDACTPU
//{
	//UINT8 SCRequestCode = SNASCRequestCodeTable(this)+FormatString(", %d(0x%X)",this,this);
	//UINT8 DeactType = SNASCDACTPUTypeTable( this )+FormatString(", %d(0x%X)",this,this);
	//UINT8 Cause = SNASCDACTPUCauseTable( this )+FormatString(", %d(0x%X)",this,this);
//// # ? this is for consistent with netmon2
	//AsciiString(FrameLength-offset) LeftSCDACTPUData;
//}

struct SNARU = FormatString("%s(%s)%s%s%s",
							Property.RRI ? "Response Unit":"Request Unit",
							SNARUTable(Property.RuCat),
							Property.SDI ? "(Sense Data Included)":"",
							Property.LCCI ? "Compressed" : "",
							Property.FMHType ? Property.FMHType : "")
{
	[FMHFollow = 1]
	switch
	{
		case Property.SDI:SNASenseData SenseData;
	}
	switch(Property.RuCat)
	{
		case 0:
			switch(Property.LCCI)
			{
				case 0:
					while condition[Property.FMHFollow]
					{
						switch
						{
							case (UINT8( Framedata, Offset + 1 ) & 0x7F) == 1: SNAFMHeader1 FMHeader1;
							case (UINT8( Framedata, Offset + 1 ) & 0x7F) == 2: SNAFMHeader2 FMHeader2;
							case (UINT8( Framedata, Offset + 1 ) & 0x7F) == 3: SNAFMHeader3 FMHeader3;
							case (UINT8( Framedata, Offset + 1 ) & 0x7F) == 4: SNAFMHeader4 FMHeader4;
							case (UINT8( Framedata, Offset + 1 ) & 0x7F) == 5 && UINT16(FrameData,offset+2) == 0x02FF: SNAFMHeader5LU62 FMHeader5LU62;
							case (UINT8( Framedata, Offset + 1 ) & 0x7F) == 5 && !(UINT16(FrameData,offset+2) == 0x02FF): SNAFMHeader5 FMHeader5;
							case (UINT8( Framedata, Offset + 1 ) & 0x7F) == 6: SNAFMHeader6 FMHeader6;
							case (UINT8( Framedata, Offset + 1 ) & 0x7F) == 7 && UINT8( Framedata, Offset ) == 7: SNAFMHeader7LU62 FMHeader7LU62;
							case (UINT8( Framedata, Offset + 1 ) & 0x7F) == 7 && UINT8( Framedata, Offset ) == 8: SNAFMHeader7 FMHeader7;
							case (UINT8( Framedata, Offset + 1 ) & 0x7F) == 8: SNAFMHeader8 FMHeader8;
							case (UINT8( Framedata, Offset + 1 ) & 0x7F) == 10: SNAFMHeader10 FMHeader10;
							case (UINT8( Framedata, Offset + 1 ) & 0x7F) == 12: SNAFMHeader12 FMHeader12;
							default: [FMHFollow=0] _struct DoNothing {};
						}
						switch
						{
							case Property.PIP: SNAPIPGDSVariable PIPVariable;
						}
					};
				default:
					AsciiString(FrameLength - offset) SNAData = "compressed";
			}
		default:
			switch(UINT16(FrameData,offset))
			{
				case  1: SNAPSHeader PSHeader;
				default: [GDSExist = 1] _struct DoNothing {};
			}
	}

	while conditions[offset < FrameLength]
	{
		switch
		{
			case Property.RRI == 0 && Property.RuCat == 0:
				switch
				{
					case UINT24(FrameData,offset)  == 0x010681:SNAFMDInitSelf0 FMDINISELF0;
					case UINT24(FrameData,offset)  == 0x810681:SNAFMDInitSelf1 FMDINITSELF1;
					case UINT24(FrameData,offset)  == 0x41038D:SNAFMDNMVT FMDNMVT;
					default: AsciiString(FrameLength-offset) FMData = "Function Management Data(" + SNAFMDNSHeaderTable(UINT8( Framedata, Offset ))+")";
				}
				// NC Request was not implemented in netmon2
			case Property.RRI == 0 && Property.RuCat == 1:
				AsciiString(FrameLength - offset) NCData = "Net Control Data(" + SNANCRequestCodeTable(UINT8( Framedata, Offset ))+")";
			case Property.RRI == 0 && Property.RuCat == 2:
				AsciiString(FrameLength - offset) DFCData = "Data Flow Control Data(" + SNADFCRequestCodeTable(UINT8( Framedata, Offset ))+")";
			case Property.RRI == 0 && Property.RuCat == 3: //SC
		   		/* switch
				{
					case UINT8( Framedata, Offset )  == 0x11: SNASCACTPU ACTPU ;//ACTPU
					case UINT8( Framedata, Offset )  == 0x31: SNASCBind BIND;//BIND
					case UINT8( Framedata, Offset )  == 0x0e: SNASCDACTLU dactlu;//DACTLU
					case UINT8( Framedata, Offset )  == 0x12: SNASCDACTPU dactpu;//DACTPU
					default: AsciiString(FrameLength-offset) SessionControlData = "Session Control Data(" + SNASCRequestCodeTable(UINT8( Framedata, Offset )) + ")";
				}*/
				AsciiString(FrameLength-offset) SessionControlData = "Session Control Data(" + SNASCRequestCodeTable(UINT8( Framedata, Offset )) + ")";
			case Property.RRI:
				AsciiString(FrameLength - offset)  ResponseData = SNARUTable(Property.RuCat) + "("+SNARUResponseCodeTable(UINT8( Framedata, Offset ))+")";
			case Property.GDSExist :
				SNAPIPGDSVariable GDSVariable;
			default:
				AsciiString(FrameLength-offset) UnknownData;
		}
	}
}


