//#  (c) 2009 CodePlex Foundation
//#
//#  Title:                  File System Control Codes
//#
//#  Details:                
//#
//#  Microsoft References:   [MS-FSCC]: File System Control Codes (14.0)
//#
//#  Comments:               
//#
//#  Revision Class and Date:Major, 4/29/2009
//#                          Minor, 2/5/2010
//#
//####

//******************************************************************************************
//FSCC TABLES
//******************************************************************************************

Table FSCCCtlCodeTable(value)
{
	switch(value)
	{
		case 0x00090083: FormatString("0x%08X - FSCTL_ALLOW_EXTENDED_DASD_IO - Signals the file system driver NOT to perform any I/O boundary checks on partition read or write calls. Instead, boundary checks are performed by the device driver.",value);
		case 0x000900c0: FormatString("0x%08X - FSCTL_CREATE_OR_GET_OBJECT_ID - Creates or retrieves the object identifier for the specified file or directory.",value);
		case 0x000900a0: FormatString("0x%08X - FSCTL_DELETE_OBJECT_ID - Removes the object identifier from a specified file or directory.",value);
		case 0x000900ac: FormatString("0x%08X - FSCTL_DELETE_REPARSE_POINT - Deletes a reparse point from the specified file or directory.",value);
		case 0x00090060: FormatString("0x%08X - FSCTL_FILESYSTEM_GET_STATISTICS		- Retrieves the information from various file system performance counters.",value);
		case 0x0009008f: FormatString("0x%08X - FSCTL_FIND_FILES_BY_SID - Searches a directory for a file whose creator owner matches the specified SID.",value);
		case 0x0009003c: FormatString("0x%08X - FSCTL_GET_COMPRESSION - Retrieves the current compression state of a file or directory on a volume whose file system supports per-stream compression.",value);
		case 0x00090064: FormatString("0x%08X - FSCTL_GET_NTFS_VOLUME_DATA - Retrieves the first file record that is in use and is of a lesser than or equal ordinal value to the requested file reference number.",value);
		case 0x0009009c: FormatString("0x%08X - FSCTL_GET_OBJECT_ID - Retrieves the object identifier for the specified file or directory.",value);
		case 0x000900a8: FormatString("0x%08X - FSCTL_GET_REPARSE_POINT - Retrieves the reparse point data associated with the file or directory identified by the specified handle.",value);
		case 0x00090073: FormatString("0x%08X - FSCTL_GET_RETRIEVAL_POINTERS - Retrieves a data structure that describes the allocation and location on disk of a specific file.",value);
		case 0x0009002c: FormatString("0x%08X - FSCTL_IS_PATHNAME_VALID - Performs static analysis of the supplied pathname and returns a status value that indicates whether the pathname is well formed ",value);
		case 0x00090078: FormatString("0x%08X - FSCTL_IS_VOLUME_DIRTY - Determines whether the specified volume is dirty.",value);	
		case 0x001400e8: FormatString("0x%08X - FSCTL_LMR_GET_LINK_TRACKING_INFORMATION - Retrieves the link tracking information for a file.",value);
		case 0x001400ec: FormatString("0x%08X - FSCTL_LMR_SET_LINK_TRACKING_INFORMATION - Sets the link tracking information for a file.",value);
		case 0x00090058: FormatString("0x%08X - FSCTL_QUERY_FAT_BPB - Query the first 0x24 bytes of sector 0 for the volume associated with the handle on which this FSCTL was invoked.",value); 
		case 0x000940cf: FormatString("0x%08X - FSCTL_QUERY_ALLOCATED_RANGES - Scans a file or alternate stream looking for ranges that contain nonzero data.",value);
		case 0x00090138: FormatString("0x%08X - FSCTL_QUERY_SPARING_INFO - Retrieves the defect management properties of the volume.",value);
		case 0x000900eb: FormatString("0x%08X - FSCTL_READ_FILE_USN_DATA - Retrieves the change-journal information for the specified file or directory.",value);
		case 0x00090117: FormatString("0x%08X - FSCTL_RECALL_FILE - Recalls a file from storage media that Remote Storage manages, which is the hierarchical storage management software.",value);
		case 0x0009c040: FormatString("0x%08X - FSCTL_SET_COMPRESSION - Sets the compression state of a file or directory on a volume whose file system supports per-file and per-directory compression.",value);
		case 0x00098134: FormatString("0x%08X - FSCTL_SET_DEFECT_MANAGEMENT - Sets the software defect management state for the specified file. Used for UDF file systems.",value);
		case 0x0009c0d7: FormatString("0x%08X - FSCTL_SET_ENCRYPTION - Sets the encryption for the file or directory associated with the given handle.",value);
		case 0x00090098: FormatString("0x%08X - FSCTL_SET_OBJECT_ID - Modifies user data associated with the object identifier for the specified file or directory.",value);
		case 0x000900bc: FormatString("0x%08X - FSCTL_SET_OBJECT_ID_EXTENDED - Modifies user data associated with the object identifier for the specified file or directory.",value);
		case 0x000900a4: FormatString("0x%08X - FSCTL_SET_REPARSE_POINT - Sets a reparse point on a file or directory.",value);
		case 0x000900b4: FormatString("0x%08X - FSCTL_SET_SHORT_NAME_BEHAVIOR - Set the short name behavior for the volume associated with the file handle on which this FSCTL was invoked.",value);
		case 0x000900c4: FormatString("0x%08X - FSCTL_SET_SPARSE - Marks the indicated file as sparse or not sparse.",value);
		case 0x000980c8: FormatString("0x%08X - FSCTL_SET_ZERO_DATA - Fills a specified range of a file with zeroes (0).",value);
		case 0x00090194: FormatString("0x%08X - FSCTL_SET_ZERO_ON_DEALLOCATION - Indicates an NTFS file system file handle should have its clusters filled with zeros when it is deallocated.",value);
		case 0x00090100: FormatString("0x%08X - FSCTL_SIS_COPYFILE - Use the Single-Instance Storage (SIS) filter to copy the file that is associated with the handle on which this FSCTL was invoked.",value);
		case 0x000900ef: FormatString("0x%08X - FSCTL_WRITE_USN_CLOSE_RECORD - Generates a record in the change journal stream for the input file.",value);
		//The following FSCTL operations are specified in [MS-SMB2] (13.0) and [MS-FSCC]
		case 0x00060194: FormatString("0x%08X - FSCTL_DFS_GET_REFERRALS - Request to resolve a DFS path (or virtual name) to an actual share name on an actual file server.",value); // [MS-DFSC] 1
		case 0x0011400C: FormatString("0x%08X - FSCTL_PIPE_PEEK - Server copy a named pipe's data into a buffer for preview without removing it.",value); // [MS-FSCC] 2.3.25
		case 0x00110018: FormatString("0x%08X - FSCTL_PIPE_WAIT - Wait until either a time-out interval elapses or an instance of the specified named pipe is available for connection.",value); // [MS-FSCC] 2.3.27
		case 0x0011C017: FormatString("0x%08X - FSCTL_PIPE_TRANSCEIVE - Request to send and receive data from an open pipe.",value); // [MS-FSCC] 2.3.29
		case 0x001440F2: FormatString("0x%08X - FSCTL_SRV_COPYCHUNK - Request to perform server side copy operations against an open handle to the target file with FILE_READ_DATA and FILE_WRITE_DATA access.",value); // [MS-SMB2] 2.2.31
		case 0x00144064: FormatString("0x%08X - FSCTL_SRV_ENUMERATE_SNAPSHOTS - Requests an enumeration of previous versions (revision time-stamps associated with the Tree Connect share in which the open resides (SRV_SNAPSHOT_ARRAY)).",value); // [MS-SMB2] 3.3.5.15.1
		case 0x00140078: FormatString("0x%08X - FSCTL_SRV_REQUEST_RESUME_KEY - Request to query the opaque resume key for a given file.",value); // [MS-SMB2] 2.2.32.3
		case 0x001441bb: FormatString("0x%08X - FSCTL_SRV_READ_HASH - Request to read set of hashes for a specific file that can be used by the application to retrieve the contents of the file using the branch cache.",value); // [MS-SMB2] 2.2.32.4
		case 0x001480F2: FormatString("0x%08X - FSCTL_SRV_COPYCHUNK_WRITE - Request to perform server side copy operations against an open handle to the target file with FILE_WRITE_DATA access.",value); // [MS-SMB2] 2.2.31
		case 0x00148118: FormatString("0x%08X - FSCTL_SRV_NOTIFY_TRANSACTION - Request ignored by Windows servers, no response is sent to the client.",value); // [MS-SMB2] 3.3.5.15 <232>
		case 0x001401D4: FormatString("0x%08X - FSCTL_LMR_REQUEST_RESILIENCY - Request for resiliency on a specified open file.",value); // [MS-SMB2] 2.2.31.3
		// END WITH
		default: FormatString("0x%08X - Unknown File System Control Code",value);
	}
}


Table FSCCCompressionStateTable(value)
{
	switch(value)
	{
		case 0x0000: "COMPRESSION_FORMAT_NONE - The file or directory is not compressed";
		case 0x0001: "COMPRESSION_FORMAT_DEFAULT - The file or directory is compressed by using the default compression algorithm";
		case 0x0002: "COMPRESSION_FORMAT_LZNT1 - The file or directory is compressed by using the LZNT1 compression algorithm";
		default: "Reserved for future use and MUST NOT be used.";
	}
}

Table FSCCFileSystemTypeTable(value)
{
	switch(value)
	{
		case 0x00000000: "The destination file system is NTFS.";
		case 0x00000001: "The destination file system is DFS";
		default: FormatString("0x%08x--Undefined Type", value);
	}
}

Table FSCCSourceInfoTable(value)
{
	switch(value)
	{
		case 0x00000001: "DATA_MANAGEMENT -- The operation provides information about a change to the file or directory that was made by the operating system";
		case 0x00000002: "AUXILIARY_DATA -- The operation adds a private data stream to a file or directory";
		case 0x00000004: "REPLICATION_MANAGEMENT -- The operation modified the file to match the contents of the same file that exists in another member of the replica set for FRS";
		default: FormatString("0x%08x - Undefined SourceInfo", value);
	}
}

Table FSCCFSCTLSISCopyFileRequestFlagsTable(value)
{
	switch(value)
	{
		case 0x0001: "COPYFILE_SIS_LINK";
		case 0x0002: "COPYFILE_SIS_REPLACE";
		default: FormatString("0x%08x - Undefined Copy File Request Flag", value);
	}
}

Table FSCCFileInforTable(value)
{
	switch(value)
	{
		case 1: FormatString("FileDirectoryInformation (%d)", value);
		case 2: FormatString("FileFullDirectoryInformation (%d)", value);
		case 3: FormatString("FileBothDirectoryInformation (%d)", value);
		case 4: FormatString("FileBasicInformation (%d)", value);
		case 5: FormatString("FileStandardInformation (%d)", value);
		case 6: FormatString("FileInternalInformation (%d)", value);
		case 7: FormatString("FileEaInformation (%d)", value);
		case 8: FormatString("FileAccessInformation (%d)", value);
		case 9: FormatString("FileNameInformation (%d)", value);
		case 10: FormatString("FileRenameInformation (%d)", value);
		case 11: FormatString("FileLinkInformation (%d)", value);
		case 12: FormatString("FileNamesInformation (%d)", value);
		case 13: FormatString("FileDispositionInformation (%d)", value);
		case 14: FormatString("FilePositionInformation (%d)", value);
		case 15: FormatString("FileFullEaInformation (%d)", value);
		case 16: FormatString("FileModeInformation (%d)", value);
		case 17: FormatString("FileAlignmentInformation (%d)", value);
		case 18: FormatString("FileAllInformation (%d)", value);
		case 19: FormatString("FileAllocationInformation (%d)", value);
		case 20: FormatString("FileEndOfFileInformation (%d)", value);
		case 21: FormatString("FileAlternateNameInformation (%d)", value);
		case 22: FormatString("FileStreamInformation (%d)", value);
		case 23: FormatString("FilePipeInformation (%d)", value);
		case 24: FormatString("FilePipeLocalInformation (%d)", value);
		case 25: FormatString("FilePipeRemoteInformation (%d)", value);
		case 26: FormatString("FileMailslotQueryInformation (%d)", value);
		case 27: FormatString("FileMailslotSetInformation (%d)", value);
		case 28: FormatString("FileCompressionInformation (%d)", value);
		case 29: FormatString("FileObjectIdInformation (%d)", value);
		case 31: FormatString("FileMoveClusterInformation (%d)", value);
		case 32: FormatString("FileQuotaInformation (%d)", value);
		case 33: FormatString("FileReparsePointInformation (%d)", value);
		case 34: FormatString("FileNetworkOpenInformation (%d)", value);
		case 35: FormatString("FileAttributeTagInformation (%d)", value);
		case 36: FormatString("FileTrackingInformation (%d)", value);
		case 37: FormatString("FileIdBothDirectoryInformation (%d)", value);
		case 38: FormatString("FileIdFullDirectoryInformation (%d)", value);
		case 39: FormatString("FileValidDataLengthInformation (%d)", value);
		case 40: FormatString("FileShortNameInformation (%d)", value);
		case 44: FormatString("FileSfioReserveInformation (%d)", value);
		case 45: FormatString("FileSfioVolumeInformation (%d)", value);
		case 46: FormatString("FileHardLinkInformation (%d)", value);
		case 48: FormatString("FileNormalizedNameInformation (%d)", value);
		case 50: FormatString("FileIdGlobalTxDirectoryInformation (%d)", value);
		case 54: FormatString("FileStandardLinkInformation (%d)", value);

		// TODO: add classes
		default: FormatString( "%u - Undefined File Information Class Level", value );
	}
}

Table FSCCFilePipeLocalInfoNamedPipeTypeTable(value)
{
	switch(value)
	{
		case 0x00000000: "FILE_PIPE_BYTE_STREAM_TYPE";
		case 0x00000001: "FILE_PIPE_MESSAGE_TYPE";
		default: FormatString( "0x%08x - Undefined Type", value);
	}
}

Table FSCCFilePipeLocalInfoNamedPipeConfigTable(value)
{
	switch(value)
	{
		case 0x00000000: "FILE_PIPE_INBOUND";
		case 0x00000001: "FILE_PIPE_OUTBOUND";
		case 0x00000002: "FILE_PIPE_FULL_DUPLEX";
		default: FormatString( "0x%08x - Undefined Named Pipe Config", value);
	}
}

Table FSCCFilePipeLocalInfoNamedPipeStateTable(value)
{
	switch(value)
	{
		case 0x00000001: "FILE_PIPE_DISCONNECTED_STATE";
		case 0x00000002: "FILE_PIPE_LISTENING_STATE";
		case 0x00000003: "FILE_PIPE_CONNECTED_STATE";
		case 0x00000004: "FILE_PIPE_CLOSING_STATE";
		default: FormatString( "0x%08x - Undefined Named Pipe State", value);
	}
}

Table FSCCFilePipeLocalInfoNamedPipeEndTable(value)
{
	switch(value)
	{
		case 0x00000000: "FILE_PIPE_CLIENT_END";
		case 0x00000001: "FILE_PIPE_SERVER_END";
		default: FormatString( "0x%08x - Undefined Named Pipe End", value);
	}
}

Table FSCCFilePipeInfoReadModeTable(value)
{
	switch(value)
	{
		case 0x00000000: "FILE_PIPE_BYTE_STREAM_MODE";
		case 0x00000001: "FILE_PIPE_MESSAGE_MODE";
		default: FormatString( "0x%08x - Undefined Read Mode", value);
	}
}
Table FSCCFilePipeInfoCompletionModeTable(value)
{
	switch(value)
	{
		case 0x00000000: "FILE_PIPE_QUEUE_OPERATION";
		case 0x00000001: "FILE_PIPE_COMPLETE_OPERATION";
		default: FormatString( "0x%08x - Undefined Completion Mode", value);
	}
}

Table FSCCFSInfoClassTable(level)
{
	switch(level)
	{
		case 1:   "Query FS Volume Info";
		case 2:   "Query FS Label Info";
		case 3:   "Query FS Size Info";
		case 4:   "Query FS Device Info";
		case 5:   "Query FS Attribute Info";
		case 6:   "Query FS Control Info";
		case 7:   "Query FS Full Size Info";
		case 8:   "Query FS Object Id Info";
		case 9:   "Query FS Drive Path Info";
		default:   FormatString("(0x%04X) Unknown Value",level);
	}
}

Table FSCCCompressionFormatTable(value)
{
	switch(value)
	{
		case 0x0000: "COMPRESSION_FORMAT_NONE";
		case 0x0001: "COMPRESSION_FORMAT_DEFAULT";
		case 0x0002: "COMPRESSION_FORMAT_LZNT1";
		default: FormatString( "0x%04x - Undefined Compression Format", value);
	}
}

Table FSCCReparseTagTable( Value )
{
	Switch( Value  )
	{
		Case 0xA0000003 : "IO_REPARSE_TAG_MOUNT_POINT - Used for mount point support.";
		Case 0xC0000004 : "IO_REPARSE_TAG_HSM - Obsolete,Used by legacy Hierarchical Storage Manager Product.";
		Case 0x80000006 : "IO_REPARSE_TAG_HSM2 - Obsolete, Used by legacy Hierarchical Storage Manager Product.";
		Case 0x80000005 : "IO_REPARSE_TAG_DRIVER_EXTENDER - Home server drive extender.";
		Case 0x80000007 : "IO_REPARSE_TAG_SIS - Used by Single Instance Storage filter driver.";
		Case 0x8000000A : "IO_REPARSE_TAG_DFS - Used by the DFS filter.";
		Case 0x80000012 : "IO_REPARSE_TAG_DFSR - Used by the DFS filter.";
		Case 0x8000000B : "IO_REPARSE_TAG_FILTER_MANAGER - Used by filter manager test harness.";
		Case 0xA000000C : "IO_REPARSE_TAG_SYMLINK - Used for symbolic link support.";
		Default: FormatString( "0x%08x - Undefined Reparse Tag", value);
	}
}

Table FSCCFileSystemStatisticsTypeTable
{
	Switch ( Value )
	{
		Case 0x0001 : "FILESYSTEM_STATISTICS_TYPE_NTFS - The file system is an NTFS file system.";
		Case 0x0002 : "FILESYSTEM_STATISTICS_TYPE_FAT - The file system is a FAT file system.";
		Case 0x0003 : "FILESYSTEM_STATISTICS_TYPE_EXFAT  - The file system is a FAT file system.";
		Default: FormatString( "0x%08x - Undefined Statistics Type", value);
	}
}

Table FSCCNamedPipeStateTable
{
	Switch ( Value )
	{
		Case 0x00000001: "FILE_PIPE_DISCONNECTED_STATE - The specified named pipe is in the disconnected state.";
		Case 0x00000002: "FILE_PIPE_LISTENING_STATE - The specified named pipe is in the listening state";
		Case 0x00000003: "FILE_PIPE_CONNECTED_STATE - The specified named pipe is in the connected state.";
		Case 0x00000004: "FILE_PIPE_CLOSING_STATE - The specified named pipe is in the closing state.";
		Default: FormatString( "0x%08x - Undefined Named Pipe State", value);
	}
}

Table FSCCEncryptionOperationTable
{
	Switch ( Value )
	{
		Case 0x00000001: "FILE_SET_ENCRYPTION - This operation requests encryption of the specified file or directory.";
		Case 0x00000002: "FILE_CLEAR_ENCRYPTION - This operation requests removal of encryption from the specified file or directory.";
		Case 0x00000003: "STREAM_SET_ENCRYPTION - This operation requests encryption of the specified stream.";
		Case 0x00000004: "STREAM_CLEAR_ENCRYPTION - This operation requests encryption of the specified file or directory.";
		Default: FormatString( "0x%08x - Undefined Encryption Operation", value);
	}
}

Table FSCCAlignmentRequirementTable
{
	Switch ( Value )
	{
		Case 0x00000000: "FILE_BYTE_ALIGNMENT - There are no alignment requirements for the device.";
		Case 0x00000001: "FILE_WORD_ALIGNMENT - Data MUST be aligned on a 2-byte boundary.";
		Case 0x00000003: "FILE_LONG_ALIGNMENT - Data MUST be aligned on a 4-byte boundary.";
		Case 0x00000007: "FILE_QUAD_ALIGNMENT - Data MUST be aligned on an 8-byte boundary.";
		Case 0x0000000f: "FILE_OCTA_ALIGNMENT - Data MUST be aligned on a 16-byte boundary.";
		Case 0x0000001f: "FILE_32_BYTE_ALIGNMENT - Data MUST be aligned on a 32-byte boundary.";
		Case 0x0000003f: "FILE_64_BYTE_ALIGNMENT - Data MUST be aligned on a 64-byte boundary.";
		Case 0x0000007f: "FILE_128_BYTE_ALIGNMENT - Data MUST be aligned on a 128-byte boundary.";
		Case 0x000000ff: "FILE_256_BYTE_ALIGNMENT - Data MUST be aligned on a 256-byte boundary.";
		Case 0x000001ff: "FILE_512_BYTE_ALIGNMENT - Data MUST be aligned on a 512-byte boundary.";
		Default: FormatString( "0x%08x - Undefined Alignment Requirement", value);
	}
}

Table FSCCFileFsDeviceTypeTable
{
	Switch ( Value )
	{
		Case 0x00000000: "FILE_DEVICE_CD_ROM - Volume resides on a CD ROM";
		Case 0x00000007: "FILE_DEVICE_DISK - Volume resides on a disk.";
		Default: FormatString( "0x%08x - Undefined Device Type", value);
	}
}

//******************************************************************************************
//FSCC STRUCTS
//******************************************************************************************

[DataTypeByteOrder = LittleEndian]
struct FSCCFileAttributes
{
	UINT32 FSCCFileAttribute
	{
		UINT32	ReadOnly:1 = FormatString("          (%s) %s", this.ToBitString, this ? "Read Only" : "Read/Write");
		UINT32	Hidden:1 = FormatString("            (%s) %s", this.ToBitString, this ? "Hidden" : "Not Hidden");
		UINT32	System:1 = FormatString("            (%s) %s", this.ToBitString, this ? "System" : "Not System");
		UINT32	Reserved_bits3:1 = FormatString("    (%s) Reserved", this.ToBitString);
		UINT32	Directory:1 = FormatString("         (%s) %s", this.ToBitString, this ? "Directory" : "File");
		UINT32	Archive:1 = FormatString("           (%s) %s", this.ToBitString, this ? "Archive" : "Not Archive");
		UINT32	Device:1 = FormatString("            (%s) %s", this.ToBitString, this ? "Device" : "Not Device");
		UINT32	Normal:1 = FormatString("            (%s) %s", this.ToBitString, this ? "Normal" : "Not Normal");

		UINT32	Temporary:1 = FormatString("         (%s) %s", this.ToBitString, this ? "Temporary" : "Permanent");
		UINT32	Sparse:1 = FormatString("            (%s) %s", this.ToBitString, this ? "Sparse" : "Not Sparse");
		UINT32	Reparse:1 = FormatString("           (%s) %s", this.ToBitString, this ? "Reparse Point" : "Not Reparse Point");
		UINT32	Compressed:1 = FormatString("        (%s) %s", this.ToBitString, this ? "Compressed" : "Uncompressed");
		UINT32	Offline:1 = FormatString("           (%s) %s", this.ToBitString, this ? "Offline" : "Online");
		UINT32	NotIndexed:1 = FormatString("        (%s) %s", this.ToBitString, this ? "Content not indexed" : "Content indexed");
		UINT32	Encrypted:1 = FormatString("         (%s) %s", this.ToBitString, this ? "Encrypted" : "Unencrypted");
		UINT32	Reserved_bits15_31:17 = FormatString("(%s) Reserved", this.ToBitString);
	}
}

struct FSCCMountPointReparseDataBuffer
{
	//ReparseTag: This value MUST be 0xA0000003
	UINT32 ReparseTag = FSCCReparseTagTable( this );
	UINT16 ReparseDataLength;
	UINT16 Reserved;
	UINT16 SubstituteNameOffset;
	UINT16 SubstituteNameLength;
	UINT16 PrintNameOffset;
	UINT16 PrintNameLength;
	switch
	{
		case SubstituteNameOffset > PrintNameOffset:
			_struct PathBuffer
			{
				BLOB(PrintNameOffset) PrintNamePadding;
				[DataFieldByteOrder = LittleEndian]
				UnicodeString(PrintNameLength / 2) PrintName;
				BLOB(SubstituteNameOffset) SubstituteNamePadding;
				[DataFieldByteOrder = LittleEndian]
				UnicodeString(SubstituteNameLength / 2) SubstituteName;
			}
		default :
			_struct PathBufferData
			{
				BLOB(SubstituteNameOffset) SubstituteNamePadding;
				[DataFieldByteOrder = LittleEndian]
				UnicodeString(SubstituteNameLength / 2) SubstituteName;
				BLOB(PrintNameOffset) PrintNamePadding;
				[DataFieldByteOrder = LittleEndian]
				UnicodeString(PrintNameLength / 2) PrintName;
			}
	}
}

struct FSCCSymbolicLinkReparseDataBuffer = FormatString( "ReparseTag: 0x%X", ReparseTag)
{
	//ReparseTag : This value MUST be 0xA000000C
	UINT32 ReparseTag = FSCCReparseTagTable( this );
	UINT16 ReparseDataLength;
	UINT16 Reserved;
	UINT16 SubstituteNameOffset;
	UINT16 SubstituteNameLength;
	UINT16 PrintNameOffset;
	UINT16 PrintNameLength;
	UINT32 Flags = FormatString("(%s) %s", this.ToBitString, this ? "the given pathname is relative to the source." : "the pathname given in SubstitueName field contains a full NT path name");
	[ Property.PathBufferOffset ]
	switch
	{
		case SubstituteNameOffset > PrintNameOffset:
			_struct PathBuffer
			{
				BLOB(PrintNameOffset) PrintNamePadding;
				[DataFieldByteOrder = LittleEndian]
				UnicodeString(PrintNameLength / 2) PrintName;
				BLOB(SubstituteNameOffset  + Property.PathBufferOffset - FrameOffset) SubstituteNamePadding;
				[DataFieldByteOrder = LittleEndian]
				UnicodeString(SubstituteNameLength / 2) SubstituteName;
			}
		default :
			_struct PathBufferData
			{
				BLOB(SubstituteNameOffset) SubstituteNamePadding;
				[DataFieldByteOrder = LittleEndian]
				UnicodeString(SubstituteNameLength / 2) SubstituteName;
				BLOB(PrintNameOffset + Property.PathBufferOffset - FrameOffset ) PrintNamePadding;
				[DataFieldByteOrder = LittleEndian]
				UnicodeString(PrintNameLength / 2) PrintName;
			}
	}
}

struct FSCCGenericReparseDataBuffer
{
	UINT32 ReparseTag = FSCCReparseTagTable( this );
	UINT16 ReparseDataLength;
	UINT16 Reserved;
	BLOB(ReparseDataLength) DataBuffer;
}

//MUST be used only with reparse tag values whose high bit is set to 1.
struct FSCCReparseDataBuffer
{
	switch(UINT32(FrameData, FrameOffset))
	{
		case 0xA0000003: 
			FSCCMountPointReparseDataBuffer MountPointReparseDataBuffer;
		case 0xA000000C:
			FSCCSymbolicLinkReparseDataBuffer SymbolicLinkReparseDataBuffer;
		default:
			FSCCGenericReparseDataBuffer ReparseDataBuffer;
	}
}

//MUST be used only with reparse tag values whose high bit is set to 0.
struct FSCCReparseGUIDDataBuffer = FormatString("ReparseTag: 0x%X, ReparseGuid: %s", ReparseTag, ReparseGuid.toString)
{
	UINT32 ReparseTag = FSCCReparseTagTable( this );
	UINT16 ReparseDataLength;
	UINT16 Reserved;
	GUID(false) ReparseGuid;
	BLOB(ReparseDataLength) DataBuffer;
	// DataBuffer : This field MUST be zero length and MUST be ignored.
}

// Unused
// Vik Desai said: There is no way to distinguish one FileObjectIdInformation from the other. 
// Based on the application type using it the file reference number would be different. 

struct FSCCFileObjectIDBufferType1 = FormatString("ObjectId: %s, BirthVolumeId: %s, BirthObjectId: %s, DomainId: %s", ObjectId.toString, BirthVolumeId.toString, BirthObjectId, DomainId)
{
	GUID(false) ObjectId;
	GUID(false) BirthVolumeId;
	GUID(false) BirthObjectId;
	GUID(false) DomainId;
}

struct FSCCFileObjectIDBuffer = FormatString("ObjectId: %s", ObjectId.toString)
{
	GUID(false) ObjectId;
	// AppSpecificData cann't be interpreted more detail because there is no way to distinguish the two types
	BLOB(48) AppSpecificData; 
}

struct FSCCFSCTLCreateOrGetObjectIDResponse
{
	FSCCFileObjectIDBuffer ObjectIDBuffer;
}

struct FSCCFSCTLDeleteReparsePointRequest
{
	switch
	{
		case (UINT32(FrameData,FrameOffset) & 0x80000000) == 0x80000000:
			FSCCReparseDataBuffer ReparseDataBuffer;
		default :
			FSCCReparseGUIDDataBuffer ReparseGUIDDataBuffer;
	}
}

struct FSCCFSCTLFindFilesBySIDRequest
{
	UINT32 Restart;
	SID(FALSE) SID;
}

struct FSCCFSCTLFindFilesBySIDResponse
{
	while[FrameOffset < FrameLength - 4]
	{
		Struct FindBySIDOutputData = FormatString("FileName: %s", FileName)
		{
			UINT16 FileNameLength;
			[DataFieldByteOrder = LittleEndian]
			UnicodeString(FileNameLength/2) FileName;
		}
	}
}

struct FSCCFSCTLGetCompressionResponse = FormatString("CompressionState: %s", FSCCCompressionStateTable(CompressionState) )
{
	UINT16 CompressionState = FSCCCompressionStateTable(this);
}

struct FSCCFSCTLGetObjectIDResponse
{
	FSCCFileObjectIDBuffer FileObjectIDBuffer;
}

struct FSCCFSCTLGetReparsePointResponse
{
	switch
	{
		case (UINT32(FrameData,FrameOffset) & 0x80000000) == 0x80000000:
			FSCCReparseDataBuffer ReparseDataBuffer;
		default :
			FSCCReparseGUIDDataBuffer ReparseGUIDDataBuffer;
	}
}

struct FSCCFSCTLGetRetrievalPointersRequest = FormatString("StartingVcn: %u", StartingVcn) 
{
	INT64 StartingVcn;
}

struct FSCCFSCTLGetRetrievalPointersResponse = FormatString("ExtentCount: %u", ExtentCount) 
{
	UINT32 ExtentCount;
	UINT32 Unused;
	INT64 StartingVcn;
	FSCCExtents	Extents[ExtentCount];
}

struct FSCCExtents = FormatString("NextVcn: %u, Lcn: %u", NextVcn, Lcn) 
{
	UINT64 NextVcn;
	UINT64 Lcn;
}

struct FSCCFSCTLIsPathnameValidRequest = FormatString("%s", PathNameLength > 0 ? "PathName: " + PathName : "")
{
	UINT32 PathNameLength;
	[DataFieldByteOrder = LittleEndian]
	UnicodeString(PathNameLength / 2) PathName;
}

struct FSCCFSCTLLMRGetLinkTrackingInformationResponse = FormatString("Type: %s, VolumeId: %s", FSCCFileSystemTypeTable(Type), VolumeId.toString)
{
	UINT32 Type = FSCCFileSystemTypeTable(this);
	GUID(false) VolumeId;
}

struct FSCCFSCTLLMRSetLinkTrackingInformationRequest
{
	UINT32 TargetFileObject;
	UINT32 TargetLinkTrackingInformationLength;
	Switch
	{
		Case TargetLinkTrackingInformationLength > 0:
			Struct TargetLinkTrackingInformationBuffer
			{
				Switch
				{
					Case TargetLinkTrackingInformationLength < 36 : FSCCTargetLinkTrackingInformationBuffer1 Buffer1;
					Default: FSCCTargetLinkTrackingInformationBuffer2 Buffer2;
				}
			}
	 }
}

struct FSCCTargetLinkTrackingInformationBuffer1 = FormatString(" NetBIOSName: %s", NetBIOSName)
{
	AsciiString NetBIOSName;
}

struct FSCCTargetLinkTrackingInformationBuffer2 = FormatString("Type: %s, NetBIOSName: %s", FSCCFileSystemTypeTable(Type), NetBIOSName)
{
	UINT32 Type = FSCCFileSystemTypeTable(this);
	GUID(false) VolumeId;
	GUID(false) ObjectId;
	AsciiString NetBIOSName;
}
		 
struct FSCCFSCTLQueryAllocatedRangesRequest = FormatString("FileOffset: %u, Length: %u", FileOffset, Length) 
{
	INT64 FileOffset;
	INT64 Length;
}

struct FSCCFSCTLQueryAllocatedRangesResponse(size)
{
	FSCCFileAllocatedRangeBuffer FileAllocatedRangeBuffer[(size - 4)/ 16 ];
}

struct FSCCFileAllocatedRangeBuffer = FormatString("FileOffset: %u, Length: %u", FileOffset, Length) 
{
	INT64 FileOffset;
	INT64 Length;
}

struct FSCCFSCTLReadFileUSNDataResponse
{
	[Local.StartOffset = FrameOffset]
	UINT32 RecordLength;
	UINT16 MajorVersion;
	UINT16 MinorVersion;
	UINT64 FileReferenceNumbe;
	UINT64 ParentFileReferenceNumber;
	INT64 USN;
	FILETIME TimeStamp;
	UINT32 Reason
	{
		UINT32 DATA_OVERWRITE:1 = FormatString("       (%s) %s", this.ToBitString, this ? "The data in the file or directory is overwritten" : "The data in the file or directory is NOT overwritten");
		UINT32 DATA_EXTEND:1 = FormatString("          (%s) %s", this.ToBitString, this ? "The file or directory is extended (added to)" : "The file or directory is NOT extended (added to)");
		UINT32 DATA_TRUNCATION:1 = FormatString("      (%s) %s", this.ToBitString, this ? "The file or directory is truncated" : "The file or directory is NOT truncated");
		UINT32 Reserved_bits3:1 = FormatString("       (%s) Reserved",this.ToBitString);
		UINT32 NAMED_DATA_OVERWRITE:1 = FormatString(" (%s) %s", this.ToBitString, this ? "The data in one or more named data streams for a file is overwritten" : "The data in one or more named data streams for a file is NOT overwritten");
		UINT32 NAMED_DATA_EXTEND:1 = FormatString("    (%s) %s", this.ToBitString, this ? "The one or more named data streams for a file are extended (added to)" : "The one or more named data streams for a file are NOT extended (added to)");
		UINT32 NAMED_DATA_TRUNCATION:1 = FormatString("(%s) %s", this.ToBitString, this ? "One or more named data streams for a file are truncated" : "One or more named data streams for a file are NOT truncated");
		UINT32 Reserved_bits7:1 = FormatString("       (%s) Reserved",this.ToBitString); //0x80
		UINT32 FILE_CREATE:1 = FormatString("          (%s) %s", this.ToBitString, this ? "The file or directory is created for the first time" : "The file or directory is NOT created for the first time");
		UINT32 FILE_DELETE:1 = FormatString("          (%s) %s", this.ToBitString, this ? "The file or directory is deleted" : "The file or directory is NOT deleted");
		UINT32 EA_CHANGE:1 = FormatString("            (%s) %s", this.ToBitString, this ? "The user made a change to the extended attributes of a file or directory" : "The user did NOT make a change to the extended attributes of a file or directory");
		UINT32 SECURITY_CHANGE:1 = FormatString("      (%s) %s", this.ToBitString, this ? "A change is made in the access rights to a file or directory" : "A change is NOT made in the access rights to a file or directory");
		UINT32 RENAME_OLD_NAME:1 = FormatString("      (%s) %s", this.ToBitString, this ? "The file or directory is renamed, and the file name in the USN_RECORD structure is the previous name" : "The file or directory is NOT renamed, and the file name in the USN_RECORD structure is NOT the previous name");
		UINT32 RENAME_NEW_NAME:1 = FormatString("      (%s) %s", this.ToBitString, this ? "A file or directory is renamed, and the file name in the USN_RECORD structure is the new name" : "A file or directory is NOT renamed, and the file name in the USN_RECORD structure is NOT the new name");
		UINT32 INDEXABLE_CHANGE:1 = FormatString("     (%s) %s", this.ToBitString, this ? "A user changes the FILE_ATTRIBUTE_NOT_CONTEXT_INDEXED attribute" : "A user does NOT change the FILE_ATTRIBUTE_NOT_CONTEXT_INDEXED attribute");
		UINT32 BASIC_INFO_CHANGE:1 = FormatString("    (%s) %s", this.ToBitString, this ? "A user has either changed one or more files or directory attributes (such as read-only, hidden, archive, or sparse) or one or more timestamps" : "A user has NOT either changed one or more files or directory attributes (such as read-only, hidden, archive, or sparse) or one or more timestamps");
		UINT32 HARD_LINK_CHANGE:1 = FormatString("     (%s) %s", this.ToBitString, this ? "An NTFS file system hard link is added to (or removed from) the file or directory" : "An NTFS file system hard link is NOT added to (or removed from) the file or directory.");
		UINT32 COMPRESSION_CHANGE:1 = FormatString("   (%s) %s", this.ToBitString, this ? "The compression state of the file or directory is changed from (or to) compressed" : "The compression state of the file or directory is NOT changed from (or to) compressed");
		UINT32 ENCRYPTION_CHANGE:1 = FormatString("    (%s) %s", this.ToBitString, this ? "The file or directory is encrypted" : "The file or directory is decrypted");
		UINT32 OBJECT_ID_CHANGE:1 = FormatString("     (%s) %s", this.ToBitString, this ? "The object identifier of a file or directory is changed" : "The object identifier of a file or directory is NOT changed");
		UINT32 REPARSE_POINT_CHANGE:1 = FormatString(" (%s) %s", this.ToBitString, this ? "The reparse point that is contained in a file or directory is changed, or a reparse point is added to (or deleted from) a file or directory" : "The reparse point that is contained in a file or directory is NOT changed, or a reparse point is NOT added to (or deleted from) a file or directory");
		UINT32 STREAM_CHANGE:1 = FormatString("        (%s) %s", this.ToBitString, this ? "A named stream is added to (or removed from) a file, or a named stream is renamed" : "A named stream is NOT added to (or removed from) a file, or a named stream is NOT renamed");
		UINT32 Reserved_bits22_30:9 = FormatString("   (%s) Reserved",this.ToBitString);
		UINT32 CLOSE:1 = FormatString("                (%s) %s", this.ToBitString, this ? "The file or directory is closed" : "The file or directory is NOT closed");
	}
	UINT32 SourceInfo = FSCCSourceInfoTable(this);
	UINT32 SecurityId;
	FSCCFileAttributes FileAttributes;
	UINT16 FileNameLength;
	UINT16 FileNameOffset;
	switch
	{
		case (Local.StartOffset + FileNameOffset) > FrameOffset:
			BLOB(Local.StartOffset + FileNameOffset - FrameOffset) FileNameOffsetBLOB;
	}
	[DataFieldByteOrder = LittleEndian]
	UnicodeString(FileNameLength / 2) FileName;
}

struct FSCCFSCTLSetCompressionRequest
{
	UINT16 CompressionState = FSCCCompressionStateTable(this);
}

struct FSCCFSCTLSetObjectIDRequest
{
	FSCCFileObjectIDBuffer FileObjectIDBuffer;
}

struct FSCCFSCTLSetObjectIDExtendedRequest
{
	BLOB(48) ExtendedInfo;
}

struct FSCCFSCTLSetReparsePointRequest
{
	switch
	{
		case (UINT32(FrameData,FrameOffset) & 0x80000000) == 0x80000000:
			FSCCReparseDataBuffer ReparseDataBuffer;
		default :
			FSCCReparseGUIDDataBuffer ReparseGUIDDataBuffer;
	}
}

struct FSCCFSCTLSetZeroDataRequest
{
	UINT64 FileOffset;
	UINT64 BeyondFinalZero;
}

struct FSCCFSCTLSISCopyfileRequest
{
	UINT32 SourceFileNameLength;
	UINT32 DestinationFileNameLength;
	UINT32 Flags = FSCCFSCTLSISCopyFileRequestFlagsTable(this);
	[DataFieldByteOrder = LittleEndian]
	UnicodeString(SourceFileNameLength / 2) SourceFileName;
	[DataFieldByteOrder = LittleEndian]
	UnicodeString(DestinationFileNameLength / 2) DestinationFileName;
}

struct FSCCFSCTLWriteUSNCloseRecordResponse
{
	UINT64 Usn;
}

Struct FSCCFSCTLFilesystemGetStatisticsResponse
{
	Struct FilesystemGetStatistics = FormatString("FileSystemType: 0x%X, Version: %d", FileSystemType, Version)
	{
		[ Property.FileSystemType ]
		UINT16 FileSystemType = FSCCFileSystemStatisticsTypeTable ( this );
		//Version: This field MUST be 0x00000001.
		UINT16 Version;
		UINT32 SizeOfCompleteStructure;
		UINT32 UserFileReads;
		UINT32 UserFileReadBytes;
		UINT32 UserDiskReads;
		UINT32 UserFileWrites;
		UINT32 UserFileWriteBytes;
		UINT32 UserDiskWrites;
		UINT32 MetaDataReads;
		UINT32 MetaDataReadBytes;
		UINT32 MetaDataDiskReads;
		UINT32 MetaDataWrites;
		UINT32 MetaDataWriteBytes;
		UINT32 MetaDataDiskWrites;
	}
	Switch( Property.FileSystemType )
	{
		Case 0x0001: FSCCNtfsStatistics  NTFSStatistics;
		Case 0x0002: FSCCFATStatistics   FATStatistics;
		Case 0x0003: FSCCExFATStatistics ExFATStatistics ;
	}
}

Struct FSCCNTFSStatistics
{
	UINT32 LogFileFullExceptions;
	UINT32 OtherExceptions;
	UINT32 MftReads;
	UINT32 MftReadBytes;
	UINT32 MftWrites;
	UINT32 MftWriteBytes;
	Struct MftWritesUserLevel = FormatString(" Write = %u, Creat = %u, SetInfo = %u, Flush = %u", Write, Creat, SetInfo, Flush)
	{
		UINT16 Write;
		UINT16 Creat;
		UINT16 SetInfo;
		UINT16 Flush;
	}
	UINT16 MftWritesFlushForLogFileFull;
	UINT16 MftWritesLazyWriter;
	UINT16 MftWritesUserReques;
	UINT32 RootIndexReads;
	UINT32 RootIndexReadBytes;
	UINT32 RootIndexWrites;
	UINT32 RootIndexWriteBytes;
	UINT32 BitmapReads;
	UINT32 BitmapReadBytes;
	UINT32 BitmapWrites;
	UINT32 BitmapWriteBytes;
	UINT16 BitmapWritesFlushForLogFileFull;
	UINT16 BitmapWritesLazyWriter;
	UINT16 BitmapWritesUserRequest;
	Struct BitmapWritesUserLevel =  FormatString(" Write = %u, Creat = %u, SetInfo = %u", Write, Creat, SetInfo)
	{
		UINT16 Write;
		UINT16 Creat;
		UINT16 SetInfo;
	}
	UINT16 Padding;
	UINT32 MftBitmapReads;
	UINT32 MftBitmapReadBytes;
	UINT32 MftBitmapWrites;
	UINT32 MftBitmapWriteBytes;
	UINT16 MftBitmapWritesFlushForLogFileFull;
	UINT16 MftBitmapWritesLazyWriter
	UINT16 MftBitmapWritesUserRequest
	Struct MftBitmapWritesUserLevel = FormatString(" Write = %u, Creat = %u, SetInfo = %u, Flush = %u", Write, Creat, SetInfo, Flush)
	{
		UINT16 Write;
		UINT16 Creat;
		UINT16 SetInfo;
		UINT16 Flush;
	}
	UINT32 UserIndexReads;
	UINT32 UserIndexReadBytes;
	UINT32 UserIndexWrites;
	UINT32 UserIndexWriteBytes;
	UINT32 LogFileReads;
	UINT32 LogFileReadBytes;
	UINT32 LogFileWrites;
	UINT32 LogFileWriteBytes;
	Struct Allocate = FormatString(" Calls = %u, Clusters = %u, Hints = %u, Cache = %u", Calls, Clusters, Hints, Cache)
	{
		UINT32 Calls
		UINT32 Clusters
		UINT32 Hints
		UINT32 RunsReturned
		UINT32 HintsHonored
		UINT32 HintsClusters
		UINT32 Cache
		UINT32 CacheClusters
		UINT32 CacheMiss
		UINT32 CacheMissClusters
	}

}

Struct FSCCFATStatistics
{
	UINT32 CreateHits;
	UINT32 SuccessfulCreates;
	UINT32 FailedCreates;
	UINT32 NonCachedReads;
	UINT32 NonCachedReadBytes;
	UINT32 NonCachedWrites;
	UINT32 NonCachedWriteBytes;
	UINT32 NonCachedDiskReads;
	UINT32 NonCachedDiskWrites;
}

Struct FSCCExFATStatistics
{
	UINT32 CreateHits;
	UINT32 SuccessfulCreates;
	UINT32 FailedCreates;
	UINT32 NonCachedReads;
	UINT32 NonCachedReadBytes;
	UINT32 NonCachedWrites;
	UINT32 NonCachedWriteBytes;
	UINT32 NonCachedDiskReads;
	UINT32 NonCachedDiskWrites;
}

Struct FSCCFSCTLIsVolumeDirtyResponse = FormatString("Flags: 0x%X", Flags)
{
	UINT32 Flags
	{
		UINT32 IsDirty:1 = FormatString("         (%s) %s", this.ToBitString, this ? "The volume is dirty":"");
		UINT32 UpgradeScheduled:1 = FormatString("(%s) %s", this.ToBitString, this ? "The volume will be upgraded to the current version the next time it is mounted.":"");
		UINT32 SessionOpen:1 = FormatString("     (%s) %s", this.ToBitString, this ? "The volume session is open":"");
		UINT32 Reserved_bits3_31:29 = FormatString("(%s) Reserved", this.ToBitString);
	}
}

Struct FSCCFSCTLPipePeekResponse = FormatString("NamedPipeState: 0x%X",NamedPipeState)
{
	UINT32 NamedPipeState = FSCCNamedPipeStateTable( this );
	UINT32 ReadDataAvailable;
	UINT32 NumberOfMessages;
	UINT32 MessageLength;
	BLOB( ReadDataAvailable ) Data;
}

Struct FSCCFSCTLPipeTransceiveRequest(size)
{
	BLOB(size) InputBuffer;
}

Struct FSCCFSCTLPipeTransceiveResponse(size)
{
	BLOB(size - 4) OutputBuffer;
}

Struct FSCCFSCTLQueryFATBPBResponse
{
	BLOB(36) FATBIOSParameterBlock;
}

Struct FSCCFSCTLQueryOnDiskVolumeInfoResponse = FormatString("FormatName: %s", FsFormatName)
{
	INT64 DirectoryCount;
	INT64 FileCount;
	INT16 FsFormatMajVersion;
	INT16 FsFormatMinVersion;
	UnicodeString(12) FsFormatName;
	FILETIME FormatTime;
	FILETIME LastUpdateTime;
	BLOB(68) CopyrightInfo
	BLOB(68) AbstractInfo;
	BLOB(68) FormattingImplementationInfo;
	BLOB(68) LastModifyingImplementationInfo;
}

Struct FSCCFSCTLQuerySparingInfoResponse
{
	UINT32 SparingUnitBytes;
	BOOLEAN SoftwareSparing = this? "The sparing behavior is software-based" : "The sparing behavior is hardware-based";
	UINT32 TotalSpareBlocks;
	UINT32 FreeSpareBlocks;
}

Struct FSCCFSCTLSetDefectManagementRequest
{
	BOOLEAN Disable = this? "Defect management will be disabled." : "Defect management won't be disabled.";
}

Struct FSCCFSCTLSetEncryptionRequest
{
	UINT32 EncryptionOperation = FSCCEncryptionOperationTable( this );
	CHAR Rrivate;
}

Struct FSCCFSCTLSetShortNameBehaviorRequest
{
	UINT32 Flags = this? "DBCS characters are permitted in short." : "DBCS characters are not permitted in short names.";
}

struct FSCCFileAllocationInformation
{
	INT64 size;
}

struct FSCCFileAlternateNameInformation
{
	UINT32 FileNameLength;
	[DataFieldByteOrder = LittleEndian]
	UnicodeString(FileNameLength / 2) FileName;
}

struct FSCCFileAttributeTagInformation
{
	FSCCFileAttributes FileAttributes;
	UINT32 ReparseTag = this? FSCCReparseTagTable( this ): this;
}

struct FSCCFileBasicInformation
{
	FILETIME CreationTime;
	FILETIME LastAccessTime;
	FILETIME LastWriteTime;
	FILETIME ChangeTime;
	FSCCFileAttributes FileAttributes;
	UINT32 Reserved;
}

[ Property.FSCCFileLastEntry  = FALSE ]
struct FSCCFileBothDirectoryInformationList
{
	while [ !Property.FSCCFileLastEntry ]
	{
		FSCCFileBothDirectoryInformation FileBothDirInfo;
	}
}

struct FSCCFileBothDirectoryInformation = FormatString("%s", FileNameLength > 0 ? "FileName: " + FileName : "")
{
	[
		EntryStartOffset = FrameOffset,
		Property.FSCCFileLastEntry = this? FALSE: TRUE
	]
	UINT32 NextEntryOffset;
	UINT32 FileIndex;
	FILETIME CreationTime;
	FILETIME LastAccessTime;
	FILETIME LastWriteTime;
	FILETIME ChangeTime;
	INT64 EndOfFile;
	INT64 AllocationSize;
	FSCCFileAttributes FileAttributes;
	UINT32 FileNameLength;
	UINT32 EaSize;
	UINT8 ShortNameLength;
	UINT8 Reserved;
	[DataFieldByteOrder = LittleEndian]
	UnicodeString(12) ShortName;
	[DataFieldByteOrder = LittleEndian]
	UnicodeString(FileNameLength / 2) FileName;
	switch                                                                     
	{                                                                          
		case (EntryStartOffset + NextEntryOffset) > FrameOffset:                 
			BLOB( EntryStartOffset + NextEntryOffset - FrameOffset) EntryPadding;  
	}                                                                          
}

struct FSCCFileCompressionInformation
{
	INT64 CompressedFileSize;
	UINT16 CompressionFormat = FSCCCompressionFormatTable(this);
	UINT8 CompressionUnitShift;
	UINT8 ChunkShift;
	UINT8 ClusterShift;
	BLOB(3) Reserved;
}

[ Property.FSCCFileLastEntry  = FALSE ]
struct FSCCFileDirectoryInformationList
{
	while [ !Property.FSCCFileLastEntry ]
	{
		FSCCFileDirectoryInformation FileDirInfo;
	}
}

struct FSCCFileDirectoryInformation = FormatString("File Directory: %s", FileName)
{
	[
		EntryStartOffset = FrameOffset,
		Property.FSCCFileLastEntry = this? FALSE: TRUE
	]
	UINT32 NextEntryOffset;
	UINT32 FileIndex;
	FILETIME CreationTime;
	FILETIME LastAccessTime;
	FILETIME LastWriteTime;
	FILETIME ChangeTime;
	INT64 EndOfFile;
	INT64 AllocationSize;
	FSCCFileAttributes FileAttributes;
	UINT32 FileNameLength;
	[DataFieldByteOrder = LittleEndian]
	UnicodeString(FileNameLength / 2) FileName;
	switch
	{
		case (EntryStartOffset + NextEntryOffset) > FrameOffset:
			BLOB( EntryStartOffset + NextEntryOffset - FrameOffset) EntryPadding;
	}
}

struct FSCCFileDispositionInformation
{
	BOOLEAN DeletePending;
}

struct FSCCFileEaInformation
{
	UINT32 EaSize;
}

struct FSCCFileEndOfFileInformation
{
	INT64 EndOfFile;
}

[ Property.FSCCFileLastEntry  = FALSE ]
struct FSCCFileFullDirectoryInformationList
{
	while [ !Property.FSCCFileLastEntry ]
	{
		FSCCFileFullDirectoryInformation FileFullDirInfo;
	}
}

struct FSCCFileFullDirectoryInformation = FormatString("File Name: %s", Filename)
{
	[
		EntryStartOffset = FrameOffset,
		Property.FSCCFileLastEntry = this? FALSE: TRUE
	]
	UINT32 NextEntryOffset;
	UINT32 FileIndex;
	FILETIME CreationTime;
	FILETIME LastAccessTime;
	FILETIME LastWriteTime;
	FILETIME ChangeTime;
	INT64 EndOfFile;
	INT64 AllocationSize;
	FSCCFileAttributes FileAttributes;
	UINT32 FileNameLength;
	UINT32 EaSize;
	[DataFieldByteOrder = LittleEndian]
	UnicodeString(FileNameLength / 2) FileName;
	switch
	{
		case (EntryStartOffset + NextEntryOffset) > FrameOffset:
			BLOB( EntryStartOffset + NextEntryOffset - FrameOffset) EntryPadding;
	}
}

[ Property.FSCCFileLastEntry  = FALSE ]
struct FSCCFileFullEaInformationList
{
	while [ !Property.FSCCFileLastEntry ]
	{
		FSCCFileFullEaInformation FileFullEaInfo;
	}
}
struct FSCCFileFullEaInformation
{
	[
		EntryStartOffset = FrameOffset,
		Property.FSCCFileLastEntry = this? FALSE: TRUE
	]
	UINT32 NextEntryOffset;
	UINT8 Flags
	{
		UINT8 FILE_NEED_EA:1 = FormatString("    (%s) %s", this.ToBitString, this ? "Need extended attributes" : "NOT Need extended attributes");
		UINT8 Reserved_bits2_7:7 = FormatString("(%s) Reserved", this.ToBitString);
	}
	UINT8 EaNameLength;
	UINT16 EaValueLength;
	AsciiString(EaNameLength + 1) EaName;
	BLOB(EaValueLength) EaValue;
	switch
	{
		case (EntryStartOffset + NextEntryOffset) > FrameOffset:
			BLOB( EntryStartOffset + NextEntryOffset - FrameOffset) EntryPadding;
	}
}

[ Property.FSCCFileLastEntry  = FALSE ]
struct FSCCFileIdBothDirectoryInformationList
{
	while [ !Property.FSCCFileLastEntry ]
	{
		FSCCFileIdBothDirectoryInformation FileIdBothDirInfo;
	}
}
struct FSCCFileIdBothDirectoryInformation = FormatString("%s", FileNameLength > 0 ? "FileName: " + FileName : "")
{
	[
		EntryStartOffset = FrameOffset,
		Property.FSCCFileLastEntry = this? FALSE: TRUE
	]
	UINT32 NextEntryOffset;
	UINT32 FileIndex;
	FILETIME CreationTime;
	FILETIME LastAccessTime;
	FILETIME LastWriteTime;
	FILETIME ChangeTime;
	INT64 EndOfFile;
	INT64 AllocationSize;
	FSCCFileAttributes FileAttributes;
	UINT32 FileNameLength;
	UINT32 EaSize;
	UINT8 ShortNameLength;
	UINT8 Reserved1;
	[DataFieldByteOrder = LittleEndian]
	UnicodeString(12) ShortName;
	UINT16 Reserved2;
	UINT64 FileID;
	[DataFieldByteOrder = LittleEndian]
	UnicodeString(FileNameLength / 2) FileName;
	switch
	{
		case (EntryStartOffset + NextEntryOffset) > FrameOffset:
			BLOB( EntryStartOffset + NextEntryOffset - FrameOffset) EntryPadding;
	}
}

[ Property.FSCCFileLastEntry  = FALSE ]
struct FSCCFileIdFullDirectoryInformationList
{
	while [ !Property.FSCCFileLastEntry ]
	{
		FSCCFileIdFullDirectoryInformation FileIdFullDirInfo;
	}
}

struct FSCCFileIdFullDirectoryInformation = FormatString("%s", FileNameLength > 0 ? "FileName: " + FileName : "")
{
	[
		EntryStartOffset = FrameOffset,
		Property.FSCCFileLastEntry = this? FALSE: TRUE
	]
	UINT32 NextEntryOffset;
	UINT32 FileIndex;
	FILETIME CreationTime;
	FILETIME LastAccessTime;
	FILETIME LastWriteTime;
	FILETIME ChangeTime;
	INT64 EndOfFile;
	INT64 AllocationSize;
	FSCCFileAttributes FileAttributes;
	UINT32 FileNameLength;
	UINT32 EaSize;
	UINT32 Reserved;
	UINT64 FileID;
	[DataFieldByteOrder = LittleEndian]
	UnicodeString(FileNameLength / 2) FileName;
	switch
	{
		case (EntryStartOffset + NextEntryOffset) > FrameOffset:
			BLOB( EntryStartOffset + NextEntryOffset - FrameOffset) EntryPadding;
	}
}

struct FSCCFileInternalInformation
{
	INT64 IndexNumber;
}

struct FSCCFileLinkInformation
{
	BOOLEAN ReplaceIfExists;
	BLOB(7) Reserved;
	UINT64 RootDirectory;
	UINT32 FileNameLength;
	[DataFieldByteOrder = LittleEndian]
	UnicodeString(FileNameLength / 2) FileName;
}

struct FSCCFileMailslotQueryInformation
{
	UINT32 MaximumMessageSize;
	UINT32 MailslotQuota;
	UINT32 NextMessageSize;
	UINT32 MessagesAvailable;
	INT64 ReadTimeout;
}

struct FSCCFileMailslotSetInformation
{
	INT64 ReadTimeout;
}

[ Property.FSCCFileLastEntry  = FALSE ]
struct FSCCFileNamesInformationList
{
	while [ !Property.FSCCFileLastEntry ]
	{
		FSCCFileNamesInformation FileNamesInfo;
	}
}

struct FSCCFileNamesInformation =  FormatString("%s", FileNameLength > 0 ? "FileName: " + FileName : "")
{
	[
		EntryStartOffset = FrameOffset,
		Property.FSCCFileLastEntry = this? FALSE: TRUE
	]
	UINT32 NextEntryOffset;
	UINT32 FileIndex;
	UINT32 FileNameLength;
	[DataFieldByteOrder = LittleEndian]
	UnicodeString(FileNameLength / 2) FileName;
	switch
	{
		case (EntryStartOffset + NextEntryOffset) > FrameOffset:
			BLOB( EntryStartOffset + NextEntryOffset - FrameOffset) EntryPadding;
	}
}

struct FSCCFileNetworkOpenInformation
{
	FILETIME CreationTime;
	FILETIME LastAccessTime;
	FILETIME LastWriteTime;
	FILETIME ChangeTime;
	INT64 AllocationSize;
	INT64 EndOfFile;
	FSCCFileAttributes FileAttributes;
	UINT32 Reserved;
}

struct FSCCFileObjectIdInformation
{
	UINT64 FileReferenceNumber;
	FSCCFileObjectIDBuffer FileObjectIDBuffer;
}

struct FSCCFilePipeInformation
{
	UINT32 ReadMode = FSCCFilePipeInfoReadModeTable(this);
	UINT32 CompletionMode = FSCCFilePipeInfoCompletionModeTable(this);
}


struct FSCCFilePipeLocalInformation
{
	UINT32 NamedPipeType = FSCCFilePipeLocalInfoNamedPipeTypeTable(this);
	UINT32 NamedPipeConfiguration = FSCCFilePipeLocalInfoNamedPipeConfigTable(this);
	UINT32 MaximumInstances;
	UINT32 CurrentInstances;
	UINT32 InboundQuota;
	UINT32 ReadDataAvailable;
	UINT32 OutboundQuota;
	UINT32 WriteQuotaAvailable;
	UINT32 NamedPipeState = FSCCFilePipeLocalInfoNamedPipeStateTable(this);
	UINT32 NamedPipeEnd	= FSCCFilePipeLocalInfoNamedPipeEndTable(this);
}

[ Property.FSCCFileLastEntry  = FALSE ]
struct FSCCFileQuotaInformationList
{
	while [ !Property.FSCCFileLastEntry ]
	{
		FSCCFileQuotaInformation FileQuotaInfostruct;
	}
}

struct FSCCFileQuotaInformation = "File SID: " + SID.toString
{
	[
		EntryStartOffset = FrameOffset,
		Property.FSCCFileLastEntry = this? FALSE: TRUE
	]
	UINT32 NextEntryOffset;
	UINT32 SidLength;
	FILETIME ChangeTime;
	INT64 QuotaUsed;
	INT64 QuotaThreshold;
	INT64 QuotaLimit;
	Switch
	{
		Case SidLength > 0: SID(FALSE) SID;
	}
	switch
	{
		case (EntryStartOffset + NextEntryOffset) > FrameOffset:
			BLOB( EntryStartOffset + NextEntryOffset - FrameOffset) EntryPadding;
	}
}

struct FSCCFileRenameInformation = FormatString("%s", FileNameLength > 0 ? "FileName: " + FileName : "")
{
	BOOLEAN ReplaceIfExists;
	BLOB(7) Reserved;
	UINT64 RootDirectory;
	UINT32 FileNameLength;
	[DataFieldByteOrder = LittleEndian]
	UnicodeString(FileNameLength / 2) FileName;
}

struct FSCCFileReparsePointInformation
{
	INT64 FileReferenceNumber;
	UINT32 Tag = FSCCReparseTagTable( this );
}

struct FSCCFileShortNameInformation = FormatString("%s", FileNameLength > 0 ? "FileName: " + FileName : "")
{
	UINT32 FileNameLength;
	[DataFieldByteOrder = LittleEndian]
	UnicodeString(FileNameLength / 2) FileName;
}

struct FSCCFileStandardInformation
{
	INT64 AllocationSize;
	INT64 EndOfFile;
	UINT32 NumberOfLinks;
	UINT8 DeletePending = FormatString("(%s) %s", this.ToBitString , this ? "requested file deletion" : "Not requested file deletion");
	UINT8 Directory = FormatString("(%s) %s", this.ToBitString , this ? "Directory" : "File");
	UINT16 Reserved;
}

[ Property.FSCCFileLastEntry  = FALSE ]
struct FSCCFileStreamInformationList
{
	while [ !Property.FSCCFileLastEntry ]
	{
		FSCCFileStreamInformation FileStreamInfo;
	}
}

struct FSCCFileStreamInformation = FormatString("%s", StreamNameLength > 0 ? "StreamName: " + StreamName: "")
{
	[
		EntryStartOffset = FrameOffset,
		Property.FSCCFileLastEntry = this? FALSE: TRUE
	]
	UINT32 NextEntryOffset;
	UINT32 StreamNameLength;
	UINT64 StreamSize;
	INT64 StreamAllocationSize;
	[DataFieldByteOrder = LittleEndian]
	UnicodeString(StreamNameLength / 2) StreamName;
	switch
	{
		case (EntryStartOffset + NextEntryOffset) > FrameOffset:
			BLOB( EntryStartOffset + NextEntryOffset - FrameOffset) EntryPadding;
	}
}

struct FSCCFileAlignmentInformation
{
	UINT32 AlignmentRequirement = FSCCAlignmentRequirementTable( this );
}

struct FSCCFileValidDataLengthInformation
{
	INT64 FileNameLength;
}

struct FSCCFileAccessInformation
{
	// A DWORD that MUST contain values specified in ACCESS_MASK of [MS-DTYP]
	 ACEAccessMask AccessFlags;
}

struct FSCCFilePositionInformation
{
	UINT64 CurrentByteOffset;
}

struct FSCCFileModeInformation
{
	UINT32 Mode
	{
		UINT32 Reserved_bits0:1 = FormatString("             (%s) Reserved", this.ToBitString);
		UINT32 FileWriteThrough:1 = FormatString("           (%s) %s", this.ToBitString, this ? "write data to the file MUST actually transfer the data into the file before any requested write operation is considered complete." : "write data to the file NEED NOT actually transfer the data into the file before any requested write operation is considered complete.");
		UINT32 FileSequentialOnly:1 = FormatString("         (%s) %s", this.ToBitString, this ? "all accesses to the file will be sequential" : "all accesses to the file will NOT be sequential");
		UINT32 FileNoIntermediateBuffering:1 = FormatString("(%s) %s", this.ToBitString, this ? "the file cannot be cached or buffered in a driver's internal buffers" : "the file can be cached or buffered in a driver's internal buffers");
		UINT32 FileSynchronousIOAlert:1 = FormatString("     (%s) %s", this.ToBitString, this ? "all operations on the file are performed synchronously. Any wait on behalf of the caller is subject to premature termination from alerts" : "NOT all operations on the file are performed synchronously");
		UINT32 FileSynchronousIONonalert:1 = FormatString("  (%s) %s", this.ToBitString, this ? "all operations on the file are performed synchronously. Wait requests in the system to synchronize I/O queuing and completion are not subject to alerts." : "NOT all operations on the file are performed synchronously");
		UINT32 Reserved_bits6_11:6 = FormatString("          (%s) Reserved", this.ToBitString);
		UINT32 FileDeleteOnClose:1 = FormatString("          (%s) %s", this.ToBitString, this ? "delete the file when the last handle to the file is closed." : "DO NOT delete the file when the last handle to the file is closed.");
		UINT32 Reserved_bits13_31:19 = FormatString("        (%s) Reserved", this.ToBitString);
	};
}

struct FSCCFileAllInformation
{
	FSCCFileBasicInformation BasicInformation;
	FSCCFileStandardInformation StandardInformation;
	FSCCFileInternalInformation InternalInformation;
	FSCCFileEaInformation EaInformation;
	FSCCFileAccessInformation AccessInformation;
	FSCCFilePositionInformation PositionInformation;
	FSCCFileModeInformation ModeInformation;
	FSCCFileAlignmentInformation AlignmentInformation;
	FSCCFileNamesInformation NameInformation;
}

struct FSCCFilePipeRemoteInformation
{
	UINT64 CollectDataTime;
	UINT32 MaximumCollectionCount;
}

struct FSCCFileLinkEntryInformation = FormatString("%s", FileNameLength > 0 ? "FileName: " + FileName : "")
{
	[Local.StartOffset = FrameOffset]
	UINT32 NextEntryOffset;
	INT64 ParentFileId;
	UINT32 FileNameLength;
	[DataFieldByteOrder = LittleEndian]
	UnicodeString(FileNameLength / 2) FileName;
	switch
	{
		case (local.StartOffset + NextEntryOffset) > FrameOffset:
			BLOB(local.StartOffset + NextEntryOffset - FrameOffset) EntryPadding;
	}
}

struct FSCCFileHardLinkInformation
{
	UINT32 BytesNeeded;
	UINT32 EntriesReturned;
	FSCCFileLinkEntryInformation Entries[EntriesReturned];
}

struct FSCCFSCTLGetNTFSVolumeDataResponse
{
	FSCCNtfsVolumeDataBuffer OutBuffer;
}

struct FSCCNtfsVolumeDataBuffer
{
	INT64 VolumeSerialNumber;
	INT64 NumberSectors;
	INT64 TotalClusters;
	INT64 FreeClusters;
	INT64 TotalReserved;
	UINT32 BytesPerSector;
	UINT32 BytesPerCluster;
	UINT32 BytesPerFileRecordSegment;
	UINT32 ClustersPerFileRecordSegment;
	INT64 MftValidDataLength;
	INT64 MftStartLcn;
	INT64 Mft2StartLcn;
	INT64 MftZoneStart;
	INT64 MftZoneEnd;
}

struct FSCCFSCTLPipeWaitRequest
{
	INT64 Timeout;
	UINT32 NameLength;
	UINT8 TimeoutSpecified = FormatString("(%s) %s", this.ToBitString, this ? "The server MUST use the value in the Timeout parameter" : "The server MUST wait forever for the named pipe. Any value in Timeout MUST be ignored.");
	UINT8 Padding;
	[DataFieldByteOrder = LittleEndian]
	UnicodeString(NameLength / 2) Name;
}

struct FSCCFileFsVolumeInformation = FormatString("%s", VolumeLabelLength > 0 ? "VolumeLabel: " +VolumeLabel : "")
{
	FILETIME VolumeCreationTime;
	UINT32 VolumeSerialNumber;
	UINT32 VolumeLabelLength;
	BOOLEAN SupportsObjects;
	UINT8 Reserved;
	[DataFieldByteOrder = LittleEndian]
	UnicodeString(VolumeLabelLength / 2) VolumeLabel;
}

struct FSCCFileFsAttributeInformation = FormatString("%s", FileSystemNameLength > 0 ? "FileSystemName " + FileSystemName : "")
{
	FSCCFileSystemAttributes FileSystemAttributes;
	INT32 MaximumComponentNameLength;
	UINT32 FileSystemNameLength;
	[DataFieldByteOrder = LittleEndian]
	UnicodeString(FileSystemNameLength / 2) FileSystemName;
}

struct FSCCFileSystemAttributes
{
	UINT32 FSCCFileSystemAttribute
	{
		UINT32	Case_Sensitive_Search:1 = FormatString("  (%s) %s", this.ToBitString, this ? "supports case-sensitive file names when looking up (searching for) file names in a directory." : "NOT supports case-sensitive file names when looking up (searching for) file names in a directory.");
		UINT32	Case_Preserved_Names:1 = FormatString("   (%s) %s", this.ToBitString, this ? "preserves the case of file names when it places a name on disk." : "Not preserves the case of file names when it places a name on disk.");
		UINT32	UNICODE_ON_DISK:1 = FormatString("        (%s) %s", this.ToBitString, this ? "supports Unicode in file and directory names." : "Not supports Unicode in file and directory names.");
		UINT32	PERSISTENT_ACLS:1 = FormatString("        (%s) %s", this.ToBitString, this ? "preserves and enforces access control lists (ACLs)." : "Not preserves and enforces access control lists (ACLs).");
		UINT32	FILE_COMPRESSION:1 = FormatString("       (%s) %s", this.ToBitString, this ? "file volume supports file-based compression." : "file volume NOT supports file-based compression.");
		UINT32	VOLUME_QUOTAS:1 = FormatString("          (%s) %s", this.ToBitString, this ? "supports per-user quotas." : "Not supports per-user quotas.");
		UINT32	SUPPORTS_SPARSE_FILES:1 = FormatString("  (%s) %s", this.ToBitString, this ? "supports sparse files." : "Not supports sparse files.");
		UINT32	SUPPORTS_REPARSE_POINTS:1 = FormatString("(%s) %s", this.ToBitString, this ? "supports reparse files." : "Not supports reparse files.");

		UINT32	SUPPORTS_REMOTE_STORAGE:1 = FormatString("(%s) %s", this.ToBitString, this ? "supports remote storage." : "NOT supports remote storage.");
		UINT32	Reserved_bits9_14:6 = FormatString("      (%s) Reserved", this.ToBitString);
		UINT32	VOLUME_IS_COMPRESSED:1 = FormatString("   (%s) %s", this.ToBitString, this ? "The specified volume is a compressed volume." : "The specified volume is NOT a compressed volume.");
		UINT32	SUPPORTS_OBJECT_IDS:1 = FormatString("    (%s) %s", this.ToBitString, this ? "supports object identifiers." : "NOT supports object identifiers.");
		UINT32	SUPPORTS_ENCRYPTION:1 = FormatString("    (%s) %s", this.ToBitString, this ? "supports the Encrypted File System (EFS)." : "NOT supports the Encrypted File System (EFS).");
		UINT32	NAMED_STREAMS:1 = FormatString("          (%s) %s", this.ToBitString, this ? "supports named streams." : "NOT supports named streams.");
		UINT32	READ_ONLY_VOLUME:1 = FormatString("       (%s) %s", this.ToBitString, this ? "The specified volume is read-only." : "The specified volume is NOT read-only.");
		UINT32  Reserved_bits20_31:12 = FormatString("     (%s) Reserved", this.ToBitString);
	}
}

struct FSCCFileFsLabelInformation  = FormatString("%s", VolumeLabelLength > 0 ? "VolumeLabel: " +VolumeLabel : "")
{
	UINT32 VolumeLabelLength;
	[DataFieldByteOrder = LittleEndian]
	UnicodeString(VolumeLabelLength / 2) VolumeLabel;
}

struct FSCCFileSystemControlFlags
{
	UINT32 FSCCFileSystemControlFlags
	{
		UINT32	QUOTA_TRACK:1 = FormatString("           (%s) %s", this.ToBitString, this ? "Quotas are tracked on the volume, but they are NOT enforced." : "");
		UINT32	QUOTA_ENFORCE:1 = FormatString("         (%s) %s", this.ToBitString, this ? "Quotas are tracked and enforced on the volume." : "");
		UINT32	Reserved_bits2_3:1 = FormatString("      (%s) Reserved", this.ToBitString);
		UINT32	CONTENT_INDEX_DISABLED:1 = FormatString("(%s) %s", this.ToBitString, this ? "Content indexing is disabled" : "Content indexing is enabled ");
		UINT32	LOG_QUOTA_THRESHOLD:1 = FormatString("   (%s) %s", this.ToBitString, this ? "An event log entry will be created when the user exceeds his or her assigned quota warning threshold." : "An event log entry will NOT be created when the user exceeds his or her assigned quota warning threshold.");
		UINT32	LOG_QUOTA_LIMIT:1 = FormatString("      (%s) %s", this.ToBitString, this ? "An event log entry will be created when the user exceeds his or her assigned disk quota limit." : "An event log entry will NOT be created when the user exceeds his or her assigned disk quota limit.");
		UINT32	LOG_VOLUME_THRESHOLD:1 = FormatString("  (%s) %s", this.ToBitString, this ? "An event log entry will be created when the volume's free space threshold is exceeded." : "An event log entry will NOT be created when the volume's free space threshold is exceeded.");
		UINT32	LOG_VOLUME_LIMIT:1 = FormatString("      (%s) Reserved", this.ToBitString);
		UINT32	QUOTAS_INCOMPLETE:1 = FormatString("     (%s) %s", this.ToBitString, this ? "The quota information for the volume is incomplete because it is corrupt, or the system is in the process of rebuilding the quota information." : "");
		UINT32	QUOTAS_REBUILDING:1 = FormatString("     (%s) %s", this.ToBitString, this ? "The file system is rebuilding the quota information for the volume." : "The file system is NOT rebuilding the quota information for the volume.");
		UINT32	Reserved_bits10_31:22 = FormatString("   (%s) Reserved", this.ToBitString);
	}
}
struct FSCCFileFsSizeInformation
{
	INT64 TotalAllocationUnits;
	INT64 ActualAvailableAllocationUnits;
	UINT32 SectorsPerAllocationUnit;
	UINT32 BytesPerSector;
}

struct FSCCFileFsControlInformation
{
	INT64 FreeSpaceStartFiltering = SHOULDBeSetToTable(this, "0") + ", and MUST be ignored.";
	INT64 FreeSpaceThreshold = SHOULDBeSetToTable(this, "0") + ", and MUST be ignored.";
	INT64 FreeSpaceStopFiltering = SHOULDBeSetToTable(this, "0") + ", and MUST be ignored.";
	INT64 DefaultQuotaThreshold;
	INT64 DefaultQuotaLimit;
	FSCCFileSystemControlFlags FileSystemControlFlags;
}

struct FSCCFileFsFullSizeInformation
{
	INT64 TotalAllocationUnits;
	INT64 CallerAvailableAllocationUnits;
	INT64 ActualAvailableAllocationUnits;
	UINT32 SectorsPerAllocationUnit;
	UINT32 BytesPerSector;
}

struct FSCCFileFsObjectIdInformation
{
	GUID(false) ObjectId;
	BLOB(48) ExtendedInfo;
}

struct FSCCFileFsDriverPathInformation = FormatString("%s", DriverNameLength > 0 ? "DriverName: " + DriverName : "")
{
	BOOLEAN DriverInPath;
	BLOB(3) Reserved;
	UINT32 DriverNameLength;
	[DataFieldByteOrder = LittleEndian]
	UnicodeString(DriverNameLength / 2) DriverName;
}

[ Property.FSCCFileLastEntry = FALSE ]
Struct FSCCFileIdGlobalTxDirectoryInformationList
{
	While [ !Property.FSCCFileLastEntry ]
	{
		FSCCFileIdGlobalTxDirectoryInformation FileIdGlobalTxDirInfo;
	}
}

Struct FSCCFileIdGlobalTxDirectoryInformation = FormatString("%s", FileNameLength > 0 ? "FileName: " + FileName : "")
{
	[
		EntryStartOffset = FrameOffset,
		Property.FSCCFileLastEntry = this? FALSE: TRUE
	]
	UINT32 NextEntryOffset;
	UINT32 FileIndex
	FILETIME CreationTime;
	FILETIME LastAccessTime;
	FILETIME LastWriteTime;
	FILETIME ChangeTime;
	INT64 EndOfFile;
	INT64 AllocationSize;
	FSCCFileAttributes FileAttributes;
	UINT32 FileNameLength;
	INT64 FileId
	GUID(FALSE) LockingTransactionId;
	FSCCTxInfoFlags TxInfoFlags;
	[DataFieldByteOrder = LittleEndian]
	UnicodeString(FileNameLength / 2) FileName;
	Switch
	{
		Case (EntryStartOffset + NextEntryOffset) > FrameOffset:
			BLOB( EntryStartOffset + NextEntryOffset - FrameOffset) EntryPadding;
	}
}

Struct FSCCTxInfoFlags
{
	UINT32 FSCCTxInfoFlags
	{
		UINT32 Writelocked :1 = FormatString("        (%s) %s", this.ToBitString, this? "The file is locked for modification by a transaction." : "");
		UINT32 VisibleToTx :1 = FormatString("        (%s) %s", this.ToBitString, this? "The file is visible to transacted enumerators of the directory whose transaction ID is in the LockingTransactionId field." : " ");
		UINT32 VisibleOutsideTx :1 = FormatString("   (%s) %s", this.ToBitString, this? "The file is visible to transacted enumerators of the directory other than the one whose transaction ID is in the LockingTransactionId field, and it is visible to non-transacted enumerators of the directory.":"");
		UINT32 Reserved_bits3_31:29 = FormatString("   (%s) Reserved", this.ToBitString);
	}
}

[ Property.FSCCFileLastEntry = FALSE ]
Struct FSCCFileGetQuotaInformationList
{
	while [ !Property.FSCCFileLastEntry ]
	{
		FSCCFileGetQuotaInformation FileGetQuotaInfoSid;
	}
}

Struct FSCCFileGetQuotaInformation
{
	[
		EntryStartOffset = FrameOffset,
		Property.FSCCFileLastEntry = this? FALSE: TRUE
	]
	UINT32 NextEntryOffset;
	UINT32 SidLength;
	Switch
	{
		Case SidLength > 0: SID(FALSE) SID;
	}
	Switch
	{
		Case (EntryStartOffset + NextEntryOffset) > FrameOffset:
			BLOB( EntryStartOffset + NextEntryOffset - FrameOffset) EntryPadding;
	}
}

Struct FSCCFileNameInformation = FormatString("%s", FileNameLength > 0 ? "FileName: " + FileName : "")
{
	UINT32 FileNameLength;
	[DataFieldByteOrder = LittleEndian]
	UnicodeString(FileNameLength / 2) FileName;
}

Struct FSCCFileSfioReserveInformation
{
	UINT32 RequestsPerPeriod;
	UINT32 Period;
	BOOLEAN RetryFailures;
	BOOLEAN Discardable;
	UINT16 Reserved;
	UINT32 RequestSize
	UINT32 NumOutstandingRequests;
}

Struct FSCCFileStandardLinkInformation
{
	UINT32 NumberOfAccessibleLinks;
	UINT32 TotalNumberOfLinks;
	UINT8 DeletePending;
	UINT8 Directory;
	UINT16 Reserved;
}

Struct FSCCFileFsDeviceInformation
{
	UINT32 DeviceType = FSCCFileFsDeviceTypeTable( this );
	FSCCFileFSCharacteristics Characteristics
}

Struct FSCCFileFSCharacteristics
{
	UINT32 FSCCFileFSCharacteristics
	{
		UINT32 RemovableMedia:1 = FormatString("  		     (%s)", this.ToBitString );
		UINT32 ReadOnlyDevice :1 = FormatString("   		 (%s)", this.ToBitString );
		UINT32 FloppyDiskette :1 = FormatString("         	 (%s)", this.ToBitString );
		UINT32 WriteOnceMedia :1 = FormatString("            (%s)", this.ToBitString );
		UINT32 RemoteDevice :1 = FormatString("       	     (%s)", this.ToBitString );
		UINT32 DeviceIsMounted:1 = FormatString("    	     (%s)", this.ToBitString );
		UINT32 VirtualVolume:1 = FormatString("              (%s)", this.ToBitString );
		UINT32 AutogeneratedDeviceName :1 = FormatString("   (%s)", this.ToBitString );
	
		UINT32 DeviceSecureOpen:1 = FormatString("           (%s)", this.ToBitString );
		UINT32 CharacteristicsPnpDevice:1 = FormatString("   (%s)", this.ToBitString );
		UINT32 CharacteristicsTsDevice:1 = FormatString("    (%s)", this.ToBitString );
		UINT32 CharacteristicsWebDavDevice:1 = FormatString("(%s)", this.ToBitString );
		UINT32  Reserved_bits12_31: 20 = FormatString("       (%s) Reserved", this.ToBitString);
	}
}

