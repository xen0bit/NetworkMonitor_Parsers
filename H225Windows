//#  (c) 2009 CodePlex Foundation
//#
//#  Title:                  H.225 Protocol
//#
//#  Details:                Call signalling protocols and media stream packetization for
//#							 packet-based multimedia communication systems
//#
//#  OEM References:         H.323 Pack-based multimedia communications systems.pdf (ITU.org)
//#                          H.323 Amendment1.pdf (ITU.org)
//#                          H.323 Amendment2.pdf (ITU.org)
//#
//#  Comments:               
//#
//#  Revision Class and Date:Minor, 5/18/2009
//#
//####

[DataTypeBitAlign]
Protocol H225 = FormatString("H.225.0 Call Signaling: %s%s",H323MessageType, H245AddrPort ?  ( ", H.245 Address: " + H245AddrPort ) : "")
{
    H323UserInformation H323UserInfo;
}

Table H225PublicTypeOfNumberTable( value )
{
    switch( value )
    {
        case 0: "unknown";
        case 1: "internationalNumber";
        case 2: "nationalNumber";
        case 3: "networkSpecificNumber";
        case 4: "subscriberNumber";
        case 5: "abbreviatedNumber";
        default: FormatString("%d", value );
    }
}

Table H225PrivateTypeOfNumberTable( value )
{
    switch( value )
    {
        case 0: "unknown";
        case 1: "level2RegionalNumber";
        case 2: "level1RegionalNumber";
        case 3: "pISNSpecificNumber";
        case 4: "localNumber";
        case 5: "abbreviatedNumber";
        default: FormatString("%d", value);
    }
}

Table H225ServiceControlSessionReasonTable( code )
{
    switch( code )
    {
        case 0: "Open";
        case 1: "Refresh";
        case 2: "Close";                                 
    }
}

Table H225CallCreditServiceControlBillingModeTable( code )
{
    switch( code )
    {
        case 0: "Credit";
        case 1: "Debit";                                
    }
}

Table H225CallCreditServiceControlCallStartingPointTable( code )
{
    switch( code )
    {
        case 0: "Alerting";
        case 1: "Connect";                                
    }
}

Table H225T38FaxRateManagementTypeTable( value )
{
    switch( value )
    {
        case 0: "localTCF";
        case 1: "transferredTCF";
        default: "Unknown";
    }
}

Table H225T38FaxUdpOptionsTypeTable( value )
{
    switch( value )
    {
        case 0: "t38UDPFEC";
        case 1: "t38UDPRedundancy";
        default: "Unknown";
    }
}

Table H245DataProtocolCapabilityTable(ExtensionBit, Choice)
{
	switch 
	{
		case (ExtensionBit == 0) && (Choice== 0): "nonStandard";
		case (ExtensionBit == 0) && (Choice== 1): "v14buffered";
		case (ExtensionBit == 0) && (Choice== 2): "v42lapm";
		case (ExtensionBit == 0) && (Choice== 3): "hdlcFrameTunnelling";
		case (ExtensionBit == 0) && (Choice== 4): "h310SeparateVCStack";
		case (ExtensionBit == 0) && (Choice== 5): "h310SingleVCStack";
		case (ExtensionBit == 0) && (Choice== 6): "transparent";
		case (ExtensionBit == 1) && (Choice== 0): "segmentationAndReassembly";
		case (ExtensionBit == 1) && (Choice== 1): "hdlcFrameTunnelingwSAR";
		case (ExtensionBit == 1) && (Choice== 2): "v120";
		case (ExtensionBit == 1) && (Choice== 3): "separateLANStack";
		case (ExtensionBit == 1) && (Choice== 4): "v76wCompression";
		case (ExtensionBit == 1) && (Choice== 5): "tcp";
		case (ExtensionBit == 1) && (Choice== 6): "udp";

	}
}

Table H225DataProtocolCapabilityExtensionTable( capability )
{ 
    switch( capability )
    {
        case 0: "segmentationAndReassembly";
        case 1: "hdlcFrameTunnelingwSAR";   
        case 2: "v120";                     
        case 3: "separateLANStack";         
        case 4: "v76wCompression";          
        case 5: "tcp";                      
        case 6: "udp";                      
        default: FormatString("%d(0x%X)",capability,capability);
    } 
}

Table SecurityServiceModeTable( mode )
{
    switch( mode )
    {
        case 0: "nonStandard";
        case 1: "none";
        case 2: "default";
    }
}

Table T35CountryCodeTable( code )
{
    switch( code )
    {
        case 0x00: "Japan";                           
        case 0x01: "Albania";                         
        case 0x02: "Algeria";                         
        case 0x03: "American Samoa";                  
        case 0x04: "Germany";                         
        case 0x05: "Anguilla";                        
        case 0x06: "Antigua and Barbuda";             
        case 0x07: "Argentina";                       
        case 0x08: "Ascension (see S. Helena)";       
        case 0x09: "Australia";                       
        case 0x0a: "Austria";                         
        case 0x0b: "Bahamas";                         
        case 0x0c: "Bahrain";                         
        case 0x0d: "Bangladesh";                      
        case 0x0e: "Barbados";                        
        case 0x0f: "Belgium";                         
        case 0x10: "Belize";                          
        case 0x11: "Benin";                           
        case 0x12: "Bermuda";                         
        case 0x13: "Bhutan";                          
        case 0x14: "Bolivia";                         
        case 0x15: "Botswana";                        
        case 0x16: "Brazil";                          
        case 0x17: "British Antarctic Territory";     
        case 0x18: "British Indian Ocean Territory";  
        case 0x19: "British Virgin Islands";          
        case 0x1a: "Brunei Darussalam";               
        case 0x1b: "Bulgaria";                        
        case 0x1c: "Myanmar";                         
        case 0x1d: "Burundi";                         
        case 0x1e: "Belarus";                         
        case 0x1f: "Cameroon";                        
        case 0x20: "Canada";                          
        case 0x21: "Cape Verde";                      
        case 0x22: "Cayman Islands";                  
        case 0x23: "Central African Rep.";            
        case 0x24: "Chad";                            
        case 0x25: "Chile";                           
        case 0x26: "China";                           
        case 0x27: "Colombia";                        
        case 0x28: "Comoros";                         
        case 0x29: "Congo";                           
        case 0x2a: "Cook Islands";                    
        case 0x2b: "Costa Rica";                      
        case 0x2c: "Cuba";                            
        case 0x2d: "Cyprus";                          
        case 0x2e: "Czech Rep.";                      
        case 0x2f: "Cambodia";                        
        case 0x30: "Dem. People's Rep. of Korea";     
        case 0x31: "Denmark";                         
        case 0x32: "Djibouti";                        
        case 0x33: "Dominican Rep.";                  
        case 0x34: "Dominica";                        
        case 0x35: "Ecuador";                         
        case 0x36: "Egypt";                           
        case 0x37: "El Salvador";                     
        case 0x38: "Equatorial Guinea";               
        case 0x39: "Ethiopia";                        
        case 0x3a: "Falkland Islands (Islas Malvinas)";     
        case 0x3b: "Fiji";                            
        case 0x3c: "Finland";                         
        case 0x3d: "France";                          
        case 0x3e: "French Polynesia";                
        /* 0x3f: "(Available)"; */               
        case 0x40: "Gabon";                           
        case 0x41: "Gambia";                          
        case 0x42: "Germany";                         
        case 0x43: "Angola";                          
        case 0x44: "Ghana";                           
        case 0x45: "Gibraltar";                       
        case 0x46: "Greece";                          
        case 0x47: "Grenada";                         
        case 0x48: "Guam";                            
        case 0x49: "Guatemala";                       
        case 0x4a: "Guernsey";                        
        case 0x4b: "Guinea";                          
        case 0x4c: "Guinea-Bissau";                   
        case 0x4d: "Guayana";                         
        case 0x4e: "Haiti";                           
        case 0x4f: "Honduras";                        
        case 0x50: "Hong Kong, China";                
        case 0x51: "Hungary";                         
        case 0x52: "Iceland";                         
        case 0x53: "India";                           
        case 0x54: "Indonesia";                       
        case 0x55: "Iran (Islamic Republic of)";      
        case 0x56: "Iraq";                            
        case 0x57: "Ireland";                         
        case 0x58: "Israel";                          
        case 0x59: "Italy";                           
        case 0x5a: "C?te d'Ivoire";                   
        case 0x5b: "Jamaica";                         
        case 0x5c: "Afghanistan";                     
        case 0x5d: "Jersey";                          
        case 0x5e: "Jordan";                          
        case 0x5f: "Kenya";                           
        case 0x60: "Kiribati";                        
        case 0x61: "Korea (Rep. of)";                 
        case 0x62: "Kuwait";                          
        case 0x63: "Lao P.D.R.";                      
        case 0x64: "Lebanon";                         
        case 0x65: "Lesotho";                         
        case 0x66: "Liberia";                         
        case 0x67: "Libya";                           
        case 0x68: "Liechtenstein";                   
        case 0x69: "Luxembourg";                      
        case 0x6a: "Macao Special Administrative Region, China";                    
        case 0x6b: "Madagascar";                      
        case 0x6c: "Malaysia";                        
        case 0x6d: "Malawi";                          
        case 0x6e: "Maldives";                        
        case 0x6f: "Mali";                            
        case 0x70: "Malta";                           
        case 0x71: "Mauritania";                      
        case 0x72: "Mauritius";                       
        case 0x73: "Mexico";                          
        case 0x74: "Monaco";                          
        case 0x75: "Mongolia";                        
        case 0x76: "Montserrat";                      
        case 0x77: "Morocco";                         
        case 0x78: "Mozambique";                      
        case 0x79: "Nauru";                           
        case 0x7a: "Nepal";                           
        case 0x7b: "Netherlands";                     
        case 0x7c: "Netherlands Antilles";            
        case 0x7d: "New Caledonia";                   
        case 0x7e: "New Zealand";                     
        case 0x7f: "Nicaragua";                       
        case 0x80: "Niger";                           
        case 0x81: "Nigeria";                         
        case 0x82: "Norway";                          
        case 0x83: "Oman";                            
        case 0x84: "Pakistan";                        
        case 0x85: "Panama";                          
        case 0x86: "Papua New Guinea";                
        case 0x87: "Paraguay";                        
        case 0x88: "Peru";                            
        case 0x89: "Philippines";                     
        case 0x8a: "Poland";                          
        case 0x8b: "Portugal";                        
        case 0x8c: "Commonwealth of Puerto Rico";                     
        case 0x8d: "Qatar";                           
        case 0x8e: "Romania";                         
        case 0x8f: "Rwanda";                          
        case 0x90: "Saint Kitts and Nevis";           
        case 0x91: "Saint Croix";                     
        case 0x92: "Saint Helena and Ascension";      
        case 0x93: "Saint Lucia";                     
        case 0x94: "San Marino";                      
        case 0x95: "Saint Thomas";                    
        case 0x96: "Sao Tome and Principe";           
        case 0x97: "Saint Vincent and the Grenadines";
        case 0x98: "Saudi Arabia";                    
        case 0x99: "Senegal";                         
        case 0x9a: "Seychelles";                      
        case 0x9b: "Sierra Leone";                    
        case 0x9c: "Singapore";                       
        case 0x9d: "Solomon";                         
        case 0x9e: "Somalia";                         
        case 0x9f: "South Africa";                    
        case 0xa0: "Spain";                           
        case 0xa1: "Sri Lanka";                       
        case 0xa2: "Sudan";                           
        case 0xa3: "Suriname";                        
        case 0xa4: "Swaziland";                       
        case 0xa5: "Sweden";                          
        case 0xa6: "Switzerland";                     
        case 0xa7: "Syria";                           
        case 0xa8: "Tanzania";                        
        case 0xa9: "Thailand";                        
        case 0xaa: "Togo";                            
        case 0xab: "Tonga";                           
        case 0xac: "Trinidad and Tobago";             
        case 0xad: "Tunisia";                         
        case 0xae: "Turkey";                          
        case 0xaf: "Turks and Caicos Islands";        
        case 0xb0: "Tuvalu";                          
        case 0xb1: "Uganda";                          
        case 0xb2: "Ukraine";                         
        case 0xb3: "United Arab Emirates";            
        case 0xb4: "United Kingdom";                  
        case 0xb5: "United States";                   
        case 0xb6: "Burkina Faso";                    
        case 0xb7: "Uruguay";                         
        case 0xb8: "Russia";                          
        case 0xb9: "Vanuatu";                         
        case 0xba: "Vatican";                         
        case 0xbb: "Venezuela";                       
        case 0xbc: "Viet Nam";                        
        case 0xbd: "Wallis and Futuna";               
        case 0xbe: "Independent State of Samoa";                           
        case 0xbf: "Yemen";                           
        case 0xc0: "Yemen";                           
        case 0xc1: "Serbia";                      
        case 0xc2: "Congo (DRC)";          
        case 0xc3: "Zambia";                          
        case 0xc4: "Zimbabwe";                        
        case 0xc5: "Slovakia";                        
        case 0xc6: "Slovenia";  
    }                      
}

Table H221ManufacturerCodeTable( code )
{
    switch( code )
    {
        case 0x04000042: "Deutsche Telekom AG";                                   
        case 0x04000043: "Deutsche Telekom AG";                                   
        case 0x04000082: "Siemens AG";                                            
        case 0x04000084: "ITO Communication";                                     
        case 0x04000086: "Hauni Elektronik";                                      
        case 0x04000088: "Dr.Neuhaus Mikroelektronik";                            
        case 0x0400008a: "mps Software";                                          
        case 0x0400008b: "Ferrari electronik GmbH";                               
        case 0x0400008c: "mbp Kommunikationssysteme GmbH";                        
        case 0x0400008d: "Schneider Rundfunkwerke AG";                            
        case 0x0400008e: "Digitronic computersysteme gmbh";                       
        case 0x0400008f: "DeTeWe - Deutsche Telephonwerke AG &Co";                
        //case 0x04000082: "SITK Institut fur Telekommunikation GmbH & Co KG";     
        case 0x0900003D: "Equivalence (OpenH323)";                                
        case 0x20000081: "Mediatrix Telecom";                                     
        case 0x3d000310: "Swissvoice";                                            
        case 0x3d000311: "Swissvoice";                                            
        case 0x3d000312: "Swissvoice";                                            
        case 0x3d000313: "Swissvoice";                                            
        case 0x3d000314: "Swissvoice";                                            
        case 0x3d000315: "Swissvoice";                                            
        case 0x3d000316: "Swissvoice";                                            
        case 0x3d000317: "Swissvoice";                                            
        case 0x3d000318: "Swissvoice";                                            
        case 0x3d000319: "Swissvoice";                                            
        case 0x3d00031a: "Swissvoice";                                            
        case 0x3d00031b: "Swissvoice";                                            
        case 0x3d00031c: "Swissvoice";                                            
        case 0x3d00031d: "Swissvoice";                                            
        case 0x3d00031e: "Swissvoice";                                            
        case 0x3d00031f: "Swissvoice";                                            
        case 0x82000002: "Ericsson";                                              
        case 0xa5000001: "Ericsson";                                              
        case 0xb4000000: "British Telecommunications";                            
        case 0xb4000100: "British Telecommunications";                            
        case 0xb4000200: "British Telecommunications";                            
        case 0xb4000300: "British Telecommunications";                            
        case 0xb4000400: "British Telecommunications";                            
        case 0xb4000500: "British Telecommunications";                            
        case 0xb4000600: "British Telecommunications";                            
        case 0xb4000700: "British Telecommunications";                            
        case 0xb4000800: "British Telecommunications";                            
        case 0xb4000900: "British Telecommunications";                            
        case 0xb4000a00: "British Telecommunications";                            
        case 0xb4000b00: "British Telecommunications";                            
        case 0xb4000c00: "British Telecommunications";                            
        case 0xb4000d00: "British Telecommunications";                            
        case 0xb4000e00: "British Telecommunications";                            
        case 0xb4000f00: "British Telecommunications";                            
        case 0xb4001000: "GPT Video Systems";                                     
        case 0xb4001100: "GPT Video Systems";                                     
        case 0xb4001200: "GPT Video Systems";                                     
        case 0xb4001300: "GPT Video Systems";                                     
        case 0xb4001400: "GPT Video Systems";                                     
        case 0xb4001500: "GPT Video Systems";                                     
        case 0xb4001600: "GPT Video Systems";                                     
        case 0xb4001700: "GPT Video Systems";                                     
        case 0xb4001800: "GPT Video Systems";                                     
        case 0xb4001900: "GPT Video Systems";                                     
        case 0xb4001a00: "GPT Video Systems";                                     
        case 0xb4001b00: "GPT Video Systems";                                     
        case 0xb4001c00: "GPT Video Systems";                                     
        case 0xb4001d00: "GPT Video Systems";                                     
        case 0xb4001e00: "GPT Video Systems";                                     
        case 0xb4001f00: "GPT Video Systems";                                     
        case 0xb4002000: "Marconi Communications";                                
        case 0xb4002100: "Indigo Active Vision Systems";                          
        case 0xb4002200: "LiveWorks Limited";                                     
        case 0xb4002300: "ATL Telecom Limited";                                   
        case 0xb4002a00: "Network Alchemy Limited";                               
        case 0xb4004200: "Motion Media Technology";                               
        case 0xb4004400: "Data Connection";                                       
        case 0xb4004500: "Westbay Engineers";                                     
        case 0xb4004600: "FarSite Communications";                                
        case 0xb4004900: "ImageCom";                                              
        case 0xb4004d00: "Madge Networks";                                        
        case 0xb4005200: "Ridgeway Systems and Software";                         
        case 0xb4005300: "SpliceCom";                                             
        case 0xb4005400: "TeleWare";                                              
        case 0xb4005600: "Vegastream";                                            
        case 0xb4006600: "Westell";                                               
        case 0xb4006900: "ISDN Communications";                                   
        case 0xb400c000: "Codian";                                                
        case 0xb5000000: "Compression Labs";                                      
        case 0xb5000001: "PictureTel";                                            
        case 0xb5000002: "Compression Labs";                                      
        case 0xb5000003: "VTEL";                                                  
        case 0xb5000005: "ERIS";                                                  
        case 0xb5000007: "AT&T Worldworx";                                        
        case 0xb5000009: "VideoServer";                                           
        case 0xb500000b: "3Com Corporation";                                      
        case 0xb500000c: "Clarent Corporation";                                   
        case 0xb500000d: "Genesys Telecommunications Labs Inc";                   
        case 0xb500000e: "C-Phone Corporation.";                                  
        case 0xb500000f: "Science Dynamics Corporation";                          
        case 0xb5000010: "AT&T Starpoint";                                        
        case 0xb5000011: "Netscape Conference";                                   
        case 0xb5000012: "Cisco";                                                 
        case 0xb5000013: "Cirilium, Inc.";                                        
        case 0xb5000014: "Ascend Communications, Inc.";                           
        case 0xb5000015: "RADVision, Inc.";                                       
        case 0xb5000016: "Objective Communications";                              
        case 0xb5000017: "VocalTec Communications, Inc.";                         
        case 0xb5000018: "Serome Technology, Inc.";                               
        case 0xb5000019: "Aspect Communications";                                 
        case 0xb500001a: "Cintech Tele-Management";                               
        case 0xb500001b: "Philips Video Conferencing Systems";                    
        case 0xb500001c: "Vertical Networks, Inc.";                               
        case 0xb500001d: "Syndeo Corp.";                                          
        case 0xb500001e: "Telxon Corporation";                                    
        case 0xb500001f: "Network Equipment Technologies";                        
        case 0xb5000020: "Pagoo, Inc.";                                           
        case 0xb5000021: "General Dynamics";                                      
        case 0xb5000022: "Vanguard Managed Solutions";                            
        case 0xb5000023: "TeleStream Technologies, Inc.";                         
        case 0xb5000024: "Spirent Communications";                                
        case 0xb5000025: "CrystalVoice Communications";                           
        case 0xb5000026: "Xiph.org";                                              
        case 0xb5000027: "NACT Telecommunications";                               
        case 0xb5000028: "AudioCodes, Inc.";                                      
        case 0xb5000120: "AT&T - GBCS";                                           
        case 0xb5000168: "Leadtek Research Inc.";                                 
        case 0xb5000247: "Lucent Technologies";                                   
        case 0xb500029a: "Symbol Technologies Inc.";                              
        case 0xb5000378: "StarVox, Inc.";                                         
        case 0xb50003f7: "Inari Inc.";                                            
        case 0xb5000727: "Quintum Technologies, Inc.";                            
        case 0xb5000918: "Netrix Corporation";                                    
        case 0xb500101e: "SysMaster Corporation";                                 
        case 0xb5001a1a: "Alpha Telecom, Inc. U.S.A.";                            
        case 0xb5002331: "ViaVideo";                                              
        case 0xb500301c: "Congruency, Inc.";                                      
        case 0xb5003039: "MiBridge Inc.";                                         
        case 0xb5003838: "8x8 Inc.";                                              
        case 0xb5004147: "Agere Systems";                                         
        case 0xb5004153: "Artisoft Inc.";                                         
        case 0xb5004156: "Avaya";                                                 
        case 0xb5004242: "IBM.";                                                  
        case 0xb5004257: "StreamComm";                                            
        case 0xb5004c54: "Lucent Technologies";                                   
        case 0xb5004d47: "MediaGate";                                             
        case 0xb5004e54: "Nortel Networks";                                       
        case 0xb5005243: "Siemens Business Communication Systems";                
        case 0xb500534c: "Microsoft";                                             
        case 0xb500600d: "Lucent Technologies";                                   
        case 0xb5008080: "Intel";
        default: "";                                               
    }                                            
}

Table H225ScnConnectionTypeTable( type )
{
    switch( type )
    {
        case 0: "unknown";   
        case 1: "bChannel -- each individual connection on the SCN is 64kbps.";  
        case 2: "hybrid2x64 -- each connection is a 128kbps hybrid call";
        case 3: "hybrid384 -- each connection is an H0 (384kbps) hybrid call"; 
        case 4: "hybrid1536 -- each connection is an H11 (1536kbps) hybrid call";
        case 5: "hybrid1920 -- each connection is an H12 (1920kbps) hybrid call";
        case 6: "multirate -- bandwidth supplied by SCN using multirate.";
        default: FormatString("%d(0x%X)",type,type); 
    }
}

Table H225ScnConnectionAggregationTable( code )
{
    switch( code )
    {
        case 0: "Auto -- aggregation mechanism is unknown";
        case 1: "None -- call produced using a single SCN connection";   
        case 2: "H221 -- use H.221 framing to aggregate the connections";
        case 3: "Bonded Mode1 -- use ISO/IEC 13871 bonding mode 1";
        case 4: "Bonded Mode2 -- use ISO/IEC 13871 bonding mode 2"; 
        case 5: "Bonded Mode3 -- use ISO/IEC 13871 bonding mode 3";                                      
    }
}

Table H225PresentationIndicatorTable( code )
{
    switch( code )
    {
        case 0: "Presentation Allowed";                                   
        case 1: "Presentation Restricted";                                   
        case 2: "Address Not Available";                                             
    }
}

Table H225ScreeningIndicatorTable( value )
{
    switch( value )
    {
        case 0: "userProvidedNotScreened -- number was provided by a remote user and has not been screened by a gatekeeper";      
        case 1: "userProvidedVerifiedAndPassed -- number was provided by user equipment (or by a remote network), and has been screened by a gatekeeper";   
        case 2: "userProvidedVerifiedAndFailed -- number was provided by user equipment (or by a remote network), and the gatekeeper has determined that the information is incorrect";   
        case 3: "networkProvided -- number was provided by a gatekeeper";                 
        default: FormatString("%d(0x%X)",value,value);  
    }
}

Table H245SecurityTypeTable( type )
{
    switch( type )
    {
        case 0: "nonStandard";
        case 1: "noSecurity"; 
        case 2: "tls";        
        case 3: "ipsec"; 
        default: FormatString("%d(0x%X)",type,type);         
    }
}

Table H225FacilityReasonTypeExtensionTable( type )
{
    switch( type )
    {
        case 0: "conferenceListChoice";   
        case 1: "startH245 -- recipient should connect to h245Address";              
        case 2: "noH245 -- endpoint does not support H.245";                 
        case 3: "newTokens";             
        case 4: "featureSetUpdate";      
        case 5: "forwardedElements";     
        case 6: "transportedInformation";
        default: FormatString("%d(0x%X)",type,type);
    }
}

Table H225FacilityReasonTypeTable( type )
{
    switch( type )
    {
        case 0: "routeCallToGatekeeper -- call must use gatekeeper model, gatekeeper is alternativeAddress";
	      case 1: "callForwarded";
	      case 2: "routeCallToMC";
	      case 3: "undefinedReason"; 
	      default: FormatString("%d(0x%X)",type,type);
    }
}

Table H225ReleaseCompleteReasonExtensionTable( reason )
{
    switch( reason )
    {
        case 0 : "call was deflected using a Facility message";     
        case 1 : "incompatible security settings";             
        case 2 : "used by gatekeeper when endpoint has preGrantedARQ to bypass ARQ/ACF";   
        case 3 : "used by gatekeeper when endpoint has preGrantedARQ to bypass ARQ/ACF";        
        case 4 : "indicates that the Setup was not accepted on this connection, but that the Setup may be accepted on a new connection";        
        case 5 : "nonStandardReason";          
        case 6 : "call dropped due to subsequent invitation to a conference";
        case 7 : "genericDataReason";          
        case 8 : "neededFeatureNotSupported";  
        case 9 : "tunnelledSignallingRejected";
        case 10: "invalidCID";
        case 11: "securityError";
        case 12: "hopCountExceeded";
        default: FormatString("%d(0x%X)",reason,reason);                 
    }   
}

Table H225ReleaseCompleteReasonTable( reason )
{
    switch( reason )
    {
        case 0 : "bandwidth taken away or ARQ denied";
	      case 1 : "gate keeper Resources exhausted";
	      case 2 : "unreachable Destination";
	      case 3 : "destination Rejection";
	      case 4 : "invalid Revision";
	      case 5 : "no Permission: called party's gatekeeper rejects";
	      case 6 : "terminal cannot reach gatekeeper for ARQ";
	      case 7 : "gatewayResources";
	      case 8 : "badFormatAddress";
	      case 9 : "call is dropping due to LAN crowding";
	      case 10: "called party busy";
	      case 11: "undefinedReason";
	      default: FormatString("%d(0x%X)",reason,reason);
    }
}

Table H225ConferenceGoalTable( value )
{
    switch( value )
    {
        case 0 : "create";
	      case 1 : "join";
	      case 2 : "invite";
	      default: FormatString("%d(0x%X)",value,value);
    }
}

Table H225ConferenceGoalExtensionTable( value )
{
    switch( value )
    {
        case 0 : "capability-negotiation";
	      case 1 : "callIndependentSupplementaryService";
	      default: FormatString("%d(0x%X)",value,value);
    }
}

Table H225TransportAddressTypeTable( type )
{
    switch( type )
    {
        case 0: "ipAddress";          
        case 1: "ipSourceRoute";         
        case 2: "ipxAddress";            
        case 3: "ip6Address";            
        case 4: "netBios";               
        case 5: "nsap";                  
        case 6: "nonStandardAddress"; 
        default: FormatString("%d(0x%X)",type,type);     
    }
}

Table H323UUIEMessageTypeTable( type )
{
    switch( type )
    {
        case 0: "Setup";
        case 1: "CallProceeding";
        case 2: "Connect";
        case 3: "Alerting";
        case 4: "Information";
        case 5: "ReleaseComplete";
        case 6: "Facility";
        default: FormatString("Unknown message type(%d)", type);
    }
}

Table H323UUIEExtensionMessageTypeTable( type )
{
    switch( type )
    {
        case 0: "Progress";
        case 1: "Empty -- used when a Facility message is sent but the Facility-UUIE is not to be invoked";
        case 2: "Status";
        case 3: "Status Inquiry";
        case 4: "Setup Acknowledge";
        case 5: "Notify";
        default: FormatString("Unknown message type(%d)", type);
    }
}

Table H225CallTypeTable( type )
{
    switch( type )
    {
        case 0: "point To Point";  
        case 1: "oneToN -- no interaction (FFS)";  
        case 2: "nToOne -- no interaction (FFS)";  
        case 3: "nToN -- interactive (multipoint)"; 
        default: FormatString("%d(0x%X)",type,type);
    }
} 

Table H225SecurityErrorsTable( error)
{
    switch( error )
    {
        case 0 : "securityWrongSyncTime -- either time server problem or network delay";     
        case 1 : "securityReplay -- replay attack encountered";                              
        case 2 : "securityWrongGeneralID";                                                   
        case 3 : "securityWrongSendersID";                                                   
        case 4 : "securityIntegrityFailed -- integrity check failed";                        
        case 5 : "securityWrongOID -- wrong token OIDs or crypto alg OIDs";                  
        case 6 : "securityDHmismatch -- mismatch of DH parameters";                          
        case 7 : "securityCertificateExpired -- certificate has expired";                    
        case 8 : "securityCertificateDateInvalid -- certificate is not yet valid";           
        case 9 : "securityCertificateRevoked -- certificate was found revoked";              
        case 10: "securityCertificateNotReadable -- decoding error";                         
        case 11: "securityCertificateSignatureInvalid -- wrong signature in the certificate";
        case 12: "securityCertificateMissing -- no certificate available";                   
        case 13: "securityCertificateIncomplete -- missing expected certificate extensions"; 
        case 14: "securityUnsupportedCertificateAlgOID -- crypto algs not understood";       
        case 15: "securityUnknownCA -- CA/root certificate could not be found";
        default: FormatString("%d(0x%X)",error,error);              
    }
}

[DataTypeBitAlign]
struct EndPoint    // SEQUENCE   
{
    UINT8 EndpointExtension:1;
    
    UINT8	nonStandardDataPresent:1; 			       
    UINT8	aliasAddressPresent:1; 			         
    UINT8	callSignalAddressPresent:1; 		       
    UINT8	rasAddressPresent:1; 			           
    UINT8	endpointTypePresent:1; 		           
    UINT8	tokensPresent:1; 				             
    UINT8	cryptoTokensPresent:1; 			         
    UINT8	priorityPresent:1; 			             
    UINT8	remoteExtensionAddressPresent:1; 		 
    UINT8	destExtraCallInfoPresent:1; 		    
       
    switch
    {
        case nonStandardDataPresent:
             NonStandardParameter nonStandardData;
    } 			       
    switch
    {
        case aliasAddressPresent:
             struct AliasAddress
             {
                 [ post.AliasAddressSize = PERLengthValue ]
                 AsnPerLengthDeterminant size;
                 while [ AliasAddressSize > 0 ]
                 {
                     [ AliasAddressSize = AliasAddressSize - 1 ]
                     AliasAddress aliasAddress; 
                 }
             }
    } 			         
    switch
    {
        case callSignalAddressPresent:
             struct CallSignalAddress
             {
                 [ post.CallSignalAddressSize = PERLengthValue ]
                 AsnPerLengthDeterminant size;
                 while [ CallSignalAddressSize > 0 ]
                 {
                     [ CallSignalAddressSize = CallSignalAddressSize  - 1 ]
                     TransportAddress callSignalAddress; 
                 }
             }
    } 		       
    switch
    {
        case rasAddressPresent:
             struct RasAddress
             {
                 [ post.rasAddressSize = PERLengthValue ]
                 AsnPerLengthDeterminant size;
                 while [ rasAddressSize > 0 ]
                 {
                     [ rasAddressSize = rasAddressSize - 1 ]
                     TransportAddress rasAddress; 
                 }
             }
    } 			           
    switch
    {
        case endpointTypePresent:
             EndpointType endpointType ;
    } 		           
    switch
    {
        case tokensPresent:
        struct SequenceOfClearToken
        {
            [post.ClearTokenSize = PERLengthValue]
            AsnPerLengthDeterminant Size;
            while [ ClearTokenSize > 0 ]
            {
                [ ClearTokenSize = ClearTokenSize - 1 ]
                H235ClearToken tokens;
            }
        }
    } 				             
    switch
    {
        case cryptoTokensPresent:
        struct SequenceOfCryptoTokens
        {
            [post.CryptoH323TokenSize = PERLengthValue]
            AsnPerLengthDeterminant Size;
            while [ CryptoH323TokenSize > 0 ]
            {
                [ CryptoH323TokenSize = CryptoH323TokenSize - 1 ]
                H235CryptoH323Token  cryptoTokens;
            }
        }
    } 			         
    switch
    {
        case priorityPresent:
             AsnPerConstrainedInteger(0, 127) priority;
    } 			             
    switch
    {
        case remoteExtensionAddressPresent:
             struct RemoteExtensionAddress
             {
                 [post.RemoteExtensionAddressSize = PERLengthValue]
                 AsnPerLengthDeterminant size;
                 while [ RemoteExtensionAddressSize > 0 ]
                 {
                     [ RemoteExtensionAddressSize = RemoteExtensionAddressSize - 1 ]
                     AliasAddress remoteExtensionAddress;
                 }
             }
    } 		 
    switch
    {
        case destExtraCallInfoPresent:
             struct DestExtraCallInfomation
             {
                 [post.DestExtraCallInfoSize = PERLengthValue]
                 AsnPerLengthDeterminant Size;
                 while [ DestExtraCallInfoSize > 0 ]
                 {
                     [ DestExtraCallInfoSize = DestExtraCallInfoSize - 1 ]
                     AliasAddress destExtraCallInfo;
                 }
             }
    } 		  
    
    switch
    {
        case EndpointExtension: // verify is there any extension fields
             struct EndpointExtension
             {
             	   AsnPerNormallySmallNonnegativeWholeNumber ExtensionNumber; // extension field count
             	   UINT8 alternateTransportAddressesPresent:1; // has an option extension field
             	   switch
             	   {
             	       case alternateTransportAddressesPresent: // get the field
             	            struct AlternateTransportAddresses
             	            {
             	            	  AsnPerLengthDeterminant length;
             	            	  [AlternateTransportAddressesEndOffset = FrameOffset + PERLengthValue]
             	    	          AlternateTransportAddresses  alternateTransportAddresses;
             	    	          switch
                              {
                                  case FrameBitOffset < AlternateTransportAddressesEndOffset * 8: 
                                       AsnPerPadding(AlternateTransportAddressesEndOffset * 8 - FrameBitOffset) Padding;
                              }
             	    	      }
             	   }
            }
    }
    
}

[DataTypeBitAlign]
struct H235NonStandardParameter
{
    AsnPerObjectIdentifier nonStandardIdentifier;
    AsnPerOctetString(-1,-1) data;
}

[DataTypeBitAlign]
struct ICV
{
    AsnPerObjectIdentifier algorithmOID;
    AsnPerBitString(-1,-1) icv;
}

[DataTypeBitAlign]
struct H225NonStandardMessage
{
    UINT8 NonStandardMessageExtensionBit:1;
    AsnPerConstrainedInteger(1,65535) requestSeqNum;
    NonStandardParameter nonStandardData;
    switch
    {
        case NonStandardMessageExtensionBit:
        struct NonStandardMessageExtension
        {
            AsnPerNormallySmallNonnegativeWholeNumber ExtensionNumber;
            UINT8 tokensPresent:1;
            switch
            {
                case PERSmallNumber >= 1: UINT8 cryptoTokensPresent:1;
            }
            switch
            {
                case PERSmallNumber >= 2: UINT8 integrityCheckValuePresent:1;
            }
            switch
            {
                case PERSmallNumber >= 3: UINT8 featureSetPresent:1;
            }
            switch
            {
                case PERSmallNumber >= 4: UINT8 genericDataPresent:1;
            }
            
            switch
            {
                case tokensPresent:
                struct tokens
                {
                    AsnPerLengthDeterminant Length;
                    [NonStandardMessageTokensEndOffset = FrameOffset + PERLengthValue, post.NonStandardMessageTokenSize = PERLengthValue]
                    AsnPerLengthDeterminant Size;
                    while [ NonStandardMessageTokenSize > 0 ]
                    {
                        [NonStandardMessageTokenSize = NonStandardMessageTokenSize - 1]
                        H235ClearToken token;
                    }
                    switch
                    {
                        case FrameBitOffset < NonStandardMessageTokensEndOffset * 8: 
                        AsnPerPadding( NonStandardMessageTokensEndOffset * 8 - FrameBitOffset ) Padding;
                    }
                };
            }
            
            switch
            {
                case cryptoTokensPresent:
                struct cryptoTokens
                {
                    AsnPerLengthDeterminant Length;
                    [NonStandardMessagecryptoTokensEndOffset = FrameOffset + PERLengthValue, post.NonStandardMessagecryptoTokenSize = PERLengthValue]
                    AsnPerLengthDeterminant Size;
                    while [ NonStandardMessagecryptoTokenSize > 0 ]
                    {
                        [NonStandardMessagecryptoTokenSize = NonStandardMessagecryptoTokenSize - 1]
                        H235CryptoH323Token cryptoToken;
                    }
                    switch
                    {
                        case FrameBitOffset < NonStandardMessagecryptoTokensEndOffset * 8: 
                        AsnPerPadding( NonStandardMessagecryptoTokensEndOffset * 8 - FrameBitOffset ) Padding;
                    }
                };
            }
            
            switch
            {
               case integrityCheckValuePresent:
               struct integrityCheckValue
               {
                   AsnPerLengthDeterminant Length;
                   [NonStandardMessageICVEndOffset = FrameOffset + PERLengthValue]
                   ICV integrityCheckValue;
                   switch
                   {
                       case FrameBitOffset < NonStandardMessageICVEndOffset * 8:
                       AsnPerPadding( NonStandardMessageICVEndOffset * 8 - FrameBitOffset ) Padding;
                   }
               };
            }
            
            switch
            {
                case featureSetPresent:
                struct featureSet
                {
                   AsnPerLengthDeterminant Length;
                   [NonStandardMessageFeatureSetEndOffset = FrameOffset + PERLengthValue]
                   FeatureSet featureSet;
                   switch
                   {
                       case FrameBitOffset < NonStandardMessageFeatureSetEndOffset * 8:
                       AsnPerPadding( NonStandardMessageFeatureSetEndOffset * 8 - FrameBitOffset ) Padding;
                   }
                };
            }
            
            switch
            {
                case genericDataPresent:
                struct GenericData
                {
                    AsnPerLengthDeterminant Length;
                    [NonStandardMessageGenericDataEndOffset = FrameOffset + PERLengthValue, post.NonStandardMessageGenericDataSize = PERLengthValue]
                    AsnPerLengthDeterminant Size;
                    while [ NonStandardMessageGenericDataSize > 0 ]
                    {
                        [NonStandardMessageGenericDataSize = NonStandardMessageGenericDataSize - 1]
                        GenericData genericData;
                    }
                    switch
                    {
                        case FrameBitOffset < NonStandardMessageGenericDataEndOffset * 8: 
                        AsnPerPadding( NonStandardMessageGenericDataEndOffset * 8 - FrameBitOffset ) Padding;
                    }
                };
            }
        };
    }
}

[DataTypeBitAlign]
struct ServiceControlSessionReason=ServiceControlSessionReasonValue// CHOICE  
{
	  UINT8 ServiceControlSessionReasonExtension:1;
    switch
    {
        case ServiceControlSessionReasonExtension:
            _struct ExtensionChoice
            {
                // TODO Here when extension...
            };
        default:
            _struct NoneExtension
            {
        	      [post.ServiceControlSessionReasonValue=this.tostring]
        	      AsnPerConstrainedInteger(0, 2) ChoiceValue = H225ServiceControlSessionReasonTable( ConstrainedValue );
            };
    }
}

[DataTypeBitAlign]
struct H235CryptoToken
{
    UINT8 CryptoTokenExtension:1;
    switch
    {
        //case CryptoToken_Extension:
        default:
        _struct NoneExtension
        {
            AsnPerConstrainedInteger(0,3) ChoiceValue;
            switch( ConstrainedValue )
            {
                case 0: struct cryptoEncryptedToken
                        {
                            AsnPerObjectIdentifier tokenOID;
                            H235Encrypted token;
                        };
                case 1: struct cryptoSignedToken
                        {
                            AsnPerObjectIdentifier tokenOID;
                            H235Signed token;
                        };
                case 2: struct cryptoHashedToken
                        {
                            AsnPerObjectIdentifier tokenOID;
                            H235ClearToken hashedVals;
                            H235Hashed token;
                        };
                case 3: H235Encrypted cryptoPwdEncr;
            }
        };
    }
}

[DataTypeBitAlign]
struct H235TypedCertificate  // SEQUENCE 
{
	  UINT8 H235TypedCertificateExtension:1;
	 
    AsnPerObjectIdentifier type;
    AsnPerOctetString( -1, -1) certificate;
    // Meybe some extension fields here...
}

[DataTypeBitAlign]
struct H235DHset(minValue, maxValue) // SEQUENCE 
{
	  UINT8 H235DHsetExtension:1;
	 
    AsnPerBitString(minValue, maxValue) halfkey;
    AsnPerBitString(minValue, maxValue) modSize;
    AsnPerBitString(minValue, maxValue) generator;
    // Meybe some extension fields here...
}

[DataTypeBitAlign]
struct T38FaxRateManagement
{
    UINT8 T38FaxRateManagementExtension:1;
    AsnPerConstrainedInteger(0,1) ChoiceValue=H225T38FaxRateManagementTypeTable( ConstrainedValue );
}

[DataTypeBitAlign]
struct T38FaxUdpOptions
{
    UINT8 t38FaxMaxBufferPresent:1;
    UINT8 t38FaxMaxDatagramPresent:1;
    switch
    {
        case t38FaxMaxBufferPresent:
        AsnPerInteger t38FaxMaxBuffer;
    }
    switch
    {
        case t38FaxMaxDatagramPresent:
        AsnPerInteger t38FaxMaxDatagram;
    }
    struct t38FaxUdpEC
    {
        UINT8 T38FaxProfileExtension:1;
        AsnPerConstrainedInteger(0,1) ChoiceValue=H225T38FaxUdpOptionsTypeTable( ConstrainedValue );
    }
}

[DataTypeBitAlign]
struct T38FaxTcpOptions
{
    UINT8 T38FaxProfileExtension:1;
    AsnPerBoolean(0) t38TCPBidirectionalMode;
}

[DataTypeBitAlign]
struct H225ECpoint(minValue, maxValue) // SEQUENCE 
{
    UINT8 ECpointExtension:1;
    
    UINT8 xPresent:1;
    UINT8 yPresent:1;
    
    switch
    {
        case xPresent: AsnPerBitString(minValue, maxValue) x;
    }
    switch
    {
        case yPresent: AsnPerBitString(minValue, maxValue) y;
    }
    // Meybe some extension fields here...
}

[DataTypeBitAlign]
struct CallsAvailable    // SEQUENCE   
{
    UINT8 CallsAvailableExtension:1;
    
    UINT8 groupPresent:1;
         
    AsnPerConstrainedInteger(0, 4294967295) calls;
    switch
    {
        case groupPresent: 
             AsnPerIA5String(-1, -1) group;
    }
    //Maybe needs extension here
}



[DataTypeBitAlign]
struct T38FaxProfile
{
    UINT8 T38FaxProfileExtensionBit:1;
    AsnPerBoolean(0) fillBitRemoval;
    AsnPerBoolean(0) transcodingJBIG;                  
    AsnPerBoolean(0) transcodingMMR;
    switch
    {
        case T38FaxProfileExtensionBit:
             struct T38FaxProfileExtension
             {
                 AsnPerNormallySmallNonnegativeWholeNumber ExtensionNumber;
                 UINT8 versionPresent:1;
                 switch
                 {
                     case PERSmallNumber >= 1: UINT8 t38FaxRateManagementPresent:1;
                 }
                 switch
                 {
                     case PERSmallNumber >= 2: UINT8 t38FaxUdpOptionsPresent:1;
                 }
                 switch
                 {
                     case PERSmallNumber >= 3: UINT8 t38FaxTcpOptionsPresent:1;
                 }
                 switch
                 {
                     case versionPresent:
                     struct Version
                     {
                         AsnPerLengthDeterminant Length;
                         [VersionEndOffset = FrameOffset + PERLengthValue]
                         AsnPerConstrainedInteger(0,255) version;
                         switch
                         {
                             case FrameBitOffset < VersionEndOffset * 8:
                             AsnPerPadding( VersionEndOffset * 8 - FrameBitOffset ) Padding;
                         }
                     }
                 }
                 switch
                 {
                     case t38FaxRateManagementPresent:
                     struct T38FaxRateManagement
                     {
                         AsnPerLengthDeterminant Length;
                         [T38FaxRateManagementEndOffset = FrameOffset + PERLengthValue]
                         T38FaxRateManagement t38FaxRateManagement;
                         switch
                         {
                             case FrameBitOffset < T38FaxRateManagementEndOffset * 8:
                             AsnPerPadding( T38FaxRateManagementEndOffset * 8 - FrameBitOffset) Padding;
                         }
                     }
                 }
                 switch
                 {
                     case t38FaxUdpOptionsPresent:
                     struct T38FaxUdpOptions
                     {
                         AsnPerLengthDeterminant Length;
                         [T38FaxUdpOptionsEndOffset = FrameOffset + PERLengthValue]
                         T38FaxUdpOptions t38FaxUdpOptions;
                         switch
                         {
                             case FrameBitOffset < T38FaxUdpOptionsEndOffset * 8:
                             AsnPerPadding( T38FaxUdpOptionsEndOffset * 8 - FrameBitOffset ) Padding;
                         }
                     }
                 }
                 switch
                 {
                     case t38FaxTcpOptionsPresent:
                     struct T38FaxTcpOptions
                     {
                         AsnPerLengthDeterminant Length;
                         [T38FaxTcpOptionsEndOffset = FrameOffset + PERLengthValue]
                         T38FaxTcpOptions t38FaxTcpOptions;
                         switch
                         {
                             case FrameBitOffset < T38FaxTcpOptionsEndOffset * 8:
                             AsnPerPadding( T38FaxTcpOptionsEndOffset * 8 - FrameBitOffset ) Padding;
                         }
                     }
                 }
             }
    }
}

[DataTypeBitAlign]
struct DataRate
{
    UINT8 DataRateExtension:1;
    UINT8 nonStandardDataPresent:1;
    UINT8 channelMultiplierPresent:1;
    switch
    {
        case nonStandardDataPresent:
        NonStandardParameter nonStandardData;
    }
    AsnPerConstrainedInteger(0,4294967295) channelRate;
    switch
    {
        case channelMultiplierPresent:
        AsnPerConstrainedInteger(1,256) channelMultiplier;
    }
}

[DataTypeBitAlign]
struct SupportedPrefix
{
    UINT8 SupportedPrefixExtension:1;
    UINT8 nonStandardDataPresent:1;
    switch
    {
        case nonStandardDataPresent:
        NonStandardParameter nonStandardData;
    }
    AliasAddress prefix;
}

[DataTypeBitAlign]
struct PublicTypeOfNumber
{
    UINT8 PublicTypeOfNumberExtension:1;
    switch
    {
        case PublicTypeOfNumberExtension:
        _struct ExtensionChoice
        {
        //empty
        };
        default:
        _struct NoneExtension
        {
            AsnPerConstrainedInteger(0,5) ChoiceValue = H225PublicTypeOfNumberTable( ConstrainedValue );
        };
    }
}

[DataTypeBitAlign]
struct PrivateTypeOfNumber
{
    UINT8 PrivateTypeOfNumberExtension:1;
    switch
    {
        case PrivateTypeOfNumberExtension:
        _struct ExtensionChoice
        {
        //empty
        };
        default:
        _struct NoneExtension
        {
            AsnPerConstrainedInteger(0,5) ChoiceValue = H225PrivateTypeOfNumberTable( ConstrainedValue );
        };
    }
}

[DataTypeBitAlign]
struct TBCDSTRING(MinLen, MaxLen) = AsciiString(FrameData, OctetStringStartOffset, OCTETSTRINGLENGTH)
{
   AsnPerIA5String(MinLen,MaxLen) tbcdString;
}

[DataTypeBitAlign]
struct Content  
{
    UINT8 ContentExtension:1;
    switch
    {
        case ContentExtension:
             _struct ExtensionChoice
             {
                 // TODO Here when extension...
             };

        default:
             _struct NoneExtension
             {
                 AsnPerConstrainedInteger(0,11) ChoiceValue;
             	   switch (ConstrainedValue)
             	   {
        	           case 0: AsnPerOctetString(-1, -1) raw;
        	           case 1: AsnPerIA5String(-1, -1) text;
        	           case 2: AsnPerBMPString(-1, -1) unicode;
         	           case 3: AsnPerBoolean(0) bool;
         	           case 4: AsnPerCOnstrainedInteger(0, 255) number8;
         	           case 5: AsnPerCOnstrainedInteger(0, 65535) number16;
         	           case 6: AsnPerCOnstrainedInteger(0, 4294967295) number32;
        	           case 7: GenericIdentifier id;
        	           case 8: AliasAddress alias;
        	           case 9: TransportAddress transport;
        	           case 10: struct compound
        	                    {
        	                        [post.ContentCompoundSize = ConstrainedValue]
                                  AsnPerConstrainedInteger(1, 512) Length;
                                  while [ ContentCompoundSize > 0 ]
                                  {
                                      [ ContentCompoundSize = ContentCompoundSize - 1 ]
                                      EnumeratedParameter parameter;
                                  }
        	                    }
        	           case 11: struct nested
        	                    {
        	                        [post.ContentNestedSize = ConstrainedValue]
                                  AsnPerConstrainedInteger(1, 16) Length;
                                  while [ ContentNestedSize > 0 ]
                                  { 
                                      [ ContentNestedSize = ContentNestedSize - 1 ]
                                      GenericData parameter;
                                  }
        	                    }
        	       }
             };
    }
};

[DataTypeBitAlign]
struct SecurityServiceMode = ChoiceValue.ToString
{
    UINT8 SecurityServiceModeExtension:1;
    AsnPerConstrainedInteger(0,2) ChoiceValue = SecurityServiceModeTable(ConstrainedValue);
    switch( ConstrainedValue )
    {
        case 0: NonStandardParameter nonStandard;
    }
}

[DataTypeBitAlign]
struct CicInfo   // SEQUENCE   
{
    UINT8 CicInfoExtension:1;
    
    struct Cic
    {
        [post.cicCount=PERLengthValue]
        AsnPerLengthDeterminant size;
        while [ cicCount > 0 ]
        {
            [ cicCount = cicCount - 1 ]
            AsnPerOctetString(2, 4) cic;
        }
    }
    AsnPerOctetString(2, 5) pointCode;
    //Maybe needs extension here
}

[DataTypeBitAlign]
struct GroupID    // SEQUENCE   
{
    UINT8 GroupIDExtension:1;
    
    UINT8 memberPresent:1;
              
    switch
    {
        case memberPresent: 
             struct Member
             {
                 [post.memberCount = PERLengthValue]
                 AsnPerLengthDeterminant size;
                 while [ memberCount > 0 ]
                 {
                     [ memberCount = memberCount - 1 ]
                     AsnPerConstrainedInteger(0, 65535) member;
                 }
             }
    }
    AsnPerIA5String(1, 128) group;
    //Maybe needs extension here
}

[DataTypeBitAlign]
struct CallCreditServiceControl  // SEQUENCE   
{
    UINT8 ServiceControlSessionExtension:1;
    
    UINT8 amountStringPresent:1;
    UINT8 billingModePresent:1;
    UINT8 callDurationLimitPresent:1;
    UINT8 enforceCallDurationLimitPresent:1;
    UINT8 callStartingPointPresent:1;
    
    switch
    {
        case amountStringPresent: AsnPerBMPString(1, 512) amountString;
    }
    switch
    {
        case billingModePresent: //CHOICE
             struct BillingMode 
             {
                 UINT8 billingModeExtension:1;
                 switch
                 {
                     case billingModeExtension:
                     _struct ExtensionChoice
                     {
                         // TODO Here when extension...
                     };
                     default:
                     _struct NoneExtension
                     {
             	          AsnPerConstrainedInteger(0,1) ChoiceValue = H225CallCreditServiceControlBillingModeTable(ConstrainedValue);
                     };
                 }
             }
    }
    switch
    {
        case callDurationLimitPresent: AsnPerConstrainedInteger(0, 4294967295) callDurationLimit;
    }
    switch
    {
        case enforceCallDurationLimitPresent: AsnPerBoolean( 0 ) enforceCallDurationLimit;
    }
    switch 
    { 
        case callStartingPointPresent: //CHOICE
            struct callStartingPoint  
            {
                UINT8 callStartingPointExtension:1;
                switch
                {
                    case callStartingPointExtension:
                    _struct ExtensionChoice
                    {
                        // TODO Here when extension...
                    };
                    default:
                    _struct NoneExtension
                    {
            	          AsnPerConstrainedInteger(0,1) ChoiceValue = H225CallCreditServiceControlCallStartingPointTable(ConstrainedValue);
                    };
                }
            }
    }     
    
    // Maybe needs extension here 
}

[DataTypeBitAlign]
struct Params
{
    UINT8 ParamsExtension:1;
    UINT8 iv8Present:1;
    UINT8 iv16Present:1;
    UINT8 ivPresent:1;
    switch
    {
        case iv8Present: AsnPerOctetString(8,8) iv8;
    }
    switch
    {
        case iv16Present: AsnPerOctetString(16,16) iv16;
    }
    switch
    {
        case ivPresent: AsnPerOctetString(-1,-1) iv;
    }
    //switch
    //{
    //    case ParamsExtension:
    //}
}

[DataTypeBitAlign]
struct ECKASDHP(minValue, maxValue) // SEQUENCE 
{
    H225ECpoint(minValue, maxValue) publicKey;
    AsnPerBitString(minValue, maxValue) modulus;
    H225ECpoint(minValue, maxValue) base;
    AsnPerBitString(minValue, maxValue) weierstrassA;
    AsnPerBitString(minValue, maxValue) weierstrassB;
}

[DataTypeBitAlign]
struct ECKASDH2(minValue, maxValue) // SEQUENCE 
{
    H225ECpoint(minValue, maxValue) publicKey;
    AsnPerBitString(minValue, maxValue) fieldSize;
    H225ECpoint(minValue, maxValue) base;
    AsnPerBitString(minValue, maxValue) weierstrassA;
    AsnPerBitString(minValue, maxValue) weierstrassB;
}

[DataTypeBitAlign]
struct CallCapacityInfo   // SEQUENCE   
{
    UINT8 CallCapacityInfoExtension:1;
    
    UINT8 voiceGwCallsAvailablePresent:1;
    UINT8 h310GwCallsAvailablePresent:1;
    UINT8 h320GwCallsAvailablePresent:1;
    UINT8 h321GwCallsAvailablePresent:1;
    UINT8 h322GwCallsAvailablePresent:1;
    UINT8 h323GwCallsAvailablePresent:1;
    UINT8 h324GwCallsAvailablePresent:1;
    UINT8 t120OnlyGwCallsAvailablePresent:1; 
    UINT8 t38FaxAnnexbOnlyGwCallsAvailablePresent:1; 
    UINT8 terminalCallsAvailablePresent:1;
    UINT8 mcuCallsAvailablePresent:1;    
        
    switch 
    { 
        case  voiceGwCallsAvailablePresent:
             struct voiceGwCallsAvailable
             {
                 [post.voiceGwCallsAvailableCount=PERLengthValue]
                 AsnPerLengthDeterminant size;
                 while [ voiceGwCallsAvailableCount > 0 ]
                 {
                     [ voiceGwCallsAvailableCount = voiceGwCallsAvailableCount - 1 ]
                     CallsAvailable voiceGwCallsAvailable; 
                 }
             }
    }
    switch 
    { 
        case  h310GwCallsAvailablePresent:
             struct h310GwCallsAvailable
             {
                 [post.h310GwCallsAvailableCount=PERLengthValue]
                 AsnPerLengthDeterminant size;
                 while [ h310GwCallsAvailableCount > 0 ]
                 {
                     [h310GwCallsAvailableCount = h310GwCallsAvailableCount - 1]
                     CallsAvailable h310GwCallsAvailable;
                 }
             }
    }
    switch 
    { 
        case  h320GwCallsAvailablePresent:
             struct h320GwCallsAvailable
             {
                 [post.h320GwCallsAvailableCount=PERLengthValue]
                 AsnPerLengthDeterminant size;
                 while [h320GwCallsAvailableCount > 0]
                 {
                     [ h320GwCallsAvailableCount = h320GwCallsAvailableCount - 1 ]
                     CallsAvailable h320GwCallsAvailable;
                 }
             }
    }
    switch 
    { 
        case  h321GwCallsAvailablePresent:
             struct h321GwCallsAvailable
             {
                 [post.h321GwCallsAvailableCount=PERLengthValue]
                 AsnPerLengthDeterminant size;
                 while [ h321GwCallsAvailableCount > 0 ]
                 {
                     [h321GwCallsAvailableCount = h321GwCallsAvailableCount - 1]
                     CallsAvailable h321GwCallsAvailable; 
                 }
             }
    }
    switch 
    { 
        case  h322GwCallsAvailablePresent:
             struct h322GwCallsAvailable
             {
                 [post.h322GwCallsAvailableCount=PERLengthValue]
                 AsnPerLengthDeterminant size;
                 while [h322GwCallsAvailableCount > 0]
                 {
                     [h322GwCallsAvailableCount = h322GwCallsAvailableCount - 1]
                     CallsAvailable h322GwCallsAvailable;
                 }
             }
    }
    switch 
    { 
        case  h323GwCallsAvailablePresent:
             struct h323GwCallsAvailable
             {
                 [post.h323GwCallsAvailableCount=PERLengthValue]
                 AsnPerLengthDeterminant size;
                 while [ h323GwCallsAvailableCount > 0 ]
                 {
                     [h323GwCallsAvailableCount = h323GwCallsAvailableCount - 1]
                     CallsAvailable h323GwCallsAvailable; 
                 }
             }
    }
    switch 
    { 
        case  h324GwCallsAvailablePresent:
             struct h324GwCallsAvailable
             {
                 [post.h324GwCallsAvailableCount=PERLengthValue]
                 AsnPerLengthDeterminant size;
                 while [ h324GwCallsAvailableCount > 0 ]
                 { 
                     [ h324GwCallsAvailableCount = h324GwCallsAvailableCount - 1 ]
                     CallsAvailable h324GwCallsAvailable; 
                 }
             }
    }
    switch 
    { 
        case  t120OnlyGwCallsAvailablePresent:
             struct t120OnlyGwCallsAvailable
             {
                 [post.t120OnlyGwCallsAvailableCount=PERLengthValue]
                 AsnPerLengthDeterminant size;
                 while [ t120OnlyGwCallsAvailableCount > 0 ]
                 {
                     [ t120OnlyGwCallsAvailableCount = t120OnlyGwCallsAvailableCount - 1 ]
                     CallsAvailable t120OnlyGwCallsAvailable; 
                 }
             }
    } 
    switch 
    { 
        case  t38FaxAnnexbOnlyGwCallsAvailablePresent:
             struct t38FaxAnnexbOnlyGwCallsAvailable
             {
                 [post.t38FaxAnnexbOnlyGwCallsAvailableCount=PERLengthValue]
                 AsnPerLengthDeterminant size;
                 while [ t38FaxAnnexbOnlyGwCallsAvailableCount > 0 ]
                 {
                     [ t38FaxAnnexbOnlyGwCallsAvailableCount = t38FaxAnnexbOnlyGwCallsAvailableCount - 1 ]
                     CallsAvailable t38FaxAnnexbOnlyGwCallsAvailable;
                 }
             }
    } 
    switch 
    { 
        case  terminalCallsAvailablePresent:
             struct TerminalCallsAvailable
             {
                 [post.terminalCallsAvailableCount=PERLengthValue]
                 AsnPerLengthDeterminant size;
                 while [ terminalCallsAvailableCount > 0 ]
                 {
                     [ terminalCallsAvailableCount = terminalCallsAvailableCount - 1 ]
                     CallsAvailable terminalCallsAvailable; 
                 }
             }
    }
    switch 
    { 
        case  mcuCallsAvailablePresent:
             struct McuCallsAvailable
             {
                 [post.mcuCallsAvailableCount=PERLengthValue]
                 AsnPerLengthDeterminant size;
                 while [ mcuCallsAvailableCount > 0 ]
                 {
                     [ mcuCallsAvailableCount = mcuCallsAvailableCount - 1 ]
                     CallsAvailable mcuCallsAvailable;
                 }
             }
    }        
   
    //Maybe needs extension here
}

[DataTypeBitAlign]
struct NonStandardProtocol
{
    UINT8 NonStandardProtocolExtension:1;
    UINT8 nonStandardDataPresent:1;
    UINT8 dataRatesSupportedPresent:1;
    switch
    {
        case nonStandardDataPresent:
             NonStandardParameter nonStandardData;
    }
    switch
    {
        case dataRatesSupportedPresent:
        struct dataRatesSupported
	      {
	          [ post.DataRatesSupportedSize = PERLengthValue ]
	          AsnPerLengthDeterminant size;
	          while [ DataRatesSupportedSize > 0 ]
	          {
	              [ DataRatesSupportedSize = DataRatesSupportedSize - 1 ]
	              DataRate dataRatesSupported;
	          }
        };
    }	
    struct supportedPrefixes
	  {
	      [ post.supportedPrefixesSize = PERLengthValue ]
	      AsnPerLengthDeterminant size;    
	      while [ supportedPrefixesSize > 0 ]
	      {
	          [ supportedPrefixesSize = supportedPrefixesSize - 1 ]
	          SupportedPrefix supportedPrefix;
	      }
    };	
}

[DataTypeBitAlign]
struct T38FaxAnnexbOnlyCaps
{
    UINT8 T38FaxAnnexbOnlyCapsExtension:1;
    UINT8 nonStandardDataPresent:1;
    UINT8 dataRatesSupportedPresent:1;
    switch
    {
        case nonStandardDataPresent:
             NonStandardParameter nonStandardData;
    }
    switch
    {
        case dataRatesSupportedPresent:
        struct dataRatesSupported
	      {
	          [ post.DataRatesSupportedSize = PERLengthValue ]
	          AsnPerLengthDeterminant size;
	          while [ DataRatesSupportedSize > 0 ]
	          {
	              [ DataRatesSupportedSize = DataRatesSupportedSize - 1 ]
	              DataRate dataRatesSupported;
	          }
        };
    }	
    struct supportedPrefixes
	  {
	      [ post.supportedPrefixesSize = PERLengthValue ]
	      AsnPerLengthDeterminant size;    
	      while [ supportedPrefixesSize > 0 ]
	      {
	          [ supportedPrefixesSize = supportedPrefixesSize - 1 ]
	          SupportedPrefix supportedPrefix;
	      }
    };
    DataProtocolCapability t38FaxProtocol;
    T38FaxProfile t38FaxProfile;
}

[DataTypeBitAlign]
struct H310Caps
{
    UINT8 H310CapsExtensionBit:1;
    UINT8 nonStandardDataPresent:1;
    switch
    {
        case nonStandardDataPresent: NonStandardParameter nonStandardData;
    }
    switch
    {
        case H310CapsExtensionBit:
             struct H310CapsExtension
             {
                 AsnPerNormallySmallNonnegativeWholeNumber ExtensionNumber;
                 UINT8 dataRatesSupportedPresent:1;
                 switch
	             	 {
	             	     case PERSmallNumber >= 1: UINT8 supportedPrefixesPresent:1;
	             	 }
	             	 switch
	             	 {
	             	     case dataRatesSupportedPresent:
	             	     struct dataRatesSupported
	             	     {
	             	         AsnPerLengthDeterminant length;
	             	         [dataRatesSupportedEndOffset = FrameOffset + PERLengthValue, post.dataRatesSupportedCount = PERLengthValue]
	             	         AsnPerLengthDeterminant size;
	             	         while [ dataRatesSupportedCount > 0 ]
	             	         {
	             	             [ dataRatesSupportedCount = dataRatesSupportedCount - 1 ]
	             	             DataRate dataRatesSupported;
	             	         }
	             	         switch
	             	         {
	             	             case FrameBitOffset < dataRatesSupportedEndOffset * 8: 
                                  AsnPerPadding(dataRatesSupportedEndOffset * 8 - FrameBitOffset) Padding;
                         }
                     };	             	                               
	             	 }
	             	 switch
	             	 {
	             	     case supportedPrefixesPresent:
	             	     struct supportedPrefixes
	             	     {
	             	         AsnPerLengthDeterminant length;
	             	         [supportedPrefixesEndOffset = FrameOffset + PERLengthValue, post.supportedPrefixesCount = PERLengthValue]
	             	         AsnPerLengthDeterminant size;
	             	         while [ supportedPrefixesCount > 0 ]
	             	         {
	             	             [ supportedPrefixesCount = supportedPrefixesCount - 1 ]
	             	             SupportedPrefix supportedPrefixe;
	             	         }
	             	         switch
	             	         {
	             	             case FrameBitOffset < supportedPrefixesEndOffset * 8: 
                                  AsnPerPadding(supportedPrefixesEndOffset * 8 - FrameBitOffset) Padding;
                         }
                     };	             	                               
	             	 }
            }       
    }
}

[DataTypeBitAlign]
struct H322Caps
{
    UINT8 H322CapsExtensionBit:1;
    UINT8 nonStandardDataPresent:1;
    switch
    {
        case nonStandardDataPresent: NonStandardParameter nonStandardData;
    }
    switch
    {
        case H322CapsExtensionBit:
             struct H322CapsExtension
             {
                 AsnPerNormallySmallNonnegativeWholeNumber ExtensionNumber;
                 UINT8 dataRatesSupportedPresent:1;
                 switch
	             	 {
	             	     case PERSmallNumber >= 1: UINT8 supportedPrefixesPresent:1;
	             	 }
	             	 switch
	             	 {
	             	     case dataRatesSupportedPresent:
	             	     struct dataRatesSupported
	             	     {
	             	         AsnPerLengthDeterminant length;
	             	         [dataRatesSupportedEndOffset = FrameOffset + PERLengthValue, post.dataRatesSupportedCount = PERLengthValue]
	             	         AsnPerLengthDeterminant size; 
	             	         while [ dataRatesSupportedCount > 0 ]
	             	         {
	             	             [ dataRatesSupportedCount = dataRatesSupportedCount - 1 ]
	             	             DataRate dataRatesSupported;
	             	         }
	             	         switch
	             	         {
	             	             case FrameBitOffset < dataRatesSupportedEndOffset * 8: 
                                  AsnPerPadding(dataRatesSupportedEndOffset * 8 - FrameBitOffset) Padding;
                         }
                     };	             	                               
	             	 }
	             	 switch
	             	 {
	             	     case supportedPrefixesPresent:
	             	     struct supportedPrefixes
	             	     {
	             	         AsnPerLengthDeterminant length;
	             	         [supportedPrefixesEndOffset = FrameOffset + PERLengthValue, post.supportedPrefixesCount = PERLengthValue]
	             	         AsnPerLengthDeterminant size;
	             	         while [ supportedPrefixesCount > 0 ]
	             	         {
	             	             [supportedPrefixesCount = supportedPrefixesCount - 1]
	             	             SupportedPrefix supportedPrefix;
	             	         }
	             	         switch
	             	         {
	             	             case FrameBitOffset < supportedPrefixesEndOffset * 8: 
                                  AsnPerPadding(supportedPrefixesEndOffset * 8 - FrameBitOffset) Padding;
                         }
                     };	             	                               
	             	 }
	           }       
    }
}

[DataTypeBitAlign]
struct H320Caps
{
    UINT8 H320CapsExtensionBit:1;
    UINT8 nonStandardDataPresent:1;
    switch
    {
        case nonStandardDataPresent: NonStandardParameter nonStandardData;
    }
    switch
    {
        case H320CapsExtensionBit:
             struct H320CapsExtension
             {
                 AsnPerNormallySmallNonnegativeWholeNumber ExtensionNumber;
                 UINT8 dataRatesSupportedPresent:1;
                 switch
	             	 {
	             	     case PERSmallNumber >= 1: UINT8 supportedPrefixesPresent:1;
	             	 }
	             	 switch
	             	 {
	             	     case dataRatesSupportedPresent:
	             	     struct dataRatesSupported
	             	     {
	             	         AsnPerLengthDeterminant length;
	             	         [dataRatesSupportedEndOffset = FrameOffset + PERLengthValue, post.dataRatesSupportedCount = PERLengthValue]
	             	         AsnPerLengthDeterminant size;
	             	         while [ dataRatesSupportedCount > 0 ]
	             	         {
	             	             [ dataRatesSupportedCount = dataRatesSupportedCount - 1 ]
	             	             DataRate dataRatesSupported;
	             	         }
	             	         switch
	             	         {
	             	             case FrameBitOffset < dataRatesSupportedEndOffset * 8: 
                                  AsnPerPadding(dataRatesSupportedEndOffset * 8 - FrameBitOffset) Padding;
                         }
                     };	             	                               
	             	 }
	             	 switch
	             	 {
	             	     case supportedPrefixesPresent:
	             	     struct supportedPrefixes
	             	     {
	             	         AsnPerLengthDeterminant length;
	             	         [supportedPrefixesEndOffset = FrameOffset + PERLengthValue, post.supportedPrefixesCount = PERLengthValue]
	             	         AsnPerLengthDeterminant size;
	             	         while [ supportedPrefixesCount > 0 ]
	             	         {
	             	             [ supportedPrefixesCount = supportedPrefixesCount - 1 ]
	             	             SupportedPrefix supportedPrefix;
	             	         }
	             	         switch
	             	         {
	             	             case FrameBitOffset < supportedPrefixesEndOffset * 8: 
                                  AsnPerPadding(supportedPrefixesEndOffset * 8 - FrameBitOffset) Padding;
                         }
                     };	             	                               
	             	 }
	           }       
    }
}

[DataTypeBitAlign]
struct H321Caps
{
    UINT8 H321CapsExtensionBit:1;
    UINT8 nonStandardDataPresent:1;
    switch
    {
        case nonStandardDataPresent: NonStandardParameter nonStandardData;
    }
    switch
    {
        case H321CapsExtensionBit:
             struct H321CapsExtension
             {
                 AsnPerNormallySmallNonnegativeWholeNumber ExtensionNumber;
                 UINT8 dataRatesSupportedPresent:1;
                 switch
	             	 {
	             	     case PERSmallNumber >= 1: UINT8 supportedPrefixesPresent:1;
	             	 }
	             	 switch
	             	 {
	             	     case dataRatesSupportedPresent:
	             	     struct dataRatesSupported
	             	     {
	             	         AsnPerLengthDeterminant length;
	             	         [dataRatesSupportedEndOffset = FrameOffset + PERLengthValue, post.dataRatesSupportedCount = PERLengthValue]
	             	         AsnPerLengthDeterminant size;
	             	         while [ dataRatesSupportedCount > 0 ]
	             	         {
	             	             [ dataRatesSupportedCount = dataRatesSupportedCount - 1 ]
	             	             DataRate dataRatesSupported;
	             	         }
	             	         switch
	             	         {
	             	             case FrameBitOffset < dataRatesSupportedEndOffset * 8: 
                                  AsnPerPadding(dataRatesSupportedEndOffset * 8 - FrameBitOffset) Padding;
                         }
                     };	             	                               
	             	 }
	             	 switch
	             	 {
	             	     case supportedPrefixesPresent:
	             	     struct supportedPrefixes
	             	     {
	             	         AsnPerLengthDeterminant length;
	             	         [supportedPrefixesEndOffset = FrameOffset + PERLengthValue, post.supportedPrefixesCount = PERLengthValue]
	             	         AsnPerLengthDeterminant size;
	             	         while [ supportedPrefixesCount > 0 ]
	             	         {
	             	             [ supportedPrefixesCount = supportedPrefixesCount - 1 ]
	             	             SupportedPrefix supportedPrefix;
	             	         }
	             	         switch
	             	         {
	             	             case FrameBitOffset < supportedPrefixesEndOffset * 8: 
                                  AsnPerPadding(supportedPrefixesEndOffset * 8 - FrameBitOffset) Padding;
                         }
                     };	             	                               
	             	 }
	           }       
    }
}

[DataTypeBitAlign]
struct H323Caps
{
    UINT8 H323CapsExtensionBit:1;
    UINT8 nonStandardDataPresent:1;
    switch
    {
        case nonStandardDataPresent: NonStandardParameter nonStandardData;
    }
    switch
    {
        case H323CapsExtensionBit:
             struct H323CapsExtension
             {
                 AsnPerNormallySmallNonnegativeWholeNumber ExtensionNumber;
                 UINT8 dataRatesSupportedPresent:1;
                 switch
	             	 {
	             	     case PERSmallNumber >= 1: UINT8 supportedPrefixesPresent:1;
	             	 }
	             	 switch
	             	 {
	             	     case dataRatesSupportedPresent:
	             	     struct dataRatesSupported
	             	     {
	             	         AsnPerLengthDeterminant length;
	             	         [dataRatesSupportedEndOffset = FrameOffset + PERLengthValue, post.dataRatesSupportedCount = PERLengthValue]
	             	         AsnPerLengthDeterminant size;
	             	         while [  dataRatesSupportedCount > 0 ]
	             	         {
	             	             [ dataRatesSupportedCount = dataRatesSupportedCount - 1 ]
	             	             DataRate dataRatesSupported;
	             	         }
	             	         switch
	             	         {
	             	             case FrameBitOffset < dataRatesSupportedEndOffset * 8: 
                                  AsnPerPadding(dataRatesSupportedEndOffset * 8 - FrameBitOffset) Padding;
                         }
                     };	             	                               
	             	 }
	             	 switch
	             	 {
	             	     case supportedPrefixesPresent:
	             	     struct supportedPrefixes
	             	     {
	             	         AsnPerLengthDeterminant length;
	             	         [supportedPrefixesEndOffset = FrameOffset + PERLengthValue, post.supportedPrefixesCount = PERLengthValue]
	             	         AsnPerLengthDeterminant size;
	             	         while [ supportedPrefixesCount > 0 ]
	             	         {
	             	             [ supportedPrefixesCount = supportedPrefixesCount - 1 ]
	             	             SupportedPrefix supportedPrefix;
	             	         }
	             	         switch
	             	         {
	             	             case FrameBitOffset < supportedPrefixesEndOffset * 8: 
                                  AsnPerPadding(supportedPrefixesEndOffset * 8 - FrameBitOffset) Padding;
                         }
                     };	             	                               
	             	 }
	           }       
    }
}

[DataTypeBitAlign]
struct H324Caps
{
    UINT8 H324CapsExtensionBit:1;
    UINT8 nonStandardDataPresent:1;
    switch
    {
        case nonStandardDataPresent: NonStandardParameter nonStandardData;
    }
    switch
    {
        case H324CapsExtensionBit:
             struct H324CapsExtension
             {
                 AsnPerNormallySmallNonnegativeWholeNumber ExtensionNumber;
                 UINT8 dataRatesSupportedPresent:1;
                 switch
	             	 {
	             	     case PERSmallNumber >= 1: UINT8 supportedPrefixesPresent:1;
	             	 }
	             	 switch
	             	 {
	             	     case dataRatesSupportedPresent:
	             	     struct dataRatesSupported
	             	     {
	             	         AsnPerLengthDeterminant length;
	             	         [dataRatesSupportedEndOffset = FrameOffset + PERLengthValue, post.dataRatesSupportedCount = PERLengthValue]
	             	         AsnPerLengthDeterminant size;
	             	         while [ dataRatesSupportedCount > 0 ]
	             	         {
	             	             [ dataRatesSupportedCount = dataRatesSupportedCount - 1 ]
	             	             DataRate dataRatesSupported;
	             	         }
	             	         switch
	             	         {
	             	             case FrameBitOffset < dataRatesSupportedEndOffset * 8: 
                                  AsnPerPadding(dataRatesSupportedEndOffset * 8 - FrameBitOffset) Padding;
                         }
                     };	             	                               
	             	 }
	             	 switch
	             	 {
	             	     case supportedPrefixesPresent:
	             	     struct supportedPrefixes
	             	     {
	             	         AsnPerLengthDeterminant length;
	             	         [supportedPrefixesEndOffset = FrameOffset + PERLengthValue, post.supportedPrefixesCount = PERLengthValue]
	             	         AsnPerLengthDeterminant size;
	             	         while [  supportedPrefixesCount > 0 ]
	             	         {
	             	             [ supportedPrefixesCount = supportedPrefixesCount - 1 ]
	             	             SupportedPrefix supportedPrefix;
	             	         }
	             	         switch
	             	         {
	             	             case FrameBitOffset < supportedPrefixesEndOffset * 8: 
                                  AsnPerPadding(supportedPrefixesEndOffset * 8 - FrameBitOffset) Padding;
                         }
                     };	             	                               
	             	 }
	           }       
    }
}

[DataTypeBitAlign]
struct VoiceCaps
{
    UINT8 VoiceCapsExtensionBit:1;
    UINT8 nonStandardDataPresent:1;
    switch
    {
        case nonStandardDataPresent: NonStandardParameter nonStandardData;
    }
    switch
    {
        case VoiceCapsExtensionBit:
             struct VoiceCapsExtension
             {
                 AsnPerNormallySmallNonnegativeWholeNumber ExtensionNumber;
                 UINT8 dataRatesSupportedPresent:1;
                 switch
	             	 {
	             	     case PERSmallNumber >= 1: UINT8 supportedPrefixesPresent:1;
	             	 }
	             	 switch
	             	 {
	             	     case dataRatesSupportedPresent:
	             	     struct dataRatesSupported
	             	     {
	             	         AsnPerLengthDeterminant length;
	             	         [dataRatesSupportedEndOffset = FrameOffset + PERLengthValue, post.dataRatesSupportedCount = PERLengthValue]
	             	         AsnPerLengthDeterminant size;
	             	         while [ dataRatesSupportedCount > 0 ]
	             	         {
	             	             [ dataRatesSupportedCount = dataRatesSupportedCount - 1 ]
	             	             DataRate dataRatesSupported;
	             	         }
	             	         switch
	             	         {
	             	             case FrameBitOffset < dataRatesSupportedEndOffset * 8: 
                                  AsnPerPadding(dataRatesSupportedEndOffset * 8 - FrameBitOffset) Padding;
                         }
                     };	             	                               
	             	 }
	             	 switch
	             	 {
	             	     case supportedPrefixesPresent:
	             	     struct supportedPrefixes
	             	     {
	             	         AsnPerLengthDeterminant length;
	             	         [supportedPrefixesEndOffset = FrameOffset + PERLengthValue, post.supportedPrefixesCount = PERLengthValue]
	             	         AsnPerLengthDeterminant size; 
	             	         while [ supportedPrefixesCount > 0 ]
	             	         {
	             	             [ supportedPrefixesCount = supportedPrefixesCount - 1 ]
	             	             SupportedPrefix supportedPrefix;
	             	         }
	             	         switch
	             	         {
	             	             case FrameBitOffset < supportedPrefixesEndOffset * 8: 
                                  AsnPerPadding(supportedPrefixesEndOffset * 8 - FrameBitOffset) Padding;
                         }
                     };	             	                               
	             	 }
	           }       
    }
}

[DataTypeBitAlign]
struct T120OnlyCaps 
{
    UINT8 T120OnlyCapsExtensionBit:1;
    UINT8 nonStandardDataPresent:1;
    switch
    {
        case nonStandardDataPresent: NonStandardParameter nonStandardData;
    }
    switch
    {
        case T120OnlyCapsExtensionBit:
             struct T120OnlyCapsExtension
             {
                 AsnPerNormallySmallNonnegativeWholeNumber ExtensionNumber;
                 UINT8 dataRatesSupportedPresent:1;
                 switch
	             	 {
	             	     case PERSmallNumber >= 1: UINT8 supportedPrefixesPresent:1;
	             	 }
	             	 switch
	             	 {
	             	     case dataRatesSupportedPresent:
	             	     struct dataRatesSupported
	             	     {
	             	         AsnPerLengthDeterminant length;
	             	         [dataRatesSupportedEndOffset = FrameOffset + PERLengthValue, post.dataRatesSupportedCount = PERLengthValue]
	             	         AsnPerLengthDeterminant size;
	             	         while [ dataRatesSupportedCount > 0 ]
	             	         {
	             	             [ dataRatesSupportedCount = dataRatesSupportedCount - 1 ]
	             	             DataRate dataRatesSupported;
	             	         }
	             	         switch
	             	         {
	             	             case FrameBitOffset < dataRatesSupportedEndOffset * 8: 
                                  AsnPerPadding(dataRatesSupportedEndOffset * 8 - FrameBitOffset) Padding;
                         }
                     };	             	                               
	             	 }
	             	 switch
	             	 {
	             	     case supportedPrefixesPresent:
	             	     struct supportedPrefixes
	             	     {
	             	         AsnPerLengthDeterminant length;
	             	         [supportedPrefixesEndOffset = FrameOffset + PERLengthValue, post.supportedPrefixesCount = PERLengthValue]
	             	         AsnPerLengthDeterminant size;
	             	         while [ supportedPrefixesCount > 0 ]
	             	         {
	             	             [supportedPrefixesCount = supportedPrefixesCount - 1]
	             	             SupportedPrefix supportedPrefix;
	             	         }
	             	         switch
	             	         {
	             	             case FrameBitOffset < supportedPrefixesEndOffset * 8: 
                                  AsnPerPadding(supportedPrefixesEndOffset * 8 - FrameBitOffset) Padding;
                         }
                     };	             	                               
	             	 }
	           }       
    }
}

[DataTypeBitAlign]
struct PublicPartyNumber
{
    PublicTypeOfNumber publicTypeOfNumber;
    NumberDigits publicNumberDigits;
}

[DataTypeBitAlign]
struct PrivatePartyNumber
{
    PrivateTypeOfNumber privateTypeOfNumber;
    NumberDigits privateNumberDigits;
}

[DataTypeBitAlign]
struct NumberDigits = AsciiString(FrameData, OctetStringStartOffset, OCTETSTRINGLENGTH)
{
    AsnPerIA5String(-1,-1) string;
}

[DataTypeBitAlign]
struct ANSI41UIM
{
    UINT8 ANSI41UIMExtension:1;
    UINT8 imsiPresent:1;
    UINT8 minPresent:1;
    UINT8 mdnPresent:1;
    UINT8 msisdnPresent:1;
    UINT8 esnPresent:1;
    UINT8 mscidPresent:1;
    UINT8 systemMyTypeCodePresent:1;
    UINT8 systemAccessTypePresent:1;
    UINT8 qualificationInformationCodePresent:1;
    UINT8 sesnPresent:1;
    UINT8 socPresent:1;
    switch
    {
        case imsiPresent: TBCDSTRING(3,16) imsi;
    }
    switch
    {
        case minPresent: TBCDSTRING(3,16) min;
    }
    switch
    {
        case mdnPresent: TBCDSTRING(3,16) mdn;
    }
    switch
    {
        case msisdnPresent: TBCDSTRING(3,16) msisdn;
    }
    switch
    {
        case esnPresent: TBCDSTRING(16,16) esn; 
    }    
    switch
    {
        case mscidPresent: TBCDSTRING(3,16) mscid; 
    }
    struct systemid
    {
        UINT8 systemidExtension:1;
        switch
        {
            case systemidExtension:
            _struct ExtensionChoice
            {
            //empty
            };
            default:
            _struct NoneExtension
            {
                AsnPerConstrainedInteger(0,1) ChoiceValue;
                switch( ConstrainedValue )
                {
                    case 0: TBCDSTRING(1,4) sid;
                    case 1: TBCDSTRING(1,4) mid;
                }
            };
        }
    };
    switch
    {
        case systemMyTypeCodePresent: AsnPerOctetString(1,1) systemMyTypeCode; 
    }
    switch
    {
        case systemAccessTypePresent: AsnPerOctetString(1,1) systemAccessType; 
    }
    switch
    {
        case qualificationInformationCodePresent: AsnPerOctetString(1,1) qualificationInformationCode; 
    }
    switch
    {
        case sesnPresent: TBCDSTRING(16,16) sesn;
    }
    switch
    {
        case socPresent: TBCDSTRING(3,16) soc;
    }
    //switch
    //{
    //    case ANSI_41_UIM_Extension:
    //}
}

[DataTypeBitAlign]
struct GSMUIM
{
    UINT8 GSMUIMExtension:1;
    UINT8 imsiPresent:1;
    UINT8 tmsiPresent:1;
    UINT8 msisdnPresent:1;
    UINT8 imeiPresent:1;
    UINT8 hplmnPresent:1;
    UINT8 vplmnPresent:1;
    switch
    {
        case imsiPresent: TBCDSTRING(3,16) imsi;
    }
    switch
    {
        case tmsiPresent: AsnPerOctetString(1,4) tmsi;
    }
    switch
    {
        case msisdnPresent: TBCDSTRING(3,16) msisdn;
    }
    switch
    {
        case imeiPresent: TBCDSTRING(15,16) imei;
    }
    switch
    {
        case hplmnPresent: TBCDSTRING(1,4) hplmn;
    }
    switch
    {
        case vplmnPresent: TBCDSTRING(1,4) vplmn;
    }
    //switch
    //{
    //    case GSM_UIM_Extension:
    //}
}

[DataTypeBitAlign]
struct H221NonStandard = FormatString("%s %s",H221ManufacturerCodeTable(H221ManufacturerCode), t35CountryCode.ToString)
{
    UINT8 H221NonStandardExtension:1;
    AsnPerConstrainedInteger(0,255) t35CountryCode = T35CountryCodeTable( ConstrainedValue );
    [H221ManufacturerCode = UINT32(FrameData,offset-1)]
    AsnPerConstrainedInteger(0,255) t35Extension;
    AsnPerConstrainedInteger(0,65535) manufactureCode;
}

[DataTypeBitAlign]
struct GenericIdentifier
{
    UINT8 GenericIdentifierExtension:1;
    AsnPerConstrainedInteger(0,2) ChoiceValue;
    switch( ConstrainedValue )
    {
        case 0: AsnPerConstrainedInteger(0,16383) standard;
        case 1: AsnPerObjectIdentifier oid;
        case 2: AsnPerGUID nonStandard;
    }
}

[DataTypeBitAlign]
struct EnumeratedParameter
{
    UINT8 GenericDataExtension:1;
    UINT8 contentPresent:1;
    GenericIdentifier id;
    switch
    {
        case contentPresent: Content content;
    }
    // Maybe needs extension here
};

[DataTypeBitAlign]
struct TunnelledProtocolAlternateIdentifier
{
    UINT8 TunnelledProtocolAlternateIdentifierExtension:1;
    UINT8 protocolVariantPresent:1;
    AsnPerIA5String(1,64) protocolType;
    switch
    {
        case protocolVariantPresent: AsnPerIA5String(1,64) protocolVariant;
    } 
}

[DataTypeBitAlign]
struct SecurityCapabilities
{
    UINT8 SecurityCapabilitiesExtension:1;
    UINT8 nonStandardPresent:1;
    switch
    {
        case nonStandardPresent: NonStandardParameter nonStandard;
    }
    SecurityServiceMode encryption;
    SecurityServiceMode authenticaton;
    SecurityServiceMode integrity;
}

[DataTypeBitAlign]
struct CircuitIdentifier   // SEQUENCE   
{
    UINT8 CircuitIdentifierExtension:1;
    
    UINT8 cicPresent:1;
    UINT8 groupPresent:1;
           
    switch
    {
        case cicPresent: 
             CicInfo cic;
    }
    switch
    {
        case groupPresent: 
             GroupID group;
    }
    //Maybe needs extension here
}

[DataTypeBitAlign]
struct ServiceControlDescriptor  // CHOICE  
{
	  UINT8 ServiceControlSessionReasonExtension:1;
    switch
    {
        case ServiceControlSessionReasonExtension:
            _struct ExtensionChoice
            {
                // TODO Here when extension...
            };
        default:
            _struct NoneExtension
            {
            	  AsnPerConstrainedInteger(0, 3) ChoiceValue;
            	  switch (ConstrainedValue)
            	  {
            	      case 0: AsnPerIA5String( 0, 512) url = AsciiString(FrameData, OctetStringStartOffset, OCTETSTRINGLENGTH);
            	      case 1: AsnPerOctetString(-1, -1) signal;
            	      case 2: NonStandardParameter nonStandard;
            	      case 3: CallCreditServiceControl callCreditServiceControl;
            	  }
            };
    }
}

[DataTypeBitAlign]
struct H235TimeStamp = timeStamp.ToString
{
    AsnPerConstrainedInteger(1,4294967295) timeStamp = FormatString( "%T{MM/dd/yyyy}, %t{hh':'mm':'ss tt} .%t{ffff} ", ConstrainedValue, ConstrainedValue, ConstrainedValue );
}

[DataTypeBitAlign]
struct H235Hashed
{
    AsnPerObjectIdentifier algorithmOID;
    Params paramS;
    AsnPerBitString(-1,-1) hash;
}

[DataTypeBitAlign]
struct H235Encrypted
{
    AsnPerObjectIdentifier algorithmOID;
    Params paramS;
    AsnPerOctetString(-1,-1) encryptedData;
}

[DataTypeBitAlign]
struct H235Signed
{
    AsnPerObjectIdentifier algorithmOID;
    Params paramS;
    AsnPerBitString(-1,-1) signature;
}

[DataTypeBitAlign]
struct H235Eckasdh(minValue, maxValue)  // CHOICE  
{
	  UINT8 ECKASDHExtension:1;
    switch
    {
        case ECKASDHExtension:
            _struct ExtensionChoice
            {
                // TODO Here when extension...
            };
        default:
            _struct NoneExtension
            {
            	  AsnPerConstrainedInteger(0,1) ChoiceValue;
                switch( ConstrainedValue )
                {
                    case 0: ECKASDHP(minValue, maxValue) eckasdhp;
                    case 1: ECKASDH2(minValue, maxValue) eckasdh2;
                }
            };
    }
}

struct SecurityErrors = SecurityError
{
    UINT8 SecurityErrorsExtension:1;
    switch
    {
        case SecurityErrorsExtension:
            _struct ExtensionChoice
            {
                //Empty
            }
        default:
        _struct NoneExtension
        {
            [post.SecurityError = H225SecurityErrorsTable(ConstrainedValue)]
            AsnPerConstrainedInteger(0,15) ChoiceValue;
        }
    }
}

struct ScnConnectionType = ConnectionType
{
    UINT8 ScnConnectionTypeExtension:1;
    switch
    {
        case ScnConnectionTypeExtension:
            _struct ExtensionChoice
            {
                //Empty
            }
        default:
            _struct NoneExtension
            {     
                [post.ConnectionType = H225ScnConnectionTypeTable( ConstrainedValue )]
                AsnPerConstrainedInteger(0,6) ChoiceValue;
            }
    }
}

[DataTypeBitAlign]
struct ScnConnectionAggregation  // CHOICE  
{
	  UINT8 ScnConnectionAggregationExtension:1;
    switch
    {
        case ScnConnectionAggregationExtension:
            _struct ExtensionChoice
            {
                // TODO Here when extension...
            };
        default:
            _struct NoneExtension
            {
        	      AsnPerConstrainedInteger(0, 5) ChoiceValue = H225ScnConnectionAggregationTable(ConstrainedValue);
            };
    }
}

[DataTypeBitAlign]
struct PresentationIndicator=PresentationIndicatorChoice   //CHOICE
{
    UINT8 PresentationIndicatorExtension:1;
    switch
    {
        case PresentationIndicatorExtension:
            _struct ExtensionChoice
            {
                // TODO Here when extension...
            };
        default:
            _struct NoneExtension
            {
                [post.PresentationIndicatorChoice =this.tostring]
                AsnPerConstrainedInteger(0,2) ChoiceValue=H225PresentationIndicatorTable(ConstrainedValue);
            };
    }
}

[DataTypeBitAlign]
struct ScreeningIndicator = ScreeningIndic
{
    UINT8 ScreeningIndicatorExtension:1;
    [post.ScreeningIndic = H225ScreeningIndicatorTable( ConstrainedValue )]
    AsnPerConstrainedInteger(0,3) EnumeratedValue;
}

[DataTypeBitAlign]
struct CallCapacity   // SEQUENCE   
{
    UINT8 CallCapacityExtension:1;
    
    UINT8 maximumCallCapacityPresent:1;
    UINT8 currentCallCapacityPresent:1;
        
    switch
    {
        case maximumCallCapacityPresent: 
             CallCapacityInfo maximumCallCapacity;
    }
    switch
    {
        case currentCallCapacityPresent: 
             CallCapacityInfo currentCallCapacity;
    }
    //Maybe needs extension here
}

[DataTypeBitAlign]
struct ExtendedAliasAddress //SEQUENCE
{
    UINT8 ExtendedAliasAddressExtension:1;
    
    UINT8 presentationIndicatorPresent:1;
    UINT8 screeningIndicatorPresent:1;
           
    AliasAddress address;
    
    switch
    {
        case presentationIndicatorPresent: 
             PresentationIndicator presentationIndicator;
    }
    switch
    {
        case screeningIndicatorPresent: 
             ScreeningIndicator screeningIndicator;
    }
		// Maybe needs extension here 
}

[DataTypeBitAlign]
struct SupportedProtocols
{
    UINT8 SupportedProtocolsExtension:1;
    switch
    {
        case SupportedProtocolsExtension:
            _struct ExtensionChoice
            {
                AsnPerNormallySmallNonnegativeWholeNumber ChoiceValue;
                AsnPerLengthDeterminant Length;
                [ExtensionEndoffset = FrameOffset + PERLengthValue]
                switch( PERSmallNumber )
                {
                    case 0: NonStandardProtocol nonStandardProtocol;
                    case 1: T38FaxAnnexbOnlyCaps t38FaxAnnexbOnly;
                }
                switch
                {
                    case FrameBitOffset < ExtensionEndoffset * 8: AsnPerPadding(ExtensionEndoffset * 8 - FrameBitOffset) padding;
                }
            };
        default:
            _struct NoneExtension
            {
                AsnPerConstrainedInteger(0,8) ChoiceValue;
                switch( ConstrainedValue )
                {
                    case 0: NonStandardParameter nonStandardData;
                    case 1: H310Caps h310;
                    case 2: H320Caps h320;
                    case 3: H321Caps h321;
                    case 4: H322Caps h322;
                    case 5: H323Caps h323;
                    case 6: H324Caps h324;
                    case 7: VoiceCaps voice;
                    case 8: T120OnlyCaps t120only;        
                }
            };
    }        
}

[DataTypeBitAlign]
struct PartyNumber
{
    UINT8 PartyNumberExtension:1;
    switch
    {
        case PartyNumberExtension:
        _struct ExtensionChoice
        {
        //empty
        };
        default:
        _struct NoneExtension
        {
            AsnPerConstrainedInteger(0,4) ChoiceValue;
            switch( ConstrainedValue )
            {
                case 0: PublicPartyNumber e164Number;
                case 1: NumberDigits dataPartyNumber;
                case 2: NumberDigits telexPartyNumber;
                case 3: PrivatePartyNumber privateNumber;
                case 4: NumberDigits nationalStandardPartyNumber;
            }
        };
    }
}

[DataTypeBitAlign]
struct MobileUIM
{
    UINT8 MobileUIMExtension:1;
    switch
    {
        case MobileUIMExtension:
        _struct ExtensionChoice
        {
        };
        default:
        _struct NoneExtension
        {
            AsnPerConstrainedInteger(0,1) ChoiceValue;
            switch( ConstrainedValue )
            {
                case 0: ANSI41UIM ansi41uim;
                case 1: GSMUIM gsmuim;
            }
        };
    }
}

[DataTypeBitAlign]
struct NonStandardIdentifier
{
    UINT8 NonStandardIdentifierExtension:1;
    switch
    {
        case NonStandardIdentifierExtension:
        _struct ExtensionChoice
        {
        //empty
        };
        default:
        _struct NoneExtension
        {
            AsnPerConstrainedInteger(0,1) ChoiceValue;
            switch( ConstrainedValue )
            {
                case 0: AsnPerObjectIdentifier object;
                case 1: H221NonStandard h221NonStandard;
            }
        };
    }
};

[DataTypeBitAlign]
struct GenericData
{
    UINT8 GenericDataExtension:1;
    UINT8 parametersPresent:1;
    GenericIdentifier id;
    switch
    {
        case parametersPresent:
        struct Parameters
        {
        	  [post.ParameterSize = ConstrainedValue]
            AsnPerConstrainedInteger(1, 512) Length;
            while [ ParameterSize > 0 ]
            {
                [ ParameterSize = ParameterSize - 1 ]
                EnumeratedParameter parameters;
            }
        }
    }
    // Maybe needs extension here
};


[DataTypeBitAlign]
struct TunnelledProtocol
{
    UINT8 TunnelledProtocolExtension:1;
    UINT8 subIdentifierPresent:1;
    struct id
    {
        UINT8 idExtension:1;
        AsnPerConstrainedInteger(0,1) ChoiceValue;
        switch( ConstrainedValue )
        {
            case 0: AsnPerObjectIdentifier tunnelledProtocolObjectID;
            case 1: TunnelledProtocolAlternateIdentifier tunnelledProtocolAlternateID;
        }
    };
    switch
    {
        case subIdentifierPresent: AsnPerIA5String(1,64) subIdentifier;
    }
}

[DataTypeBitAlign]
struct CallLinkage
{
    UINT8 CallLinkageExtension:1;
    UINT8 globalCallIdPresent:1;
    UINT8 threadIdPresent:1;
    switch
    {
        case globalCallIdPresent: AsnPerGUID globalCallId;
    }
    switch
    {
        case threadIdPresent: AsnPerGUID threadId;
    }
    //switch
    //{
        //case CallLinkage_Extension:
        // ???maybe there are some extension values
    //}
}

[DataTypeBitAlign]
struct H245Security
{
    UINT8 h245SecurityExtension:1;
    AsnPerConstrainedInteger(0,3) ChoiceValue = H245SecurityTypeTable( ConstrainedValue );
    switch( ConstrainedValue )
    {
        case 0: NonStandardParameter nonStandard;
        case 2: SecurityCapabilities tls;
        case 3: SecurityCapabilities ipsec;
    }
}

[DataTypeBitAlign]
struct H225SequenceOfFeatureDescriptor
{
    [post.genericDataSize = PERLengthValue]
    AsnPerLengthDeterminant Length;
    while [ genericDataSize > 0 ]
    {
        [genericDataSize = genericDataSize - 1]
        GenericData genericData;
    }
}

[DataTypeBitAlign]
struct FeatureSet
{
    UINT8 FeatureSetExtension:1;
    UINT8 neededFeaturesPresent:1;
    UINT8 desiredFeaturesPresent:1;
    UINT8 supportedFeaturesPresent:1;
    AsnPerBoolean(0) replacementFeatureSet;
    switch
    {
        case neededFeaturesPresent: H225SequenceOfFeatureDescriptor neededFeatures;
    }
    
    switch
    {
        case desiredFeaturesPresent: H225SequenceOfFeatureDescriptor desiredFeatures;
    }
    
    switch
    {
        case supportedFeaturesPresent: H225SequenceOfFeatureDescriptor supportedFeatures;
    }
}

[DataTypeBitAlign]
struct CircuitInfo   // SEQUENCE   
{
    UINT8 CircuitInfoExtension:1;
    
    UINT8 sourceCircuitIDPresent:1;
    UINT8 destinationCircuitIDPresent:1;
    UINT8 genericDataPresent:1;
        
    switch
    {
        case sourceCircuitIDPresent: 
             CircuitIdentifier sourceCircuitID;
    }
    switch
    {
        case destinationCircuitIDPresent: 
             CircuitIdentifier destinationCircuitID;
    }
    switch
    {
        case genericDataPresent: 
             struct GenericData
             {
             	   [post.genericDataCount = PERLengthValue]
             	   AsnPerLengthDeterminant size;
             	   while [ genericDataCount > 0 ]
             	   {
             	       [ genericDataCount = genericDataCount - 1 ]
                     GenericData  genericData;
                 }
             }
    }
    //Maybe needs extension here
}

[DataTypeBitAlign]
struct ServiceControlSession  // SEQUENCE   
{
    UINT8 ServiceControlSessionExtension:1;
    
    UINT8 contentsPresent:1;
      
    AsnPerConstrainedInteger(0, 255) sessionId;
    switch
    {
        case contentsPresent: 
             ServiceControlDescriptor contents;
    }
    ServiceControlSessionReason reason;
    
    // Maybe needs extension here 
}    

[DataTypeBitAlign]
struct H225ConferenceList
{
    UINT8 ConferenceListExtension:1;
    UINT8 UconferenceIDPresent:1;
    UINT8 conferenceAliasPresent:1;
    UINT8 nonStandardDataPresent:1;
    switch
    {
        case UconferenceIDPresent:
             GUID(true) conferenceID;
    }
    switch
    {
        case conferenceAliasPresent:
             AliasAddress conferenceAlias;
    }
    switch
    {
        case nonStandardDataPresent:
             NonStandardParameter nonStandardData;
    }
}

[DataTypeBitAlign]
struct H235CryptoH323Token
{
    UINT8 CryptoH323TokenExtension:1;
    switch
    {
        //case CryptoH323Token_Extension
        default:
        _struct NoneExtension
        {
            AsnPerConstrainedInteger(0,7) ChoiceValue;
            switch( ConstrainedValue )
            {
                case 0:
                struct cryptoEPPwdHash
                {
                    AliasAddress alias;
                    H235TimeStamp timeStamp;
                    H235Hashed token;
                };
                case 1:
                struct cryptoGKPwdHash
                {
                    AsnPerBMPString(1,128) gatekeeperId;
                    H235TimeStamp timeStamp;
                    H235Hashed token;
                };
                case 2: H235Encrypted cryptoEPPwdEncr;
                case 3: H235Encrypted cryptoGKPwdEncr;
                case 4: H235Signed cryptoEPCert;
                case 5: H235Signed cryptoGKCert;
                case 6: H235Signed cryptoFastStart;
                case 7: H235CryptoToken nestedcryptoToken;
            }
        };
    }
}

[DataTypeBitAlign]
struct H235ClearToken // SEQUENCE   
{
    UINT8 ClearTokenExtensionBit:1;
    
    UINT8 timeStampPresent:1;
    UINT8 passwordPresent:1;
    UINT8 dhkeyPresent:1;
    UINT8 challengePresent:1;
    UINT8 randomPresent:1;
    UINT8 certificatePresent:1;
    UINT8 generalIDPresent:1;
    UINT8 nonStandardPresent:1;
        
    AsnPerObjectIdentifier tokenOID;
    
    switch
    {
        case timeStampPresent: H235TimeStamp timeStamp;
    }
    switch
    {
        case passwordPresent: AsnPerBMPString(1, 128) password;
    }
    switch
    {
        case dhkeyPresent: H235DHset(0, 2048) dhkey;
    }
    switch
    {
        case challengePresent: AsnPerOctetString( 8, 128) challenge;
    }
    switch 
    { 
        case  randomPresent: AsnPerConstrainedInteger(4, 4) random;
    }
    switch 
    { 
        case  certificatePresent: H235TypedCertificate certificate;
    }
    switch 
    { 
        case  generalIDPresent: AsnPerBMPString(1, 128) generalID;
    }
    switch 
    { 
        case  nonStandardPresent: H235NonStandardParameter nonStandard;
    }
    
    switch 
    {
        case ClearTokenExtensionBit:
             struct ClearTokenExtension
             {
             	    AsnPerNormallySmallNonnegativeWholeNumber ExtensionNumber;
             	    UINT8 eckasdhKeyPresent:1;
             	    switch
             	    {
             	        case PERSmallNumber >= 1: UINT8 sendersIDPresent:1;
             	    }
             	   
                  switch 
                  { 
                      case  eckasdhKeyPresent: 
                            struct 	EckasdhKey
                            {
                                AsnPerLengthDeterminant length;  
                                [EckasdhKeyEndOffset = FrameOffset + PERLengthValue]
                            	  H235Eckasdh(0, 511) eckasdhKey;
                            	  switch
                                {
                                    case FrameBitOffset < EckasdhKeyEndOffset * 8: 
                                    AsnPerPadding(EckasdhKeyEndOffset * 8 - FrameBitOffset) Padding;
                                }
                            }
                  }
                  switch 
                  { 
                      case sendersIDPresent:
                           struct SendersID
                           {
                                AsnPerLengthDeterminant length; 
                                [SendersIDEndOffset = FrameOffset + PERLengthValue]
                                AsnPerBMPString(1, 128) sendersID;
                                switch
                                {
                                    case FrameBitOffset < SendersIDEndOffset * 8: 
                                    AsnPerPadding(SendersIDEndOffset * 8 - FrameBitOffset) Padding;
                                }
                           }
                  }
             }
     }
}

[DataTypeBitAlign]
struct CallIdentifier  = guid.ToString
{
    UINT8 CallIdentifierExtension:1;
    AsnPerGUID guid;
}

[DataTypeBitAlign]
struct FacilityReason=FacilityReasonChoiceValue
{
    UINT8 FacilityReasonExtension:1; 
    switch
    {
        case FacilityReasonExtension:
            _struct ExtensionChoice
            {
                [post.FacilityReasonChoiceValue=this.tostring]
                AsnPerNormallySmallNonnegativeWholeNumber ExtFacilityReason = H225FacilityReasonTypeExtensionTable(PERSmallNumber);
                AsnPerLengthDeterminant Length;
                [ExtensionEndoffset = FrameOffset + PERLengthValue]
                switch
                {
                    case FrameBitOffset < ExtensionEndoffset * 8: AsnPerPadding(ExtensionEndoffset * 8 - FrameBitOffset) padding;
                }
            }
        default: 
               _struct NonExtension
               {
                   [post.FacilityReasonChoiceValue=this.tostring]
                   AsnPerConstrainedInteger(0,3) FacilityReason = H225FacilityReasonTypeTable( ConstrainedValue );
               }
    }
}

[DataTypeBitAlign]
struct ReleaseCompleteExtension
{
    AsnPerNormallySmallNonnegativeWholeNumber ExtensionNumber;
    // the present bits of the setup extension      
    UINT8 callIdentifierPresent:1 = this.ToBitString;
    switch
    {
        case PERSmallNumber >= 1: UINT8 tokensPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 2: UINT8 cryptoTokensPresent:1;
    }
    
    switch
    {
        case PERSmallNumber >= 3: UINT8 busyAddressPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 4: UINT8 presentationIndicatorPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 5: UINT8 screeningIndicatorPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 6: UINT8 capacityPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 7: UINT8 serviceControlPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 8: UINT8 featureSetPresent:1;
    } 
    
     // the content of the extension
    switch
    {
        case callIdentifierPresent: 
		         struct CallIdentifier = callIdentifier.ToString
		         {
		             AsnPerLengthDeterminant length;
		             [CallIdentifierEndOffset = FrameOffset + PERLengthValue]
		             CallIdentifier callIdentifier;
		             switch
                 {
                     case FrameBitOffset < CallIdentifierEndOffset * 8: 
                          AsnPerPadding(CallIdentifierEndOffset * 8 - FrameBitOffset) Padding;
                 }
		         };
    }
    
    switch
    {
        case tokensPresent: 
		         struct Tokens 
		         {
		             AsnPerLengthDeterminant length;
    	           [TokensEndOffset = FrameOffset + PERLengthValue, post.TokensCount = PERLengthValue]
    	           AsnPerLengthDeterminant size;
    	           while [ TokensCount > 0 ]
    	           {
    	               [ TokensCount = TokensCount - 1 ]
    	               H235ClearToken clearToken;
    	           }
    	           switch
                 {
                     case FrameBitOffset < TokensEndOffset * 8: 
                          AsnPerPadding(TokensEndOffset * 8 - FrameBitOffset) Padding;
                 }
		         };
    }
    
    switch
    {
        case cryptoTokensPresent: 
		         struct CryptoTokens 
		         {
		             AsnPerLengthDeterminant length;
    	           [CryptoTokensEndOffset = FrameOffset + PERLengthValue, post.CryptoTokensCount = PERLengthValue]
    	           AsnPerLengthDeterminant size;
    	           while [ CryptoTokensCount > 0 ]
    	           {
    	               [ CryptoTokensCount = CryptoTokensCount - 1 ]
    	               H235CryptoH323Token CryptoToken;
    	           }
    	           switch
                 {
                     case FrameBitOffset < CryptoTokensEndOffset * 8: 
                          AsnPerPadding(CryptoTokensEndOffset * 8 - FrameBitOffset) Padding;
                 }
		         };
    }
    
    switch
    {
        case busyAddressPresent: 
		         struct BusyAddress 
		         {
		             AsnPerLengthDeterminant length;
    	           [BusyAddressEndOffset = FrameOffset + PERLengthValue, post.BusyAddressCount = PERLengthValue]
    	           AsnPerLengthDeterminant size;
    	           while [ BusyAddressCount > 0 ]
    	           {
    	               [ BusyAddressCount = BusyAddressCount - 1 ]
    	               AliasAddress busyAddress;
    	           }
    	           switch
                 {
                     case FrameBitOffset < BusyAddressEndOffset * 8: 
                          AsnPerPadding(BusyAddressEndOffset * 8 - FrameBitOffset) Padding;
                 }
		         };
    }
    
    switch
    {
        case presentationIndicatorPresent: 
		         struct PresentationIndicator = presentationIndicator.ToString
		         {
		             AsnPerLengthDeterminant length;
		             [PresentationIndicatorEndOffset = FrameOffset + PERLengthValue]
		             PresentationIndicator presentationIndicator;
		             switch
                 {
                     case FrameBitOffset < PresentationIndicatorEndOffset * 8: 
                          AsnPerPadding(PresentationIndicatorEndOffset * 8 - FrameBitOffset) Padding;
                 }
		         };
    }
    
    switch
    {
        case screeningIndicatorPresent: 
		         struct PresentationIndicator = screeningIndicator.ToString
		         {
		             AsnPerLengthDeterminant length;
		             [ScreeningIndicatorEndOffset = FrameOffset + PERLengthValue]
		             ScreeningIndicator screeningIndicator;
		             switch
                 {
                     case FrameBitOffset < ScreeningIndicatorEndOffset * 8: 
                          AsnPerPadding(ScreeningIndicatorEndOffset * 8 - FrameBitOffset) Padding;
                 }
		         };
    }   
    
    switch
    {
        case capacityPresent: 
		         struct PresentationIndicator = capacity.ToString
		         {
		             AsnPerLengthDeterminant length;
		             [CapacityEndOffset = FrameOffset + PERLengthValue]
		             CallCapacity capacity;
		             switch
                 {
                     case FrameBitOffset < CapacityEndOffset * 8: 
                          AsnPerPadding(CapacityEndOffset * 8 - FrameBitOffset) Padding;
                 }
		         };
    }   
    
    switch
    {
        case serviceControlPresent: 
		         struct ServiceControl 
		         {
		             AsnPerLengthDeterminant length;
    	           [ServiceControlEndOffset = FrameOffset + PERLengthValue, post.ServiceControlCount = PERLengthValue]
    	           AsnPerLengthDeterminant size;
    	           while [ ServiceControlCount > 0 ]
    	           {
    	               [ ServiceControlCount = ServiceControlCount - 1 ]
    	               ServiceControlSession serviceControl;
    	           }
    	           switch
                 {
                     case FrameBitOffset < ServiceControlEndOffset * 8: 
                          AsnPerPadding(ServiceControlEndOffset * 8 - FrameBitOffset) Padding;
                 }
		         };
    }
    
    switch
    {
        case featureSetPresent: 
		         struct PresentationIndicator = featureSet.ToString
		         {
		             AsnPerLengthDeterminant length;
		             [FeatureSetEndOffset = FrameOffset + PERLengthValue]
		             FeatureSet featureSet;
		             switch
                 {
                     case FrameBitOffset < FeatureSetEndOffset * 8: 
                          AsnPerPadding(FeatureSetEndOffset * 8 - FrameBitOffset) Padding;
                 }
		         };
    }   
}

[DataTypeBitAlign]
struct ReleaseCompleteReason   // CHOICE  
{
	  UINT8 ReleaseCompleteReasonExtension:1;
    switch
    {
        case ReleaseCompleteReasonExtension:
             _struct ExtensionChoice
             {
                 AsnPerNormallySmallNonnegativeWholeNumber ChoiceValue = H225ReleaseCompleteReasonExtensionTable( ConstrainedValue );
                 AsnPerLengthDeterminant Length;
                 [ExtensionEndoffset = FrameOffset + PERLengthValue]
                 switch( PERSmallNumber )
                 {
                     case  5: NonStandardParameter nonStandardReason;
                     case  6: AsnPerGUID replaceWithConferenceInvite;
                     case 11: SecurityErrors SecurityError;
                 }
                 switch
                 {
                     case FrameBitOffset < ExtensionEndoffset * 8: AsnPerPadding(ExtensionEndoffset * 8 - FrameBitOffset) padding;
                 }
             };
        default:
             _struct NoneExtension
             {
                 AsnPerConstrainedInteger(0,11) ChoiceValue = H225ReleaseCompleteReasonTable( ConstrainedValue );             	   
             }    
    }                 
}

[DataTypeBitAlign]
struct InformationExtension
{
    AsnPerNormallySmallNonnegativeWholeNumber ExtensionNumber;
    // the present bits of the setup extension      
    UINT8 callIdentifierPresent:1 = this.ToBitString;
    switch
    {
        case PERSmallNumber >= 1: UINT8 tokensPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 2: UINT8 cryptoTokensPresent:1;
    } 
    switch
    {
        case PERSmallNumber >= 3: UINT8 fastStartPresent:1;
    }  
    switch
    {
        case PERSmallNumber >= 4: UINT8 fastConnectRefusedPresent:1;
    } 
    switch
    {
        case PERSmallNumber >= 5: UINT8 circuitInfoPresent:1;
    }  
    
    // the content of the extension
    switch
    {
        case callIdentifierPresent: 
		         struct CallIdentifier = CallIdentifier.ToString
		         {
		             AsnPerLengthDeterminant length;
		             [CallIdentifierEndOffset = FrameOffset + PERLengthValue]
		             CallIdentifier callIdentifier;
		             switch
                 {
                     case FrameBitOffset < CallIdentifierEndOffset * 8: 
                          AsnPerPadding(CallIdentifierEndOffset * 8 - FrameBitOffset) Padding;
                 }
		         };
    }
    
    switch
    {
        case tokensPresent: 
		         struct Tokens 
		         {
		             AsnPerLengthDeterminant length;
    	           [TokensEndOffset = FrameOffset + PERLengthValue, post.TokensCount = PERLengthValue]
    	           AsnPerLengthDeterminant size;
    	           while [ TokensCount > 0 ]
    	           {
    	               [ TokensCount = TokensCount - 1 ]
    	               H235ClearToken clearToken;
    	           }
    	           switch
                 {
                     case FrameBitOffset < TokensEndOffset * 8: 
                          AsnPerPadding(TokensEndOffset * 8 - FrameBitOffset) Padding;
                 }
		         };
    }
    
    switch
    {
        case cryptoTokensPresent: 
		         struct CryptoTokens 
		         {
		             AsnPerLengthDeterminant length;
    	           [CryptoTokensEndOffset = FrameOffset + PERLengthValue, post.CryptoTokensCount = PERLengthValue]
    	           AsnPerLengthDeterminant size;
    	           while [CryptoTokensCount > 0]
    	           {
    	               [CryptoTokensCount = CryptoTokensCount - 1]
    	               H235CryptoH323Token CryptoToken;
    	           }
    	           switch
                 {
                     case FrameBitOffset < CryptoTokensEndOffset * 8: 
                          AsnPerPadding(CryptoTokensEndOffset * 8 - FrameBitOffset) Padding;
                 }
		         };
    }
    
    switch
    {
        case fastStartPresent:
             struct fastStart
             {
                 AsnPerLengthDeterminant Length;
                 [FastStartEndOffset = FrameOffset+PERLengthValue, post.fastStartCount = PERLengthValue]
                 AsnPerLengthDeterminant Size;
                 while [ fastStartCount > 0 ]
                 {
                     [fastStartCount = fastStartCount - 1]
                     AsnPerOctetString(-1,-1) fastStart;
                 }
                 switch
                 {
                     case Framebitoffset< FastStartEndOffset * 8:
                          AsnPerPadding(FastStartEndOffset * 8-FrameBitOffset) Padding;
                 }
             };
    }
    
    switch
    {
        case fastConnectRefusedPresent:  // NULL
             // NOTICE HERE: How to handle this NULL  
             struct FastConnectRefused
             {
                 AsnPerLengthDeterminant length; 
                 BLOB(PERLengthValue) Value;
             };
    }
    
    switch
    {
        case circuitInfoPresent: 
		         struct CircuitInfo 
		         {
		             AsnPerLengthDeterminant length;
		             [CircuitInfoEndOffset = FrameOffset + PERLengthValue]
		             CircuitInfo circuitInfo;
		             switch
                 {
                     case FrameBitOffset < CircuitInfoEndOffset * 8: 
                          AsnPerPadding(CircuitInfoEndOffset * 8 - FrameBitOffset) Padding;
                 }
		         };
    }
}

[DataTypeBitAlign]
struct AlertingExtension
{
    AsnPerNormallySmallNonnegativeWholeNumber ExtensionNumber;
    UINT8 callIdentifierPresent:1;
    switch
    {
        case PERSmallNumber >= 1: UINT8 h245SecurityModePresent:1;
    }
    switch
    {
        case PERSmallNumber >= 2: UINT8 tokensPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 3: UINT8 cryptoTokensPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 4: UINT8 fastStartPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 5: UINT8 multipleCallsPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 6: UINT8 maintainConnectionPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 7: UINT8 alertingAddressPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 8: UINT8 presentationIndicatorPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 9: UINT8 screeningIndicatorPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 10: UINT8 fastConnectRefusedPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 11: UINT8 serviceControlPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 12: UINT8 capacityPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 13: UINT8 featureSetPresent:1;
    }
    
    switch
    {
        case callIdentifierPresent: 
		         struct CallID
		         {
		             AsnPerLengthDeterminant length;
		             CallIdentifier  callIdentifier;
		         };
		}
		
		switch
		{
		    case h245SecurityModePresent:
		         struct H245SecurityMode
		         {
		             AsnPerLengthDeterminant length;
		             H245Security h245SecurityMode; 
		         };        
    }
    
    switch
    {
        case tokensPresent:
             struct tokens
             {
                 AsnPerLengthDeterminant Length;
                 [post.TokenCount = PERLengthValue]
                 AsnPerLengthDeterminant Size;
                 while [ TokenCount > 0 ]
                 {
                     [ TokenCount = TokenCount - 1 ]
                     H235ClearToken token;
                 }
             };
    }
    
    switch
    {
        case cryptoTokensPresent:
             struct CryptoTokens
             {
                 AsnPerLengthDeterminant Length;
                 [post.CryptoTokenCount = PERLengthValue]
                 AsnPerLengthDeterminant Size;
                 while [ CryptoTokenCount > 0 ]
                 {
                     [ CryptoTokenCount = CryptoTokenCount  - 1 ]
                     H235CryptoH323Token CryptoToken;
                 }
             };
    }
    
    switch        
    {             
        case fastStartPresent:
             struct FastStart
             {    
                 AsnPerLengthDeterminant length;  
                 [FastStartEndOffset = FrameOffset + PERLengthValue, ConsumeFastStartCount = 0, post.fastStartCount = PERLengthValue]
                 AsnPerLengthDeterminant Size;
                 while [ConsumeFastStartCount < fastStartCount]
                 {
                      [ConsumeFastStartCount = ConsumeFastStartCount + 1]
                      AsnPerOctetString(-1,-1) fastStart;
                 }
                 switch                                                                     
                 {                                                                          
                     case FrameBitOffset < FastStartEndOffset * 8:                          
                          AsnPerPadding(FastStartEndOffset * 8 - FrameBitOffset) Padding;   
                 }                                                                          
            };
    }
    
    switch
    {
        case multipleCallsPresent: AsnPerBoolean(1) multipleCalls;
    }
    switch
    {
        case maintainConnectionPresent: AsnPerBoolean(1) maintainConnection;
    }
    
    switch
    {
        case alertingAddressPresent: 
             struct AlertingAddress
             {
                 AsnPerLengthDeterminant Length;
                 [post.AlertingAddressSize = PERLengthValue]
                 AsnPerLengthDeterminant Size;
                 while [ AlertingAddressSize > 0 ]
                 {
                     [ AlertingAddressSize = AlertingAddressSize - 1 ]
                     AliasAddress alertingAddress;
                 }
             };
    }
    
    switch
    {
        case presentationIndicatorPresent:
             struct PresentationIndicator
             {
                 AsnPerLengthDeterminant Length;
                 [PresentationIndicatorEndOffset = FrameOffset + PERLengthValue]
                 PresentationIndicator presentationIndicator;
                 switch
                 {
                     case FrameBitOffset < PresentationIndicatorEndOffset * 8: 
                          AsnPerPadding(PresentationIndicatorEndOffset * 8 - FrameBitOffset) Padding;
                 }
             };
    }
    
    switch
    {
        case screeningIndicatorPresent:
             struct ScreeningIndicator
             {
                 AsnPerLengthDeterminant Length;
                 [ScreeningIndicatorEndOffset = FrameOffset + PERLengthValue] 
                 ScreeningIndicator screeningIndicator;
                 switch
                 {
                     case FrameBitOffset < ScreeningIndicatorEndOffset * 8:
                          AsnPerPadding(ScreeningIndicatorEndOffset * 8 - FrameBitOffset) Padding;
                 }
             };
    }
    
    switch
    {
        case serviceControlPresent:
             struct ServiceControl
             {
                 AsnPerLengthDeterminant Length;
                 [post.ServiceControlCount = PERLengthValue, ServiceControlEndOffset = FrameOffset + PERLengthValue]
                 AsnPerLengthDeterminant Size;
                 while [ ServiceControlCount > 0 ]
                 {
                     [ ServiceControlCount = ServiceControlCount - 1 ]
                     ServiceControlSession ServiceControl;
                 }
                 switch
                 {
                     case FrameBitOffset < ServiceControlEndOffset * 8:
                          AsnPerPadding(ServiceControlEndOffset * 8 - FrameBitOffset) Padding;
                 }
             };
    }
    
    switch
    {
        case capacityPresent:
             struct Capacity
             {
                 AsnPerLengthDeterminant Length;
                 [CapacityEndOffset = FrameOffset + PERLengthValue]
                 CallCapacity capacity;
                 switch
                 {
                     case FrameBitOffset < CapacityEndOffset * 8:
                          AsnPerPadding( CapacityEndOffset * 8 - FrameBitOffset ) Padding;
                 }
             };
    }
    switch
    {
        case featureSetPresent:
             struct FeatureSet
             {
                 AsnPerLengthDeterminant Length;
                 [FeatureSetEndOffset = FrameOffset + PERLengthValue]
                 FeatureSet featureSet;
                 switch
                 {
                     case FrameBitOffset < FeatureSetEndOffset * 8:
                          AsnPerPadding( FeatureSetEndOffset * 8 - FrameBitOffset ) Padding;
                 }
             };
    }   
}

[DataTypeBitAlign]
struct ConnectExtension
{
    AsnPerNormallySmallNonnegativeWholeNumber ExtensionNumber;
    UINT8 callIdentifierPresent:1;
    switch
    {
        case PERSmallNumber >= 1: UINT8 h245SecurityModePresent:1;
    }
    switch
    {
        case PERSmallNumber >= 2: UINT8 tokensPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 3: UINT8 cryptoTokensPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 4: UINT8 fastStartPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 5: UINT8 multipleCallsPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 6: UINT8 maintainConnectionPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 7: UINT8 languagePresent:1;
    }
    switch
    {
        case PERSmallNumber >= 8: UINT8 connectedAddressPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 9: UINT8 presentationIndicatorPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 10: UINT8 screeningIndicatorPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 11: UINT8 fastConnectRefusedPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 12: UINT8 serviceControlPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 13: UINT8 capacityPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 14: UINT8 featureSetPresent:1;
    }
    
    switch
    {
        case callIdentifierPresent: 
		         struct callID = PERGUID
		         {
		             AsnPerLengthDeterminant length;
		             CallIdentifier  callIdentifier;
		         };
		}
		
		switch
		{
		    case h245SecurityModePresent:
		         struct h245SecurityMode
		         {
		             AsnPerLengthDeterminant length;
		             H245Security h245SecurityMode; 
		         };        
    }
    
    switch
    {
        case tokensPresent:
             struct tokens
             {
                 AsnPerLengthDeterminant Length;
                 [tokensEndOffest=FrameOffset+PERLengthValue, post.tokensCount = PERLengthValue]
                 AsnPerLengthDeterminant size;
                 while [ tokensCount > 0 ]
                 {
                     [ tokensCount = tokensCount - 1 ]
                     H235ClearToken Token;
                 }
                 switch
                 {
                     case Framebitoffset< tokensEndOffest * 8:
                          AsnPerPadding(tokensEndOffest * 8-FrameBitOffset) Padding;
                 }   
                          
             };
    }
    
    switch
    {
        case cryptoTokensPresent:
             struct cryptoTokens
             {
                 AsnPerLengthDeterminant Length;
                 [cryptoTokensEndOffest=FrameOffset+PERLengthValue, post.cryptoTokensCount = PERLengthValue]
                 AsnPerLengthDeterminant size;
                 while [ cryptoTokensCount > 0 ]
                 {
                     [ cryptoTokensCount = cryptoTokensCount - 1 ]
                     H235CryptoH323Token cryptoToken;
                 }
                 switch
                 {
                     case Framebitoffset< cryptoTokensEndOffest * 8:
                          AsnPerPadding(cryptoTokensEndOffest * 8-FrameBitOffset) Padding;
                 }   
                          
             };
    }
    
    switch
    {
        case fastStartPresent:
             struct fastStart
             {
                 AsnPerLengthDeterminant Length;
                 [FastStartEndOffset = FrameOffset+PERLengthValue, post.fastStartCount = PERLengthValue]
                 AsnPerLengthDeterminant Size;
                 while [ fastStartCount > 0 ]
                 {
                     [fastStartCount = fastStartCount - 1]
                     AsnPerOctetString(-1,-1) fastStart;
                 }
                 switch
                 {
                     case Framebitoffset< FastStartEndOffset * 8:
                          AsnPerPadding(FastStartEndOffset * 8-FrameBitOffset) Padding;
                 }
             };
    }
    
    switch
    {
        case multipleCallsPresent: AsnPerBoolean(1) multipleCalls;
    }
    switch
    {
        case maintainConnectionPresent: AsnPerBoolean(1) maintainConnection;
    }
    switch
    {
        case languagePresent:
             struct language
             {
                 AsnPerLengthDeterminant Length;
                 [languageEndOffest=FrameOffset+PERLengthValue, post.languageCount = PERLengthValue]
                 AsnPerLengthDeterminant size;
                 while [ languageCount > 0 ]
                 {
                     [languageCount = languageCount - 1]
                     AsnPerIA5String(1, 32) Language = AsciiString(FrameData, OctetStringStartOffset, OCTETSTRINGLENGTH);
                 };
                 switch
                 {
                     case Framebitoffset< languageEndOffest * 8:
                          AsnPerPadding(languageEndOffest * 8-FrameBitOffset) Padding;
                 }      
             };
    }
    
    switch
    {
        case connectedAddressPresent:
             struct connectedAddress
             {
                 AsnPerLengthDeterminant Length;
                 [connectedAddressEndOffest=FrameOffset+PERLengthValue, post.connectedAddressCount = PERLengthValue]
                 AsnPerLengthDeterminant size;
                 while [ connectedAddressCount > 0 ]
                 {
                     [ connectedAddressCount = connectedAddressCount - 1 ]
                     AliasAddress ConnectedAddress;
                 }
                 switch
                 {
                     case Framebitoffset< connectedAddressEndOffest * 8:
                          AsnPerPadding(connectedAddressEndOffest * 8-FrameBitOffset) Padding;
                 }   
                          
             };
    }
    switch
		{
		    case presentationIndicatorPresent:
		         struct presentationIndicator
		         {
		             AsnPerLengthDeterminant length;
		             [presentationIndicatorEndOffest=FrameOffset+PERLengthValue]
		             PresentationIndicator presentationIndicator;
		             switch
                 {
                     case Framebitoffset< presentationIndicatorEndOffest * 8:
                          AsnPerPadding(presentationIndicatorEndOffest * 8-FrameBitOffset) Padding;
                 }  
		         };        
    }
    
    switch
		{
		    case screeningIndicatorPresent:
		         struct screeningIndicator
		         {
		             AsnPerLengthDeterminant length;
		             [screeningIndicatorEndOffest=FrameOffset+PERLengthValue]
		             ScreeningIndicator screeningIndicator;
		             switch
                 {
                     case Framebitoffset< screeningIndicatorEndOffest * 8:
                          AsnPerPadding(screeningIndicatorEndOffest * 8-FrameBitOffset) Padding;
                 }   
		         };        
    }
    
    switch
    {
        case fastConnectRefusedPresent: AsnPerNULL(1) FastConnectRefused;
    }
    
    switch
    {
        case serviceControlPresent:
             struct serviceControl
             {
                 AsnPerLengthDeterminant Length;
                 [serviceControlEndOffest=FrameOffset+PERLengthValue, post.serviceControlCount = PERLengthValue]
                 AsnPerLengthDeterminant size;
                 while [ serviceControlCount > 0 ]
                 {
                     [ serviceControlCount = serviceControlCount - 1 ]
                     ServiceControlSession ServiceControl;
                 }
                 switch
                 {
                     case Framebitoffset< serviceControlEndOffest * 8:
                          AsnPerPadding(serviceControlEndOffest * 8-FrameBitOffset) Padding;
                 }   
                          
             };
    }
    
    switch
		{
		    case capacityPresent:
		         struct capacity
		         {
		             AsnPerLengthDeterminant length;
		             [capacityEndOffest=FrameOffset+PERLengthValue]
		             CallCapacity capacity;		             
		             switch
                 {
                     case Framebitoffset< capacityEndOffest * 8:
                          AsnPerPadding(capacityEndOffest * 8-FrameBitOffset) Padding;
                 }    
		         };        
    }
    
    switch
		{
		    case featureSetPresent:
		         struct featureSet
		         {
		             AsnPerLengthDeterminant length;
		             [featureSetEndOffest=FrameOffset+PERLengthValue]
		             FeatureSet featureSet;
		             switch
                 {
                     case Framebitoffset< featureSetEndOffest * 8:
                          AsnPerPadding(featureSetEndOffest * 8-FrameBitOffset) Padding;
                 }     
		         };        
    }   
}

[DataTypeBitAlign]
struct CallType = ChoiceValue.ToString
{
     UINT8 callTypeExtension:1;
     AsnPerConstrainedInteger(0,3) ChoiceValue = H225CallTypeTable( ConstrainedValue );
}

[DataTypeBitAlign]
struct CallProceedingExtension
{
    AsnPerNormallySmallNonnegativeWholeNumber ExtensionNumber;
    UINT8 callIdentifierPresent:1;
    switch
    {
        case PERSmallNumber >= 1: UINT8 h245SecurityModePresent:1;
    }
    switch
    {
        case PERSmallNumber >= 2: UINT8 tokensPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 3: UINT8 cryptoTokensPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 4: UINT8 fastStartPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 5: UINT8 multipleCallsPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 6: UINT8 maintainConnectionPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 7: UINT8 fastConnectRefusedPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 8: UINT8 featureSetPresent:1;
    }
    
    
    switch
    {
        case callIdentifierPresent: 
		         struct CallID
		         {
		             AsnPerLengthDeterminant length;
		             [CallIdentifierEndOffset = FrameOffset + PERLengthValue]
		             CallIdentifier  callIdentifier;
		             switch
		             {
		                 case FrameBitOffset < CallIdentifierEndOffset * 8:
		                      AsnPerPadding( CallIdentifierEndOffset * 8 - FrameBitOffset) Padding;
		             }
		         };
		}
		
		switch
		{
		    case h245SecurityModePresent:
		         struct H245SecurityMode
		         {
		             AsnPerLengthDeterminant length;
		             [H245SecurityEndOffset = FrameOffset + PERLengthValue]
		             H245Security h245SecurityMode; 
		             switch
		             {
		                 case FrameBitOffset < H245SecurityEndOffset * 8:
		                      AsnPerPadding(H245SecurityEndOffset * 8 - FrameBitOffset) Padding;
		             }
		         };        
    }
    
    switch
    {
        case tokensPresent:
             struct tokens
             {
                 AsnPerLengthDeterminant Length;
                 [post.TokenCount = PERLengthValue, TokenEndOffset = FrameOffset + PERLengthValue]
                 AsnPerLengthDeterminant Size;
                 while [ TokenCount > 0 ]
                 {
                     [ TokenCount = TokenCount - 1 ]
                     H235ClearToken token;
                 }
                 switch
                 {
                     case FrameBitOffset < TokenEndOffset * 8:
                          AsnPerPadding( TokenEndOffset * 8 - FrameBitOffset) Padding;
                 }
             };
    }
    
    switch
    {
        case cryptoTokensPresent:
             struct CryptoTokens
             {
                 AsnPerLengthDeterminant Length;
                 [post.CryptoTokenCount = PERLengthValue, CryptoTokenEndOffset = FrameOffset + PERLengthValue]
                 AsnPerLengthDeterminant Size;
                 while [ CryptoTokenCount > 0 ]
                 {
                     [ CryptoTokenCount = CryptoTokenCount - 1 ]
                     H235CryptoH323Token CryptoToken;
                 }
                 switch
                 {
                     case FrameBitOffset < CryptoTokenEndOffset * 8: 
                          AsnPerPadding(CryptoTokenEndOffset * 8 - FrameBitOffset) Padding;
                 }
             };
    }
    
    switch
    {
        case fastStartPresent:
             struct fastStart
             {
                 AsnPerLengthDeterminant Length;
                 [FastStartEndOffset = FrameOffset+PERLengthValue, post.fastStartCount = PERLengthValue]
                 AsnPerLengthDeterminant Size;
                 while [ fastStartCount > 0 ]
                 {
                     [fastStartCount = fastStartCount - 1]
                     AsnPerOctetString(-1,-1) fastStart;
                 }
                 switch
                 {
                     case Framebitoffset< FastStartEndOffset * 8:
                          AsnPerPadding(FastStartEndOffset * 8-FrameBitOffset) Padding;
                 }
             };
    }
    
    
    switch
    {
        case multipleCallsPresent: AsnPerBoolean(1) multipleCalls;
    }
    switch
    {
        case maintainConnectionPresent: AsnPerBoolean(1) maintainConnection;
    }
    
    switch
    {
        case featureSetPresent: 
             struct FeatureSet
             {
                 AsnPerLengthDeterminant Length;
                 [FeatureSetEndOffset = FrameOffset + PERLengthValue]
                 FeatureSet featureSet;
                 switch
                 {
                     case FrameBitOffset < FeatureSetEndOffset * 8:
                          AsnPerPadding( FeatureSetEndOffset * 8 - FrameBitOffset) Padding;
                 }
             };
    }
}

[DataTypeBitAlign]
struct SetupExtension
{   
    AsnPerNormallySmallNonnegativeWholeNumber ExtensionNumber;
    // the present bits of the setup extension      
    UINT8 sourceCallSignalAddressPresent:1 = this.ToBitString;
    switch
    {
        case PERSmallNumber >= 1: UINT8 remoteExtensionAddressPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 2: UINT8 callIdentifierPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 3: UINT8 h245SecurityCapabilityPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 4: UINT8 tokensPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 5: UINT8 cryptoTokensPresent:1;
    }
    switch
    { 
        case PERSmallNumber >= 6: UINT8 fastStartPresent:1;
    } 
    switch
    { 
        case PERSmallNumber >= 7: UINT8 mediaWaitForConnectPresent:1;
    } 
    switch
    {
        case PERSmallNumber >= 8: UINT8 canOverlapSendPresent:1;
    }
    switch
    {  
        case PERSmallNumber >= 9: UINT8 endpointIdentifierPresent:1;
    }  
    switch
    {  
        case PERSmallNumber >= 10: UINT8 multipleCallsPresent:1;
    }  
    switch
    {
        case PERSmallNumber >= 11: UINT8 maintainConnectionPresent:1;
    }
    switch
    {   
        case PERSmallNumber >= 12: UINT8 connectionParametersPresent:1;
    }   
    switch
    {   
        case PERSmallNumber >= 13: UINT8 languagePresent:1;
    }   
    switch
    {
        case PERSmallNumber >= 14: UINT8 presentationIndicatorPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 15: UINT8 screeningIndicatorPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 16: UINT8 serviceControlPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 17: UINT8 symmetricOperationRequiredPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 18: UINT8 capacityPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 19: UINT8 circuitInfoPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 20: UINT8 desiredProtocolsPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 21: UINT8 neededFeaturesPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 22: UINT8 desiredFeaturesPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 23: UINT8 supportedFeaturesPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 24: UINT8 parallelH245ControlPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 25: UINT8 additionalSourceAddressesPresent:1;
    }
    switch
    {
        case PERSmallNumber >= 26: UINT8 hopCountPresent:1;
    }

    // the content of the extension
    switch
    {
        case sourceCallSignalAddressPresent: 
		         struct SourceCallSignalAddress = sourceCallSignalAddress.ToString
		         {
		             AsnPerLengthDeterminant length;
		             [SourceCallSignalAddressEndOffset = FrameOffset + PERLengthValue]
		             TransportAddress sourceCallSignalAddress;
		             switch
                 {
                     case FrameBitOffset < SourceCallSignalAddressEndOffset * 8: 
                          AsnPerPadding(SourceCallSignalAddressEndOffset * 8 - FrameBitOffset) Padding;
                 }
		         };
    }
    
    switch
    {
        case remoteExtensionAddressPresent: 
		         struct RemoteExtensionAddress = remoteExtensionAddress.ToString
		         {
		             AsnPerLengthDeterminant length;
		             [RemoteExtensionAddressEndOffset = FrameOffset + PERLengthValue]
		             AliasAddress remoteExtensionAddress;
		             switch
                 {
                     case FrameBitOffset < RemoteExtensionAddressEndOffset * 8: 
                          AsnPerPadding(RemoteExtensionAddressEndOffset * 8 - FrameBitOffset) Padding;
                 }
		         };
    }

    switch
    {
        case callIdentifierPresent: 
		         struct CallID = PERGUID
		         {
		             AsnPerLengthDeterminant length;
		             [CallIDEndOffset = FrameOffset + PERLengthValue]
		             CallIdentifier  callIdentifier;
		             switch
                 {
                     case FrameBitOffset < CallIDEndOffset * 8: 
                          AsnPerPadding(CallIDEndOffset * 8 - FrameBitOffset) Padding;
                 }
		         };
    }

    switch 
    {
        case h245SecurityCapabilityPresent:
             struct H245SecurityCapability
    	       {
    	           AsnPerLengthDeterminant length;
    	           [H245SecurityCapabilityEndOffset = FrameOffset + PERLengthValue, post.H245SecurityCapabilityCount = PERLengthValue]
    	           AsnPerLengthDeterminant size;
    	           while [ H245SecurityCapabilityCount > 0 ]
    	           {
    	               [ H245SecurityCapabilityCount = H245SecurityCapabilityCount  - 1 ]
    	               H245Security h245Security;
    	           }
    	           switch
                 {
                     case FrameBitOffset < H245SecurityCapabilityEndOffset * 8: 
                          AsnPerPadding(H245SecurityCapabilityEndOffset * 8 - FrameBitOffset) Padding;
                 }
    	       };
    }
    
    switch 
    {
        case tokensPresent:
             struct ClearTokens
             {
    	           AsnPerLengthDeterminant length;
    	           [ClearTokenEndOffset = FrameOffset + PERLengthValue, post.ClearTokenCount = PERLengthValue]
    	           AsnPerLengthDeterminant size;
    	           while [ ClearTokenCount > 0 ]
    	           {
    	               [ ClearTokenCount = ClearTokenCount - 1 ]
    	               H235ClearToken clearToken;
    	           }
    	           switch
                 {
                     case FrameBitOffset < ClearTokenEndOffset * 8: 
                          AsnPerPadding(ClearTokenEndOffset * 8 - FrameBitOffset) Padding;
                 }           
             };
    }
    
    switch 
    {
        case cryptoTokensPresent:
             struct CryptoH323Tokens
             {
             	   AsnPerLengthDeterminant length;
             	   [CryptoH323TokenEndOffset = FrameOffset + PERLengthValue, post.CryptoH323TokenCount = PERLengthValue]
             	   AsnPerLengthDeterminant size;
             	   while [ CryptoH323TokenCount > 0 ]
             	   {
             	       [ CryptoH323TokenCount = CryptoH323TokenCount - 1 ]
             	       H235CryptoH323Token cryptoH323Token;
             	   }
             	   switch
                 {
                     case FrameBitOffset < CryptoH323TokenEndOffset * 8: 
                          AsnPerPadding(CryptoH323TokenEndOffset * 8 - FrameBitOffset) Padding;
                 }    
             };
    }

    switch
    {
        case fastStartPresent:
             struct FastStart
             {
                 AsnPerLengthDeterminant Length;
                 [FastStartEndOffset = FrameOffset+PERLengthValue, post.fastStartCount = PERLengthValue]
                 AsnPerLengthDeterminant Size;
                 while [ fastStartCount > 0 ]
                 {
                     [fastStartCount = fastStartCount - 1]
                     AsnPerOctetString(-1,-1) fastStart;
                 }
                 switch
                 {
                     case Framebitoffset< FastStartEndOffset * 8:
                          AsnPerPadding(FastStartEndOffset * 8-FrameBitOffset) Padding;
                 }
             };
    }

    switch
    {
        case mediaWaitForConnectPresent: AsnPerBoolean(1) mediaWaitForConnect;
    }
    
    switch
    {
        case canOverlapSendPresent: AsnPerBoolean(1) canOverlapSend;
    }

    switch 
    {
        case endpointIdentifierPresent:
             struct EndpointIdentifier = endpointIdentifier.ToString
             {
              	 AsnPerLengthDeterminant length;
             	   [EndpointIdentifierEndOffset = FrameOffset + PERLengthValue]
             	   AsnPerBMPString(1, 128) endpointIdentifier;
             	   switch
                 {
                     case FrameBitOffset < FastStartEndOffset * 8: 
                          AsnPerPadding(FastStartEndOffset * 8 - FrameBitOffset) Padding;
                 }  
             };
    }      
           
    switch
    {
        case multipleCallsPresent: AsnPerBoolean(1) multipleCalls;
    }
    
    switch
    {
        case maintainConnectionPresent: AsnPerBoolean(1) maintainConnection;
    }

    switch 
    {
        case connectionParametersPresent: 
             struct ConnectionParameters // SEQUENCE
             {
             	   AsnPerLengthDeterminant length;
             	   [ConnectionParametersEndOffset = FrameOffset + PERLengthValue]
                 UINT8 ConnectionParametersExtension:1;
                 ScnConnectionType connectionType;
                 AsnPerConstrainedInteger(0, 65535) NumberOfScnConnections;
		             ScnConnectionAggregation connectionAggregation;
		             switch
                 {
                     case FrameBitOffset < ConnectionParametersEndOffset * 8: 
                          AsnPerPadding(ConnectionParametersEndOffset * 8 - FrameBitOffset) Padding;
                 }
                 // Maybe some extension fields here... 
                 // TODO: How to handle the padding here????
             }
    }    
         
    switch
    {
        case languagePresent:
             struct language
             {
                 AsnPerLengthDeterminant Length;
                 [languageEndOffest=FrameOffset+PERLengthValue, post.languageCount = PERLengthValue]
                 AsnPerLengthDeterminant size;
                 while [ languageCount > 0 ]
                 {
                     [languageCount = languageCount - 1]
                     AsnPerIA5String(1, 32) Language = AsciiString(FrameData, OctetStringStartOffset, OCTETSTRINGLENGTH);
                 };
                 switch
                 {
                     case Framebitoffset< languageEndOffest * 8:
                          AsnPerPadding(languageEndOffest * 8-FrameBitOffset) Padding;
                 }      
             };
    }

    switch 
    {
        case presentationIndicatorPresent:
             struct PresentationIndicator = presentationIndicator.ToString
             {
             	   AsnPerLengthDeterminant length;
             	   [PresentationIndicatorEndOffset = FrameOffset + PERLengthValue]
             	   PresentationIndicator presentationIndicator;
             	   switch
                 {
                     case FrameBitOffset < PresentationIndicatorEndOffset * 8: 
                          AsnPerPadding(PresentationIndicatorEndOffset * 8 - FrameBitOffset) Padding;
                 }
             };
    }

    switch 
    {
        case screeningIndicatorPresent: 
             struct ScreeningIndicator = presentationIndicator.ToString
             {
             	   AsnPerLengthDeterminant length;
             	   [ScreeningIndicatorEndOffset = FrameOffset + PERLengthValue]
             	   ScreeningIndicator screeningIndicator;
             	   switch
                 {
                     case FrameBitOffset < ScreeningIndicatorEndOffset * 8: 
                          AsnPerPadding(ScreeningIndicatorEndOffset * 8 - FrameBitOffset) Padding;
                 }
             };
    }

    switch 
    {
        case serviceControlPresent: 
             struct ServiceControlSession
             {
             	   AsnPerLengthDeterminant length;
             	   [ServiceControlSessionEndOffset = FrameOffset + PERLengthValue, post.ServiceControlSessionCount = PERLengthValue]
             	   AsnPerLengthDeterminant size;
             	   while [ ServiceControlSessionCount > 0 ]
             	   {
             	       [ ServiceControlSessionCount = ServiceControlSessionCount - 1 ]
             	       ServiceControlSession serviceControlSession;
             	   }
             	   switch
                 {
                     case FrameBitOffset < ServiceControlSessionEndOffset * 8: 
                          AsnPerPadding(ServiceControlSessionEndOffset * 8 - FrameBitOffset) Padding;
                 }
             };
    }

    switch 
    {
    	  // symmetricOperationRequired	NULL OPTIONAL,
        case symmetricOperationRequiredPresent:
             _struct symmetricOperationRequired
             {
                 AsnPerLengthDeterminant length;
                 switch
                 {
                     case PERLengthValue>0: AsnPerPadding(PERLengthValue * 8 ) padding;
                 }
             }         
             
    }

    switch 
    {
        case capacityPresent:
             struct Capacity = capacity.ToString
             {
             	   AsnPerLengthDeterminant length;
             	   [CapacityEndOffset = FrameOffset + PERLengthValue]
             	   CallCapacity capacity;
             	   switch
                 {
                     case FrameBitOffset < CapacityEndOffset * 8: 
                          AsnPerPadding(CapacityEndOffset * 8 - FrameBitOffset) Padding;
                 }
             };
    }

    switch 
    {
        case circuitInfoPresent:
             struct CircuitInfo = circuitInfo.ToString
             {
             	   AsnPerLengthDeterminant length;
             	   [CircuitInfoEndOffset = FrameOffset + PERLengthValue]
             	   CircuitInfo circuitInfo;
             	   switch
                 {
                     case FrameBitOffset < CircuitInfoEndOffset * 8: 
                          AsnPerPadding(CircuitInfoEndOffset * 8 - FrameBitOffset) Padding;
                 }
             };
    }

    switch 
    {
        case desiredProtocolsPresent:
             struct DesiredProtocols
             {
             	   AsnPerLengthDeterminant length;
             	   [DesiredProtocolsEndOffset = FrameOffset + PERLengthValue, post.DesiredProtocolsCount = PERLengthValue]
             	   AsnPerLengthDeterminant size;
             	   // TODO
             	   while [ DesiredProtocolsCount > 0 ]
             	   {
             	       [ DesiredProtocolsCount = DesiredProtocolsCount - 1 ]
             	       SupportedProtocols protocol;
             	   }
             	   switch
                 {
                     case FrameBitOffset < DesiredProtocolsEndOffset * 8: 
                          AsnPerPadding(DesiredProtocolsEndOffset * 8 - FrameBitOffset) Padding;
                 }
             };
    }

    switch 
    {
        case neededFeaturesPresent: 
             struct NeededFeatures
             {
             	   AsnPerLengthDeterminant length;
             	   [NeededFeaturesEndOffset = FrameOffset + PERLengthValue, post.NeededFeaturesCount = PERLengthValue]
             	   AsnPerLengthDeterminant size;
             	   while [ NeededFeaturesCount > 0 ]
             	   {
             	       [NeededFeaturesCount = NeededFeaturesCount - 1]
             	       GenericData feature;
             	   }
             	   switch
                 {
                     case FrameBitOffset < NeededFeaturesEndOffset * 8: 
                          AsnPerPadding(NeededFeaturesEndOffset * 8 - FrameBitOffset) Padding;
                 }
             };
    }

    switch 
    {
        case desiredFeaturesPresent:
             struct DesiredFeatures
             {
             	   AsnPerLengthDeterminant length;
             	   [DesiredFeaturesEndOffset = FrameOffset + PERLengthValue, post.DesiredFeaturesCount = PERLengthValue]
             	   AsnPerLengthDeterminant size;
             	   while [ DesiredFeaturesCount > 0 ]
             	   {
             	       [ DesiredFeaturesCount = DesiredFeaturesCount - 1 ]
             	       GenericData feature;
             	   }
             	   switch
                 {
                     case FrameBitOffset < DesiredFeaturesEndOffset * 8: 
                          AsnPerPadding(DesiredFeaturesEndOffset * 8 - FrameBitOffset) Padding;
                 } 
             };
    }

    switch 
    {
        case supportedFeaturesPresent: 
             struct SupportedFeatures
             {
             	   AsnPerLengthDeterminant length;
             	   [SupportedFeaturesEndOffset = FrameOffset + PERLengthValue, post.SupportedFeaturesCount = PERLengthValue]
             	   AsnPerLengthDeterminant size;
             	   while [SupportedFeaturesCount > 0]
             	   {
             	       [SupportedFeaturesCount = SupportedFeaturesCount - 1]
             	       GenericData feature;
             	   }
             	   switch
                 {
                     case FrameBitOffset < SupportedFeaturesEndOffset * 8: 
                          AsnPerPadding(SupportedFeaturesEndOffset * 8 - FrameBitOffset) Padding;
                 }  
             };
    }

    switch 
    {
        case parallelH245ControlPresent: 
             struct ParallelH245Control
             {
                 AsnPerLengthDeterminant length;
                 [ParallelH245ControlEndOffset = FrameOffset + PERLengthValue, post.ParallelH245ControlCount = PERLengthValue]
                 AsnPerLengthDeterminant size;
                 while [ ParallelH245ControlCount > 0 ]
                 {
                     [ ParallelH245ControlCount = ParallelH245ControlCount - 1 ]
             	       AsnPerOctetString(-1,-1) parallelH245Control;
             	   }
             	   switch
                 {
                     case FrameBitOffset < ParallelH245ControlEndOffset * 8: 
                          AsnPerPadding(ParallelH245ControlEndOffset * 8 - FrameBitOffset) Padding;
                 }   
                 //# [ConsumeFastStartCount = 0, post.fastStartCount = PER_LengthValue]
                 //# AsnPerLengthDeterminant Size;
                 //# while [ConsumeFastStartCount < fastStartCount]
                 //# {
                 //#     [ConsumeFastStartCount = ConsumeFastStartCount + 1]
                 //#     AsnPerOctetString(-1,-1) parallelH245Control;
                 //# }
             };   
    }             
                  
    switch        
    {              
        case additionalSourceAddressesPresent: 
             struct AdditionalSourceAddresses
             {     
             	   AsnPerLengthDeterminant length;
             	   [AdditionalSourceAddressesEndOffset = FrameOffset + PERLengthValue, post.AdditionalSourceAddressesCount = PERLengthValue]
                 AsnPerLengthDeterminant size;
             	   // TODO
             	   while [ AdditionalSourceAddressesCount > 0 ]
             	   {
             	       [ AdditionalSourceAddressesCount = AdditionalSourceAddressesCount - 1 ]
             	       ExtendedAliasAddress address;
             	   }
             	   switch
                 {
                     case FrameBitOffset < AdditionalSourceAddressesEndOffset * 8: 
                          AsnPerPadding(AdditionalSourceAddressesEndOffset * 8 - FrameBitOffset) Padding;
                 }   
             };
    }
}

[DataTypeBitAlign]
struct ConferenceGoal = ConferenceGoalDes
{
    UINT8 conferenceGoalExtension:1;
    switch
    {
        case conferenceGoalExtension:
             _struct ExtensionChoice
             {
                     [ConferenceGoalDes = this.ToString]
                     AsnPerNormallySmallNonnegativeWholeNumber ChoiceValue = H225ConferenceGoalExtensionTable(PERSmallNumber);
                     AsnPerLengthDeterminant Length;
                     [ConferenceGoalExtensionEndOffset = FrameOffset + PERLengthValue]
                     switch
                     {
                         case FrameBitOffset < ConferenceGoalExtensionEndOffset * 8:
                         AsnPerPadding( ConferenceGoalExtensionEndOffset * 8 - FrameBitOffset) Padding;
                     }
             };
        default:
             _struct NoneExtension
             {
                 [ConferenceGoalDes = this.ToString]
                 AsnPerConstrainedInteger(0,2) ChoiceValue = H225ConferenceGoalTable( ConstrainedValue );
             }
    }
}

[DataTypeBitAlign]
struct EndpointType
{
    UINT8 EndpointTypeExtension:1;
    UINT8 nonStandardDataPresent:1;
    UINT8 vendorPresent:1;
    UINT8 gatekeeperPresent:1;
    UINT8 gatewayPresent:1;
    UINT8 mcuPresent:1;
    UINT8 terminalPresent:1;
    switch
    {
        case nonStandardDataPresent: NonStandardParameter nonStandardData; 
    }
    switch
    {
        case vendorPresent: struct vendor = FormatString("%s%s",
                                                          productIdPresent ? ( "product id: " + productId.ToString ) : "",
                                                          versionIdPresent ? ( ", version id: " + versionId.ToString ) : "")
                             {
                                 UINT8 VendorIdentifierExtension:1;
                                 UINT8 productIdPresent:1;
                                 UINT8 versionIdPresent:1;
                                 H221NonStandard vendor;
    	                           switch
    	                           {
    	                               case productIdPresent: 
    	                               AsnPerOctetString(1,256) productId = AsciiString(FrameData, OctetStringStartOffset , OCTETSTRINGLENGTH);
    	                           }
    	                           switch
    	                           {
    	                               case versionIdPresent: 
    	                               AsnPerOctetString(1,256) versionId = AsciiString(FrameData, OctetStringStartOffset , OCTETSTRINGLENGTH);
    	                           }
                             };
    }
    switch
    {
        case gatekeeperPresent: struct gatekeeper
                                 {
                                     UINT8 gatekeeperExtension:1;
                                     UINT8 nonStandardDataPresent:1;
                                     switch
                                     {
                                         case nonStandardDataPresent: NonStandardParameter nonStandardData;
                                     }
                                 };
    }
    switch
    {
        case gatewayPresent: struct gateway
                              {
                                  UINT8 gatewayExtension:1;
                                  UINT8 protocolPresent:1;
                                  UINT8 nonStandardDataPresent:1;
                                  switch
                                  {
                                      case protocolPresent:
                                           struct protocol
                                           {
                                               [post.protocolCount=PERLengthValue]
                                               AsnPerLengthDeterminant length;
                                               while [ protocolCount > 0 ]
                                               {
                                                   [ protocolCount = protocolCount - 1 ]
                                                   SupportedProtocols Protocol;
                                               }
                                           }
                                  }
                                  switch
                                  {
                                      case nonStandardDataPresent:
                                           NonStandardParameter nonStandardData;
                                  }
                              };
    }
    switch
    {
        case mcuPresent: struct mcu
                          {
                              UINT8 mcuExtensionBit:1;
                              UINT8 nonStandardDataPresent:1;
                              switch
                              {
                                  case nonStandardDataPresent: NonStandardParameter nonStandardData;
                              }
                              switch
                              {
                                  case mcuExtensionBit:
                                       struct mcuExtension
                                       {
                                           AsnPerNormallySmallNonnegativeWholeNumber ExtensionNumber;
                                           UINT8 protocolPresent:1;
                                           switch
                                           {
                                                case protocolPresent:
                                                     struct protocol
                                                     {
                                                         AsnPerLengthDeterminant length;
                                                         [protocolEndoffset=Frameoffset+PERLengthValue, post.protocolCount=PERLengthValue]
                                                         AsnPerLengthDeterminant size;
                                                         while [ protocolCount > 0 ]
                                                         {
                                                             [ protocolCount = protocolCount - 1 ]
                                                             SupportedProtocols Protocol;
                                                         }
                                                         switch
                                                         {
                                                             case FrameBitOffset < protocolEndoffset * 8: 
                                                                  AsnPerPadding(protocolEndoffset * 8 - FrameBitOffset) padding;
                                                         }
                                                     }
                                           }
                                       }                   
                              }        
                          };
    }
    switch
    {
        case terminalPresent: struct terminal
                               {
                                   UINT8 terminalExtension:1;
                                   UINT8 nonStandardDataPresent:1;
                                   switch
                                   {
                                       case nonStandardDataPresent: NonStandardParameter nonStandardData;
                                   }
                               };
    }
    AsnPerBoolean(0) mc;
    AsnPerBoolean(0) undefinedNode;
    switch
    {
        case EndpointTypeExtension:
             struct EndpointTypeExtension
             {
                 AsnPerNormallySmallNonnegativeWholeNumber ExtensionNumber;
                 UINT8 setPresent:1;
                 switch
                 {
                     case PERSmallNumber >= 1: UINT8 supportedTunnelledProtocolsPresent:1;
                 }
                 switch
                 {
                     case setPresent:
                          struct set
                          {
                              AsnPerLengthDeterminant length;
                              [setEndoffset=Frameoffset+PERLengthValue]
                              AsnPerBitString(32,32) Set;
                              switch
                              {
                                  case FrameBitOffset < setEndoffset * 8: AsnPerPadding(setEndoffset * 8 - FrameBitOffset) padding;
                              }
                          }
                 }
                 
                 switch
                 {
                     case supportedTunnelledProtocolsPresent:
                          struct supportedTunnelledProtocols 
                          {
                              AsnPerLengthDeterminant length;
                              [supportedTunnelledProtocolsEndoffset=Frameoffset+PERLengthValue, post.supportedTunnelledProtocolsCount=PERLengthValue]
                              AsnPerLengthDeterminant size;
                              while [ supportedTunnelledProtocolsCount > 0 ]
                              {
                                  [ supportedTunnelledProtocolsCount = supportedTunnelledProtocolsCount - 1 ]
                                  TunnelledProtocol SupportedTunnelledProtocol;
                              }
                              switch
                              {
                                  case FrameBitOffset < supportedTunnelledProtocolsEndoffset * 8: AsnPerPadding(supportedTunnelledProtocolsEndoffset * 8 - FrameBitOffset) padding;
                              }
                          }
                 }
             }
    }                       
}

[DataTypeBitAlign]
struct AliasAddress
{
    UINT8 AliasAddressExtension:1 = this ? "Extension value(s) present in AliasAddress " + this.ToBitString
    	                                   : "No Extension value(s) present in AliasAddress " + this.ToBitString;
    switch
    {
        case AliasAddressExtension:
             _struct ExtensionChoice
             {
                 AsnPerNormallySmallNonnegativeWholeNumber ChoiceValue;
                 AsnPerLengthDeterminant Length;
                 [ExtensionEndoffset = FrameOffset + PERLengthValue]
                 switch( PERSmallNumber )
                 {
        	           case 0: AsnPerIA5String(1, 512) urlID = AsciiString(FrameData, OctetStringStartOffset, OCTETSTRINGLENGTH);
        	           case 1: TransportAddress transportID;
        	           case 2: AsnPerIA5String(1, 512) emailID = AsciiString(FrameData, OctetStringStartOffset, OCTETSTRINGLENGTH); 
         	           case 3: PartyNumber partyNumber;
         	           case 4: MobileUIM mobileUIM;
                 }
                 switch
                 {
                     case FrameBitOffset < ExtensionEndoffset * 8: AsnPerPadding( ExtensionEndoffset * 8 - FrameBitOffset ) Padding;
                 }
             }
        default:
             _struct NoneExtension
             {
                 AsnPerConstrainedInteger(0,1) ChoiceValue;             	   
             	   switch (ConstrainedValue)
             	   {
                     case 0: 
                     AsnPerIA5String(1,128) dialedDigits = AsciiString(FrameData, OctetStringStartOffset, OCTETSTRINGLENGTH);
                     case 1: AsnPerBMPString(1,256) h323ID;
                 };        
             }  
     }               
}

[DataTypeBitAlign]
struct TransportAddress = TransportAdd
{
    UINT8 TransportAddressExtension:1 = this ? "Extension value(s) present in TransportAddress " + this.ToBitString
    	                                       : "No Extension value(s) present in TransportAddress " + this.ToBitString;
    AsnPerConstrainedInteger(0,6) ChoiceValue = H225TransportAddressTypeTable( ConstrainedValue );
    switch( ConstrainedValue )
    {
        case 0: 
                [TransportAdd = this.ToString]
                struct ipAddress = FormatString("%s:%d",ip.ToString, port)
                {
                    AsnPerAlign align;
                    IPv4Address ip;
                    UINT16 port;
                };
        case 1: 
                [TransportAdd = this.ToString]
                struct ipSourceRoute = FormatString("%s:%d, %d route, routing is %s",
                                                     ip.ToString,
                                                     port,
                                                     PERLengthValue,
                                                     routing.ToString)
                {
                    UINT8 ipSourceRouteExtension:1 = this ? "Extension value(s) present in ipSourceRoute " + this.ToBitString
                    	                                    : "No Extension value(s) present in ipSourceRoute " + this.ToBitString;
                    AsnPerAlign align;
                    IPv4Address ip;
                    UINT16 port;
                    AsnPerLengthDeterminant DeterminantLength;
                    IPv4Address route[PERLengthValue];
                    struct routing = ConstrainedValue ? "loose" : "strict"
                    {
                        UINT8 routingExtension:1 = this ? "Extension value(s) present in routing " + this.ToBitString
                        	                              : "No Extension value(s) present in routing " + this.ToBitString;
                        AsnPerConstrainedInteger(0,1) ChoiceValue = FormatString("%s%s", ConstrainedValue == 0 ? "loose" : "", ConstrainedValue == 1 ? "strict" : "");
                    };
                };
        case 2: 
                [TransportAdd = this.ToString]
                struct ipxAddress = FormatString("%s, %s, %s",
                                                 node.ToString,
                                                 netnum.ToString,
                                                 port.ToString)
                {
                    AsnPerAlign align;
                    AsnPerOctetString(6,6) node = IPXNodeFormatTable( this );
                    AsnPerOctetString(4,4) netnum = IPXNetworkNumberTable( this );
                    AsnPerOctetString(2,2) port = IPXSocketNumberTable( this );
                };
        case 3: 
                [TransportAdd = this.ToString]
                struct ip6Address = FormatString("%s:%d",ip.ToString, port)
                {
                    UINT8 ip6AddressExtension:1 = this ? "Extension value(s) present in ip6Address " + this.ToBitString
                    	                                 : "No Extension value(s) present in ip6Address " + this.ToBitString;
                    AsnPerAlign align;
                    IPv6Address ip;
                    UINT16 port;
                };
        case 4: AsnPerOctetString(16,16) netbios;
        case 5: AsnPerOctetString(1,20) nsap;
        case 6: NonStandardParameter nonStandardAddress;
    }
}

[DataTypeBitAlign]
struct NotifyUUIE
{
    UINT8 StatusUUIEExtension:1;
    UINT8 tokensPresent:1;
    UINT8 cryptoTokensPresent:1;
    
    AsnPerObjectIdentifier protocolIdentifier;
    CallIdentifier callIdentifier;
    switch
    {
       case tokensPresent: 
            struct Tokens
            {
                [post.TokenSize = PERLengthValue]
                AsnPerLengthDeterminant Size;
                while [ TokenSize > 0 ]
                {
                    [ TokenSize = TokenSize  - 1 ]
                    H235ClearToken token;
                }
            }; 
    }
    
    switch
    {
        case cryptoTokensPresent:
             struct CryptoTokens
             {
                [post.CryptoTokenSize = PERLengthValue]
                AsnPerLengthDeterminant Size;
                while [ CryptoTokenSize > 0 ]
                {
                    [ CryptoTokenSize = CryptoTokenSize - 1 ]
                    H235CryptoH323Token token;
                }
             };
    }
    
    //switch
    //{
    //   case Status_UUIE_Extension:
    //    ??? there may be some extensions
    //}
}

[DataTypeBitAlign]
struct SetupAcknowledgeUUIE
{
    UINT8 StatusUUIEExtension:1;
    UINT8 tokensPresent:1;
    UINT8 cryptoTokensPresent:1;
    
    AsnPerObjectIdentifier protocolIdentifier;
    CallIdentifier callIdentifier;
    switch
    {
       case tokensPresent: 
            struct Tokens
            {
                [post.TokenSize = PERLengthValue]
                AsnPerLengthDeterminant Size;
                while [ TokenSize > 0 ]
                {
                    [ TokenSize = TokenSize  - 1 ]
                    H235ClearToken token;
                }
            }; 
    }
    
    switch
    {
        case cryptoTokensPresent:
             struct CryptoTokens
             {
                [post.CryptoTokenSize = PERLengthValue]
                AsnPerLengthDeterminant Size;
                while [ CryptoTokenSize > 0 ]
                {
                    [ CryptoTokenSize = CryptoTokenSize - 1 ]
                    H235CryptoH323Token token;
                }
             };
    }
    
    //switch
    //{
    //    //case Status_UUIE_Extension:
    //    // ??? there may be some extensions
    //}
}

[DataTypeBitAlign]
struct StatusInquiryUUIE
{
    UINT8 StatusUUIEExtension:1;
    UINT8 tokensPresent:1;
    UINT8 cryptoTokensPresent:1;
    
    AsnPerObjectIdentifier protocolIdentifier;
    CallIdentifier callIdentifier;
    switch
    {
       case tokensPresent: 
            struct Tokens
            {
                [post.TokenSize = PERLengthValue]
                AsnPerLengthDeterminant Size;
                while [ TokenSize > 0 ]
                {
                    [ TokenSize = TokenSize  - 1 ]
                    H235ClearToken token;
                }
            }; 
    }
    
    switch
    {
        case cryptoTokensPresent:
             struct CryptoTokens
             {
                [post.CryptoTokenSize = PERLengthValue]
                AsnPerLengthDeterminant Size;
                while [ CryptoTokenSize > 0 ]
                {
                    [ CryptoTokenSize = CryptoTokenSize - 1 ]
                    H235CryptoH323Token token;
                }
             };
    }
    
    //switch
    //{
    //    //case Status_UUIE_Extension:
    //    // ??? there may be some extensions
    //}
}

[DataTypeBitAlign]
struct StatusUUIE
{
    UINT8 StatusUUIEExtension:1;
    UINT8 tokensPresent:1;
    UINT8 cryptoTokensPresent:1;
    
    AsnPerObjectIdentifier protocolIdentifier;
    CallIdentifier callIdentifier;
    switch
    {
       case tokensPresent: 
            struct Tokens
            {
                [post.TokenSize = PERLengthValue]
                AsnPerLengthDeterminant Size;
                while [ TokenSize > 0 ]
                {
                    [ TokenSize = TokenSize  - 1 ]
                    H235ClearToken token;
                }
            }; 
    }
    
    switch
    {
        case cryptoTokensPresent:
             struct CryptoTokens
             {
                [post.CryptoTokenSize = PERLengthValue]
                AsnPerLengthDeterminant Size;
                while [ CryptoTokenSize > 0 ]
                {
                    [ CryptoTokenSize = CryptoTokenSize - 1 ]
                    H235CryptoH323Token token;
                }
             };
    }
    
    //switch
    //{
    //    //case Status_UUIE_Extension:
    //    // ??? there may be some extensions
    //}
}

[DataTypeBitAlign]
struct StimulusControl
{
    UINT8 StimulusControlExtension:1;
    UINT8 nonStandardPresent:1;
    UINT8 isTextPresent:1;
    UINT8 h248MessagePresent:1;
    switch
    {
        case nonStandardPresent: NonStandardParameter nonStandard;
    }
    switch
    {
        case h248MessagePresent: AsnPerOctetString(-1,-1) h248Message;
    }
    
    //switch
    //{
        //case StimulusControl_Extension:
        //??? there may be some extensions
    //}
}

[DataTypeBitAlign]
struct ProgressUUIE
{
    UINT8 ProgressUUIEExtension:1;
    UINT8 h245AddressPresent:1;
    UINT8 h245SecurityModePresent:1;
    UINT8 tokensPresent:1;
    UINT8 cryptoTokensPresent:1;
    UINT8 fastStartPresent:1;
    AsnPerObjectIdentifier protocolIdentifier;
    EndpointType destinationInfo;
    switch
    {
        case h245AddressPresent: TransportAddress h245Address;
    }
    
    CallIdentifier callIdentifier;
    
    switch
    {
        case h245SecurityModePresent: H245Security h245SecurityMode;
    }
    
    switch
    {
       case tokensPresent: 
            struct Tokens
            {
                [post.TokenSize = PERLengthValue]
                AsnPerLengthDeterminant Size;
                while [ TokenSize > 0 ]
                {
                    [ TokenSize = TokenSize  - 1 ]
                    H235ClearToken token;
                }
            }; 
    }
    
    switch
    {
        case cryptoTokensPresent:
             struct CryptoTokens
             {
                [post.CryptoTokenSize = PERLengthValue]
                AsnPerLengthDeterminant Size;
                while [ CryptoTokenSize > 0 ]
                {
                    [ CryptoTokenSize = CryptoTokenSize - 1 ]
                    H235CryptoH323Token token;
                }
             };
    }
    
    switch
    {
        case fastStartPresent:
             struct fastStart
             {
                 AsnPerLengthDeterminant Length;
                 [FastStartEndOffset = FrameOffset+PERLengthValue, post.fastStartCount = PERLengthValue]
                 AsnPerLengthDeterminant Size;
                 while [ fastStartCount > 0 ]
                 {
                     [fastStartCount = fastStartCount - 1]
                     AsnPerOctetString(-1,-1) fastStart;
                 }
                 switch
                 {
                     case Framebitoffset< FastStartEndOffset * 8:
                          AsnPerPadding(FastStartEndOffset * 8-FrameBitOffset) Padding;
                 }
             };
    }
    
    switch
    {
        case ProgressUUIEExtension:
             struct ProgressUUIEExtension
             {
                 AsnPerNormallySmallNonnegativeWholeNumber ExtensionNumber;
                 UINT8 multipleCallsPresent:1;
                 switch
                 {
                     case PERSmallNumber >= 1: UINT8 maintainConnectionPresent:1;
                 }
                 
                 switch
                 {
                     case PERSmallNumber >= 2: UINT8 fastConnectRefusedPresent:1;
                 }
                 
                 switch
                 {
                     case multipleCallsPresent: AsnPerBoolean(1) multipleCalls;
                 }
                 
                 switch
                 {
                     case maintainConnectionPresent: AsnPerBoolean(1) maintainConnection;
                 }
                 
                 switch
                 {
                     case fastConnectRefusedPresent:
                          struct FastConnectRefused
                          {
                              AsnPerLengthDeterminant length; 
                              switch
                              {
                                  case PERLengthValue > 0: BLOB(PERLengthValue) Value;
                              }  
                          };
                 }
             };
    }
}

[DataTypeBitAlign]
struct NonStandardParameter
{
    NonStandardIdentifier nonStandardIdentifier;
    AsnPerOctetString(-1, -1) data;
};

[DataTypeBitAlign]
struct H323UUPDUExtension
{
    AsnPerNormallySmallNonnegativeWholeNumber ExtensionNumber;
    UINT8 h4501SupplementaryServicePresent:1;
    switch
    {
        case PERSmallNumber >= 1: UINT8 h245TunnelingPresent:1;
    }
	
    switch
    {
        case PERSmallNumber >= 2: UINT8 h245ControlPresent:1;
    }
	
    switch
    {
        case PERSmallNumber >= 3: UINT8 nonStandardControlPresent:1;
    }
	
    switch
    {
        case PERSmallNumber >= 4: UINT8 callLinkagePresent:1;
    }
	
    switch
    {
        case PERSmallNumber >= 5: UINT8 tunnelledSignallingMessagePresent:1;
    }
	
    switch
    {
        case PERSmallNumber >= 6: UINT8 provisionalRespToH245TunnelingPresent:1;
    }
	
    switch
    {
        case PERSmallNumber >= 7: UINT8 stimulusControlPresent:1;
    }
	
    switch
    {
        case PERSmallNumber >= 8: UINT8 genericDataPresent:1;
    }

    switch
    {
        case h4501SupplementaryServicePresent: 
             struct h4501SupplementaryService
             {
                 AsnPerLengthDeterminant Length;
                 [h4501SupplementaryServiceEndOffset = FrameOffset + PERLengthValue, post.h4501SupplementaryServiceSize = PERLengthValue]
                 AsnPerLengthDeterminant Size;
                 while [ h4501SupplementaryServiceSize > 0 ]
                 {
                     [ h4501SupplementaryServiceSize = h4501SupplementaryServiceSize - 1 ]
                     AsnPerOctetString(-1,-1) h4501SupplementaryService;
                 }
                 switch
                 {
                     case FrameBitOffset < h4501SupplementaryServiceEndOffset * 8:
                          AsnPerPadding(h4501SupplementaryServiceEndOffset * 8 - FrameBitOffset) Padding;
                 }
             };
    }
    
    switch
    {
        case h245TunnelingPresent: AsnPerBoolean(1) h245Tunneling;
    }
    
    switch
    {
        case h245ControlPresent:
             struct h245Control
             {
                 AsnPerLengthDeterminant Length;
                 [post.h245ControlSize = PERLengthValue, h245ControlEndOffset = FrameOffset + PERLengthValue]
                 AsnPerLengthDeterminant Size;
                 while [ h245ControlSize > 0 ]
                 {
                     [ h245ControlSize = h245ControlSize - 1 ]
                     AsnPerOctetString(-1,-1) h245Control;
                 }
                 switch
                 {
                     case FrameBitOffset < h245ControlEndOffset * 8:
                     AsnPerPadding(h245ControlEndOffset * 8 - FrameBitOffset) Padding;
                 }
             };
    }
    
    switch
    {
        case nonStandardControlPresent:
             struct nonStandardControl
             {
                 AsnPerLengthDeterminant Length;
                 [post.nonStandardControlSize = PERLengthValue, nonStandardControlEndOffset = FrameOffset + PERLengthValue]
                 AsnPerLengthDeterminant Size;
                 while [ nonStandardControlSize > 0 ]
                 {
                     [ nonStandardControlSize = nonStandardControlSize - 1 ]
                     NonStandardParameter nonStandardControl;
                 }
                 switch
                 {
                     case FrameBitOffset < nonStandardControlEndOffset * 8:
                     AsnPerPadding(nonStandardControlEndOffset * 8 - FrameBitOffset) Padding;
                 }
             };
    }
    
    switch
    {
        case callLinkagePresent: 
             struct CallLinkage
             {
                 AsnPerLengthDeterminant Length;
                 [CallLinkageEndOffset = FrameOffset + PERLengthValue]
                 CallLinkage callLinkage;
                 switch
                 {
                     case FrameBitOffset < CallLinkageEndOffset * 8:
                     AsnPerPadding(CallLinkageEndOffset * 8 - FrameBitOffset) Padding;
                 }
             };
    }
    
    switch
    {
        case tunnelledSignallingMessagePresent:
             struct tunnelledSignallingMessage
             {
                 AsnPerLengthDeterminant Length;
                 [tunnelledSignallingMessageEndOffset = FrameOffset + PERLengthValue]
                 UINT8 tunnelledSignallingMessageExtension:1;
                 UINT8 tunnellingRequiredPresent:1;
                 UINT8 nonStandardDataPresent:1;
                 TunnelledProtocol tunnelledProtocolID;
                 [post.messageContentCount=PERLengthValue]
                 AsnPerLengthDeterminant Size;
                 while [ messageContentCount > 0 ]
                 {
                     [ messageContentCount = messageContentCount - 1]
                     AsnPerOctetString(-1,-1) messageContent;
                 }
                 switch
                 {
                     case nonStandardDataPresent: NonStandardParameter nonStandardData;
                 }
                 
                 //switch
                 //{
                 //    case tunnelledSignallingMessageExtension
                 //}
                 
                 switch
                 {
                     case FrameBitOffset < tunnelledSignallingMessageEndOffset * 8:
                     AsnPerPadding( tunnelledSignallingMessageEndOffset * 8 - FrameBitOffset ) Padding;
                 }
             };
    }
    
    switch
    {
        case provisionalRespToH245TunnelingPresent:
             struct ProvisionalRespToH245Tunneling
             {
                 AsnPerLengthDeterminant Length;
                 switch
                 {
                     case PERLengthValue > 0: BLOB(PERLengthValue) Value;
                 }
             };
    }
    
    switch
    {
        case stimulusControlPresent:
             struct StimulusControl
             {
                 AsnPerLengthDeterminant Length;
                 [StimulusControlEndOffset = FrameOffset + PERLengthValue]
                 StimulusControl stimulusControl;
                 switch
                 {
                     case FrameBitOffset < StimulusControlEndOffset * 8:
                          AsnPerPadding(StimulusControlEndOffset * 8 - FrameBitOffset) Padding;
                 }
             };
    }
    
    switch
    {
        case genericDataPresent:
             struct GenericDataList
             {
                 AsnPerLengthDeterminant Length;
                 [post.GenericDataSize = PERLengthValue, GenericDataEndOffset = FrameOffset + PERLengthValue]
                 AsnPerLengthDeterminant Size;
                 while [ GenericDataSize > 0 ]
                 {
                     [ GenericDataSize = GenericDataSize - 1 ]
                     GenericData genericData;
                 }
                 switch
                 {
                     case FrameBitOffset < GenericDataEndOffset * 8:
                          AsnPerPadding(GenericDataEndOffset * 8 - FrameBitOffset) Padding;
                 }
             };
    }
}         

[DataTypeBitAlign]
struct H323messagebody = FormatString("MessageType: %s, %s",
                                        H323MessageType,
                                        h323messagebodyExtension ? "Extension value(s) present in h323-message-body"
                                                                    : "No Extension value(s) present in h323-message-body")
{
    UINT8 H323messagebodyExtension:1;
    switch
    {
        case H323messagebodyExtension:
             _struct ExtensionChoice
             {
                 [H323MessageType = this.ToString]
                 AsnPerNormallySmallNonnegativeWholeNumber ChoiceValue = H323UUIEExtensionMessageTypeTable( PERSmallNumber );
                 AsnPerLengthDeterminant Length;
                 [ExtensionEndoffset = FrameOffset + PERLengthValue]
                 switch( PERSmallNumber )
                 {
                     case 0: ProgressUUIE progress;
                     case 2: StatusUUIE status;
                     case 3: StatusInquiryUUIE statusInquiry;
                     case 4: SetupAcknowledgeUUIE setupAcknowledge;
                     case 5: NotifyUUIE notify;
                 }
                 switch
                 {
                     case FrameBitOffset < ExtensionEndoffset * 8: AsnPerPadding( ExtensionEndoffset * 8 - FrameBitOffset ) Padding;
                 }
             };
             
        default :
        _struct NoneExtension
        {
            [H323MessageType = this.ToString]
            AsnPerConstrainedInteger(0,6) MessageType = H323UUIEMessageTypeTable( ConstrainedValue );
            switch( ConstrainedValue )
            {
                case 0: struct SetupUUIE = FormatString("ProtocolID: %s, %s",
                                                         ProtocolID.ToString,
                                                         SetupExtension ? "Extension value(s) present in Setup"
                                                                         : "No Extension value(s) present in Setup")
                        {
                            UINT8 SetupExtension:1;
                            UINT8 h245AddressPresent:1;
                            UINT8 sourceAddressPresent:1;
                            UINT8 destinationAddressPresent:1;
                            UINT8 destCallSignalAddressPresent:1;
                            UINT8 destExtraCallInfoPresent:1;
                            UINT8 destExtraCRVPresent:1;
                            UINT8 callServicesPresent:1;
                            AsnPerObjectIdentifier ProtocolID;
            	              switch
            	              {
            	                  case h245AddressPresent: TransportAddress h245Address;
            	              }
            	              switch
            	              {
            	                  case sourceAddressPresent: 
            	                       struct SourceAddress
            	                       {
            	                           [post.addressCount= PERLengthValue]
            	                           AsnPerLengthDeterminant LengthDeterminant;
            	                           while [ addressCount > 0 ]
            	                           {
            	                               [ addressCount = addressCount - 1 ]
            	                               AliasAddress address;
            	                           }
            	                       };
            	              }
                            EndpointType sourceInfo;
            	              switch
            	              {
            	                  case destinationAddressPresent: 
            	                       struct destinationAddress
            	                       {
            	                           [post.addressCount = PERLengthValue]
            	                           AsnPerLengthDeterminant LengthDeterminant;
            	                           while [ addressCount > 0 ]
            	                           {
            	                               [ addressCount = addressCount - 1 ]
            	                               AliasAddress address;
            	                           }
            	                       };
            	              }
            	              switch
            	              {
            	                  case destCallSignalAddressPresent: TransportAddress destCallSignalAddress;
            	              }
            	              switch
            	              {
            	                  case destExtraCallInfoPresent: 
            	                       struct destExtraCallInfo
            	                       {
            	                           [post.addressCount = PERLengthValue]
            	                           AsnPerLengthDeterminant LengthDeterminant;
            	                           while [ addressCount > 0 ]
            	                           {
            	                               [ addressCount = addressCount - 1 ]
            	                               AliasAddress address;
            	                           }
            	                       };
            	              }
            	              switch
            	              {
            	                  case destExtraCRVPresent: 
            	                       struct destExtraCRV
            	                       {
            	                           [post.destExtraCRVCount = PERLengthValue]
            	                           AsnPerLengthDeterminant LengthDeterminant;
            	                           while [ destExtraCRVCount > 0 ]
            	                           {
            	                               [ destExtraCRVCount = destExtraCRVCount - 1 ]
            	                               AsnPerConstrainedInteger(0,65535) destExtraCRV;
            	                           }
            	                       };
            	              }
            	              AsnPerBoolean(0) activeMC;
            	              AsnPerGUID conferenceID;
                            ConferenceGoal conferenceGoal;
            	              switch
            	              {
            	                  case callServicesPresent: 
            	                       struct callServices
            	                       {
            	                           UINT8 callServicesExtension:1;
                                         AsnPerBoolean(0) q932Full;
                                         AsnPerBoolean(0) q951Full;
                                         AsnPerBoolean(0) q952Full;
                                         AsnPerBoolean(0) q953Full;
                                         AsnPerBoolean(0) q955Full;
                                         AsnPerBoolean(0) q956Full;
                                         AsnPerBoolean(0) q957Full;
            	                           struct Q954Info
            	                           {
            	                               UINT8 Q954InfoExtension:1;
            	                               AsnPerBoolean(0) conferenceCalling;
            	                               AsnPerBoolean(0) threePartyService;
            	                           };
            	                       };
            	              }
                            CallType callType;
		                        switch
		                        {
		                            case 	SetupExtension: SetupExtension extension;
		                        }
                        };
                case 1: struct callProceeding = FormatString("ProtocolID: %s, %s",
                                                             protocolIdentifier.ToString,
                                                             callProceedingExtension ? "Extension value(s) present in callProceeding"
                                                                                      : "No Extension value(s) present in callProceeding")
                        {
                            UINT8 callProceedingExtension:1;
		                        UINT8 h245AddressPresent:1;
		                        AsnPerObjectIdentifier protocolIdentifier;
		                        EndpointType destinationInfo;
		                        switch
		                        {
		                            case h245AddressPresent: TransportAddress h245Address;
		                        }
		                        switch
		                        {
		                            case callProceedingExtension: CallProceedingExtension extension;
		                        }
                        };
	             case 2: struct connect = FormatString("ProtocolID: %s, H.245 Address: %s, %s",
                                                protocolIdentifier.ToString,
                                                H245AddrPort,
                                                connectExtension ? "Extension value(s) present in connect"
                                                                  : "No Extension value(s) present in connect")
	 	                  {
	 	                  UINT8 connectExtension:1;
		                  UINT8 h245AddressPresent:1;
		                  AsnPerObjectIdentifier protocolIdentifier;
		                  switch
		                  {
		                      case h245AddressPresent: 
		                      [Post.Global.H245Port$[MakeByteArray(this.ipAddress.ip, this.ipAddress.port)] = TRUE, H245AddrPort = this.ToString]
		                      TransportAddress h245Address;
		                  }
		                  EndpointType destinationInfo;
		                  AsnPerGUID conferenceID;
		                  switch
		                  { 
		                      case connectExtension: ConnectExtension extension;
		                  }
	 	              };
               case 3: struct alerting = FormatString("ProtocolID: %s, %s",
                                                      protocolIdentifier.ToString,
                                                      alertingExtension ? "Extension value(s) present in alerting"
                                                                         : "No Extension value(s) present in alerting")
               	       {
               	           UINT8 alertingExtension:1;
		                       UINT8 h245AddressPresent:1;
		                       AsnPerObjectIdentifier protocolIdentifier;
		                       EndpointType destinationInfo;
		                       switch
		                       {
		                           case h245AddressPresent: TransportAddress h245Address;
		                       }
		                       switch
		                       {
		                           case alertingExtension: AlertingExtension extension;
		                       }
               	       };
	             case 4: struct information = FormatString("ProtocolID: %s, %s",
                                                         protocolIdentifier.ToString,
                                                         informationExtension ? "Extension value(s) present in information"
                                                                               : "No Extension value(s) present in information")
		                   {
		                       UINT8 informationExtension:1;
		                       AsnPerObjectIdentifier protocolIdentifier;
		                       switch
		                       {
		                           case informationExtension: InformationExtension extension;
		                       }
		                   };
               case 5: struct releaseComplete = FormatString("ProtocolID: %s, %s",
                                                             protocolIdentifier.ToString,
                                                             releaseCompleteExtension ? "Extension value(s) present in releaseComplete"
                                                                                       : "No Extension value(s) present in releaseComplete")
               	       {
               	           UINT8 releaseCompleteExtension:1;
		                       UINT8 reasonPresent:1;
		                       AsnPerObjectIdentifier protocolIdentifier;
		                       switch
		                       {
		                           case reasonPresent: ReleaseCompleteReason reason;
		                       }
		                       switch
		                       {
		                           case releaseCompleteExtension: ReleaseCompleteExtension extension;
		                       }
               	       };
	             case 6: struct facility = FormatString("ProtocolID: %s, %s",
                                                      protocolIdentifier.ToString,
                                                      facilityExtension ? "Extension value(s) present in facility"
                                                                         : "No Extension value(s) present in facility")
	             	       {
	             	           UINT8 facilityExtensionBit:1;
	             	           UINT8 alternativeAddressPresent:1;
	             	           UINT8 alternativeAliasAddressPresent:1;
	             	           UINT8 conferenceIDPresent:1;
	             	           AsnPerObjectIdentifier protocolIdentifier;
	             	           switch
	             	           {
	             	               case alternativeAddressPresent: TransportAddress alternativeAddress;
	             	           }
	             	           switch
	             	           {
	             	               case alternativeAliasAddressPresent: 
	             	      	        struct alternativeAliasAddress
	             	      	        {
	             	      	           [post.addressCount = PERLengthValue]
                 	                 AsnPerLengthDeterminant LengthDeterminant;
                 	                 while [ addressCount > 0 ]
                 	                 {
                 	                     [ addressCount = addressCount - 1 ]
                 	                     AliasAddress address;
                 	                 }
	             	      	        };
	             	           }
	             	           switch
	             	           {
	             	               case conferenceIDPresent: AsnPerGUID conferenceID;
	             	           }
	             	           FacilityReason reason;
	             	           switch
	             	               {
	             	                   case facilityExtensionBit:
	             	                       struct facilityExtension
	             	                       {
	             	                           AsnPerNormallySmallNonnegativeWholeNumber ExtensionNumber;
	             	                           UINT8 callIdentifierPresent:1;
	             	                           switch
	             	                           {
	             	                               case PERSmallNumber >= 1: UINT8 destExtraCallInfoPresent:1;
	             	                           }
	             	                           switch
	             	                           {
	             	                               case PERSmallNumber >= 2: UINT8 remoteExtensionAddressPresent:1;
	             	                           }
	             	                           switch
	             	                           {
	             	                               case PERSmallNumber >= 3: UINT8 tokensPresent:1;
	             	                           }
	             	                           switch
	             	                           {
	             	                               case PERSmallNumber >= 4: UINT8 cryptoTokensPresent:1;
	             	                           }
	             	                           switch
	             	                           {
	             	                               case PERSmallNumber >= 5: UINT8 conferencesPresent:1;
	             	                           }
	             	                           switch
	             	                           {
	             	                               case PERSmallNumber >= 6: UINT8 h245AddressPresent:1;
	             	                           }
	             	                           switch
	             	                           {
	             	                               case PERSmallNumber >= 7: UINT8 fastStartPresent:1;
	             	                           }
	             	                           switch
	             	                           {
	             	                               case PERSmallNumber >= 8: UINT8 multipleCallsPresent:1;
	             	                           }
	             	                           switch
	             	                           {
	             	                               case PERSmallNumber >= 9: UINT8 maintainConnectionPresent:1;
	             	                           }
	             	                           switch
	             	                           {
	             	                               case PERSmallNumber >= 10: UINT8 fastConnectRefusedPresent:1;
	             	                           }
	             	                           switch
	             	                           {
	             	                               case PERSmallNumber >= 11: UINT8 serviceControlPresent:1;
	             	                           }
	             	                           switch
	             	                           {
	             	                               case PERSmallNumber >= 12: UINT8 circuitInfoPresent:1;
	             	                           }
	             	                           switch
	             	                           {
	             	                               case PERSmallNumber >= 13: UINT8 featureSetPresent:1;
	             	                           }
	             	                           switch
	             	                           {
	             	                               case PERSmallNumber >= 14: UINT8 destinationInfoPresent:1;
	             	                           }
	             	                           switch
	             	                           {
	             	                               case PERSmallNumber >= 15: UINT8 h245SecurityModePresent:1;
	             	                           }
	             	                           switch
	             	                           {
	             	                               case callIdentifierPresent:
	             	                               struct CallID
	             	                               {
	             	                                   AsnPerLengthDeterminant Length;
	             	                                   [CallIdentifierEndOffset = FrameOffset + PERLengthValue]
	             	                                   CallIdentifier callIdentifier;
	             	                                   switch
	             	                                   {
	             	                                       case FrameBitOffset < CallIdentifierEndOffset * 8:
	             	                                       AsnPerPadding( CallIdentifierEndOffset * 8 - FrameBitOffset ) Padding;
	             	                                   }
	             	                               }
	             	                           }
	             	                           switch
	             	                           {
	             	                               case destExtraCallInfoPresent:
	             	                               struct destExtraCallInfo
	             	                               {
	             	                                   AsnPerLengthDeterminant length;
	             	                                   [destExtraCallInfoEndOffset = FrameOffset + PERLengthValue, post.destExtraCallInfoCount = PERLengthValue]
	             	                                   AsnPerLengthDeterminant size;
	             	                                   while [ destExtraCallInfoCount > 0 ]
	             	                                   {
	             	                                       [ destExtraCallInfoCount = destExtraCallInfoCount - 1 ]
	             	                                       AliasAddress destExtraCallInfo;
	             	                                   }
	             	                                   switch
	             	                                   {
	             	                                       case FrameBitOffset < destExtraCallInfoEndOffset * 8: 
                                                            AsnPerPadding(destExtraCallInfoEndOffset * 8 - FrameBitOffset) Padding;
                                                   }
                                               };
                                           }  
	             	                           switch
	             	                           {
	             	                               case remoteExtensionAddressPresent:
	             	                               struct RemoteExtensionAddress
	             	                               {
	             	                                   AsnPerLengthDeterminant Length;
	             	                                   [RemoteExtensionAddEndOffset = FrameOffset + PERLengthValue]
	             	                                   AliasAddress remoteExtensionAddress;
	             	                                   switch
	             	                                   {
	             	                                       case FrameBitOffset < RemoteExtensionAddEndOffset * 8:
	             	                                       AsnPerPadding( RemoteExtensionAddEndOffset * 8 - FrameBitOffset ) Padding;
	             	                                   }
	             	                               }
	             	                           }
	             	                           switch
	             	                           {
	             	                               case tokensPresent:
	             	                               struct tokens
	             	                               {
	             	                                   AsnPerLengthDeterminant length;
	             	                                   [tokensEndOffset = FrameOffset + PERLengthValue, post.tokensCount = PERLengthValue]
	             	                                   AsnPerLengthDeterminant size;
	             	                                   while [ tokensCount > 0 ]
	             	                                   {
	             	                                       [ tokensCount = tokensCount - 1 ]
	             	                                       H235ClearToken  token;
	             	                                   }
	             	                                   switch
	             	                                   {
	             	                                       case FrameBitOffset < tokensEndOffset * 8: 
                                                            AsnPerPadding(tokensEndOffset * 8 - FrameBitOffset) Padding;
                                                   }
                                               };	             	                               
	             	                           }
	             	                           switch
	             	                           {
	             	                               case cryptoTokensPresent:
	             	                               struct cryptoTokens
	             	                               {
	             	                                   AsnPerLengthDeterminant length;
	             	                                   [cryptoTokensEndOffset = FrameOffset + PERLengthValue, post.cryptoTokensCount = PERLengthValue]
	             	                                   AsnPerLengthDeterminant size; 
	             	                                   while [ cryptoTokensCount > 0 ]
	             	                                   {
	             	                                       [ cryptoTokensCount = cryptoTokensCount - 1 ]   
	             	                                       H235CryptoH323Token cryptoToken;
	             	                                   }
	             	                                   switch
	             	                                   {
	             	                                       case FrameBitOffset < cryptoTokensEndOffset * 8: 
                                                            AsnPerPadding(cryptoTokensEndOffset * 8 - FrameBitOffset) Padding;
                                                   }
                                               };	             	                               
	             	                           }
	             	                           switch
	             	                           {
	             	                               case conferencesPresent:
	             	                               struct conferences
	             	                               {
	             	                                   AsnPerLengthDeterminant length;
	             	                                   [conferencesEndOffset = FrameOffset + PERLengthValue, post.conferencesCount = PERLengthValue]
	             	                                   AsnPerLengthDeterminant size;
	             	                                   while [ conferencesCount > 0 ]
	             	                                   {
	             	                                       [ conferencesCount = conferencesCount - 1 ]
	             	                                       H225ConferenceList conference;
	             	                                   }
	             	                                   switch
	             	                                   {
	             	                                       case FrameBitOffset < cryptoTokensEndOffset * 8: 
                                                            AsnPerPadding(cryptoTokensEndOffset * 8 - FrameBitOffset) Padding;
                                                   }
                                               };	             	                               
	             	                           }
	             	                           switch
	             	                           {
	             	                               case h245AddressPresent:
	             	                               struct H245TransportAddress
	             	                               {
	             	                                   AsnPerLengthDeterminant Length;
	             	                                   [TransportAddressEndOffset = FrameOffset + PERLengthValue]
	             	                                   TransportAddress h245Address;
	             	                                   switch
	             	                                   {
	             	                                       case FrameBitOffset < TransportAddressEndOffset * 8:
	             	                                       AsnPerPadding( TransportAddressEndOffset * 8 - FrameBitOffset ) Padding;
	             	                                   }
	             	                               }
	             	                           }
                                           switch        
                                           {             
                                               case fastStartPresent:
                                                    struct FastStart
                                                    {    
                                                        AsnPerLengthDeterminant length;  
                                                        [FastStartEndOffset = FrameOffset + PERLengthValue, post.fastStartCount = PERLengthValue]
                                                        AsnPerLengthDeterminant Size;
                                                        while [fastStartCount > 0]
                                                        {
                                                             [fastStartCount = fastStartCount - 1]
                                                             AsnPerOctetString(-1,-1) fastStart;
                                                        }
                                                        switch                                                                     
                                                        {                                                                          
                                                            case FrameBitOffset < FastStartEndOffset * 8:                          
                                                                 AsnPerPadding(FastStartEndOffset * 8 - FrameBitOffset) Padding;   
                                                        }                                                                          
                                                   };
                                           }
	             	                           switch
	             	                           {
	             	                               case multipleCallsPresent:
	             	                               AsnPerBoolean(1) multipleCalls;
	             	                           }
	             	                           switch
	             	                           {
	             	                               case maintainConnectionPresent:
	             	                               AsnPerBoolean(1) maintainConnection;
	             	                           }
	             	                           switch
	             	                           {
	             	                               case fastConnectRefusedPresent:
	             	                               struct FastConnectRefused
                                               {
                                                   AsnPerLengthDeterminant length; 
                                                   BLOB(PERLengthValue) Value;
                                               };
	             	                           }
	             	                           switch
	             	                           {
	             	                               case serviceControlPresent:
	             	                               struct serviceControl
	             	                               {
	             	                                   AsnPerLengthDeterminant length;
	             	                                   [serviceControlEndOffset = FrameOffset + PERLengthValue, post.serviceControlCount = PERLengthValue]
	             	                                   AsnPerLengthDeterminant size;
	             	                                   while [ serviceControlCount > 0 ]
	             	                                   {
	             	                                       [ serviceControlCount = serviceControlCount - 1 ]
	             	                                       ServiceControlSession serviceControl;
	             	                                   }
	             	                                   switch
                                                   {
                                                       case FrameBitOffset < serviceControlEndOffset * 8: 
                                                       AsnPerPadding(serviceControlEndOffset * 8 - FrameBitOffset) Padding;
                                                   }
                                               };                	                               
	             	                           }
	             	                           switch
	             	                           {
	             	                               case circuitInfoPresent:
	             	                               struct CircuitInfomation
	             	                               {
	             	                                   AsnPerLengthDeterminant Length;
	             	                                   [CircuitInfoEndOffset = FrameOffset + PERLengthValue]
	             	                                   CircuitInfo circuitInfo;
	             	                                   switch
	             	                                   {
	             	                                       case FrameBitOffset < CircuitInfoEndOffset * 8:
	             	                                       AsnPerPadding( CircuitInfoEndOffset * 8 - FrameBitOffset ) Padding;
	             	                                   }
	             	                               }
	             	                           }
	             	                           switch
	             	                           {
	             	                               case featureSetPresent:
	             	                               struct FeatureSet
	             	                               {
	             	                                   AsnPerLengthDeterminant Length;
	             	                                   [FeatureSetEndOffset = FrameOffset + PERLengthValue]
	             	                                   FeatureSet featureSet;
	             	                                   switch
	             	                                   {
	             	                                       case FrameBitOffset < FeatureSetEndOffset * 8:
	             	                                       AsnPerPadding( FeatureSetEndOffset * 8 - FrameBitOffset ) Padding;
	             	                                   }
	             	                               }
	             	                           }
	             	                           switch
	             	                           {
	             	                               case destinationInfoPresent:
	             	                               struct DestinationInfomation
	             	                               {
	             	                                   AsnPerLengthDeterminant Length;
	             	                                   [DestinationInfoEndOffset = FrameOffset + PERLengthValue]
	             	                                   EndpointType destinationInfo;
	             	                                   switch
	             	                                   {
	             	                                       case FrameBitOffset < DestinationInfoEndOffset * 8:
	             	                                       AsnPerPadding( DestinationInfoEndOffset * 8 - FrameBitOffset ) Padding;
	             	                                   }
	             	                               }
	             	                           }
	             	                           switch
	             	                           {
	             	                               case h245SecurityModePresent:
	             	                               struct H245Security
	             	                               {
	             	                                   AsnPerLengthDeterminant Length;
	             	                                   [H245SecurityModeEndOffset = FrameOffset + PERLengthValue]
	             	                                   H245Security h245SecurityMode;
	             	                                   switch
	             	                                   {
	             	                                       case FrameBitOffset < H245SecurityModeEndOffset * 8:
	             	                                       AsnPerPadding( H245SecurityModeEndOffset * 8 - FrameBitOffset ) Padding;
	             	                                   }
	             	                               }
	             	                           }	             	           
	             	                       };
	             	               }
	             	       } 
            }
        }; 
    }
}

[DataTypeBitAlign]
struct H323UUPDU = FormatString("%s", h323uupduExtension ? "Extension value(s) present in h323-uu-pdu"
                                                              : "No Extension value(s) present in h323-uu-pdu")
{
    UINT8 H323UUPDUExtension:1;
    UINT8 nonStandardDataPresent:1;
    H323messagebody messagebody;
    switch
    {
        case nonStandardDataPresent: NonStandardParameter nonStandardData;
    }
    switch
    {
        case H323UUPDUExtension: H323UUPDUExtension Extension;
    }
}

[DataTypeBitAlign]
struct H323UserInformation = FormatString("%s", H323UIExtension ? "Extension value(s) present in H323_UserInformation"
                                                                   : "No Extension value(s) present in H323_UserInformation" )
{
    UINT8 H323UIExtension:1;
    UINT8 UserDataPresent:1;
    H323UUPDU pdu;
    switch
    {
        case UserDataPresent:
             struct userdata
             {
                 UINT8 userdataExtension:1;
                 AsnPerConstrainedInteger(0,255) protocoldiscriminator;
                 AsnPerOctetString(1,131) userinformation;
                 /*
                 switch
                 {
                     //case user_data_Extension:
                     //??? there may be some extensions
                 }
                 */
             };       
    }
    
    //switch
    //{
    //   // case H323_UI_Extension:
    //    //??? there may be some extensions
    //}
    
}


