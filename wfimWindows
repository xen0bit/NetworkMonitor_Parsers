//#  (c) 2009 CodePlex Foundation
//#
//#  Title:                  Workflow Instance Management Protocol
//#
//#  Details:                
//#
//#  Microsoft References:   [MS-WFIM]: Workflow Instance Management Protocol
//#
//#  Comments:               
//#
//#  Revision Class and Date:Major, 01/21/2010
//#                          Minor, 3/11/2010
//#
//####

[Property.SoapBodySummary = "WFIM Payload"]
[RegisterBefore(SoapBody.DefaultSoapBody, WFIM, WFIMSoapActionTable(Property.SOAPAction))]
Protocol WFIM = Property.WFIMSummary
{
	Switch(Property.SOAPAction)
	{
		Case "http://schemas.datacontract.org/2008/10/WorkflowServices/IWorkflowInstanceManagement/TransactedTerminate":
			[Property.WFIMSummary = this.ToString]
			WFIMTransactedTerminate WFIMTransactedTerminate;
		Case "http://schemas.datacontract.org/2008/10/WorkflowServices/IWorkflowInstanceManagement/TransactedSuspend":
			[Property.WFIMSummary = this.ToString]
			WFIMTransactedSuspend WFIMTransactedSuspend;
		Case "http://schemas.datacontract.org/2008/10/WorkflowServices/IWorkflowInstanceManagement/TransactedRun":
			[Property.WFIMSummary = this.ToString]
			WFIMTransactedRun WFIMTransactedRun;
		Case "http://schemas.datacontract.org/2008/10/WorkflowServices/IWorkflowInstanceManagement/TransactedCancel":
			[Property.WFIMSummary = this.ToString]
			WFIMTransactedCancel WFIMTransactedCancel;
		Case "http://schemas.datacontract.org/2008/10/WorkflowServices/IWorkflowInstanceManagement/Unsuspend":
			[Property.WFIMSummary = this.ToString]
			WFIMUnsuspend WFIMUnsuspend;
		Case "http://schemas.datacontract.org/2008/10/WorkflowServices/IWorkflowInstanceManagement/Terminate":
			[Property.WFIMSummary = this.ToString]
			WFIMTerminate WFIMTerminate;
		Case "http://schemas.datacontract.org/2008/10/WorkflowServices/IWorkflowInstanceManagement/Suspend":
			[Property.WFIMSummary = this.ToString]
			WFIMSuspend WFIMSuspend;
		Case "http://schemas.datacontract.org/2008/10/WorkflowServices/IWorkflowInstanceManagement/Run":
			[Property.WFIMSummary = this.ToString]
			WFIMRun WFIMRun;
		Case "http://schemas.datacontract.org/2008/10/WorkflowServices/IWorkflowInstanceManagement/Cancel":
			[Property.WFIMSummary = this.ToString]
			WFIMCancel WFIMCancel;
		Case "http://schemas.datacontract.org/2008/10/WorkflowServices/IWorkflowInstanceManagement/Abandon":
			[Property.WFIMSummary = this.ToString]
			WFIMAbandon WFIMAbandon;
		Case "http://schemas.datacontract.org/2008/10/WorkflowServices/IWorkflowInstanceManagement/TransactedUnsuspend":
			[Property.WFIMSummary = this.ToString]
			WFIMTransactedUnsuspend WFIMTransactedUnsuspend;
		Default:
			While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
			{
				XmlElement(true) AnyNode;
			}
	}
}

Struct WFIMTransactedTerminate = FormatString("%s Message", Property.WFIMTransactedTerminateSummary)
{
	[Post.Local.WFIMTransactedTerminate_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.WFIMTransactedTerminate_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "TransactedTerminateResponse"):
						[Property.WFIMTransactedTerminateSummary = "TransactedTerminate Response"]
						WFIMwsTransactedTerminateResponseElement TransactedTerminateResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "TransactedTerminate"):
						[Property.WFIMTransactedTerminateSummary = "TransactedTerminate Request"]
						WFIMwsTransactedTerminateElement TransactedTerminate;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.WFIMTransactedTerminateSummary = "Fault TransactedTerminate Response"]
						SoapFaultElement FaultTransactedTerminateElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WFIMTransactedTerminateSummary = "Encrypted TransactedTerminate Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

Struct WFIMTransactedSuspend = FormatString("%s Message", Property.WFIMTransactedSuspendSummary)
{
	[Post.Local.WFIMTransactedSuspend_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.WFIMTransactedSuspend_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "TransactedSuspendResponse"):
						[Property.WFIMTransactedSuspendSummary = "TransactedSuspend Response"]
						WFIMwsTransactedSuspendResponseElement TransactedSuspendResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "TransactedSuspend"):
						[Property.WFIMTransactedSuspendSummary = "TransactedSuspend Request"]
						WFIMwsTransactedSuspendElement TransactedSuspend;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.WFIMTransactedSuspendSummary = "Fault TransactedSuspend Response"]
						SoapFaultElement FaultTransactedSuspendElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WFIMTransactedSuspendSummary = "Encrypted TransactedSuspend Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

Struct WFIMTransactedRun = FormatString("%s Message", Property.WFIMTransactedRunSummary)
{
	[Post.Local.WFIMTransactedRun_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.WFIMTransactedRun_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "TransactedRunResponse"):
						[Property.WFIMTransactedRunSummary = "TransactedRun Response"]
						WFIMwsTransactedRunResponseElement TransactedRunResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "TransactedRun"):
						[Property.WFIMTransactedRunSummary = "TransactedRun Request"]
						WFIMwsTransactedRunElement TransactedRun;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.WFIMTransactedRunSummary = "Fault TransactedRun Response"]
						SoapFaultElement FaultTransactedRunElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WFIMTransactedRunSummary = "Encrypted TransactedRun Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

Struct WFIMTransactedCancel = FormatString("%s Message", Property.WFIMTransactedCancelSummary)
{
	[Post.Local.WFIMTransactedCancel_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.WFIMTransactedCancel_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "TransactedCancelResponse"):
						[Property.WFIMTransactedCancelSummary = "TransactedCancel Response"]
						WFIMwsTransactedCancelResponseElement TransactedCancelResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "TransactedCancel"):
						[Property.WFIMTransactedCancelSummary = "TransactedCancel Request"]
						WFIMwsTransactedCancelElement TransactedCancel;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.WFIMTransactedCancelSummary = "Fault TransactedCancel Response"]
						SoapFaultElement FaultTransactedCancelElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WFIMTransactedCancelSummary = "Encrypted TransactedCancel Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

Struct WFIMUnsuspend = FormatString("%s Message", Property.WFIMUnsuspendSummary)
{
	[Post.Local.WFIMUnsuspend_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.WFIMUnsuspend_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "UnsuspendResponse"):
						[Property.WFIMUnsuspendSummary = "Unsuspend Response"]
						WFIMwsUnsuspendResponseElement UnsuspendResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Unsuspend"):
						[Property.WFIMUnsuspendSummary = "Unsuspend Request"]
						WFIMwsUnsuspendElement Unsuspend;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.WFIMUnsuspendSummary = "Fault Unsuspend Response"]
						SoapFaultElement FaultUnsuspendElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WFIMUnsuspendSummary = "Encrypted Unsuspend Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

Struct WFIMTerminate = FormatString("%s Message", Property.WFIMTerminateSummary)
{
	[Post.Local.WFIMTerminate_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.WFIMTerminate_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "TerminateResponse"):
						[Property.WFIMTerminateSummary = "Terminate Response"]
						WFIMwsTerminateResponseElement TerminateResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Terminate"):
						[Property.WFIMTerminateSummary = "Terminate Request"]
						WFIMwsTerminateElement Terminate;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.WFIMTerminateSummary = "Fault Terminate Response"]
						SoapFaultElement FaultTerminateElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WFIMTerminateSummary = "Encrypted Terminate Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

Struct WFIMSuspend = FormatString("%s Message", Property.WFIMSuspendSummary)
{
	[Post.Local.WFIMSuspend_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.WFIMSuspend_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "SuspendResponse"):
						[Property.WFIMSuspendSummary = "Suspend Response"]
						WFIMwsSuspendResponseElement SuspendResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Suspend"):
						[Property.WFIMSuspendSummary = "Suspend Request"]
						WFIMwsSuspendElement Suspend;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.WFIMSuspendSummary = "Fault Suspend Response"]
						SoapFaultElement FaultSuspendElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WFIMSuspendSummary = "Encrypted Suspend Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

Struct WFIMRun = FormatString("%s Message", Property.WFIMRunSummary)
{
	[Post.Local.WFIMRun_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.WFIMRun_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RunResponse"):
						[Property.WFIMRunSummary = "Run Response"]
						WFIMwsRunResponseElement RunResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Run"):
						[Property.WFIMRunSummary = "Run Request"]
						WFIMwsRunElement Run;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.WFIMRunSummary = "Fault Run Response"]
						SoapFaultElement FaultRunElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WFIMRunSummary = "Encrypted Run Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

Struct WFIMCancel = FormatString("%s Message", Property.WFIMCancelSummary)
{
	[Post.Local.WFIMCancel_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.WFIMCancel_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "CancelResponse"):
						[Property.WFIMCancelSummary = "Cancel Response"]
						WFIMwsCancelResponseElement CancelResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Cancel"):
						[Property.WFIMCancelSummary = "Cancel Request"]
						WFIMwsCancelElement Cancel;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.WFIMCancelSummary = "Fault Cancel Response"]
						SoapFaultElement FaultCancelElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WFIMCancelSummary = "Encrypted Cancel Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

Struct WFIMAbandon = FormatString("%s Message", Property.WFIMAbandonSummary)
{
	[Post.Local.WFIMAbandon_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.WFIMAbandon_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "AbandonResponse"):
						[Property.WFIMAbandonSummary = "Abandon Response"]
						WFIMwsAbandonResponseElement AbandonResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Abandon"):
						[Property.WFIMAbandonSummary = "Abandon Request"]
						WFIMwsAbandonElement Abandon;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.WFIMAbandonSummary = "Fault Abandon Response"]
						SoapFaultElement FaultAbandonElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WFIMAbandonSummary = "Encrypted Abandon Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

Struct WFIMTransactedUnsuspend = FormatString("%s Message", Property.WFIMTransactedUnsuspendSummary)
{
	[Post.Local.WFIMTransactedUnsuspend_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	Switch
	{
		Case !Local.WFIMTransactedUnsuspend_IsEmpty:
			Struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "TransactedUnsuspendResponse"):
						[Property.WFIMTransactedUnsuspendSummary = "TransactedUnsuspend Response"]
						WFIMwsTransactedUnsuspendResponseElement TransactedUnsuspendResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "TransactedUnsuspend"):
						[Property.WFIMTransactedUnsuspendSummary = "TransactedUnsuspend Request"]
						WFIMwsTransactedUnsuspendElement TransactedUnsuspend;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.WFIMTransactedUnsuspendSummary = "Fault TransactedUnsuspend Response"]
						SoapFaultElement FaultTransactedUnsuspendElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WFIMTransactedUnsuspendSummary = "Encrypted TransactedUnsuspend Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

//
// Element TransactedUnsuspend
// Embedded ComplexType 
//
Struct WFIMwsTransactedUnsuspendElement = this.STag.ToString
{
	[Post.Local.WFIMwsTransactedUnsuspendElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("TransactedUnsuspend") STag;
	Switch
	{
		Case !Local.WFIMwsTransactedUnsuspendElement_IsEmpty:
			Struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "instanceId") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						Struct InstanceId = this.STag.ToString
						{
							[Post.Local.InstanceId_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("instanceId") STag;
							Switch
							{
								Case !Local.InstanceId_IsEmpty:
									Struct
									{
										StringTerm(Property.XMLEncoding, "<", true, false, false)InstanceId;
										XmlTag("instanceId") ETag;
									}
							}
						}
						
				}
				
				XmlTag("TransactedUnsuspend") ETag;
			}
	}
}

//
// Element TransactedUnsuspendResponse
// Embedded ComplexType 
//
Struct WFIMwsTransactedUnsuspendResponseElement = this.STag.ToString
{
	[Post.Local.WFIMwsTransactedUnsuspendResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("TransactedUnsuspendResponse") STag;
	Switch
	{
		Case !Local.WFIMwsTransactedUnsuspendResponseElement_IsEmpty:
			Struct
			{
				XmlTag("TransactedUnsuspendResponse") ETag;
			}
	}
}

//
// Element Abandon
// Embedded ComplexType 
//
Struct WFIMwsAbandonElement = this.STag.ToString
{
	[Post.Local.WFIMwsAbandonElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Abandon") STag;
	Switch
	{
		Case !Local.WFIMwsAbandonElement_IsEmpty:
			Struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "instanceId") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						Struct InstanceId = this.STag.ToString
						{
							[Post.Local.InstanceId_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("instanceId") STag;
							Switch
							{
								Case !Local.InstanceId_IsEmpty:
									Struct
									{
										StringTerm(Property.XMLEncoding, "<", true, false, false)InstanceId;
										XmlTag("instanceId") ETag;
									}
							}
						}
						
				}
				
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "reason") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						Struct Reason = this.Reason
						{
							[Post.Local.Reason_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("reason") STag;
							Switch
							{
								Case !Local.Reason_IsEmpty:
									Struct
									{
										StringTerm(Property.XMLEncoding, "<", true, false, false) Reason;
										XmlTag("reason") ETag;
									}
							}
						}
						
				}
				
				XmlTag("Abandon") ETag;
			}
	}
}

//
// Element AbandonResponse
// Embedded ComplexType 
//
Struct WFIMwsAbandonResponseElement = this.STag.ToString
{
	[Post.Local.WFIMwsAbandonResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("AbandonResponse") STag;
	Switch
	{
		Case !Local.WFIMwsAbandonResponseElement_IsEmpty:
			Struct
			{
				XmlTag("AbandonResponse") ETag;
			}
	}
}

//
// Element Cancel
// Embedded ComplexType 
//
Struct WFIMwsCancelElement = this.STag.ToString
{
	[Post.Local.WFIMwsCancelElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Cancel") STag;
	Switch
	{
		Case !Local.WFIMwsCancelElement_IsEmpty:
			Struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "instanceId") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						Struct InstanceId = this.STag.ToString
						{
							[Post.Local.InstanceId_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("instanceId") STag;
							Switch
							{
								Case !Local.InstanceId_IsEmpty:
									Struct
									{
										StringTerm(Property.XMLEncoding, "<", true, false, false)InstanceId;
										XmlTag("instanceId") ETag;
									}
							}
						}
						
				}
				
				XmlTag("Cancel") ETag;
			}
	}
}

//
// Element CancelResponse
// Embedded ComplexType 
//
Struct WFIMwsCancelResponseElement = this.STag.ToString
{
	[Post.Local.WFIMwsCancelResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("CancelResponse") STag;
	Switch
	{
		Case !Local.WFIMwsCancelResponseElement_IsEmpty:
			Struct
			{
				XmlTag("CancelResponse") ETag;
			}
	}
}

//
// Element Run
// Embedded ComplexType 
//
Struct WFIMwsRunElement = this.STag.ToString
{
	[Post.Local.WFIMwsRunElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Run") STag;
	Switch
	{
		Case !Local.WFIMwsRunElement_IsEmpty:
			Struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "instanceId") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						Struct InstanceId = this.STag.ToString
						{
							[Post.Local.InstanceId_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("instanceId") STag;
							Switch
							{
								Case !Local.InstanceId_IsEmpty:
									Struct
									{
										StringTerm(Property.XMLEncoding, "<", true, false, false)InstanceId;
										XmlTag("instanceId") ETag;
									}
							}
						}
						
				}
				
				XmlTag("Run") ETag;
			}
	}
}

//
// Element RunResponse
// Embedded ComplexType 
//
Struct WFIMwsRunResponseElement = this.STag.ToString
{
	[Post.Local.WFIMwsRunResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("RunResponse") STag;
	Switch
	{
		Case !Local.WFIMwsRunResponseElement_IsEmpty:
			Struct
			{
				XmlTag("RunResponse") ETag;
			}
	}
}

//
// Element Suspend
// Embedded ComplexType 
//
Struct WFIMwsSuspendElement = this.STag.ToString
{
	[Post.Local.WFIMwsSuspendElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Suspend") STag;
	Switch
	{
		Case !Local.WFIMwsSuspendElement_IsEmpty:
			Struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "instanceId") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						Struct InstanceId = this.STag.ToString
						{
							[Post.Local.InstanceId_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("instanceId") STag;
							Switch
							{
								Case !Local.InstanceId_IsEmpty:
									Struct
									{
										StringTerm(Property.XMLEncoding, "<", true, false, false)InstanceId;
										XmlTag("instanceId") ETag;
									}
							}
						}
						
				}
				
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "reason") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						Struct Reason = this.Reason
						{
							[Post.Local.Reason_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("reason") STag;
							Switch
							{
								Case !Local.Reason_IsEmpty:
									Struct
									{
										StringTerm(Property.XMLEncoding, "<", true, false, false) Reason;
										XmlTag("reason") ETag;
									}
							}
						}
						
				}
				
				XmlTag("Suspend") ETag;
			}
	}
}

//
// Element SuspendResponse
// Embedded ComplexType 
//
Struct WFIMwsSuspendResponseElement = this.STag.ToString
{
	[Post.Local.WFIMwsSuspendResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("SuspendResponse") STag;
	Switch
	{
		Case !Local.WFIMwsSuspendResponseElement_IsEmpty:
			Struct
			{
				XmlTag("SuspendResponse") ETag;
			}
	}
}

//
// Element Terminate
// Embedded ComplexType 
//
Struct WFIMwsTerminateElement = this.STag.ToString
{
	[Post.Local.WFIMwsTerminateElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Terminate") STag;
	Switch
	{
		Case !Local.WFIMwsTerminateElement_IsEmpty:
			Struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "instanceId") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						Struct InstanceId = this.STag.ToString
						{
							[Post.Local.InstanceId_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("instanceId") STag;
							Switch
							{
								Case !Local.InstanceId_IsEmpty:
									Struct
									{
										StringTerm(Property.XMLEncoding, "<", true, false, false)InstanceId;
										XmlTag("instanceId") ETag;
									}
							}
						}
						
				}
				
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "reason") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						Struct Reason = this.Reason
						{
							[Post.Local.Reason_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("reason") STag;
							Switch
							{
								Case !Local.Reason_IsEmpty:
									Struct
									{
										StringTerm(Property.XMLEncoding, "<", true, false, false) Reason;
										XmlTag("reason") ETag;
									}
							}
						}
						
				}
				
				XmlTag("Terminate") ETag;
			}
	}
}

//
// Element TerminateResponse
// Embedded ComplexType 
//
Struct WFIMwsTerminateResponseElement = this.STag.ToString
{
	[Post.Local.WFIMwsTerminateResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("TerminateResponse") STag;
	Switch
	{
		Case !Local.WFIMwsTerminateResponseElement_IsEmpty:
			Struct
			{
				XmlTag("TerminateResponse") ETag;
			}
	}
}

//
// Element Unsuspend
// Embedded ComplexType 
//
Struct WFIMwsUnsuspendElement = this.STag.ToString
{
	[Post.Local.WFIMwsUnsuspendElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Unsuspend") STag;
	Switch
	{
		Case !Local.WFIMwsUnsuspendElement_IsEmpty:
			Struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "instanceId") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						Struct InstanceId = this.STag.ToString
						{
							[Post.Local.InstanceId_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("instanceId") STag;
							Switch
							{
								Case !Local.InstanceId_IsEmpty:
									Struct
									{
										StringTerm(Property.XMLEncoding, "<", true, false, false)InstanceId;
										XmlTag("instanceId") ETag;
									}
							}
						}
						
				}
				
				XmlTag("Unsuspend") ETag;
			}
	}
}

//
// Element UnsuspendResponse
// Embedded ComplexType 
//
Struct WFIMwsUnsuspendResponseElement = this.STag.ToString
{
	[Post.Local.WFIMwsUnsuspendResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("UnsuspendResponse") STag;
	Switch
	{
		Case !Local.WFIMwsUnsuspendResponseElement_IsEmpty:
			Struct
			{
				XmlTag("UnsuspendResponse") ETag;
			}
	}
}

//
// Element TransactedCancel
// Embedded ComplexType 
//
Struct WFIMwsTransactedCancelElement = this.STag.ToString
{
	[Post.Local.WFIMwsTransactedCancelElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("TransactedCancel") STag;
	Switch
	{
		Case !Local.WFIMwsTransactedCancelElement_IsEmpty:
			Struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "instanceId") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						Struct InstanceId = this.STag.ToString
						{
							[Post.Local.InstanceId_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("instanceId") STag;
							Switch
							{
								Case !Local.InstanceId_IsEmpty:
									Struct
									{
										StringTerm(Property.XMLEncoding, "<", true, false, false)InstanceId;
										XmlTag("instanceId") ETag;
									}
							}
						}
						
				}
				
				XmlTag("TransactedCancel") ETag;
			}
	}
}

//
// Element TransactedCancelResponse
// Embedded ComplexType 
//
Struct WFIMwsTransactedCancelResponseElement = this.STag.ToString
{
	[Post.Local.WFIMwsTransactedCancelResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("TransactedCancelResponse") STag;
	Switch
	{
		Case !Local.WFIMwsTransactedCancelResponseElement_IsEmpty:
			Struct
			{
				XmlTag("TransactedCancelResponse") ETag;
			}
	}
}

//
// Element TransactedRun
// Embedded ComplexType 
//
Struct WFIMwsTransactedRunElement = this.STag.ToString
{
	[Post.Local.WFIMwsTransactedRunElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("TransactedRun") STag;
	Switch
	{
		Case !Local.WFIMwsTransactedRunElement_IsEmpty:
			Struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "instanceId") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						Struct InstanceId = this.STag.ToString
						{
							[Post.Local.InstanceId_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("instanceId") STag;
							Switch
							{
								Case !Local.InstanceId_IsEmpty:
									Struct
									{
										StringTerm(Property.XMLEncoding, "<", true, false, false)InstanceId;
										XmlTag("instanceId") ETag;
									}
							}
						}
						
				}
				
				XmlTag("TransactedRun") ETag;
			}
	}
}

//
// Element TransactedRunResponse
// Embedded ComplexType 
//
Struct WFIMwsTransactedRunResponseElement = this.STag.ToString
{
	[Post.Local.WFIMwsTransactedRunResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("TransactedRunResponse") STag;
	Switch
	{
		Case !Local.WFIMwsTransactedRunResponseElement_IsEmpty:
			Struct
			{
				XmlTag("TransactedRunResponse") ETag;
			}
	}
}

//
// Element TransactedSuspend
// Embedded ComplexType 
//
Struct WFIMwsTransactedSuspendElement = this.STag.ToString
{
	[Post.Local.WFIMwsTransactedSuspendElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("TransactedSuspend") STag;
	Switch
	{
		Case !Local.WFIMwsTransactedSuspendElement_IsEmpty:
			Struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "instanceId") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						Struct InstanceId = this.STag.ToString
						{
							[Post.Local.InstanceId_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("instanceId") STag;
							Switch
							{
								Case !Local.InstanceId_IsEmpty:
									Struct
									{
										StringTerm(Property.XMLEncoding, "<", true, false, false)InstanceId;
										XmlTag("instanceId") ETag;
									}
							}
						}
						
				}
				
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "reason") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						Struct Reason = this.Reason
						{
							[Post.Local.Reason_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("reason") STag;
							Switch
							{
								Case !Local.Reason_IsEmpty:
									Struct
									{
										StringTerm(Property.XMLEncoding, "<", true, false, false) Reason;
										XmlTag("reason") ETag;
									}
							}
						}
						
				}
				
				XmlTag("TransactedSuspend") ETag;
			}
	}
}

//
// Element TransactedSuspendResponse
// Embedded ComplexType 
//
Struct WFIMwsTransactedSuspendResponseElement = this.STag.ToString
{
	[Post.Local.WFIMwsTransactedSuspendResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("TransactedSuspendResponse") STag;
	Switch
	{
		Case !Local.WFIMwsTransactedSuspendResponseElement_IsEmpty:
			Struct
			{
				XmlTag("TransactedSuspendResponse") ETag;
			}
	}
}

//
// Element TransactedTerminate
// Embedded ComplexType 
//
Struct WFIMwsTransactedTerminateElement = this.STag.ToString
{
	[Post.Local.WFIMwsTransactedTerminateElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("TransactedTerminate") STag;
	switch
	{
		Case !Local.WFIMwsTransactedTerminateElement_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "instanceId") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct InstanceId = this.STag.ToString
						{
							[Post.Local.InstanceId_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("instanceId") STag;
							switch
							{
								Case !Local.InstanceId_IsEmpty:
									struct
									{
										StringTerm(Property.XMLEncoding, "<", true, false, false)InstanceId;
										XmlTag("instanceId") ETag;
									}
							}
						}
						
				}
				
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "reason") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct Reason = this.Reason
						{
							[Post.Local.Reason_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("reason") STag;
							switch
							{
								Case !Local.Reason_IsEmpty:
									struct
									{
										StringTerm(Property.XMLEncoding, "<", true, false, false) Reason;
										XmlTag("reason") ETag;
									}
							}
						}
						
				}
				
				XmlTag("TransactedTerminate") ETag;
			}
	}
}

//
// Element TransactedTerminateResponse
// Embedded ComplexType 
//
Struct WFIMwsTransactedTerminateResponseElement = this.STag.ToString
{
	[Post.Local.WFIMwsTransactedTerminateResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("TransactedTerminateResponse") STag;
	Switch
	{
		Case !Local.WFIMwsTransactedTerminateResponseElement_IsEmpty:
			Struct
			{
				XmlTag("TransactedTerminateResponse") ETag;
			}
	}
}

Table WFIMSoapActionTable(value)
{
	Switch(value)
	{
		Case "http://schemas.datacontract.org/2008/10/WorkflowServices/IWorkflowInstanceManagement/TransactedTerminate":
		Case "http://schemas.datacontract.org/2008/10/WorkflowServices/IWorkflowInstanceManagement/TransactedSuspend":
		Case "http://schemas.datacontract.org/2008/10/WorkflowServices/IWorkflowInstanceManagement/TransactedRun":
		Case "http://schemas.datacontract.org/2008/10/WorkflowServices/IWorkflowInstanceManagement/TransactedCancel":
		Case "http://schemas.datacontract.org/2008/10/WorkflowServices/IWorkflowInstanceManagement/Unsuspend":
		Case "http://schemas.datacontract.org/2008/10/WorkflowServices/IWorkflowInstanceManagement/Terminate":
		Case "http://schemas.datacontract.org/2008/10/WorkflowServices/IWorkflowInstanceManagement/Suspend":
		Case "http://schemas.datacontract.org/2008/10/WorkflowServices/IWorkflowInstanceManagement/Run":
		Case "http://schemas.datacontract.org/2008/10/WorkflowServices/IWorkflowInstanceManagement/Cancel":
		Case "http://schemas.datacontract.org/2008/10/WorkflowServices/IWorkflowInstanceManagement/Abandon":
		Case "http://schemas.datacontract.org/2008/10/WorkflowServices/IWorkflowInstanceManagement/TransactedUnsuspend":
			 true;
		Default:false;
	}
}