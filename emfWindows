//#  (c) 2009 CodePlex Foundation
//#
//#  Title:                  Enhanced Metafile Format
//#
//#  Details:                MS-EMF and MS-EMFSPOOL only; there is no parser for MS-EMFPLUS
//#
//#  Microsoft References:   [MS-EMF]: Enhanced Metafile Format Specification (6.5.1)
//#                          [MS-EMFSPOOL]: Enhanced Metafile Spool Format Specification (4.2.1)
//#                          [MS-EMFPLUS]: Enhanced Metafile Format Plus Extensions Specification (7.3)
//#
//#  Comments:               
//#
//#  Revision Class and Date:Major, 01/19/2010
//#                          Minor, 01/27/2010
//#
//####


[DataTypeByteOrder = LittleEndian]
[RegisterBefore(FileTypeContent.FileData, EMF, Property.SMBFileName.contains(".emf"))]
protocol EMF
{
	while[FrameOffset < FrameLength]
	{
		EMFRecord EMFRecord;
	}
}

//EMF Enumeration Tables

Table EMFRecordTypeEnumerationTable (value)
{
	switch(value)
	{
		case 0x00000001: FormatString ("0x%08X - EMR_HEADER - This record defines the start of the EMF metafile", value);
		case 0x00000002: FormatString ("0x%08X - EMR_POLYBEZIER - This record defines one or more Bezier curves", value);
		case 0x00000003: FormatString ("0x%08X - EMR_POLYGON - This record defines a polygon consisting of two or more vertices connected by straight lines", value);
		case 0x00000004: FormatString ("0x%08X - EMR_POLYLINE - This record defines a series of line segments by connecting the points in the specified array", value);
		case 0x00000005: FormatString ("0x%08X - EMR_POLYBEZIERTO - This record defines one or more Bezier curves based upon the current position", value);
		case 0x00000006: FormatString ("0x%08X - EMR_POLYLINETO - This record defines one or more straight lines based upon the current position", value);
		case 0x00000007: FormatString ("0x%08X - EMR_POLYPOLYLINE - This record defines multiple series of connected line segments", value);
		case 0x00000008: FormatString ("0x%08X - EMR_POLYPOLYGON - This record defines a series of closed polygons", value);
		case 0x00000009: FormatString ("0x%08X - EMR_SETWINDOWEXTEX - This record defines the window extent", value);
		case 0x0000000A: FormatString ("0x%08X - EMR_SETWINDOWORGEX - This record defines the window origin", value);
		case 0x0000000B: FormatString ("0x%08X - EMR_SETVIEWPORTEXTEX - This record defines the viewport extent", value);
		case 0x0000000C: FormatString ("0x%08X - EMR_SETVIEWPORTORGEX - This record defines the viewport origin", value);
		case 0x0000000D: FormatString ("0x%08X - EMR_SETBRUSHORGEX - This record defines the origin of the current brush", value);
		case 0x0000000E: FormatString ("0x%08X - EMR_EOF - This record defines data for the enhanced metafile record that indicates the end of the metafile", value);
		case 0x0000000F: FormatString ("0x%08X - EMR_SETPIXELV - This record defines the color of the pixel at the specified logical coordinates", value);
		case 0x00000010: FormatString ("0x%08X - EMR_SETMAPPERFLAGS - This record redefines the algorithm the font mapper uses when it maps logical fonts to physical fonts", value);
		case 0x00000011: FormatString ("0x%08X - EMR_SETMAPMODE - This record defines the mapping mode of the specified device context", value);
		case 0x00000012: FormatString ("0x%08X - EMR_SETBKMODE - This record defines the background mix mode of the specified device context", value);
		case 0x00000013: FormatString ("0x%08X - EMR_SETPOLYFILLMODE - This record defines polygon fill mode", value);
		case 0x00000014: FormatString ("0x%08X - EMR_SETROP2 - This record defines binary raster operation mode", value);
		case 0x00000015: FormatString ("0x%08X - EMR_SETSTRETCHBLTMODE - This record defines bitmap stretch mode", value);
		case 0x00000016: FormatString ("0x%08X - EMR_SETTEXTALIGN - This record defines text alignment", value);
		case 0x00000017: FormatString ("0x%08X - EMR_SETCOLORADJUSTMENT - This record defines the color adjustment values for a device context (DC) using the specified values", value);
		case 0x00000018: FormatString ("0x%08X - EMR_SETTEXTCOLOR - This record defines the current text color", value);
		case 0x00000019: FormatString ("0x%08X - EMR_SETBKCOLOR - This record defines the background color", value);
		case 0x0000001A: FormatString ("0x%08X - EMR_OFFSETCLIPRGN - This record redefines the clipping region of a device context by the specified offsets", value);
		case 0x0000001B: FormatString ("0x%08X - EMR_MOVETOEX - This record defines coordinates of the new current position in logical units", value);
		case 0x0000001C: FormatString ("0x%08X - EMR_SETMETARGN - This record intersects the current clipping region for the specified device context", value);
		case 0x0000001D: FormatString ("0x%08X - EMR_EXCLUDECLIPRECT - This record defines a new clipping region that consists of the existing clipping region minus the specified rectangle", value);
		case 0x0000001E: FormatString ("0x%08X - EMR_INTERSECTCLIPRECT - This record defines a new clipping region from the intersection of the current clipping region and the specified rectangle", value);
		case 0x0000001F: FormatString ("0x%08X - EMR_SCALEVIEWPORTEXTEX - This record redefines the viewport for a device context using the ratios formed by the specified multiplicands and divisors", value);
		case 0x00000020: FormatString ("0x%08X - EMR_SCALEWINDOWEXTEX - This record redefines the window for a device context using the ratios formed by the specified multiplicands and divisors", value);
		case 0x00000021: FormatString ("0x%08X - EMR_SAVEDC - This record defines an instruction to save the current state of the specified device context (DC)", value);
		case 0x00000022: FormatString ("0x%08X - EMR_RESTOREDC - This record defines an instruction to restore a device context (DC) to the specified state", value);
		case 0x00000023: FormatString ("0x%08X - EMR_SETWORLDTRANSFORM - This record defines a two-dimensional linear transformation between world space and page space", value);
		case 0x00000024: FormatString ("0x%08X - EMR_MODIFYWORLDTRANSFORM - This record redefines the world transformation for a device context using the specified mode", value);
		case 0x00000025: FormatString ("0x%08X - EMR_MODIFYWORLDTRANSFORM - This record redefines the world transformation for a device context using the specified mode.", value);
		case 0x00000026: FormatString ("0x%08X - EMR_CREATEPEN - This record defines a logical pen that has the specified style, width, and color", value);
		case 0x00000027: FormatString ("0x%08X - EMR_CREATEBRUSHINDIRECT - This record defines a logical brush that has the specified style, color, and pattern", value);
		case 0x00000028: FormatString ("0x%08X - EMR_DELETEOBJECT - This record defines index of the object to be deleted from the handle table", value);
		case 0x00000029: FormatString ("0x%08X - EMR_ANGLEARC - This record defines a line segment of an arc", value);
		case 0x0000002A: FormatString ("0x%08X - EMR_ELLIPSE - This record defines an ellipse", value);
		case 0x0000002B: FormatString ("0x%08X - EMR_RECTANGLE - This record defines a rectangle", value);
		case 0x0000002C: FormatString ("0x%08X - EMR_ROUNDRECT - This record defines a rectangle with rounded corners", value);
		case 0x0000002D: FormatString ("0x%08X - EMR_ARC - This record defines an elliptical arc", value);
		case 0x0000002E: FormatString ("0x%08X - EMR_CHORD - This record defines a chord", value);
		case 0x0000002F: FormatString ("0x%08X - EMR_PIE - This record defines a pie-shaped wedge bounded by the intersection of an ellipse and two radials", value);
		case 0x00000030: FormatString ("0x%08X - EMR_SELECTPALETTE - This record selects the specified logical palette into a device context", value);
		case 0x00000031: FormatString ("0x%08X - EMR_CREATEPALETTE - This record defines a logical palette", value);
		case 0x00000032: FormatString ("0x%08X - EMR_SETPALETTEENTRIES - This record defines RGB (red, green, blue) color values and values in a range of entries in a logical palette", value);
		case 0x00000033: FormatString ("0x%08X - EMR_RESIZEPALETTE - This record increases or decreases the size of a logical palette based on the specified value", value);
		case 0x00000034: FormatString ("0x%08X - EMR_REALIZEPALETTE - This record maps palette entries from the current logical palette to the system palette", value);
		case 0x00000035: FormatString ("0x%08X - EMR_EXTFLOODFILL - This record fills an area of the display surface with the current brush", value);
		case 0x00000036: FormatString ("0x%08X - EMR_LINETO - This record defines a line from the current position up to, but not including, the specified point", value);
		case 0x00000037: FormatString ("0x%08X - EMR_ARCTO - This record defines an elliptical arc. It resets the current position to the end point of the arc", value);
		case 0x00000038: FormatString ("0x%08X - EMR_POLYDRAW - This record defines a set of line segments and Bezier curves", value);
		case 0x00000039: FormatString ("0x%08X - EMR_SETARCDIRECTION - This record defines the drawing direction to be used for arc and rectangle functions", value);
		case 0x0000003A: FormatString ("0x%08X - EMR_SETMITERLIMIT - This record defines the limit for the length of miter joins for the specified device context", value);
		case 0x0000003B: FormatString ("0x%08X - EMR_BEGINPATH - This record opens a path bracket in the specified device context", value);
		case 0x0000003C: FormatString ("0x%08X - EMR_ENDPATH - This record closes a path bracket and selects the path defined by the bracket into the specified device context", value);
		case 0x0000003D: FormatString ("0x%08X - EMR_CLOSEFIGURE - This record closes an open figure in a path", value);
		case 0x0000003E: FormatString ("0x%08X - EMR_FILLPATH - This record closes any open figures in the current path and fills the path's interior by using the current brush and polygon-filling mode", value);
		case 0x0000003F: FormatString ("0x%08X - EMR_STROKEANDFILLPATH - This record closes any open figures in a path", value);
		case 0x00000040: FormatString ("0x%08X - EMR_STROKEPATH - This record renders the specified path by using the current pen", value);
		case 0x00000041: FormatString ("0x%08X - EMR_FLATTENPATH - This record transforms any curves in the path that is selected into the current device context (DC), turning each curve into a sequence of lines", value);
		case 0x00000042: FormatString ("0x%08X - EMR_WIDENPATH - This record redefines the current path as the area that would be painted if the path were stroked using the pen currently selected into the given device context", value);
		case 0x00000043: FormatString ("0x%08X - EMR_SELECTCLIPPATH - This record defines the current path as a clipping region for a device context, combining the new region with any existing clipping region using the specified mode", value);
		case 0x00000044: FormatString ("0x%08X - EMR_ABORTPATH - This record aborts a path bracket or discards the path from a closed path bracket", value);
		case 0x00000046: FormatString ("0x%08X - EMR_GDICOMMENT - This record contains public or private data", value);
		case 0x00000047: FormatString ("0x%08X - EMR_FILLRGN - This record fills the specified region by using the specified brush", value);
		case 0x00000048: FormatString ("0x%08X - EMR_FRAMERGN - This record draws a border around the specified region using the specified brush", value);
		case 0x00000049: FormatString ("0x%08X - EMR_INVERTRGN - This record inverts the colors in the specified region", value);
		case 0x0000004A: FormatString ("0x%08X - EMR_PAINTRGN - This record paints the specified region by using the brush currently selected into the device context", value);
		case 0x0000004B: FormatString ("0x%08X - EMR_EXTSELECTCLIPRGN - This record combines the specified region with the current clip region using the specified mode", value);
		case 0x0000004C: FormatString ("0x%08X - EMR_BITBLT - This record performs a bit-block transfer of the color data corresponding to a rectangle of pixels from the specified bitmap data to the metafile device context", value);
		case 0x0000004D: FormatString ("0x%08X - EMR_STRETCHBLT - This record copies a bitmap from a source rectangle into a destination rectangle, stretching or compressing the bitmap to fit the dimensions of the destination rectangle", value);
		case 0x0000004E: FormatString ("0x%08X - EMR_MASKBLT - This record combines the color data for the source and destination bitmaps using the specified mask and raster operation", value);
		case 0x0000004F: FormatString ("0x%08X - EMR_PLGBLT - This record defines a bit-block transfer of the bits of color data from the specified rectangle in the source device context to the specified parallelogram in the destination device context", value);
		case 0x00000050: FormatString ("0x%08X - EMR_SETDIBITSTODEVICE - This record sets the pixels in the specified rectangle on the device that is associated with the destination device context using color data from a DIB", value);
		case 0x00000051: FormatString ("0x%08X - EMR_STRETCHDIBITS - This record copies the color data for a rectangle of pixels in a DIB to the specified destination rectangle", value);
		case 0x00000052: FormatString ("0x%08X - EMR_EXTCREATEFONTINDIRECTW - This record defines a logical font that has the specified characteristics", value);
		case 0x00000053: FormatString ("0x%08X - EMR_EXTTEXTOUTA - This record defines ASCII text using the currently selected font, background color, and text color", value);
		case 0x00000054: FormatString ("0x%08X - EMR_EXTTEXTOUTW - This record defines Unicode text using the currently selected font, background color, and text color", value);
		case 0x00000055: FormatString ("0x%08X - EMR_POLYBEZIER16 - This record defines one or more Bezier curves. The curves are drawn using the current pen", value);
		case 0x00000056: FormatString ("0x%08X - EMR_POLYGON16 - This record defines a polygon consisting of two or more vertices connected by straight lines", value);
		case 0x00000057: FormatString ("0x%08X - EMR_POLYLINE16 - This record defines a series of line segments by connecting the points in the specified array", value);
		case 0x00000058: FormatString ("0x%08X - EMR_POLYBEZIERTO16 - This record defines one or more Bezier curves based on the current position", value);
		case 0x00000059: FormatString ("0x%08X - EMR_POLYLINETO16 - This record defines one or more straight lines based upon the current position", value);
		case 0x0000005A: FormatString ("0x%08X - EMR_POLYPOLYLINE16 - This record defines multiple series of connected line segments", value);
		case 0x0000005B: FormatString ("0x%08X - EMR_POLYPOLYGON16 - This record defines a series of closed polygons", value);
		case 0x0000005C: FormatString ("0x%08X - EMR_POLYDRAW16 - This record defines a set of line segments and Bezier curves", value);
		case 0x0000005D: FormatString ("0x%08X - EMR_CREATEMONOBRUSH - This record defines a logical brush with the specified bitmap pattern", value);
		case 0x0000005E: FormatString ("0x%08X - EMR_CREATEDIBPATTERNBRUSHPT - This record defines logical brush that has the pattern specified by the device-independent bitmap (DIB)", value);
		case 0x0000005F: FormatString ("0x%08X - EMR_EXTCREATEPEN - This record defines a logical cosmetic or geometric pen that has the specified style, width, and brush attributes", value);
		case 0x00000060: FormatString ("0x%08X - EMR_POLYTEXTOUTA - This record defines several ASCII strings using the font and text colors currently selected in the specified device context", value);
		case 0x00000061: FormatString ("0x%08X - EMR_POLYTEXTOUTW - This record defines several UNICODE strings using the font and text colors currently selected in the specified device context", value);
		case 0x00000062: FormatString ("0x%08X - EMR_SETICMMODE - This record defines Image Color Management to be enabled, disabled, or queried on a given device context (DC)", value);
		case 0x00000063: FormatString ("0x%08X - EMR_CREATECOLORSPACE - This record defines a logical color space", value);
		case 0x00000064: FormatString ("0x%08X - EMR_SETCOLORSPACE - This record sets current logical color space", value);
		case 0x00000065: FormatString ("0x%08X - EMR_DELETECOLORSPACE - This record defines how to delete a logical color space from the handle table", value);
		case 0x00000066: FormatString ("0x%08X - EMR_GLSRECORD - This record defines an enhanced metafile record generated by OpenGL functions", value);
		case 0x00000067: FormatString ("0x%08X - EMR_GLSBOUNDEDRECORD - This record defines an enhanced metafile record generated by OpenGL functions within a bounding rectangle", value);
		case 0x00000068: FormatString ("0x%08X - EMR_PIXELFORMAT - This record defines the pixel format of the specified device context to the format specified by the data in this record", value);
		case 0x00000069: FormatString ("0x%08X - EMR_DRAWESCAPE - This record passes arbitrary information to the driver. The intent is that the information will result in drawing being done", value);
		case 0x0000006A: FormatString ("0x%08X - EMR_EXTESCAPE - This record passes arbitrary information to the driver. The intent is that the information will not result in drawing being done", value);
		case 0x0000006B: FormatString ("0x%08X - EMR_STARTDOC - This record defines the beginning of a UNICODE (as specified in [UNICODE]) document", value);
		case 0x0000006C: FormatString ("0x%08X - EMR_SMALLTEXTOUT - This record outputs a string", value);
		case 0x0000006D: FormatString ("0x%08X - EMR_FORCEUFIMAPPING - This record forces the font mapper to match fonts based on their UNIVERSAL_FONT_ID in preference to their LOGFONT information", value);
		case 0x0000006E: FormatString ("0x%08X - EMR_NAMEDESCAPE - This record passes arbitrary information to the given named driver", value);
		case 0x0000006F: FormatString ("0x%08X - EMR_COLORCORRECTPALETTE - This record defines how to correct the entries of a palette using the WCS 1.0 members in the specified device context", value);
		case 0x00000070: FormatString ("0x%08X - EMR_SETICMPROFILEA - This record defines how to set a specified color profile as the output profile for a specified device context (DC) using an ASCII filename", value);
		case 0x00000071: FormatString ("0x%08X - EMR_SETICMPROFILEW - This record defines how to set a specified color profile as the output profile for a specified device context (DC) using a UNICODE (as specified in [UNICODE]) filename", value);
		case 0x00000072: FormatString ("0x%08X - EMR_ALPHABLEND - This record defines bitmaps that have transparent or semitransparent pixels", value);
		case 0x00000073: FormatString ("0x%08X - EMR_SETLAYOUT - This record redefines the layout of a device context (DC)", value);
		case 0x00000074: FormatString ("0x%08X - EMR_TRANSPARENTBLT - This record defines a bit-block transfer of the color data corresponding to a rectangle of pixels from the specified source device context into a destination device context", value);
		case 0x00000076: FormatString ("0x%08X - EMR_GRADIENTFILL - This record defines how to fill rectangle and triangle records", value);
		case 0x00000077: FormatString ("0x%08X - EMR_SETLINKEDUFIS - This record sets the UNIVERSAL_FONT_ID's of linked fonts to use during character lookup", value);
		case 0x00000078: FormatString ("0x%08X - EMR_SETTEXTJUSTIFICATION - This record sets the amount of extra space to add to break characters for justification purposes", value);
		case 0x00000079: FormatString ("0x%08X - EMR_COLORMATCHTOTARGETW - This record defines how to preview colors as they would appear on the target device", value);
		case 0x0000007A: FormatString ("0x%08X - EMR_CREATECOLORSPACEW - This record defines a logical color space using a UNICODE (as specified in [UNICODE]) filename", value);
		default : FormatString ("0x%08X - No Description Available", value);
	}
}

Table EMFArcDirectionEnumerationTable(value)
{
	switch(value)
	{
		case 0x00000001: FormatString ("0x%08X - AD_COUNTERCLOSEWISE - Figures drawn counterclockwise", value);
		case 0x00000002: FormatString ("0x%08X - AD_CLOCKWISE - Figures drawn clockwise", value);
		default : FormatString ("0x%08X - No Description Available", value);
	}
}

Table EMFArmStyleEnumerationTable(value)
{
	switch(value)
	{
		case 0x00: FormatString ("0x%02X - PAN_ANY - Any", value);
		case 0x01: FormatString ("0x%02X - PAN_NO_FIT - No Fit", value);
		case 0x02: FormatString ("0x%02X - PAN_STRAIGHT_ARMS_HORZ - Straight Arms/Horizontal", value);
		case 0x03: FormatString ("0x%02X - PAN_STRAIGHT_ARMS_WEDGE - Straight Arms/Wedge", value);
		case 0x04: FormatString ("0x%02X - PAN_STRAIGHT_ARMS_VERT - Straight Arms/Vertical", value);
		case 0x05: FormatString ("0x%02X - PAN_STRAIGHT_ARMS_SINGLE_SERIF - Straight Arms/Single-Serif", value);
		case 0x06: FormatString ("0x%02X - PAN_STRAIGHT_ARMS_DOUBLE_SERIF - Straight Arms/Double-Serif", value);
		case 0x07: FormatString ("0x%02X - PAN_BENT_ARMS_HORZ - Non-Straight Arms/Horizontal", value);
		case 0x08: FormatString ("0x%02X - PAN_BENT_ARMS_WEDGE - Non-Straight Arms/Wedge", value);
		case 0x09: FormatString ("0x%02X - PAN_BENT_ARMS_VERT - Non-Straight Arms/Vertical", value);
		case 0x0A: FormatString ("0x%02X - PAN_BENT_ARMS_SINGLE_SERIF - Non-Straight Arms/Single-Serif", value);
		case 0x0B: FormatString ("0x%02X - PAN_BENT_ARMS_DOUBLE_SERIF - Non-Straight Arms/Double-Serif", value);
		default : FormatString ("0x%02X - No Description Available", value);
	}
}

Table EMFBackgroundModeEnumerationTable(value)
{
	switch(value)
	{
		case 0x0001: FormatString ("0x%04X - TRANSPARENT - Background remains untouched", value);
		case 0x0002: FormatString ("0x%04X - OPAQUE - Background is filled with the current background color before the text, hatched brush, or pen is drawn", value);
		default	   : FormatString ("0x%04X - No Description Available", value);
	}
}

Table EMFColorAdjustmentEnumerationTable(value)
{
	switch(value)
	{
		case 0x0001: FormatString ("0x%04X - CA_NEGATIVE - Specifies that the negative of the original image should be displayed", value);
		case 0x0002: FormatString ("0x%04X - CA_LOG_FILTER - Specifies that a logarithmic function should be applied to the final density of the output colors", value);
		default	   : FormatString ("0x%04X - No Description Available", value);
	}
}

Table EMFColorMatchToTargetEnumerationTable(value)
{
	switch(value)
	{
		case 0x00000001:  FormatString ("0x%08X - COLORMATCHTOTARGET_EMBEDED: Indicates that a color profile has been embedded in the metafile", value);
		default		   : FormatString ("0x%08X - No Description Available", value);
	}
}

Table EMFColorSpaceEnumerationTable(value)
{
	switch(value)
	{
		case 0x00000001: FormatString ("0x%08X - CS_ENABLE - Maps colors to the target device's color gamut. This enables color proofing", value);
		case 0x00000002: FormatString ("0x%08X - CS_DISABLE - Disables color proofing", value);
		case 0x00000003: FormatString ("0x%08X - CS_DELETE_TRANSFORM - If color management is enabled for the target profile, disables it and deletes the concatenated transform", value);
		default		   : FormatString ("0x%08X - No Description Available", value);
	}
}

Table EMFContrastEnumerationTable(value)
{
	switch(value)
	{
		case 0x00: FormatString ("0x%02X - PAN_ANY - Any", value); 
		case 0x01: FormatString ("0x%02X - PAN_NO_FIT - No Fit", value);
		case 0x02: FormatString ("0x%02X - PAN_CONTRAST_NONE - None", value);
		case 0x03: FormatString ("0x%02X - PAN_CONTRAST_VERY_LOW - Very Low", value);
		case 0x04: FormatString ("0x%02X - PAN_CONTRAST_LOW - Low", value);
		case 0x05: FormatString ("0x%02X - PAN_CONTRAST_MEDIUM_LOW - Medium Low", value);
		case 0x06: FormatString ("0x%02X - PAN_CONTRAST_MEDIUM - Medium", value);
		case 0x07: FormatString ("0x%02X - PAN_CONTRAST_MEDIUM_HIGH - Medium High", value);
		case 0x08: FormatString ("0x%02X - PAN_CONTRAST_HIGH - High", value);
		case 0x09: FormatString ("0x%02X - PAN_CONTRAST_VERY_HIGH - Very High", value);
		default	 : FormatString ("0x%02X - No Description Available", value);
	}
}

Table EMFDIBColorsEnumerationTable(value)
{
	switch(value)
	{
		case 0x00000000: FormatString ("0x%08X - DIB_RGB_COLORS - The color table contains literal RGB values", value); 
		case 0x00000001: FormatString ("0x%08X - DIB_PAL_COLORS - The color table consists of an array of 16-bit indexes into the currently selected logical palette", value);
		default		   : FormatString ("0x%08X - No Description Available", value);
	}
}

Table EMFFamilyTypeEnumerationTable(value)
{
	switch(value)
	{
		case 0x00: FormatString ("0x%02X - PAN_ANY - Any", value);
		case 0x01: FormatString ("0x%02X - PAN_NO_FIT - No Fit", value);
		case 0x02: FormatString ("0x%02X - PAN_FAMILY_TEXT_DISPLAY - Text and Display", value);
		case 0x03: FormatString ("0x%02X - PAN_FAMILY_SCRIPT - Script", value);
		case 0x04: FormatString ("0x%02X - PAN_FAMILY_DECORATIVE - Decorative", value);
		case 0x05: FormatString ("0x%02X - PAN_FAMILY_PICTORIAL - Pictorial", value);
		default	 : FormatString ("0x%02X - No Description Available", value);
	}
}
	
Table EMFFloodFillEnumerationTable(value)
{
	switch(value)
	{
		case 0x00000000: FormatString ("0x%08X - FLOODFILLBORDER - The fill area is bounded by the color specified by the Color member", value);
		case 0x00000001: FormatString ("0x%08X - FLOODFILLSURFACE - The fill area is defined by the color that is specified by the Color member", value);
		default		   : FormatString ("0x%08X - No Description Available", value);
	}
}

Table EMFFormatSignatureEnumerationTable(value)
{
	switch(value)
	{
		case 0x464D4520: FormatString ("0x%08X - ENHMETA_SIGNATURE - Version must be less than or equal to META_FORMAT_ENHANCED (0x10000). 0x'FME' or 0x'EMF'", value);
		case 0x46535045: FormatString ("0x%08X - EPS_SIGNATURE - The driver must support an ENCAPSULATED_POSTSCRIPT escape. 0x'FSPE' or 0x'EPSF'", value);
		default		   : FormatString ("0x%08X - No Description Available", value);
	}
}

Table EMFGDICommentEnumerationTable(value)
{
	switch(value)
	{
		case 0x00000002: FormatString ("0x%08X - GDICOMMENT_BEGINGROUP - This record comment identifies the beginning of a group of drawing records", value);
		case 0x00000003: FormatString ("0x%08X - GDICOMMENT_ENDGROUP - This record comment identifies the end of a group of drawing records", value);
		case 0x00000040: FormatString ("0x%08X - GDICOMMENT_UNICODE_STRING - This record comment identifies the beginning of a group of UNICODE (as specified in [UNICODE]) string records", value);
		case 0x00000080: FormatString ("0x%08X - GDICOMMENT_UNICODE_END - This record comment identifies the end of a group of UNICODE (as specified in [UNICODE]) string records", value);
		case 0x40000004: FormatString ("0x%08X - GDICOMMENT_MULTIFORMATS - Windows NT 4.0 SP4 and earlier: This record allows multiple definitions of a picture to be included in an enhanced metafile", value);
		case 0x80000001: FormatString ("0x%08X - GDICOMMENT_WINDOWS_METAFILE - This record comment contains a Windows-format metafile that is equivalent to an enhanced-format metafile", value);
		default		   : FormatString ("0x%08X - No Description Available", value);
	}
}

Table EMFGradientFillEnumerationTable(value)
{
	switch(value)
	{
		case 0x00000000: FormatString ("0x%08X - GRADIENT_FILL_RECT_H - GDI interpolates the color from the left to right edge and fills the interior", value);
		case 0x00000001: FormatString ("0x%08X - GRADIENT_FILL_RECT_V - GDI interpolates the color from the top to bottom edge and fills the interior", value);
		case 0x00000002: FormatString ("0x%08X - GRADIENT_FILL_TRIANGLE - GDI performs linear interpolation between triangle vertices and fills the interior", value);
		default		   : FormatString ("0x%08X - No Description Available", value);
	}
}

Table EMFICMModeEnumerationTable(value)
{
	switch(value)
	{
		case 0x00000001: FormatString ("0x%08X - ICM_OFF - Turns off color management. Turns on old-style color correction of halftones", value);
		case 0x00000002: FormatString ("0x%08X - ICM_ON - Turns on color management. Turns off old-style color correction of halftones", value);
		case 0x00000003: FormatString ("0x%08X - ICM_QUERY - Queries the current state of color management", value);
		case 0x00000004: FormatString ("0x%08X - ICM_DONE_OUTSIDEDC - Turns off color management inside DC, and turns off old-style color correction of halftones", value);
		default		   : FormatString ("0x%08X - No Description Available", value);
	}
}

Table EMFIlluminantEnumerationTable(value)
{
	switch(value)
	{
		case 0x00: FormatString ("0x%02X - ILLUMINANT_DEVICE_DEFAULT - Device's default. Standard used by output devices", value);
		case 0x01: FormatString ("0x%02X - ILLUMINANT_A or ILLUMINANT_TUNGSTEN - Tungsten lamp", value); 
		case 0x02: FormatString ("0x%02X - ILLUMINANT_B - Noon sunlight", value);
		case 0x03: FormatString ("0x%02X - ILLUMINANT_C NTSC or ILLUMINANT_NTSC or ILLUMINANT_DAYLIGHT - daylight", value);
		case 0x04: FormatString ("0x%02X - ILLUMINANT_D50 - Normal print", value);
		case 0x05: FormatString ("0x%02X - ILLUMINANT_D55 - Bond paper print", value);
		case 0x06: FormatString ("0x%02X - ILLUMINANT_D65 - Standard daylight. Standard for CRTs and pictures", value);
		case 0x07: FormatString ("0x%02X - ILLUMINANT_D75 - Northern daylight", value);
		case 0x08: FormatString ("0x%02X - ILLUMINANT_F2 or ILLUMINANT_FLUORESCENT - Cool white lamp", value);
		default	 : FormatString ("0x%02X - No Description Available", value);
	}
}

Table EMFLetterformEnumerationTable(value)
{
	switch(value)
	{
		case 0x00: FormatString ("0x%02X - PAN_ANY - Any", value);
		case 0x01: FormatString ("0x%02X - PAN_NO_FIT - No Fit", value);
		case 0x02: FormatString ("0x%02X - PAN_LETT_NORMAL_CONTACT - Normal/Contact", value);
		case 0x03: FormatString ("0x%02X - PAN_LETT_NORMAL_WEIGHTED - Normal/Weighted", value);
		case 0x04: FormatString ("0x%02X - PAN_LETT_NORMAL_BOXED - Normal/Boxed", value);
		case 0x05: FormatString ("0x%02X - PAN_LETT_NORMAL_FLATTENED - Normal/Flattened", value);
		case 0x06: FormatString ("0x%02X - PAN_LETT_NORMAL_ROUNDED - Normal/Rounded", value);
		case 0x07: FormatString ("0x%02X - PAN_LETT_NORMAL_OFF_CENTER - Normal/Off Center", value);
		case 0x08: FormatString ("0x%02X - PAN_LETT_NORMAL_SQUARE - Normal/Square", value);
		case 0x09: FormatString ("0x%02X - PAN_LETT_OBLIQUE_CONTACT - Oblique/Contact", value);
		case 0x0A: FormatString ("0x%02X - PAN_LETT_OBLIQUE_WEIGHTED - Oblique/Weighted", value);
		case 0x0B: FormatString ("0x%02X - PAN_LETT_OBLIQUE_BOXED - Oblique/Boxed", value);
		case 0x0C: FormatString ("0x%02X - PAN_LETT_OBLIQUE_FLATTENED - Oblique/Flattened", value);
		case 0x0D: FormatString ("0x%02X - PAN_LETT_OBLIQUE_ROUNDED - Oblique/Rounded", value);
		case 0x0E: FormatString ("0x%02X - PAN_LETT_OBLIQUE_OFF_CENTER - Oblique/Off Center", value);
		case 0x0F: FormatString ("0x%02X - PAN_LETT_OBLIQUE_SQUARE - Oblique/Square", value);
		default	 : FormatString ("0x%02X - No Description Available", value);
	}
}

Table EMFMapModeEnumerationTable(value)
{
	switch(value)
	{
		case 0x00000001: FormatString ("0x%08X - MM_TEXT - Each logical unit is mapped to one device pixel. Positive x is to the right; positive y is down", value);
		case 0x00000002: FormatString ("0x%08X - MM_LOMETRIC - Each logical unit is mapped to 0.1 millimeter. Positive x is to the right; positive y is up", value);
		case 0x00000003: FormatString ("0x%08X - MM_HIMETRIC - Each logical unit is mapped to 0.01 millimeter. Positive x is to the right; positive y is up", value);
		case 0x00000004: FormatString ("0x%08X - MM_LOENGLISH - Each logical unit is mapped to 0.01 inch. Positive x is to the right; positive y is up", value);
		case 0x00000005: FormatString ("0x%08X - MM_HIENGLISH - Each logical unit is mapped to 0.001 inch. Positive x is to the right; positive y is up", value);
		case 0x00000006: FormatString ("0x%08X - MM_TWIPS: Each logical unit is mapped to one twentieth of a printer's point. Positive x is to the right; positive y is up", value);
		case 0x00000007: FormatString ("0x%08X - MM_ISOTROPIC - Logical units are mapped to arbitrary units with equally scaled axes; that is, one unit along the x-axis is equal to one unit along the y-axis", value);
		case 0x00000008: FormatString ("0x%08X - MM_ANISOTROPIC - Logical units are mapped to arbitrary units with arbitrarily scaled axes", value);
		default		   : FormatString ("0x%08X - No Description Available", value);
	}
}

Table EMFMidLineEnumerationTable(value)
{
	switch(value)
	{
		case 0x00: FormatString ("0x%02X - PAN_ANY - Any", value);
		case 0x01: FormatString ("0x%02X - PAN_NO_FIT - No Fit", value);
		case 0x02: FormatString ("0x%02X - PAN_MIDLINE_STANDARD_TRIMMED - Standard/Trimmed", value);
		case 0x03: FormatString ("0x%02X - PAN_MIDLINE_STANDARD_POINTED - Standard/Pointed", value);
		case 0x04: FormatString ("0x%02X - PAN_MIDLINE_STANDARD_SERIFED - Standard/Serifed", value);
		case 0x05: FormatString ("0x%02X - PAN_MIDLINE_HIGH_TRIMMED - High/Trimmed", value);
		case 0x06: FormatString ("0x%02X - PAN_MIDLINE_HIGH_POINTED - High/Pointed", value);
		case 0x07: FormatString ("0x%02X - PAN_MIDLINE_HIGH_SERIFED - High/Serifed", value);
		case 0x08: FormatString ("0x%02X - PAN_MIDLINE_CONSTANT_TRIMMED - Constant/Trimmed", value);
		case 0x09: FormatString ("0x%02X - PAN_MIDLINE_CONSTANT_POINTED - Constant/Pointed", value);
		case 0x0A: FormatString ("0x%02X - PAN_MIDLINE_CONSTANT_SERIFED - Constant/Serifed", value);
		case 0x0B: FormatString ("0x%02X - PAN_MIDLINE_LOW_TRIMMED - Low/Trimmed", value);
		case 0x0C: FormatString ("0x%02X - PAN_MIDLINE_LOW_POINTED - Low/Pointed", value);
		case 0x0D: FormatString ("0x%02X - PAN_MIDLINE_LOW_SERIFED - Low/Serifed", value);
		default	 : FormatString ("0x%02X - No Description Available", value);
	}
}

Table EMFModifyWorldTransformModeEnumerationTable(value)
{
	switch(value)
	{
		case 0x01: FormatString ("0x%02X - MWT_IDENTITY - Resets the current world transformation by using the identity matrix", value);
		case 0x02: FormatString ("0x%02X - MWT_LEFTMULTIPLY - Multiplies the current transformation by the data in the XForm object", value);
		case 0x03: FormatString ("0x%02X - MWT_RIGHTMULTIPLY - Multiplies the current transformation by the data in the XForm object", value);
		case 0x04: FormatString ("0x%02X - MWT_SET - Same as using an EMR_MODIFYWORLDTRANSFORM record", value);
		default	 : FormatString ("0x%02X - No Description Available", value);
	}
}

Table EMFSerifTypeEnumerationTable(value)
{
	switch(value)
	{
		case 0x00: FormatString ("0x%02X - PAN_ANY - Any", value);
		case 0x01: FormatString ("0x%02X - PAN_NO_FIT - No Fit", value);
		case 0x02: FormatString ("0x%02X - PAN_SERIF_COVE - Cove", value);
		case 0x03: FormatString ("0x%02X - PAN_SERIF_OBTUSE_COVE - Obtuse Cove", value);
		case 0x04: FormatString ("0x%02X - PAN_SERIF_SQUARE_COVE - Square Cove", value);
		case 0x05: FormatString ("0x%02X - PAN_SERIF_OBTUSE_SQUARE_COVE - Obtuse Square Cove", value);
		case 0x06: FormatString ("0x%02X - PAN_SERIF_SQUARE - Square", value);
		case 0x07: FormatString ("0x%02X - PAN_SERIF_THIN - Thin", value);
		case 0x08: FormatString ("0x%02X - PAN_SERIF_BONE - Bone", value);
		case 0x09: FormatString ("0x%02X - PAN_SERIF_EXAGGERATED - Exaggerated", value);
		case 0x0A: FormatString ("0x%02X - PAN_SERIF_TRIANGLE - Triangle", value);
		case 0x0B: FormatString ("0x%02X - PAN_SERIF_NORMAL_SANS - Normal Sans", value);
		case 0x0C: FormatString ("0x%02X - PAN_SERIF_OBTUSE_SANS - Obtuse Sans", value);
		case 0x0D: FormatString ("0x%02X - PAN_SERIF_PERP_SANS - Perp Sans", value);
		case 0x0E: FormatString ("0x%02X - PAN_SERIF_FLARED - Flared", value);
		case 0x0F: FormatString ("0x%02X - PAN_SERIF_ROUNDED - Rounded", value);
		default	 : FormatString ("0x%02X - No Description Available", value);		
	}
}

Table EMFWeightEnumerationTable(value)
{
	switch(value)
	{
		case 0x00: FormatString ("0x%02X - PAN_ANY - Any", value);
		case 0x01: FormatString ("0x%02X - PAN_NO_FIT - No Fit", value);
		case 0x02: FormatString ("0x%02X - PAN_WEIGHT_VERY_LIGHT - Very Light", value);
		case 0x03: FormatString ("0x%02X - PAN_WEIGHT_LIGHT - Light", value);
		case 0x04: FormatString ("0x%02X - PAN_WEIGHT_THIN - Thin", value);
		case 0x05: FormatString ("0x%02X - PAN_WEIGHT_BOOK - Book", value);
		case 0x06: FormatString ("0x%02X - PAN_WEIGHT_MEDIUM - Medium", value);
		case 0x07: FormatString ("0x%02X - PAN_WEIGHT_DEMI - Demi", value);
		case 0x08: FormatString ("0x%02X - PAN_WEIGHT_BOLD - Bold", value);
		case 0x09: FormatString ("0x%02X - PAN_WEIGHT_HEAVY - Heavy", value);
		case 0x0A: FormatString ("0x%02X - PAN_WEIGHT_BLACK - Black", value);
		case 0x0B: FormatString ("0x%02X - PAN_WEIGHT_NORD - Nord", value);
		default	 : FormatString ("0x%02X - No Description Available", value);		
	}
}

Table EMFProportionEnumerationTable(value)
{
	switch(value)
	{
		case 0x00: FormatString ("0x%02X - PAN_ANY - Any", value);
		case 0x01: FormatString ("0x%02X - PAN_NO_FIT - No Fit", value);
		case 0x02: FormatString ("0x%02X - PAN_PROP_OLD_STYLE - Old Style", value);
		case 0x03: FormatString ("0x%02X - PAN_PROP_MODERN - Modern", value);
		case 0x04: FormatString ("0x%02X - PAN_PROP_EVEN_WIDTH - Even Width", value);
		case 0x05: FormatString ("0x%02X - PAN_PROP_EXPANDED - Expanded", value);
		case 0x06: FormatString ("0x%02X - PAN_PROP_CONDENSED - Condensed", value);
		case 0x07: FormatString ("0x%02X - PAN_PROP_VERY_EXPANDED - Very Expanded", value);
		case 0x08: FormatString ("0x%02X - PAN_PROP_VERY_CONDENSED - Very Condensed", value);
		case 0x09: FormatString ("0x%02X - PAN_PROP_MONOSPACED - Monospaced", value);
		default	 : FormatString ("0x%02X - No Description Available", value);
	}
}

Table EMFStrokeVariationEnumerationTable(value)
{
	switch(value)
	{
		case 0x00: FormatString ("0x%02X - PAN_ANY - Any", value);
		case 0x01: FormatString ("0x%02X - PAN_NO_FIT - No Fit", value);
		case 0x02: FormatString ("0x%02X - PAN_STROKE_GRADUAL_DIAG - Gradual/Diagonal", value);
		case 0x03: FormatString ("0x%02X - PAN_STROKE_GRADUAL_TRAN - Gradual/Transitional", value);
		case 0x04: FormatString ("0x%02X - PAN_STROKE_GRADUAL_VERT - Gradual/Vertical", value);
		case 0x05: FormatString ("0x%02X - PAN_STROKE_GRADUAL_HORZ - Gradual/Horizontal", value);
		case 0x06: FormatString ("0x%02X - PAN_STROKE_RAPID_VERT - Rapid/Vertical", value);
		case 0x07: FormatString ("0x%02X - PAN_STROKE_RAPID_HORZ - Rapid/Horizontal", value);
		case 0x08: FormatString ("0x%02X - PAN_STROKE_INSTANT_VERT - Instant/Vertical", value);
		default	 : FormatString ("0x%02X - No Description Available", value);
	}
}

Table EMFXHeightEnumerationTable(value)
{
	switch(value)
	{
		case 0x00: FormatString ("0x%02X - PAN_ANY - Any", value);
		case 0x01: FormatString ("0x%02X - PAN_NO_FIT - No Fit", value);
		case 0x02: FormatString ("0x%02X - PAN_XHEIGHT_CONSTANT_SMALL - Constant/Small", value);
		case 0x03: FormatString ("0x%02X - PAN_XHEIGHT_CONSTANT_STD - Constant/Standard", value);
		case 0x04: FormatString ("0x%02X - PAN_XHEIGHT_CONSTANT_LARGE - Constant/Large", value);
		case 0x05: FormatString ("0x%02X - PAN_XHEIGHT_DUCKING_SMALL - Ducking/Small", value);
		case 0x06: FormatString ("0x%02X - PAN_XHEIGHT_DUCKING_STD - Ducking/Standard", value);
		case 0x07: FormatString ("0x%02X - PAN_XHEIGHT_DUCKING_LARGE - Ducking/Large", value);
		default	 : FormatString ("0x%02X - No Description Available", value);
	}
}

Table EMFPolygonFillModeEnumerationTable(value)
{
	switch(value)
	{
		case 0x00000001: FormatString ("0x%08X - ALTERNATE - Selects alternate mode (fills the area between odd-numbered and even-numbered polygon sides on each scan line)", value);
		case 0x00000002: FormatString ("0x%08X - WINDING - Selects winding mode (fills any region with a nonzero winding value)", value);
	}
}


//referred in MS-WMF for EMFExtLogPenObject.PenStyle
Table EMFWMFPenStyleEnumerationTable(value)
{
	switch(value)
	{
		case 0x00000000: FormatString ("0x%08X - PS_COSMETIC/PS_ENDCAP_ROUND/PS_JOIN_ROUND/PS_SOLID - The pen is solid", value);
		case 0x00000001: FormatString ("0x%08X - PS_DASH - The pen is dashed", value);
		case 0x00000002: FormatString ("0x%08X - PS_DOT - The pen is dotted", value);
		case 0x00000003: FormatString ("0x%08X - PS_DASHDOT - The pen has alternating dashes and dots", value);
		case 0x00000004: FormatString ("0x%08X - PS_DASHDOTDOT - The pen has dashes and double dots", value);
		case 0x00000005: FormatString ("0x%08X - PS_NULL - The pen is invisible", value);
		case 0x00000006: FormatString ("0x%08X - PS_INSIDEFRAME - The pen is solid. This applies only to geometric pens", value);
		case 0x00000007: FormatString ("0x%08X - PS_USERSTYLE - The pen uses a styling array supplied by the user", value);
		case 0x00000008: FormatString ("0x%08X - PS_ALTERNATE - The pen sets every other pixel", value);
		case 0x00000100: FormatString ("0x%08X - PS_ENDCAP_SQUARE - A line cap that specifies square ends.", value);
		case 0x00000200: FormatString ("0x%08X - PS_ENDCAP_FLAT - A line cap that specifies flat ends.", value);
		case 0x00001000: FormatString ("0x%08X - PS_JOIN_BEVEL - A line join that specifies beveled joins.", value);
		case 0x00002000: FormatString ("0x%08X - PS_JOIN_MITER - A line join that specifies mitered joins", value);
		case 0x00010000: FormatString ("0x%08X - PS_GEOMETRIC - A pen type that specifies a line with a width", value);
		default		   : FormatString ("0x%08X - No Description Available", value);
	}
}


Table EMFStretchModeEnumerationTable(value)
{
	switch(value)
	{
		case 0x00000001: FormatString ("0x%08X - STRETCH_ANDSCANS - Performs a Boolean AND operation using the color values for the eliminated and existing pixels", value);                 
		case 0x00000002: FormatString ("0x%08X - STRETCH_ORSCANS - Performs a Boolean OR operation using the color values for the eliminated and existing pixels", value);                
		case 0x00000003: FormatString ("0x%08X - STRETCH_DELETESCANS - Deletes the pixels", value);                
		case 0x00000004: FormatString ("0x%08X - STRETCH_HALFTONE - Maps pixels from the source rectangle into blocks of pixels in the destination rectangle", value);
		default : FormatString ("0x%08X - No Description Available", value);
	}
}

Table EMFTextAlignmentModeEnumerationTable(value)
{
	switch(value)
	{
		case 0x00000000: FormatString ("0x%08X - TA_TOP,TA_LEFT or TA_NOUPDATECP - The reference point will be on the top and left edges of the bounding rectangle or The current position is not updated after each text output call", value);
		case 0x00000001: FormatString ("0x%08X - TA_UPDATECP - The current position is updated after each text output call", value);
		case 0x00000002: FormatString ("0x%08X - TA_RIGHT - The reference point will be on the right edge of the bounding rectangle", value);
		case 0x00000006: FormatString ("0x%08X - TA_CENTER - The reference point will be aligned horizontally with the center of the bounding rectangle", value);
		case 0x00000008: FormatString ("0x%08X - TA_BOTTOM - The reference point will be on the bottom edge of the bounding rectangle", value);
		case 0x00000018: FormatString ("0x%08X - TA_BASELINE - The reference point will be on the base line of the text", value);
		case 0x00000100: FormatString ("0x%08X - TA_RTLREADING - The text is laid out in right to left reading order, as opposed to the default left to right order", value);
		default : FormatString ("0x%08X - No Description Available", value);
	}
}

Table EMFRegionModeEnumerationTable(value)
{
	switch(value)
	{
		case 0x00000001: FormatString ("0x%08X - RGN_AND - The new clipping region includes the intersection of the current clipping region and the current path", value);
		case 0x00000002: FormatString ("0x%08X - RGN_OR - The new clipping region includes the union of the current clipping region and the current path", value);
		case 0x00000003: FormatString ("0x%08X - RGN_XOR - The new clipping region includes the union of the current clipping region and the current path (or new region) but without the overlapping areas", value);
		case 0x00000004: FormatString ("0x%08X - RGN_DIFF - The new clipping region includes the areas of the current clipping region with those of the current path (or new region) excluded", value);
		case 0x00000005: FormatString ("0x%08X - RGN_COPY - The new clipping region is the current path (or the new region)", value);
		default : FormatString ("0x%08X - No Description Available", value);
	}
}

//EMFSpool Enumerations
Table EMFSpoolRecordTypeEnumerationTable(value)
{
	switch(value)
	{
		case 0x00000001: FormatString ("0x%08X - EMRI_METAFILE: Page content in EMF format", value);
		case 0x00000002: FormatString ("0x%08X - EMRI_ENGINE_FONT: TrueType Font", value);
		case 0x00000003: FormatString ("0x%08X - EMRI_DEVMODE: Device settings", value);
		case 0x00000004: FormatString ("0x%08X - EMRI_TYPE1_FONT: PostScript Type 1 Font", value);
		case 0x00000005: FormatString ("0x%08X - EMRI_PRESTARTPAGE: Start page EPS value", value);
		case 0x00000006: FormatString ("0x%08X - EMRI_DESIGNVECTOR: Font Design Vector", value);
		case 0x00000007: FormatString ("0x%08X - EMRI_SUBSET_FONT: Subset Font", value);
		case 0x00000008: FormatString ("0x%08X - EMRI_DELTA_FONT: Delta font for Subset font", value);
		case 0x00000009: FormatString ("0x%08X - EMRI_FORM_METAFILE: Page content in EMF format", value);
		case 0x0000000A: FormatString ("0x%08X - EMRI_BW_METAFILE: Page content in EMF format", value);
		case 0x0000000B: FormatString ("0x%08X - EMRI_BW_FORM_METAFILE: Page content in EMF format", value);
		case 0x0000000C: FormatString ("0x%08X - EMRI_METAFILE_DATA: Page content in EMF format", value);
		case 0x0000000D: FormatString ("0x%08X - EMRI_METAFILE_EXT: Offset to page content record", value);
		case 0x0000000E: FormatString ("0x%08X - EMRI_BW_METAFILE_EXT: Offset to black/white page content record", value);
		case 0x0000000F: FormatString ("0x%08X - EMRI_ENGINE_FONT_EXT: Offset to TrueType font within an page content record", value);
		case 0x00000010: FormatString ("0x%08X - EMRI_TYPE1_FONT_EXT: Offset to PostScript Type 1 font within a page content record", value);
		case 0x00000011: FormatString ("0x%08X - EMRI_DESIGNVECTOR_EXT: Offset to font design vector within a page content record", value);
		case 0x00000012: FormatString ("0x%08X - EMRI_SUBSET_FONT_EXT: Offset to subset font within a page content record", value);
		case 0x00000013: FormatString ("0x%08X - EMRI_DELTA_FONT_EXT: Offset to delta font within a page content record", value);
		case 0x00000014: FormatString ("0x%08X - EMRI_PS_JOB_DATA: Job level PostScript data", value);
		case 0x00000015: FormatString ("0x%08X - EMRI_EMBED_FONT_EXT: Offset to embedded font within a page content record", value);
		default : FormatString ("0x%08X - No Description Available", value);
	}
}

Table EMFSpoolSpecVersionEnumerationTable(value)
{
	switch(value)
	{
		case 0x0400: FormatString ("0x%04X - WIN32_WINNT_NT4: Windows NT 4.0", value);
		case 0x0500: FormatString ("0x%04X - WIN32_WINNT_WIN2K: Windows 2000", value);
		case 0x0501: FormatString ("0x%04X - WIN32_WINNT_WINXP: Windows XP", value);
		case 0x0502: FormatString ("0x%04X - WIN32_WINNT_WS03: Windows Server 2003", value);
		case 0x0600: FormatString ("0x%04X - WIN32_WINNT_LONGHORN: Windows Vista", value);
		default : FormatString ("0x%04X - No Description Available", value);
	}
}

Table EMFSpoolPostScriptEscapeEnumerationTable(value)
{
	switch(value)
	{
		case 0x1006: FormatString ("0x%04X - POSTSCRIPT_INJECTION: Insert a block of raw PostScript data", value);
		case 0x1005: FormatString ("0x%04X - POSTSCRIPT_IDENTITY: Set PostScript driver mode", value);
		default : FormatString ("0x%08X - No Description Available", value);
	}
}

table EMFAlphaFormatTable( Value )
{
	switch( Value )
	{
		case 0x00: "The pixels in the source bitmap do not specify alpha transparency.";
		case 0x01: "AC_SRC_ALPHA  Indicates that the source bitmap is 32 bits-per-pixel and specifies an alpha transparency value for each pixel.";
		default: "Unknown";
	}
}

//2.1.16 GraphicsMode Enumeration
table EMFGraphicsModeEnumerationTable(Value)
{
	switch(Value)
	{
		case 0x00000001: FormatString ("0x%08X - GM_COMPATIBLE: In GM_COMPATIBLE graphics mode, bottom and rightmost edges MUST be excluded when rectangles are drawn.", value);
		case 0x00000002: FormatString ("0x%08X - GM_ADVANCED: In GM_ADVANCED graphics mode, bottom and rightmost edges MUST be included when rectangles are drawn.", value);
	}
}

// ref WMFExtendedTextOutOptions  2.1.11   ExtTextOutOptions Enumeration
struct EMFExtendedTextOutOptions = FormatString("0x%X", this)
{
	UINT32 ExtendedTextOutOptions
	{
		UINT32 ASPECT_FILTERING:1 = FormatString("     (%s) %s", this.ToBitString, this ? "SHOULD select only fonts whose x-aspect and y-aspect exactly match those of the specified device." : "SHOULD NOT select only fonts whose x-aspect and y-aspect exactly match those of the specified device.");
		UINT32 ETO_OPAQUE:1 = FormatString("           (%s) %s", this.ToBitString, this ? "SHOULD be used to fill the rectangle" : "SHOULD NOT be used to fill the rectangle");
		UINT32 ETO_CLIPPED:1 = FormatString("          (%s) %s", this.ToBitString, this ? "The text will be clipped to the rectangle." : "The text will NOT be clipped to the rectangle.");
		UINT32 Reserved_bits4:1 = FormatString("       (%s) Reserved" , this.ToBitString);
		UINT32 ETO_GLYPH_INDEX:1 = FormatString("      (%s) %s", this.ToBitString, this ? "should be parsed directly by GDI" : "should NOT be parsed directly by GDI");
		UINT32 Reserved_bits6_7:2 = FormatString("     (%s) Reserved" , this.ToBitString);
		UINT32 ETO_RTLREADING:1 = FormatString("       (%s) %s", this.ToBitString, this ? "string is output using right-to-left reading order" : "string is output in left-to-right order");
		[Property.EtoNoRrect = this]
		UINT32 ETO_NO_RECT:1 = FormatString("          (%s) %s", this.ToBitString, this ? "The optional Bounds field in the EMR_SMALLTEXTOUT record is NOT included." : "The optional Bounds field in the EMR_SMALLTEXTOUT record is included.");
		[Property.EtoSmailChars = this]
		UINT32 ETO_SMALL_CHARS:1 = FormatString("      (%s) %s", this.ToBitString, this ? "the text string in a text output operation is made up of 8-bit characters" : "the text string in a text output operation is made up of 16-bit characters");
		UINT32 ETO_NUMERICSLOCAL:1 = FormatString("    (%s) %s", this.ToBitString, this ? "use digits appropriate to the locale" : "NOT use digits appropriate to the locale");
		UINT32 ETO_NUMERICSLATIN:1 = FormatString("    (%s) %s", this.ToBitString, this ? "use European digits" : "NOT use European digits");
		UINT32 ETO_IGNORELANGUAGE:1 = FormatString("   (%s) Reserved for system use", this.ToBitString);
		UINT32 ETO_PDY:1 = FormatString("              (%s) %s", this.ToBitString, this ? "the array pointed to by lpDx contains pairs of values" : "the array NOT pointed to by lpDx contains pairs of values");
		UINT32 Reserved_bits15_16:2 = FormatString("   (%s) Reserved" , this.ToBitString);
//		UINT16 ETO_REVERSE_INDEX_MAP:1 = FormatString("(%s) %s", this.ToBitString, this ? "the mapper SHOULD reverse-map them back to characters" : "the mapper SHOULD NOT reverse-map them back to characters");
	}
}

[DataTypeByteOrder = LittleEndian]
struct EMFPaletteObject = FormatString("Version: %u, NumberOfEntries: %u", Version, NumberOfEntries)
{
	UINT16 Version;
	UINT16 NumberOfEntries;
	EMFPaletteEntryObject PaletteEntries[NumberOfEntries];
}
[DataTypeByteOrder = LittleEndian]
struct EMFPaletteEntryObject = FormatString("Values: %s, Blue: %u, Green: %u, Red: %u", Values.toString, Blue, Green, Red)
{
	UINT8 Values = FormatString("%s",this == 0?"0x00":WMFPaletteEntryFlagTable(this));
	UINT8 Blue;
	UINT8 Green;
	UINT8 Red;
}

//EMFSpool Records		2.1   EMFSPOOL Enumerations
[DataTypeByteOrder = LittleEndian]
struct EMFSpoolRecord
{
	switch(UINT32(FrameData, FrameOffset))
	{
		Case 0x00000001:  EMFSpoolPageContentRecord				EMFSpoolEMRIMetaFileRecord;
		Case 0x00000002:  EMFSpoolEMRIEngineFontRecord			EMFSpoolEMRIEngineFontRecord;
		Case 0x00000003:  EMFSpoolEMRIDevModeRecord				EMFSpoolEMRIDevModeRecord;
		Case 0x00000004:  EMFSpoolEMRIType1FontRecord			EMFSpoolEMRIType1FontRecord;
		Case 0x00000005:  EMFSpoolEMRIPreStartPageRecord		EMFSpoolEMRIPreStartPageRecord;
		Case 0x00000006:  EMFSpoolEMRIDesignVectorRecord		EMFSpoolEMRIDesignVectorRecord;
		Case 0x00000007:  EMFSpoolEMRISubSetFontRecord			EMFSpoolEMRISubSetFontRecord;
		Case 0x00000008:  EMFSpoolEMRIDeltaFontRecord			EMFSpoolEMRIDeltaFontRecord;
		Case 0x00000009:  EMFSpoolPageContentRecord				EMFSpoolEMRIFormMetaFileRecord;
		Case 0x0000000A:  EMFSpoolPageContentRecord				EMFSpoolEMRIBwMetaFileRecord;
		Case 0x0000000B:  EMFSpoolPageContentRecord				EMFSpoolEMRIBwFormMetaFileRecord;
		Case 0x0000000C:  EMFSpoolPageContentRecord				EMFSpoolEMRIMetaFileDataRecord;
		Case 0x0000000D:  EMFSpoolPageOffsetRecord				EMFSpoolEMRIMetaFileExtRecord;
		Case 0x0000000E:  EMFSpoolPageOffsetRecord				EMFSpoolEMRIBwMetaFileExtRecord;
		Case 0x0000000F:  EMFSpoolFontOffsetRecord				EMFSpoolEMRIEngineFontExtRecord;
		Case 0x00000010:  EMFSpoolFontOffsetRecord				EMFSpoolEMRIType1FontExtRecord;
		Case 0x00000011:  EMFSpoolFontOffsetRecord				EMFSpoolEMRIDesignVectorExtRecord;
		Case 0x00000012:  EMFSpoolFontOffsetRecord				EMFSpoolEMRISubSetFontExtRecord;
		Case 0x00000013:  EMFSpoolFontOffsetRecord				EMFSpoolEMRIDeltaFontExtRecord;
		Case 0x00000014:  EMFSpoolEMRIPSJOBDATARecord			EMFSpoolEMRIPsJobDataRecord;
		Case 0x00000015:  EMFSpoolFontOffsetRecord				EMFSpoolEMRIEmbedFontExtRecord;
		Case 0x00010000:  EMFSpoolHeaderRecord					EMFSpoolHeaderRecord;
		default : UINT32 Type;
	}
}

//2.2.2   Header Record [MS-EMFSPOOL]
//[DataFieldFrameLength = this.Size ]
struct EMFSpoolHeaderRecord
{
	[Property.SpoolHeaderOffset = FrameOffset]
	UINT32	Version = MustBeSetToTable(this, "0x00010000");
	UINT32	Size;
	UINT32	DocNameOffset;
	UINT32	OutputDeviceNameOffset;
	switch
	{
		case DocNameOffset > 0: 
			struct EMFExtraDataDocName = FormatString("%s",DocName.ToString)
			{
				Blob(DocNameOffset - (FrameOffset - Property.SpoolHeaderOffset)) PaddingDocName;
				UnicodeString	DocName;
			}
	}
	switch
	{
		case OutputDeviceNameOffset > 0: 
			struct EMFExtraDataOutputDevice = FormatString("%s",OutputDeviceName.ToString)
			{
				Blob(OutputDeviceNameOffset - (FrameOffset - Property.SpoolHeaderOffset)) PaddingOutputDevice;
				UnicodeString	OutputDeviceName;
				Align4 AlignmentOutputDevice;
			}
	}
}

//2.2.3.3.1   EMRI_ENGINE_FONT Record [MS-EMFSPOOL]
struct EMFSpoolEMRIEngineFontRecord
{
	UINT32	Identifier = EMFSpoolRecordTypeEnumerationTable(this);//0x00000002
	UINT32	Size;
	UINT32	Type1ID = MustBeSetToTable(this, "0x00000000");
	UINT32	NumFiles;
	[Property.EMFFileCounter = 0]
	while FileSizes [Property.EMFFileCounter < NumFiles]
	{
		[Property.FileSizeArray$[Property.EMFFileCounter], post.Property.EMFFileCounter = Property.EMFFileCounter + 1]
		UINT32	FileSize;
	}
	Align8 AlignBuffer;
	[Property.EMFFileCounter = 0]
	while FileContents[Property.EMFFileCounter < NumFiles]
	{
		[post.Property.EMFFileCounter = Property.EMFFileCounter + 1]
		Blob(FrameLength - FrameOffset - 4 > Property.FileSizeArray$[Property.EMFFileCounter] ? Property.FileSizeArray$[Property.EMFFileCounter] : (FrameLength - FrameOffset - 4)) FileContent;
	}
}


//2.2.3.3.2   EMRI_TYPE1_FONT Record [MS-EMFSPOOL]
struct EMFSpoolEMRIType1FontRecord
{
	UINT32	Identifier = EMFSpoolRecordTypeEnumerationTable(this);//0x00000004
	UINT32	Size;
	UINT32	Type1ID = MustBeSetToTable(this, "0x00000000");
	UINT32	NumFiles;
	
	[Property.EMFFileCounter = 0]
	while FileEndOffs [Property.EMFFileCounter < NumFiles]
	{
		[Property.FileSizeArray$[Property.EMFFileCounter], post.Property.EMFFileCounter = Property.EMFFileCounter + 1]
		UINT32	FileEndOff;
	}
	UINT32	Padding;
	[Property.EMFFileCounter = 0]
	while FileContents[Property.EMFFileCounter < NumFiles]
	{
		[post.Property.EMFFileCounter = Property.EMFFileCounter + 1]
		Blob(Property.FileSizeArray$[Property.EMFFileCounter]) FileContent;
	}
}

//2.2.3.6   EMRI_PRESTARTPAGE Record [MS-EMFSPOOL]
struct EMFSpoolEMRIPrestartPageRecord
{
	UINT32	Identifier = EMFSpoolRecordTypeEnumerationTable(this);//0x00000005
	UINT32	Size;
	UINT32	Unused = MustBeSetToTable(this, "0xFFFFFFFF");
	UINT32	EPS = FormatString("0x%08X - %s", this,this?"EPS printing is enabled":"EPS printing is disabled");
}

//2.2.3.3.3   EMRI_DESIGNVECTOR Record [MS-EMFSPOOL]
struct EMFSpoolEMRIDesignVectorRecord
{
	UINT32	Identifier = EMFSpoolRecordTypeEnumerationTable(this);//0x00000006
	UINT32	Size;
	EMFUniversalFontId UniversalFontId;
	EMFDesignVectorObject DesignVector;
}

//2.2.3.3.4   EMRI_SUBSET_FONT Record [MS-EMFSPOOL]
struct EMFSpoolEMRISubsetFontRecord
{
	UINT32	Identifier = EMFSpoolRecordTypeEnumerationTable(this);//0x00000007
	UINT32	Size;
	EMFUniversalFontId	UniversalFontId;
	BLOB(Size - 16)	FontData;//*
	Align4	Pad;
}

//2.2.3.3.5   EMRI_DELTA_FONT Record [MS-EMFSPOOL]
struct EMFSpoolEMRIDeltaFontRecord
{
	UINT32	Identifier = EMFSpoolRecordTypeEnumerationTable(this);//0x00000008
	UINT32	Size;
	EMFUniversalFontId	UniversalFontId;
	BLOB(Size - 8)	FontData;//*
}

//2.2.3.1   Page Content Records [MS-EMFSPOOL]
struct EMFSpoolPageContentRecord
{
	UINT32	Identifier = EMFSpoolRecordTypeEnumerationTable(this);//0x00000001/0x00000009/0x0000000A/0x0000000B/0x0000000C
	UINT32	Size;
	EMFRecord	EMFRecord;
}

//2.2.3.2   Page Offset Records [MS-EMFSPOOL]
struct EMFSpoolPageOffsetRecord
{
	UINT32	Identifier = EMFSpoolRecordTypeEnumerationTable(this);//0x0000000D/0x0000000E
	UINT32	Size;
	UINT64	Offset;
}

//2.2.3.4   Font Offset Records [MS-EMFSPOOL]
struct EMFSpoolFontOffsetRecord
{
	UINT32	Identifier = EMFSpoolRecordTypeEnumerationTable(this);//0x0000000F/0x00000010/0x00000011/0x00000012/0x00000013/0x00000015
	UINT32	Size;
	UINT32	OffsetLow;
	UINT32	OffsetHigh;
}

//2.2.3.7   EMRI_PS_JOB_DATA Record [MS-EMFSPOOL]
struct EMFSpoolEMRIPsjobDataRecord
{
	UINT32	Identifier = EMFSpoolRecordTypeEnumerationTable(this);//0x00000014
	UINT32	Size;
	[Property.EMFSpoolInjectionDataOffset = FrameOffset]
	while EMFSpoolInjectionDataLoop[FrameOffset - Property.EMFSpoolInjectionDataOffset <= Size]
	{
		struct EMFSpoolInjectionData
		{
			[Property.PostScriptDataSize = UINT32(FrameData, FrameOffset + 8)]
			UINT32	PostScriptDataRecordSize = EMFSPOOLPostScriptDataRecordSizeTable(Property.PostScriptDataSize % 4, this, Property.PostScriptDataSize);
			UINT16	Escape = FormatString("0x%04X",EMFSpoolPostScriptEscapeEnumerationTable(this));
			UINT16 Ignore = MustBeSetToTable(this, "0");
			UINT32 PostScriptDataSize;
			Blob(PostScriptDataSize) PostScriptData;
			switch(PostScriptDataSize % 4)
			{
				case 0: Blob(4) Alignment0;
				case 1: Blob(3) Alignment1;
				case 2: Blob(6) Alignment2;
				case 3: Blob(5) Alignment3;
			}
		}
	}
}

//2.2.3.7   EMRI_PS_JOB_DATA Record [MS-EMFSPOOL]
table EMFSPOOLPostScriptDataRecordSizeTable(value1, value2, value3)
{
	switch(value1)
	{
		case 0: FormatString("%d   PostScriptDataRecordSize Value should be %d", Value2, value3 + 16);
		case 1: FormatString("%d   PostScriptDataRecordSize Value should be %d", Value2, value3 + 15);
		case 2: FormatString("%d   PostScriptDataRecordSize Value should be %d", Value2, value3 + 18);
		case 3: FormatString("%d   PostScriptDataRecordSize Value should be %d", Value2, value3 + 17);
	}
}

//2.2.2   ColorAdjustment Object  EMF Objects 
struct EMFColorAdjustmentObject
{
	UINT16	Size;
	UINT16	Values;
	UINT16	IlluminantIndex;
	UINT16	RedGamma;
	UINT16	GreenGamma;
	UINT16	BlueGamma;
	UINT16	ReferenceBlack;
	UINT16	ReferenceWhite;
	UINT16	Contrast;
	UINT16	Brightness;
	UINT16	Colorfulness;
	UINT16	RedGreenTint;
}

//2.2.3   DesignVector Object
struct EMFDesignVectorObject
{
	UINT32	Signature = MustBeSetToTable(this, "0x08007664");
	UINT32	NumAxes;
	switch
	{
		case NumAxes > 0: UINT32	Values[NumAxes];
	}
}

//2.2.4   EmrFormat Object
struct EMFEMRFormatObject
{
	[Property.Signature]
	UINT32	Signature = EMFFormatSignatureEnumerationTable(this);
	UINT32	Version;
	UINT32	SizeData;
	UINT32	offData;
}

//2.2.5   EmrText Object
struct EMFEMRTextObject(StringType)
{
	WMFPointLObject	Reference;
	UINT32	Chars;
	UINT32	OffString;
	EMFExtendedTextOutOptions	Options;
	WMFRectLObject	Rectangle;
	UINT32	OffDx;
	switch
	{
		case OffString - (FrameOffset - Property.EMFRecordOffset) > 0:
			Blob(OffString - (FrameOffset - Property.EMFRecordOffset)) UndefinedSpace1;
	}
	String(StringType,Chars) OutputString;
	switch
	{
		case OffDx - (FrameOffset - Property.EMFRecordOffset) > 0:
			Blob(OffDx - (FrameOffset - Property.EMFRecordOffset)) UndefinedSpace2;
	}
	switch
	{
		case Options.ExtendedTextOutOptions.ETO_PDY: UINT32 OutputDxPdy[Chars * 2];
		case Options.ExtendedTextOutOptions.ETO_RTLREADING: UINT32 OutputDxRtl[Chars];
		default: UINT32 OutputDx[Chars];
	}
}

//2.2.3.5   EMRI_DEVMODE Record
struct EMFSpoolEMRIDevModeRecord
{
	UINT32	Identifier = EMFSpoolRecordTypeEnumerationTable(this);//0x00000003
	UINT32	SizeofRecord;
	RPRNDevMode Devmode;	//[MS-RPRN] section 2.2.2.1
}

//2.2.13   LogFont Object
struct EMFLogFontWObject
{
	INT32	Height;
	INT32	Width;
	INT32	Escapement;
	INT32	Orientation;
	INT32	Weight;
	UINT8	Italic = FormatString("%s",this?"TRUE":"FALSE");
	UINT8	Underline = FormatString("%s",this?"TRUE":"FALSE");
	UINT8	StrikeOut = FormatString("%s",this?"TRUE":"FALSE");
	UINT8	CharSet = WMFCharacterSetTable(this);
	UINT8	OutPrecision = WMFOutPrecisionTable(this);
	UINT8	ClipPrecision = WMFClipPrecisionTable(this);
	UINT8	Quality = WMFFontQualityTable(this);
	UINT8	PitchAndFamily
	{
		UINT8	PitchFont:2 = FormatString("(%s) %s", this.ToBitString,WMFPitchFontTable(this));
		UINT8	Reserved:2 = FormatString(" (%s)", this.ToBitString);
		UINT8	FamilyFont:4 = FormatString("(%s) %s", this.ToBitString,WMFFamilyFontTable(this));
	}
	[DataFieldByteOrder = LittleEndian]
	UnicodeString(32)	Facename;
}

//2.2.14   LogFontEx Object
struct EMFEnumLogFontEXWObject
{
	EMFLogFontWObject		LogFont;
	UnicodeString(64)		FullName;
	UnicodeString(32)		Style;
	UnicodeString(32)		Script;
}

//2.2.15   LogFontExDv Object
struct EMFEnumLogFontEXDVWObject
{
	EMFEnumLogFontEXWObject	EnumLogFontEx;
	EMFDesignVectorObject	DesignVector;
}

//2.2.6   EpsData Object
struct EMFEPSDataObject
{
	UINT32	SizeData;
	UINT32	Version = MustBeSetToTable(this, "0x00000001");
	WMFPointLObject	Points[3];
}

// 2.2.16 LogFontPanose Object
struct EMFLogFontPanoseObject
{
	EMFLogFontWObject	LogFont;
	UnicodeString(64)		FullName;
	UnicodeString(32)		Style;
	UINT32				Version;
	UINT32				StyleSize;
	UINT32				Match;
	UINT32				Reserved;
	UINT8				VendorId[4];
	UINT32				Culture;
	EMFPANOSEObject		PANOSE;
	Blob(2) Padding;
}

//2.2.20   LogPenEx Object
struct EMFExtLogPenObject
{
	UINT32	PenStyle// = Formatstring("%s %s %s %s",EMFWMFPenStyleEnumerationTable(),WMFPenStyleEndcapTable(),WMFPenStyleJoinTable(),WMFPenStyleTypeTable())
	{
		UINT32	PenStyle:4 = FormatString(" (%s) %s", this.ToBitString,EMFWMFPenStyleEnumerationTable(this));
		UINT32	Reserved1:4 = FormatString("(%s)", this.ToBitString);
		UINT32	PenEndCap:2 = FormatString("(%s) %s", this.ToBitString,WMFPenStyleEndcapTable(this));
		UINT32	Reserved2:2 = FormatString("(%s)", this.ToBitString);
		UINT32	PenJoin:2 = FormatString("  (%s) %s", this.ToBitString,WMFPenStyleJoinTable(this));
		UINT32	Reserved3:2 = FormatString("(%s)", this.ToBitString);
		UINT32	PenType:2 = FormatString("  (%s) %s", this.ToBitString,WMFPenStyleTypeTable(this));
		UINT32	Reserved:14 = FormatString("(%s)", this.ToBitString);
	}
	switch(PenStyle)
	{
		case 0x00010000: UINT32 LogicalWidth;
		case 0x00000000: UINT32 CosMeticWidth = MustBeSetToTable(this, "0x00000001");
		default: UINT32 DeviceWidth;
	}
	UINT32	BrushStyle = WMFBrushStyleTable(this);
	
	switch(BrushStyle)
	{
		case 0x00000001: UINT32	ColorRefIgnored; 
		case 0x00000000: 
		case 0x00000002: WMFColorRefObject ColorRef;
		case 0x00000003: 
		case 0x00000005: 
		case 0x00000006: 
			[DataFieldByteOrder = LittleEndian]
			UINT32 ColorRefUsage = WMFColorUsageTable( this );
	}
	switch(BrushStyle)
	{
		case 0x00000000:
		case 0x00000001:UINT32	BrushHatchIgnored; 
		case 0x00000002:UINT32	BrushHatch = WMFHatchStyleTable(this);
		case 0x00000003:
		case 0x00000005:
		case 0x00000006: WMFDeviceIndependentBitmapobject	DIBBrushHatch;
	}
	//no datatype defined for NumStyleEntries
	switch(PenStyle)
	{
		case 0x00000007: UINT32	NumStyleEntries;
		default: UINT32	NumStyleEntrie = MustBeSetToTable(this, "0");
	}
	//Length of each entry is not defined
	UINT32	StyleEntry[NumStyleEntries];
}

//2.2.10   HeaderExtension1 Object
struct EMFHeaderExtension1Object
{
	UINT32	PixelFormat;
	UINT32	OffPixelFormat;
	UINT32	OpenGL = EMFHeaderExtension1ObjectTable(this);//FormatString("%u:%s",this,this?"OpenGL records are present in the metafile":"OpenGL records are not present in the metafile");
}

////2.2.10   HeaderExtension1 Object
table EMFHeaderExtension1ObjectTable( Value )
{
	switch( Value )
	{
		case 0x00000000: FormatString("0x%08X - OpenGL records are not present in the metafile.", Value);
		case 0x00000001: FormatString("0x%08X - OpenGL records are present in the metafile.", Value);
		default: "Unknow";
	}
}

//2.2.11   HeaderExtension2 Object
struct EMFHeaderExtension2Object
{
	UINT32	MicrometersX;
	UINT32	MicrometersY;
}

//2.2.12   LogBrushEx Object
struct EMFLogBrushExObject
{
	UINT32	BrushStyle = WMFBrushStyleTable(this);
	
	switch(BrushStyle)
	{
		case 0x00000001: UINT32	ColorIgnored; 
		case 0x00000000: 
		case 0x00000002: WMFColorRefObject Color;
	}
	switch(BrushStyle)
	{
		case 0x00000000:
		case 0x00000001:UINT32	BrushHatchIgnored; 
		case 0x00000002:UINT32	BrushHatch = WMFHatchStyleTable(this);
	}
}

//2.2.19   LogPen Object
struct EMFLogPenObject
{
	UINT32	PenStyle = EMFWMFPenStyleEnumerationTable(this);
	WMFPointLObject	Width;
	WMFColorRefObject	ColorRef;	
}

//2.2.21   Panose Object
struct EMFPanoseObject
{
	UINT8	FamilyType = EMFFamilyTypeEnumerationTable(this);
	UINT8	SerifStyle = EMFSerifTypeEnumerationTable(this);
	UINT8	Weight = EMFWeightEnumerationTable(this);
	UINT8	Proportion = EMFProportionEnumerationTable(this);
	UINT8	Contrast = EMFContrastEnumerationTable(this);
	UINT8	StrokeVariation = EMFStrokeVariationEnumerationTable(this);
	UINT8	ArmStyle = EMFArmStyleEnumerationTable(this);
	UINT8	Letterform = EMFLetterformEnumerationTable(this);
	UINT8	Midline = EMFMidLineEnumerationTable(this);
	UINT8	XHeight = EMFXHeightEnumerationTable(this);
}

//2.2.22   PixelFormatDescriptor Object
struct EMFPixelFormatDescriptORObject
{
	UINT16	Size;
	UINT16	Version = MustBeSetToTable(this, "0x0001");
	UINT32	Flags;
	UINT8	PixelType = EMFPixelTypeTable( this );
	//Below fields' datatypes are not defined explicitly
	UINT8	ColorBits;
	UINT8	RedBits;
	UINT8	RedShift;
	UINT8	GreenBits;
	UINT8	GreenShift;
	UINT8	BlueBits;
	UINT8	BlueShift;
	UINT8	AlphaBits;
	UINT8	AlphaShift;
	UINT8	AccumBits;
	UINT8	AccumRedBits;
	UINT8	AccumGreenBits;
	UINT8	AccumBlueBits;
	UINT8	AccumAlphaBits;
	UINT8	DepthBits;
	UINT8	StencilBits;
	UINT8	AuxBuffers;
	UINT8	LayerType;
	UINT8	Reserved;
	UINT32	LayerMask;
	UINT32	VisibleMask;
	UINT32	DamageMask;
}

//2.2.25   RegionDataHeader Object
struct EMFRegionDataHeaderObject
{
	UINT32	Size;
	UINT32	Type;
	UINT32	CountRects;
	UINT32	RgnSize;
	WMFRectLObject	Bounds;
}

//2.2.24   RegionData Object
struct EMFRegionDataObject
{
	EMFRegionDataHeaderObject	RegionDataHeader;
	WMFRectLObject	RegionData[RegionDataHeader.CountRects];
}

//2.2.26   TriVertex Object
struct EMFTriVertexObject
{
	INT32	X;
	INT32	Y;
	UINT16	Red;
	UINT16	Green;
	UINT16	Blue;
	UINT16	Alpha;
}

//2.2.28   XForm Object
struct EMFXFormObject
{
	Float	M11;
	Float	M12;
	Float	M21;
	Float	M22;
	Float	Dx;
	Float	Dy;
}

//
//2.3.1.1 EMR_ALPHABLEND Record
//
struct EMFEMRAlphaBlendRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000072
	UINT32	Size;
	WMFRectLObject	Bounds;
	INT32	XDest;
	INT32	YDest;
	INT32	CxDest;
	INT32	CyDest;
	UINT32	BlendFunction
	{
		UINT8 BlengOperation;
		UINT8 BlendFlags = MustBeSetToTable(this, "0x00");
		UINT8 SrcConstantAlpha;
		UINT8 AlphaFormat = EMFAlphaFormatTable( this );
	}
	INT32	XSrc;
	INT32	YSrc;
	EMFXFormObject	XFormSrc;
	WMFColorRefObject	BkColorSrc;
	UINT32	UsageSrc = EMFDIBColorsEnumerationTable(this);
	UINT32	OffBmiSrc;
	UINT32	CbBmiSrc;
	UINT32	OffBitsSrc;
	UINT32	CbBitsSrc;
	INT32	CxSrc;
	INT32	CySrc;//*
	switch
	{
		case CbBmiSrc > 0: 
			EMFBitmapBuffer(OffBmiSrc, CbBmiSrc, OffBitsSrc, CbBitsSrc) BitmapBuffer;
	}
}

//
//2.3.1.2 EMR_BITBLT Record
//
struct EMFEMRBitBltRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x0000004C
	UINT32	Size;
	WMFRectLObject	Bounds;
	INT32	XDest;
	INT32	YDest;
	INT32	CXDest;
	INT32	CYDest;
	UINT32	BitBltRasterOperation = WMFTernaryRasterOperationTable(this);
	INT32	XSrc;
	INT32	YSrc;
	EMFXFormObject	XformSrc;
	WMFColorRefObject	BkColorSrc;
	UINT32	UsageSrc = EMFDIBColorsEnumerationTable(this);
	UINT32	OffBmiSrc;
	UINT32	CbBmiSrc;
	UINT32	OffBitsSrc;
	UINT32	CbBitsSrc;//*
	switch
	{
		case CbBmiSrc > 0: 
			EMFBitmapBuffer(OffBmiSrc, CbBmiSrc, OffBitsSrc, CbBitsSrc) BitmapBuffer;
	}
	
}

//
//2.3.1.3 EMR_MASKBLT Record
//
struct EMFEMRMaskBltRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x0000004E
	UINT32	Size;
	WMFRectLObject	Bounds;
	INT32	XDest;
	INT32	YDest;
	INT32	CXDest;
	INT32	CYDest;
	UINT32	ROP4
	{
		UINT16 Reserved = MustBeSetToTable(this, "0x00");
		UINT8 BackGroundROP3;
		UINT8 ForeGroundROP3;
	}
	INT32	XSrc;
	INT32	YSrc;
	EMFXFormObject	XformSrc;
	WMFColorRefObject	BkColorSrc;
	UINT32	UsageSrc = EMFDIBColorsEnumerationTable(this);
	UINT32	OffBmiSrc;
	UINT32	CbBmiSrc;
	UINT32	OffBitsSrc;
	UINT32	CbBitsSrc;
	INT32	XMask;
	INT32	YMask;
	UINT32	UsageMask;
	UINT32	OffBmiMask;
	UINT32	CbBmiMask;
	UINT32	OffBitsMask;
	UINT32	CbBitsMask;//*
	switch
	{
		case CbBmiSrc > 0: 
			EMFBitmapBuffer(OffBmiSrc, CbBmiSrc, OffBitsSrc, CbBitsSrc) BitmapBuffer;
	}
	switch
	{
		case CbBmiSrc > 0 && FrameLength > FrameOffset: 
			EMFBitmapBuffer(OffBmiMask, CbBmiMask, OffBitsMask, CbBitsMask) MaskBuffer;
	}
	//switch
	//{
		//case OffBmiMask - (FrameOffset - Property.EMFRecordOffset) > 0:
			//BLOB(OffBmiMask - (FrameOffset - Property.EMFRecordOffset)) UndefinedSpace3;
	//}
	//switch
	//{
		//case CbBmiMask > 0: WMFBitmapObject BitmapInfo;
	//}
	//switch
	//{
		//case OffBitsMask - (FrameOffset - Property.EMFRecordOffset) > 0:
			//BLOB(OffBitsMask - (FrameOffset - Property.EMFRecordOffset)) UndefinedSpace4;
	//}
	//switch
	//{
		//case CbBitsMask > 0:BLOB(CbBitsMask > FrameLength - FrameOffset ? FrameLength - FrameOffset : CbBitsMask)BitmapData;
	//}
}

//
//2.3.1.4 EMR_PLGBLT Record
//
struct EMFEMRPlgBltRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x0000004F
	UINT32	Size;
	WMFRectLObject	Bounds;
	WMFPointLObject	AptlDest[3];
	INT32	XSrc;
	INT32	YSrc;
	INT32	CxSrc;
	INT32	CySrc;
	EMFXFormObject	XformSrc;
	WMFColorRefObject	BkColorSrc;
	UINT32	UsageSrc = EMFDIBColorsEnumerationTable(this);
	UINT32	OffBmiSrc;
	UINT32	CbBmiSrc;
	UINT32	OffBitsSrc;
	UINT32	CbBitsSrc;
	INT32	XMask;
	INT32	YMask;
	UINT32	UsageMask;
	UINT32	OffBmiMask;
	UINT32	CbBmiMask;
	UINT32	OffBitsMask;
	UINT32	CbBitsMask;//*
	switch
	{
		case CbBmiSrc > 0 :
			EMFBitmapBuffer(OffBmiSrc, CbBmiSrc, OffBitsSrc, CbBitsSrc) BitmapBuffer;
	}
	switch
	{
		case CbBmiSrc > 0 && FrameLength > FrameOffset: 
			EMFBitmapBuffer(OffBmiMask, CbBmiMask, OffBitsMask, CbBitsMask) MaskBuffer;
	}
	//switch
	//{
		//case OffBmiMask - (FrameOffset - Property.EMFRecordOffset) > 0:
			//BLOB(OffBmiMask - (FrameOffset - Property.EMFRecordOffset)) UndefinedSpace3;
	//}
	//switch
	//{
		//case CbBmiMask > 0: WMFBitmapObject	BitmapInfo;
	//}
	//switch
	//{
		//case OffBitsMask - (FrameOffset - Property.EMFRecordOffset) > 0:
			//BLOB(OffBitsMask - (FrameOffset - Property.EMFRecordOffset)) UndefinedSpace4;
	//}
	//switch
	//{
		//case CbBitsMask > 0: BLOB(CbBitsMask > FrameLength - FrameOffset ? FrameLength - FrameOffset : CbBitsMask) BitmapData;
	//}
}

//
//2.3.1.5 EMR_SETDIBITSTODEVICE Record
//
struct EMFEMRSetDIBitsToDeviceRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000050
	UINT32	Size;
	WMFRectLObject	Bounds;
	INT32	XDest;
	INT32	YDest;
	INT32	XSrc;
	INT32	YSrc;
	INT32	CxSrc;
	INT32	CySrc;
	UINT32	OffBmiSrc;
	UINT32	CbBmiSrc;
	UINT32	OffBitsSrc;
	UINT32	CbBitsSrc;
	UINT32	UsageSrc = EMFDIBColorsEnumerationTable(this);
	UINT32	StartScan;
	UINT32	Scans;//*
	switch
	{
		case CbBmiSrc > 0: 
			EMFBitmapBuffer(OffBmiSrc, CbBmiSrc, OffBitsSrc, CbBitsSrc) BitmapBuffer;
	}
}

//
//2.3.1.6 EMR_STRETCHBLT Record
//
struct EMFEMRStretchBltRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x0000004D
	UINT32	Size;
	WMFRectLObject	Bounds;
	INT32	XDest;
	INT32	YDest;
	INT32	CXDest;
	INT32	CYDest;
	UINT32	BitBlitRasterOperation = WMFTernaryRasterOperationTable(this);
	INT32	XSrc;
	INT32	YSrc;
	EMFXFormObject	XformSrc;
	WMFColorRefObject	BkColorSrc;
	UINT32	UsageSrc = EMFDIBColorsEnumerationTable(this);
	UINT32	OffBmiSrc;
	UINT32	CbBmiSrc;
	UINT32	OffBitsSrc;
	UINT32	CbBitsSrc;
	INT32	CxSrc;
	INT32	CySrc;//*
	switch
	{
		case CbBmiSrc > 0: 
			EMFBitmapBuffer(OffBmiSrc, CbBmiSrc, OffBitsSrc, CbBitsSrc) BitmapBuffer;
	}
}

//
//2.3.1.7 EMR_STRETCHDIBITS Record
//
struct EMFEMRStretchDIBitsRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000051
	UINT32	Size;
	WMFRectLObject	Bounds;
	INT32	XDest;
	INT32	YDest;
	INT32	XSrc;
	INT32	YSrc;
	INT32	CxSrc;
	INT32	CySrc;
	UINT32	OffBmiSrc;
	UINT32	CbBmiSrc;
	UINT32	OffBitsSrc;
	UINT32	CbBitsSrc;
	UINT32	UsageSrc = EMFDIBColorsEnumerationTable(this);
	UINT32	BitBlitRasterOperation = WMFTernaryRasterOperationTable(this);
	INT32	CXDest;
	INT32	CYDest;//*
	switch
	{
		case CbBmiSrc > 0: 
			EMFBitmapBuffer(OffBmiSrc, CbBmiSrc, OffBitsSrc, CbBitsSrc) BitmapBuffer;
	}
}

//
//2.3.1.8 EMR_TRANSPARENTBLT Record
//
struct EMFEMRTransParentBLTRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000074
	UINT32	Size;
	WMFRectLObject	Bounds;
	INT32	XDest;
	INT32	YDest;
	INT32	CxDest;
	INT32	CyDest;
	WMFColorRefObject	TransparentColor;
	INT32	XSrc;
	INT32	YSrc;
	EMFXFormObject	XFormSrc;
	WMFColorRefObject	BkColorSrc;
	UINT32	UsageSrc = EMFDIBColorsEnumerationTable(this);
	UINT32	OffBmiSrc;
	UINT32	CbBmiSrc;
	UINT32	OffBitsSrc;
	UINT32	CbBitsSrc;
	INT32	CxSrc;
	INT32	CySrc;//*
	switch
	{
		case CbBmiSrc > 0: 
			EMFBitmapBuffer(OffBmiSrc, CbBmiSrc, OffBitsSrc, CbBitsSrc) BitmapBuffer;
	}
}

//
//2.3.2 Clipping Record Types
//
struct EMFEMRSetMETARGN
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x0000001C
	UINT32	Size;
	//*
}

//
//2.3.2.1 EMR_EXCLUDECLIPRECT Record
//
struct EMFEMRExcludeClipRectRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x0000001D
	UINT32	Size;
	WMFRectLObject	Clip;
}

//
//2.3.2.2 EMR_EXTSELECTCLIPRGN Record
//
struct EMFEMREXTSelectClipRgnRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x0000004B
	UINT32	Size;
	UINT32	RgnDataSize;
	UINT32	RegionMode = EMFRegionModeEnumerationTable(this);
	switch
	{
		case RgnDataSize > 0 : EMFRegionDataObject	RgnData;
	}
	Align4 AlignmentPadding;
}

//
//2.3.2.3 EMR_INTERSECTCLIPRECT Record
//
struct EMFEMRInterSectClipRectRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x0000001E
	UINT32	Size;
	WMFRectLObject	Clip;
}

//
//2.3.2.4 EMR_OFFSETCLIPRGN Record
//
struct EMFEMROffsetClipRGNRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x0000001A
	UINT32	Size;
	WMFPointLObject	Offset;
}

//
//2.3.2.5 EMR_SELECTCLIPPATH Record
//
struct EMFEMRSelectClipPathRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000043
	UINT32	Size;
	UINT32	RegionMode = EMFRegionModeEnumerationTable(this);
}

//
//2.3.3 COMMENT Record TYPES
//
struct EMFEMRCommentRecordTypes
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000046
	[Property.CommentRecordTypeSize]
	UINT32	Size;
	[Property.DataSize]
	UINT32	DataSize;
	UINT32 CommentIdentifier = FormatString("0x%08X - COMMENT_IDENTIFIER", this);
	switch(CommentIdentifier)
	{
		case 0x00000000:
			EMFEMRCOMMENTEMFSPOOLRecord EMRCOMMENTEMFSPOOL;
		case 0x2B464D45:
			EMFEMRCommentEMFPlusRecord EMRCommentEMFPlus;
		case 0x43494447:
			EMFEMRCommentPublicRecord EMRCommentPublic;
		default: Blob(DataSize - 4) PrivateData;
	}
	Align4 AlignmentPadding;
}

//
//2.3.3.2 EMR_COMMENT_EMFPLUS Record
//
struct EMFEMRCommentEMFPlusRecord
{
	switch
	{
		case Property.CommentRecordTypeSize > Property.RPRNSize: EMFPlusClippingRecord EMFPlusRecordData;
		default:
			while EMFPlusRecords[FrameLength - FrameOffset - 4 < Property.DataSize]
			{
				EMFPlusClippingRecord EMFPlusRecordData;
			}
	}
}

//
//2.3.3.3 EMR_COMMENT_EMFSPOOL Record
//
struct EMFEMRCOMMENTEMFSPOOLRecord
{
	UINT32	EMFSpoolRecordIdentifier = EMFSpoolRecordIdentifierTable( this );
	switch
	{
		case Property.CommentRecordTypeSize > Property.RPRNSize: EMFSpoolRecord EMFSpoolRecord;
		default:
			while EMFSpoolRecords[FrameLength - FrameOffset - 4 < Property.DataSize]
			{
				EMFSpoolRecord EMFSpoolRecord;
			}
	}
	
}

table EMFSpoolRecordIdentifierTable( Value )
{
	switch( Value )
	{
		case 0x544F4E46: "EMFSpoolFontDefinition  The ASCII string TONF, which identifies this as a record that contains embedded EMFSPOOL font definition data.";
	}
}

//
//2.3.3.4 EMR_COMMENT_PUBLIC Record Types
//
struct EMFEMRCommentPublicRecord
{
	UINT32 PublicCommentIdentifier = EMFGDICommentEnumerationTable(this);
	switch(PublicCommentIdentifier)
	{
		case 0x00000002:
			EMFEMRCommentBeginGroupRecord CommentBeginGroupRecord;
		case 0x00000003:
			EMFEMRCommentEndGroupRecord CommentEndGroupRecord;
		case 0x00000040:
		case 0x00000080:
			UnicodeString String;
		case 0x40000004:
			EMFEMRCommentMultiFormatsRecord CommentMultiFormatsRecord;
		case 0x80000001:
			EMFEMRCommentWindowsMETAFileRecord CommentWindowsMETAFileRecord;
		default:
			Blob(DataSize) EMFPublicCommentData;
	}
	Align4 AlignmentPadding;
}

//
//2.3.3.4.1 EMR_COMMENT_BEGINGROUP Record
//
struct EMFEMRCommentBeginGroupRecord
{
	WMFRectLObject Rectangle;
	UINT32 nDescription;
	switch
	{
		case nDescription !=0: UnicodeString Description[nDescription];
	}
}

//
//2.3.3.4.2 EMR_COMMENT_ENDGROUP Record
//
struct EMFEMRCommentEndGroupRecord
{
	_struct {};
}

//
//2.3.3.4.3 EMR_COMMENT_MULTIFORMATS Record
//
struct EMFEMRCommentMultiFormatsRecord
{
	WMFRectLObject OutputRect;
	[local.Count]
	UINT32 CountFormats;
	[Local.Sum = 0]
	while[Local.Count > 0]
	{
		[Local.Sum = Local.sum + Format.SizeData ,Local.Count = Local.Count -1]
		EMFEMRFORMATObject Format;
		[Property.Signature$[Count] = Property.Signature]
		_struct{}
	}
	[Local.Ct = CountFormats]
	while[Local.Ct > 0]
	{
		[Local.Ct = Local.Ct-1]
		switch
		{
			case Property.Signature$[Local.Ct] == 0x46535045:
				EMFEPSDataObject EPSDataObject;
			default:
				Blob(EMFEMRFORMATObject.SizeData) Unknownblock;
		}
	}
}

//
//2.3.3.4.4 EMR_COMMENT_WINDOWS_METAFILE Record
//
struct EMFEMRCommentWindowsMETAFileRecord
{
	UINT16 Version = WMFMetafileVersionTable( this );
	UINT16 Reserved = MustBeSetToTable(this, "0x0000");
	UINT32 Checksum;
	UINT32 Flags = MustBeSetToTable(this, "0x00000000");
	UINT32 WinMetaFileSize;
	WMFRecords MetaFileData;
	//BLOB(WinMetaFileSize) MetaFileData; //*
}

//
//2.3.4.1 EMR_EOF Record
//
struct EMFEMREOFRecord
{
	[EMFEOF = "TRUE"]
	UINT32 Type = EMFRecordTypeEnumerationTable( this );//0x0000000E
	UINT32 Size;
	UINT32 PalEntries;
	UINT32 OffPalEntries;
	switch
	{
		case OffPalEntries - (FrameOffset - Property.EMFRecordOffset) > 0 : 
			Blob(OffPalEntries - (FrameOffset - Property.EMFRecordOffset)) UndefinedSpace1;
	}
	EMFPaletteEntryObject PaletteEntries[PalEntries];
	UINT32 SizeLast;
}

//
//2.3.4.2 EMR_HEADER Record Types
//
struct EMFEMRHeaderRecordTypes 
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000001
	UINT32	Size;
	EMFHeaderObject EmfHeaderObject;
	switch
	{
		case Size > 88 :
			[Size >= 88 ? Property.EMFHeaderSize = Size : Property.EMFHeaderSize = 88]
			[Property.CbPixelFormat = UINT32(FrameData,FrameOffset)]
			[Property.OffPixelFormat = UINT32(FrameData,FrameOffset + 4)]
			[((Property.OffDescription >= 88) && ((Property.OffDescription + Property.nDescription * 2) <= Size)) ? Property.EMFHeaderSize = Property.OffDescription : Property.EMFHeaderSize]
			[Property.EMFHeaderSize >= 100 ? ((Property.OffPixelFormat >= 100 && (Property.OffPixelFormat + Property.CbPixelFormat) <= Size) ? 
			(Property.OffPixelFormat < Property.EMFHeaderSize ? Property.EMFHeaderSize = Property.OffPixelFormat : Property.EMFHeaderSize) :  Property.EMFHeaderSize) : Property.EMFHeaderSize]
			struct
			{ 
				switch
				{
					case property.EMFHeaderSize >= 100 :
						EMFMetafileHeaderExtension1Record MetafileHeaderExtension1Record;
					case property.EMFHeaderSize >= 108 :
						EMFMetafileHeaderExtension2Record MetafileHeaderExtension2Record;
					default:
						EMFMetafileHeaderRecord MetafileHeaderRecord;
				}
				Align4 AlignmentPadding;
			}
	}
}

//
//2.3.4.2.1 EmfMetafileHeader Record
//
struct EMFMetafileHeaderRecord
{
	switch
	{
		case Property.OffDescription - (FrameOffset - Property.EMFRecordOffset) > 0: 
			Blob(Property.OffDescription - (FrameOffset - Property.EMFRecordOffset)) UndefinedSpace;
	}
	
	switch
	{
		case Property.nDescription !=0 :
			UnicodeString(Property.nDescription) EmfDescription;
	}
}

//
//2.3.4.2.2 EmfMetafileHeaderExtension1 Record
//
struct EMFMetafileHeaderExtension1Record
{
	EMFHeaderExtension1object EmfHeaderExtension1;
	switch
	{
		case Property.OffDescription - (FrameOffset - Property.EMFRecordOffset) > 0:
			Blob(Property.OffDescription - (FrameOffset - Property.EMFRecordOffset)) UndefinedSpace;
	}
	switch
	{
		case Property.nDescription !=0 :
			UnicodeString(Property.nDescription) EmfDescription;
	}
	switch
	{
		case EMFHeaderExtension1object.PixelFormat != 0: EMFPixelFormatDescriptorObject EmfPixelFormat;
	}
}

//
//2.3.4.2.3 EmfMetafileHeaderExtension2 Record
//
struct EMFMetafileHeaderExtension2Record
{
	EMFHeaderExtension1object EmfHeaderExtension1;
	EMFHeaderExtension2object EmfHeaderExtension2;
	switch
	{
		case Property.OffDescription - (FrameOffset - Property.EMFRecordOffset) > 0:
			Blob(Property.OffDescription - (FrameOffset - Property.EMFRecordOffset)) UndefinedSpace;
	}
	switch
	{
		case Property.nDescription !=0 :
			UnicodeString(Property.nDescription) EmfDescription;
	}
	switch
	{
		case EMFHeaderExtension1object.PixelFormat != 0: EMFPixelFormatDescriptorObject EmfPixelFormat;
	}
}

//
//2.3.5.1 EMR_ANGLEARC Record
//
struct EMFEMRAngleArcRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000029
	UINT32	Size;
	WMFPointLObject	Center;
	UINT32	Radius;
	Float	StartAngle;
	Float	SweepAngle;
}

//
//2.3.5.2 EMR_ARC Record
//
struct EMFEMRARCRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x0000002D
	UINT32	Size;
	WMFRectLObject	Box;
	WMFPointLObject	Start;
	WMFPointLObject	End;
}

//
//2.3.5.3 EMR_ARCTO Record
//
struct EMFEMRARCToRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000037
	UINT32	Size;
	WMFRectLObject	Box;
	WMFPointLObject	Start;
	WMFPointLObject	End;
}

//
//2.3.5.4 EMR_CHORD Record
//
struct EMFEMRChordRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x0000002E
	UINT32	Size;
	WMFRectLObject	Box;
	WMFPointLObject	Start;
	WMFPointLObject	End;
}

//
//2.3.5.5 EMR_ELLIPSE Record
//
struct EMFEMREllipseRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x0000002A
	UINT32	Size;
	WMFRectLObject	Box;
}

//
//2.3.5.6 EMR_EXTFLOODFILL Record
//
struct EMFEMREXTFloodFillRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000035
	UINT32	Size;
	WMFPointLObject	Start;
	WMFColorRefObject	Color;
	UINT32	FloodFillMode = EMFFloodFillEnumerationTable(this);
}

//
//2.3.5.7 EMR_EXTTEXTOUTA Record
//
struct EMFEMREXTTextOutARecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000053
	UINT32	Size;
	WMFRectLObject	Bounds;
	UINT32	GraphicsMode = EMFGraphicsModeEnumerationTable( this );
	Float	ExScale;
	Float	EyScale;
	EMFEMRTextObject(0)	MrText;
}

//
//2.3.5.8 EMR_EXTTEXTOUTW Record
//
struct EMFEMREXTTextOutWRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000054
	UINT32	Size;
	WMFRectLObject	Bounds;
	UINT32	GraphicsMode = EMFGraphicsModeEnumerationTable( this );
	Float	ExScale;
	Float	EyScale;
	EMFEMRTextObject(1)	EMrText;
}

//
//2.3.5.9 EMR_FILLPATH Record
//
struct EMFEMRFillPathRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x0000003E
	UINT32	Size;
	WMFRectLObject	Bounds;
}

//
//2.3.5.10 EMR_FILLRGN Record
//
struct EMFEMRFillRgnRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000047
	UINT32	Size;
	WMFRectLObject	Bounds;	
	UINT32	RgnDataSize;
	UINT32	Brush;
	EMFRegionDataObject	RgnData;
}

//
//2.3.5.11 EMR_FRAMERGN Record
//
struct EMFEMRFrameRgnRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000048
	UINT32	Size;
	WMFRectLObject	Bounds;	
	UINT32	RgnDataSize;
	UINT32	Brush;
	INT32	Width;
	INT32	Height;
	EMFRegionDataObject	RgnData;
}

//
//2.3.5.12 EMR_GRADIENTFILL Record
//
struct EMFEMRGradientFillRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000076
	UINT32	Size;
	WMFRectLObject	Bounds;
	UINT32	NumVertices;
	UINT32	NumTri;
	UINT32	Mode = EMFGradientFillEnumerationTable(this);
	EMFTriVertexObject	VertexData[NumTri];
}

//
//2.3.5.13 EMR_LINETO Record
//
struct EMFEMRLineToRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000036
	UINT32	Size;
	WMFPointLObject	Point;
}

//
//2.3.5.14 EMR_PAINTRGN Record
//
struct EMFEMRPaintRgnRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x0000004A
	UINT32	Size;
	WMFRectLObject	Bounds;	
	UINT32	RgnDataSize;
	EMFRegionDataObject	RgnData;
}

//
//2.3.5.15 EMR_PIE Record
//
struct EMFEMRPieRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x0000002F
	UINT32	Size;
	WMFRectLObject	Box;
	WMFPointLObject	Start;
	WMFPointLObject	End;
}

//
//2.3.5.16 EMR_POLYBEZIER Record
//
struct EMFEMRPolybezierRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000002 0x00000005
	UINT32	Size;
	WMFRectLObject	Bounds;
	UINT32	Count;
	WMFPointLObject	Points[Count];
}

//
//2.3.5.17 EMR_POLYBEZIER16 Record
//
struct EMFEMRPolybezier16Record
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000055
	UINT32	Size;
	WMFRectLObject	Bounds;
	UINT32	Count;
	WMFPointSObject	Points[Count];
}

//
//2.3.5.18 EMR_POLYBEZIERTO Record
//
struct EMFEMRPolybeziertoRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000005
	UINT32	Size;
	WMFRectLObject	Bounds;
	UINT32	Count;
	WMFPointLObject	Points[Count];
}

//
//2.3.5.19 EMR_POLYBEZIERTO16 Record
//
struct EMFEMRPolybezierTo16Record
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000058
	UINT32	Size;
	WMFRectLObject	Bounds;
	UINT32	Count;
	WMFPointSObject	Points[Count];
}

//
//2.3.5.20 EMR_POLYDRAW Record
//
struct EMFEMRPolydrawRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000038
	UINT32	Size;
	WMFRectLObject	Bounds;
	UINT32	Count;
	WMFPointLObject	Points[Count];
	UINT8	Types[Count] = EMFPointEnumerationTable( this );//Point Enumeration
}

//
//2.3.5.21 EMR_POLYDRAW16 Record
//
struct EMFEMRPolydraw16Record
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x0000005C
	UINT32	Size;
	WMFRectLObject	Bounds;
	UINT32	Count;
	WMFPointSObject	Points[Count];
	UINT8	Types[Count] = EMFPointEnumerationTable( this );//PointEnumeration
}

//
//2.3.5.22 EMR_POLYGON Record
//
struct	EMFEMRPolygonRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000003
	UINT32	Size;
	WMFRectLObject	Bounds;
	UINT32	Count;
	WMFPointLObject	Points[Count];
}

//
//2.3.5.23 EMR_POLYGON16 Record
//
struct EMFEMRPolygon16Record
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000056
	UINT32	Size;
	WMFRectLObject	Bounds;
	UINT32	Count;
	WMFPointSObject	Points[Count];
}

//
//2.3.5.24 EMR_POLYLINE Record
//
struct EMFEMRPolylineRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000004
	UINT32	Size;
	WMFRectLObject	Bounds;
	UINT32	Count;
	WMFPointLObject	Points[Count];
}

//
//2.3.5.25 EMR_POLYLINE16 Record
//
struct EMFEMRPolyline16Record
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000057
	UINT32	Size;
	WMFRectLObject	Bounds;
	UINT32	Count;
	WMFPointSObject	Points[Count];
}

//
//2.3.5.26 EMR_POLYLINETO Record
//
struct EMFEMRPolylineToRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000006
	UINT32	Size;
	WMFRectLObject	Bounds;
	UINT32	Count;
	WMFPointLObject	Points[Count];
}

//
//2.3.5.27 EMR_POLYLINETO16 Record
//
struct EMFEMRPolylineTo16Record
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000059
	UINT32	Size;
	WMFRectLObject	Bounds;
	UINT32	Count;
	WMFPointSObject	Points[Count];
}

//
//2.3.5.28 EMR_POLYPOLYGON Record
//
struct EMFEMRPolypolygonRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000008
	UINT32	Size;
	WMFRectLObject	Bounds;
	UINT32	NumberOfPolygons;
	UINT32	Count;
	UINT32	PolygonPointCount[NumberOfPolygons];
	WMFPointLObject	Points[Count];
}

//
//2.3.5.29 EMR_POLYPOLYGON16 Record
//
struct EMFEMRPolyPolygon16Record
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x0000005B
	UINT32	Size;
	WMFRectLObject	Bounds;
	UINT32	NumberOfPolygons;
	UINT32	Count;
	UINT32	PolygonPointCount[NumberOfPolygons];
	WMFPointSObject	Points[Count];
}

//
//2.3.5.30 EMR_POLYPOLYLINE Record
//
struct EMFEMRPolypolylineRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000007
	UINT32	Size;
	WMFRectLObject	Bounds;
	UINT32	NumberOfPolylines;
	UINT32	Count;
	UINT32	PolylinePointCount[NumberOfPolylines];
	WMFPointLObject	Points[Count];
}

//
//2.3.5.31 EMR_POLYPOLYLINE16 Record
//
struct EMFEMRPolyPolyline16Record
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x0000005A
	UINT32	Size;
	WMFRectLObject	Bounds;
	UINT32	NumberOfPolylines;
	UINT32	Count;
	UINT32	PolylinePointCount[NumberOfPolylines];
	WMFPointSObject	Points[Count];
}

//
//2.3.5.32 EMR_POLYTEXTOUTA Record
//
struct EMFEMRPolyTextOutARecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000060
	UINT32	Size;
	WMFRectLObject	Bounds;
	UINT32	GraphicsMode = EMFGraphicsModeEnumerationTable( this );
	Float	ExScale;
	Float	EyScale;
	UINT32	Strings;
	EMFEMRTEXTObject(0)	Emrtext[Strings];
}

//
//2.3.5.33 EMR_POLYTEXTOUTW Record
//
struct EMFEMRPolyTextOutWRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000061
	UINT32	Size;
	WMFRectLObject	Bounds;
	UINT32	GraphicsMode = EMFGraphicsModeEnumerationTable( this );
	Float	ExScale;
	Float	EyScale;
	UINT32	Strings;
	EMFEMRTEXTObject(1)	Emrtext[Strings];
}


//
//2.3.5.34 EMR_RECTANGLE Record
//
struct EMFEMRRectangleRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x0000002B
	UINT32	Size;
	WMFRectLObject	Box;
}

//
//2.3.5.35 EMR_ROUNDRECT Record
//
struct EMFEMRRoundRectRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x0000002C
	UINT32	Size;
	WMFRectLObject	Box;
	WMFSizeLObject	Corner;
}

//
//2.3.5.36 EMR_SETPIXELV Record
//
struct EMFEMRSetPixelVRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x0000000F
	UINT32	Size;
	WMFPointLObject	Pixel;
	WMFColorRefObject	Color;
}

//
//2.3.5.37 EMR_SMALLTEXTOUT Record
//
struct EMFEMRSmallTextOutRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x0000006C
	UINT32	Size;
	INT32	X;
	INT32	Y;
	UINT32	Chars;
	EMFExtendedTextOutOptions fuOptions;
	UINT32	GraphicsMode = EMFGraphicsModeEnumerationTable( this );
	Float	ExScale;
	Float	EyScale;
	switch
	{
		case !Property.EtoNoRrect: WMFRectLObject Bounds;
	}
	switch
	{
		case Property.EtoSmailChars: AsciiString(Size - (FrameOffset - Property.EMFRecordOffset)) AsciiTextString;
		default: UnicodeString UnicodeTextString;
	} //*
}

//
//2.3.5.38 EMR_STROKEANDFILLPATH Record
//
struct EMFEMRStrokeAndFillPathRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x0000003F
	UINT32	Size;
	WMFRectLObject	Bounds;
}

//
//2.3.5.39 EMR_STROKEPATH Record
//
struct EMFEMRStrokePathRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000040
	UINT32	Size;
	WMFRectLObject	Bounds;
}

//
//2.3.6.1 EMR_DRAWESCAPE Record
//
struct EMFEMRDrawEscapeRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000069
	UINT32	Size;
	UINT32	Escape;
	UINT32	CjIn;
	BLOB(CjIn)	Data;
}

//
//2.3.6.2 EMR_EXTESCAPE Record
//
struct EMFEMREXTEscapeRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x0000006A
	UINT32	Size;
	UINT32	Escape;
	UINT32	CjIn;
	BLOB(CjIn)	Data;
}

//
//2.3.6.3 EMR_NAMEDESCAPE Record
//
struct EMFEMRNamedEscapeRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x0000006E
	UINT32	Size;
	UINT32	Escape;
	INT32	Driver;
	UINT32	CjIn;
	[DataFieldByteOrder = LittleEndian]
	UnicodeString(Driver)	DriverName;
	BLOB(CjIn)	Data;
}

//
//2.3.7.1 EMR_CREATEBRUSHINDIRECT Record
//
struct EMFEMRCreateBrushIndirectRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000027
	UINT32	Size = MustBeSetToTable(this, "0x00000018");
	UINT32	Brush;
	EMFLogBrushExObject	LogBrush;
}

//
//2.3.7.2 EMR_CREATECOLORSPACE Record
//
struct EMFEMRCreateColorSpaceRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000063
	UINT32	Size;
	UINT32	IHCS;
	WMFlogColorSpaceAObject lcs;
}

//
//2.3.7.3 EMR_CREATECOLORSPACEW Record
//
struct EMFEMRCreateColorSpaceWRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x0000007A
	UINT32	Size;
	UINT32	IHCS;
	WMFlogColorSpaceWObject	LCS;
	UINT32	Flags
	{
		UINT32 Reserved:31;
		UINT32 C:1;
	};
	UINT32	DataSize;
	[Property.EMFSetColorSpaceOffset = FrameOffset]
	while[FrameOffset - Property.EMFSetColorSpaceOffset < DataSize]
	{
		EMFEMRSetColorSpaceRecord Data;
	}
}

//
//2.3.7.4 EMR_CREATEDIBPATTERNBRUSHPT Record
//
struct EMFEMRCreateDIBPatternBrushPTRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x0000005E
	UINT32	Size;
	UINT32	Brush;
	UINT32	Usage = EMFDIBColorsEnumerationTable(this);
	UINT32	OffBmiSrc;
	UINT32	CbBmiSrc;
	UINT32	OffBitsSrc;
	UINT32	CbBitsSrc;
	switch
	{
		case CbBmiSrc > 0: 
			EMFBitmapBuffer(OffBmiSrc, CbBmiSrc, OffBitsSrc, CbBitsSrc) BitmapBuffer;
	}
}

//
//2.3.7.5 EMR_CREATEMONOBRUSH Record
//
struct EMFEMRCreateMONOBrushRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x0000005D
	UINT32	Size;
	UINT32	Brush;
	UINT32	Usage = EMFDIBColorsEnumerationTable(this);
	UINT32	OffBmiSrc;
	UINT32	CbBmiSrc;
	UINT32	OffBitsSrc;
	UINT32	CbBitsSrc;
	switch
	{
		case CbBmiSrc > 0:
			EMFBitmapBuffer(OffBmiSrc, CbBmiSrc, OffBitsSrc, CbBitsSrc) BitmapBuffer;
	}
}

//
//2.3.7.6 EMR_CREATEPALETTE Record
//
struct EMFEMRCreatePaletteRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000031
	UINT32	Size;
	UINT32	PalHandleIndex;
	EMFPaletteObject	LogPalette;
}

//
//2.3.7.7 EMR_CREATEPEN Record
//
struct EMFEMRCreatePenRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000026
	UINT32	Size;
	UINT32	Pen;
	EMFLogPenObject	LogPen;
}

//
//2.3.7.8 EMR_EXTCREATEFONTINDIRECTW Record
//
struct EMFEMREXTCreateFontIndirectWRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000052
	UINT32	Size;
	UINT32	Fonts;
	switch
	{
		case size <= 332: 
			struct
			{
				EMFLogFontWObject EXTLogFontW; //*
				switch
				{
					case Size > 104: Blob(Size - 104) IgnoredData;
				}
			}
		default:
			EMFEnumLogFontEXDVWObject EnumLogFontEXDVW;
	}
}

//
//2.3.7.9 EMR_EXTCREATEPEN Record
//
struct EMFEMREXTCreatePenRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x0000005F
	UINT32	Size;
	UINT32	Pen;
	UINT32	OffBmiSrc;
	UINT32	CbBmiSrc;
	UINT32	OffBitsSrc;
	UINT32	CbBitsSrc;
	EMFExtLogPenObject	Elp;
	switch
	{
		case CbBmiSrc > 0: 
			EMFBitmapBuffer(OffBmiSrc, CbBmiSrc, OffBitsSrc, CbBitsSrc) BitmapBuffer;
	}
}

//
//2.3.8.1 EMR_COLORCORRECTPALETTE Record
//
struct EMFEMRColorCorrectPaletteRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x0000006F
	UINT32	Size = MustBeSetToTable(this, "0x00000018");
	UINT32	Palette;
	UINT32	FirstEntry;
	UINT32	PalEntries;
	UINT32	Reserved;
}

//
//2.3.8.2 EMR_DELETECOLORSPACE Record
//
struct EMFEMRDeleteColorSpaceRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000065
	UINT32	Size;
	UINT32	CSHandleIndex;
}

//
//2.3.8.3 EMR_DELETEOBJECT Record
//
struct EMFEMRDeleteObjectRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000028
	UINT32	Size;
	UINT32	Object;
}

//
//2.3.8.4 EMR_RESIZEPALETTE Record
//
struct EMFEMRResizePaletteRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000033
	UINT32	Size;
	UINT32	Pal;
	UINT32	NumberofEntries;
}

//
//2.3.8.5 EMR_SELECTOBJECT Record
//
struct EMFEMRSelectObjectRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000025
	UINT32	Size;
	UINT32	Object;
}

//
//2.3.8.6 EMR_SELECTPALETTE Record
//
struct EMFEMRSelectPaletteRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000030
	UINT32	Size;
	UINT32	Pal;
}

//
//2.3.8.7 EMR_SETCOLORSPACE Record
//
struct EMFEMRSetColorSpaceRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000064
	UINT32	Size;
	UINT32	CSHandleIndex;
}

//
//2.3.8.8 EMR_SETPALETTEENTRIES Record
//
struct EMFEMRSetPaletteEntriesRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000032
	UINT32	Size;
	UINT32	Pal;
	UINT32	Start;
	UINT32	NumberofEntries;
	EMFPaletteEntryObject	PalEntries[NumberofEntries];
}

//
//2.3.9.1 EMR_GLSBOUNDEDRECORD Record
//
struct EMFEMRGLSBoundedRecordRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000067
	UINT32	Size;
	WMFRectLObject	Bounds;
	UINT32	DataSize;
	BLOB(DataSize)	Data;
}

//
//2.3.9.2 EMR_GLSRECORD Record
//
struct EMFEMRGLSRecordRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000066
	UINT32	Size;
	UINT32	DataSize;
	BLOB(DataSize)	Data;
}

//
//2.3.10 Path Bracket Record Types
//
struct EMFEMRSaveDC
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000021
	UINT32	Size;
}

//
//2.3.11 STATE RECORD TYPES
//
struct EMFEMRRealizePalette
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000034
	UINT32	Size;
}

//
//2.3.11.1 EMR_COLORMATCHTOTARGETW Record
//
struct EMFEMRColorMatchToTargetWRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000079
	UINT32	Size;
	UINT32	Action = EMFColorSpaceEnumerationTable(this);
	UINT32	Flags = EMFColorMatchToTargetEnumerationTable(this);
	UINT32	NameSize;
	UINT32	DataSize;
	BLOB(NameSize + DataSize)	ProfileData;//*
}

//
//2.3.11.2 EMR_FORCEUFIMAPPING Record
//
struct EMFEMRForceUFIMAPPingRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x0000006D
	UINT32	Size;
	EMFUniversalFontId EMFUFI;
}

//
//2.3.11.3 EMR_INVERTRGN Record
//
struct EMFEMRInvertRgnRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000049
	UINT32	Size;
	WMFRectLObject	Bounds;	
	UINT32	RgnDataSize;
	EMFRegionDataObject	RgnData;
}

//
//2.3.11.4 EMR_MOVETOEX Record
//
struct EMFEMRMoveToEXRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x0000001B
	UINT32	Size;
	WMFPointLObject	Offset;
}

//
//2.3.11.5 EMR_PIXELFORMAT Record
//
struct EMFEMRPixelFormatRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000068
	UINT32	Size;
	EMFPixelFormatDescriptorObject	Pfd;
}

//
//2.3.11.6 EMR_RESTOREDC Record
//
struct EMFEMRRestoreDCRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000022
	UINT32	Size = MustBeSetToTable(this, "0x0000000C");
	INT32	SavedDC;
}

//
//2.3.11.7 EMR_SCALEVIEWPORTEXTEX Record
//
struct	EMFEMRScaleViewPortExtexRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x0000001F
	UINT32	Size;
	INT32	XNum;
	INT32	XDenom;
	INT32	YNum;
	INT32	YDenom;
}

//
//2.3.11.8 EMR_SCALEWINDOWEXTEX Record
//
struct EMFEMRScaleWindowExtexRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000020
	UINT32	Size;
	INT32	XNum;
	INT32	XDenom;
	INT32	YNum;
	INT32	YDenom;
}

//
//2.3.11.9 EMR_SETARCDIRECTION Record
//
struct EMFEMRSetARCDirectionRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000039
	UINT32	Size = MustBeSetToTable(this, "0x0000000C");
	UINT32	ArcDirection = EMFArcDirectionEnumerationTable(this);
}

//
//2.3.11.10 EMR_SETBKCOLOR Record
//
struct EMFEMRSetBKColorRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000019
	UINT32	Size;
	WMFColorRefObject	Color;
}

//
//2.3.11.11 EMR_SETBKMODE Record
//
struct EMFEMRSetBKModeRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000012
	UINT32	Size;
	UINT32	BackgroundMode = EMFBackgroundModeEnumerationTable(this);
}

//
//2.3.11.12 EMR_SETBRUSHORGEX Record
//
struct EMFEMRSetBrushORGEXRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x0000000D
	UINT32	Size;
	WMFPointLObject	Origin;
}

//
//2.3.11.13 EMR_SETCOLORADJUSTMENT Record
//
struct EMFEMRSetColorAdjustmentRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000017 0x00000064
	UINT32	Size = MustBeSetToTable(this, "0x00000020");
	EMFColorAdjustmentObject	ColorAdjustment;
}

//
//2.3.11.14 EMR_SETICMMode Record
//
struct EMFEMRSetICMModeRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000062
	UINT32	Size = MustBeSetToTable(this, "0x0000000C");
	UINT32	ICMMode = EMFICMModeEnumerationTable(this);
}

//
//2.3.11.15 EMR_SETICMPROFILEA Record
//
struct EMFEMRSetICMProfileARecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000070
	UINT32	Size;
	UINT32	Values;
	UINT32	ProfileNameSize;
	UINT32	ProfileDataSize;
	BLOB(ProfileNameSize + ProfileDataSize)	ProfileData;//*
}

//
//2.3.11.16 EMR_SETICMPROFILEW Record
//
struct EMFEMRSetICMProfileWRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000071
	UINT32	Size;
	UINT32	Flags;
	UINT32	NameSize;
	UINT32	DataSize;
	BLOB(NameSize + DataSize)	ProfileData;//*
}

//
//2.3.11.17 EMR_SETLAYOUT Record
//
struct EMFEMRSetLayoutRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000073
	UINT32	Size = MustBeSetToTable(this, "0x0000000C");
	UINT32	LayoutMode = WMFLayoutTable(this);
}

//
//2.3.11.18 EMR_SETLINKEDUFIS Record
//
struct EMFEMRSetLinkedUFISRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000077
	UINT32	Size;
	UINT32	NumLinkedUFI;
	switch(NumLinkedUFI)
	{
		case NumLinkedUFI !=0 : EMFUniversalFontId	UFI[NumLinkedUFI];
	}
	UINT64 Reserved;
}

//
//2.3.11.19 EMR_SETMAPMODE Record
//
struct EMFEMRSetMapModeRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000011
	UINT32	Size;
	UINT32	MapMode = EMFMapModeEnumerationTable(this);
}

//
//2.3.11.20 EMR_SETMAPPERFLAGS Record
//
struct EMFEMRSetMapperFlagsRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000010
	UINT32	Size = MustBeSetToTable(this, "0x0000000C");
	UINT32	Flags = EMFEMRSetMapperFlagsTable( this );
}

//
//2.3.11.21 EMR_SETMITERLIMIT Record
//
struct EMFEMRSetMiterLimitRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x0000003A
	UINT32	Size;
	UINT32	MiterLimit;
}

//
//2.3.11.22 EMR_SETPOLYFILLMODE Record
//
struct EMFEMRSetPolyfillModeRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000013
	UINT32	Size;
	UINT32	PolygonFillMode = EMFPolygonFillModeEnumerationTable(this);
}

//
//2.3.11.23 EMR_SETROP2 Record
//
struct EMFEMRSetRop2Record
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000014
	UINT32	Size;
	UINT32	ROP2Mode = WMFBinaryRasterOperationTable(this);
}

//
//2.3.11.24 EMR_SETSTRETCHBLTMODE Record
//
struct EMFEMRSetStretchBLTModeRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000015
	UINT32	Size;
	UINT32	StretchMode = EMFStretchModeEnumerationTable(this);
}

//
//2.3.11.25 EMR_SETTEXTALIGN Record
//
struct EMFEMRSetTextAlignRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000016
	UINT32	Size;
	UINT32	TextAlignmentMode = EMFTextAlignmentModeEnumerationTable(this);
}

//
//2.3.11.26 EMR_SETTEXTCOLOR Record
//
struct EMFEMRSetTextColorRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000018
	UINT32	Size;
	WMFColorRefObject	Color;
}

//
//2.3.11.27 EMR_SETTEXTJUSTIFICATION Record
//
struct EMFEMRSetTextJustificationRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000078
	UINT32	Size;
	INT32	BreakExtra;
	INT32	BreakCount;
}

//
//2.3.11.28 EMR_SETVIEWPORTEXTEX Record
//
struct EMFEMRSetViewPortEXTEXRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x0000000B
	UINT32	Size;
	WMFSizeLObject	Extent;
}

//
//2.3.11.29 EMR_SETVIEWPORTORGEX Record
//
struct EMFEMRSetViewPortOrgexRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x0000000C
	UINT32	Size;
	WMFPointLObject	Origin;
}

//
//2.3.11.30 EMR_SETWINDOWEXTEX Record
//
struct EMFEMRSetWindowExtexRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000009
	UINT32	Size;
	WMFSizeLObject	Extent;
}

//
//2.3.11.31 EMR_SETWINDOWORGEX Record
//
struct EMFEMRSetWindowOrgexRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x0000000A
	UINT32	Size;
	WMFPointLObject	Origin;
}

//
//2.3.12.1 EMR_MODIFYWORLDTRANSFORM Record
//
struct EMFEMRModifyWorldTransformRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000024
	UINT32	Size;
	EMFXFormObject	XForm;
	UINT32	ModifyWorldTransformMode = EMFModifyWorldTransformModeEnumerationTable(this);
}

//
//2.3.12.2 EMR_SETWORLDTRANSFORM Record
//
struct EMFEMRSetWorldTransformRecord
{
	UINT32	Type = EMFRecordTypeEnumerationTable( this );//0x00000023
	UINT32	Size;
	EMFXFormObject	XForm;
} 

//EMF Objects
//EMR records

[DataTypeByteOrder = LittleEndian]
struct EMFRecord
{
	[EMFEOF = "FALSE"]
	while EMFRecordWhileLoop[(FrameOffset < FrameLength - 4) && (EMFEOF == "FALSE")]
	{
		[Property.EMFRecordOffset = FrameOffset]
		switch(UINT32(FrameData, FrameOffset))
		{
			case 0x00000001:
				EMFEMRHeaderRecordTypes EmfHeader;
			case 0x00000002:
				EMFEMRPolybezierRecord EMRPolybezierRecord2;
			case 0x00000003:
				EMFEMRPolygonRecord EMRPolygonRecord;
			case 0x00000004:
				EMFEMRPolylineRecord EMRPolylineRecord4;
			case 0x00000005:
				EMFEMRPolybeziertoRecord EMRPolybeziertoRecord5;
			case 0x00000006:
				EMFEMRPolylineToRecord EMRPolylineRecord6;
			case 0x00000007:
				EMFEMRPolypolylineRecord EMRPolypolylineRecord;
			case 0x00000008:
				EMFEMRPolypolygonRecord EMRPolypolygonRecord;
			case 0x00000009:
				EMFEMRSetWindowExtexRecord EMRSetWindowExtexRecord;
			case 0x0000000A:
				EMFEMRSetWindowOrgexRecord EMRSetWindowOrgexRecord;
			case 0x0000000B:
				EMFEMRSetViewPortEXTEXRecord EMRSetViewPortEXTEXRecord;
			case 0x0000000C:
				EMFEMRSetViewPortOrgexRecord EMRSetViewPortOrgexRecord;
			case 0x0000000D:
				EMFEMRSetBrushORGEXRecord EMRSetBrushORGEXRecord;
			case 0x0000000E:
				EMFEMREOFRecord EMREOFRecord;
			case 0x0000000F:
				EMFEMRSetPixelVRecord EMRSetPixelVRecord;
			case 0x00000010:
				EMFEMRSetMapperFlagsRecord EMRSetMapperFlagsRecord;
			case 0x00000011:
				EMFEMRSetMapModeRecord EMRSetMapModeRecord;
			case 0x00000012:
				EMFEMRSetBKModeRecord EMRSetBKModeRecord;
			case 0x00000013:
				EMFEMRSetPolyfillModeRecord EMRSetPolyfillModeRecord;
			case 0x00000014:
				EMFEMRSetRop2Record EMRSetRop2Record;
			case 0x00000015:
				EMFEMRSetStretchBLTModeRecord EMRSetStretchBLTModeRecord;
			case 0x00000016:
				EMFEMRSetTextAlignRecord EMRSetTextAlignRecord;
			case 0x00000017:
				EMFEMRSetColorAdjustmentRecord EMRSetColorAdjustmentRecord;
			case 0x00000018:
				EMFEMRSetTextColorRecord EMRSetTextColorRecord;
			case 0x00000019:
				EMFEMRSetBKColorRecord EMRSetBKColorRecord;
			case 0x0000001A:
				EMFEMROffsetClipRGNRecord EMROffsetClipRGNRecord;
			case 0x0000001B:
				EMFEMRMoveToEXRecord EMRMoveToEXRecord;
			case 0x0000001C:
				EMFEMRSetMETARGN EMRSetMETARGN;
			case 0x0000001D:
				EMFEMRExcludeClipRectRecord EMRExcludeClipRectRecord;
			case 0x0000001E:
				EMFEMRInterSectClipRectRecord EMRInterSectClipRectRecord;
			case 0x0000001F:
				EMFEMRScaleViewPortExtexRecord EMRScaleViewPortExtexRecord;
			case 0x00000020:
				EMFEMRScaleWindowExtexRecord EMRScaleWindowExtexRecord;
			case 0x00000021:
				EMFEMRSaveDC EMRSaveDC;
			case 0x00000022:
				EMFEMRRestoreDCRecord EMRRestoreDCRecord;
			case 0x00000023:
				EMFEMRSetWorldTransformRecord EMRSetWorldTransformRecord;
			case 0x00000024:
				EMFEMRModifyWorldTransformRecord EMRModifyWorldTransformRecord;
			case 0x00000025:
				EMFEMRSelectObjectRecord EMRSelectObjectRecord;
			case 0x00000026:
				EMFEMRCreatePenRecord EMRCreatePenRecord;
			case 0x00000027:
				EMFEMRCreateBrushIndirectRecord EMRCreateBrushIndirectRecord;
			case 0x00000028:
				EMFEMRDeleteObjectRecord EMRDeleteObjectRecord;
			case 0x00000029:
				EMFEMRAngleArcRecord EMRAngleArcRecord;
			case 0x0000002A:
				EMFEMREllipseRecord EMREllipseRecord;
			case 0x0000002B:
				EMFEMRRectangleRecord EMRRectangleRecord;
			case 0x0000002C:
				EMFEMRRoundRectRecord EMRRoundRectRecord;
			case 0x0000002D:
				EMFEMRARCRecord EMRARCRecord;
			case 0x0000002E:
				EMFEMRChordRecord EMRChordRecord;
			case 0x0000002F:
				EMFEMRPieRecord EMRPieRecord;
			case 0x00000030:
				EMFEMRSelectPaletteRecord EMRSelectPaletteRecord;
			case 0x00000031:
				EMFEMRCreatePaletteRecord EMRCreatePaletteRecord;
			case 0x00000032:
				EMFEMRSetPaletteEntriesRecord EMRSetPaletteEntriesRecord;
			case 0x00000033:
				EMFEMRResizePaletteRecord EMRResizePaletteRecord;
			case 0x00000034:
				EMFEMRRealizePalette EMRRealizePalette;
			case 0x00000035:
				EMFEMREXTFloodFillRecord EMREXTFloodFillRecord;
			case 0x00000036:
				EMFEMRLineToRecord EMRLineToRecord;
			case 0x00000037:
				EMFEMRARCToRecord EMRARCToRecord;
			case 0x00000038:
				EMFEMRPolydrawRecord EMRPolydrawRecord;
			case 0x00000039:
				EMFEMRSetARCDirectionRecord EMRSetARCDirectionRecord;
			case 0x0000003A:
				EMFEMRSetMiterLimitRecord EMRSetMiterLimitRecord;
			case 0x0000003B:
				EMFEMRSaveDC EMRBeginPath;
			case 0x0000003C:
				EMFEMRSaveDC EMREndPath;
			case 0x0000003D:
				EMFEMRSaveDC EMFEMRCloseFigure;
			case 0x0000003E:
				EMFEMRFillPathRecord EMRFillPathRecord;
			case 0x0000003F:
				EMFEMRStrokeAndFillPathRecord EMRStrokeAndFillPathRecord;
			case 0x00000040:	
				EMFEMRStrokePathRecord EMRStrokePathRecord;
			case 0x00000041:
				EMFEMRSaveDC EMFEMRFlattenPath;
			case 0x00000042:
				EMFEMRSaveDC EMFEMRWidenPath;
			case 0x00000043:	
				EMFEMRSelectClipPathRecord EMRSelectClipPathRecord;
			case 0x00000044:
				EMFEMRSaveDC EMFEMRAbortPath;
			case 0x00000046:
				EMFEMRCommentRecordTypes EMRCommentRecordTypes;
			case 0x00000047:
				EMFEMRFillRgnRecord EMRFillRgnRecord;
			case 0x00000048:
				EMFEMRFrameRgnRecord EMRFrameRgnRecord;
			case 0x00000049:
				EMFEMRInvertRgnRecord EMRInvertRgnRecord;
			case 0x0000004A:
				EMFEMRPaintRgnRecord EMRPaintRgnRecord;
			case 0x0000004B:
				EMFEMREXTSelectClipRgnRecord EMREXTSelectClipRgnRecord;
			case 0x0000004C:
				EMFEMRBitBltRecord EMRBitBltRecord;
			case 0x0000004D:
				EMFEMRStretchBltRecord EMRStretchBltRecord;
			case 0x0000004E:
				EMFEMRMaskBltRecord EMRMaskBltRecord;
			case 0x0000004F:
				EMFEMRPlgBltRecord EMRPlgBltRecord;
			case 0x00000050:
				EMFEMRSetDIBitsToDeviceRecord EMRSetDIBitsToDeviceRecord;
			case 0x00000051:
				EMFEMRStretchDIBitsRecord EMRStretchDIBitsRecord;
			case 0x00000052:
				EMFEMREXTCreateFontIndirectWRecord EMREXTCreateFontIndirectWRecord;
			case 0x00000053:
				EMFEMREXTTextOutARecord EMREXTTextOutARecord;
			case 0x00000054:
				EMFEMREXTTextOutWRecord EMREXTTextOutWRecord;
			case 0x00000055:
				EMFEMRPolybezier16Record EMRPolybezier16Record;
			case 0x00000056:
				EMFEMRPolygon16Record EMRPolygon16Record;
			case 0x00000057:
				EMFEMRPolyline16Record EMRPolyline16Record;
			case 0x00000058:
				EMFEMRPolybezierTo16Record EMRPolybezierTo16Record;
			case 0x00000059:
				EMFEMRPolylineTo16Record EMRPolylineTo16Record;
			case 0x0000005A:
				EMFEMRPolyPolyline16Record EMRPolyPolyline16Record;
			case 0x0000005B:
				EMFEMRPolyPolygon16Record EMRPolyPolygon16Record;
			case 0x0000005C:
				EMFEMRPolydraw16Record EMRPolydraw16Record;
			case 0x0000005D:
				EMFEMRCreateMONOBrushRecord EMRCreateMONOBrushRecord;
			case 0x0000005E:
				EMFEMRCreateDIBPatternBrushPTRecord EMRCreateDIBPatternBrushPTRecord;
			case 0x0000005F:
				EMFEMREXTCreatePenRecord EMREXTCreatePenRecord;
			case 0x00000060:
				EMFEMRPolyTextOutARecord EMRPolyTextOutARecord;
			case 0x00000061:
				EMFEMRPolyTextOutWRecord EMRPolyTextOutWRecord;
			case 0x00000062:
				EMFEMRSetICMModeRecord EMRSetICMModeRecord;
			case 0x00000063:
				EMFEMRCreateColorSpaceRecord EMRCreateColorSpaceRecord;
			case 0x00000064:
				EMFEMRSetColorSpaceRecord EMFEMRSetColorSpaceRecord;
			case 0x00000065:
				EMFEMRDeleteColorSpaceRecord EMRDeleteColorSpaceRecord;
			case 0x00000066:
				EMFEMRGLSRecordRecord EMRGLSRecordRecord;
			case 0x00000067:
				EMFEMRGLSBoundedRecordRecord EMRGLSBoundedRecordRecord;
			case 0x00000068:
				EMFEMRPixelFormatRecord EMRPixelFormatRecord;
			case 0x00000069:
				EMFEMRDrawEscapeRecord EMRDrawEscapeRecord;
			case 0x0000006A:
				EMFEMREXTEscapeRecord EMREXTEscapeRecord;
			case 0x0000006B:
				EMFEMRSaveDC EMFEMRStartDOC;
			case 0x0000006C:
				EMFEMRSmallTextOutRecord EMRSmallTextOutRecord;
			case 0x0000006D:
				EMFEMRForceUFIMAPPingRecord EMRForceUFIMAPPingRecord;
			case 0x0000006E:
				EMFEMRNamedEscapeRecord EMRNamedEscapeRecord;
			case 0x0000006F:
				EMFEMRColorCorrectPaletteRecord EMRColorCorrectPaletteRecord;
			case 0x00000070:
				EMFEMRSetICMProfileARecord EMRSetICMProfileARecord;
			case 0x00000071:
				EMFEMRSetICMProfileWRecord EMRSetICMProfileWRecord;
			case 0x00000072:
				EMFEMRAlphaBlendRecord EMRAlphaBlendRecord;
			case 0x00000073:
				EMFEMRSetLayoutRecord EMRSetLayoutRecord;
			case 0x00000074:
				EMFEMRTransParentBLTRecord EMRTransParentBLTRecord;
			case 0x00000076:
				EMFEMRGradientFillRecord EMRGradientFillRecord;
			case 0x00000077:
				EMFEMRSetLinkedUFISRecord EMRSetLinkedUFISRecord;
			case 0x00000078:
				EMFEMRSetTextJustificationRecord EMRSetTextJustificationRecord;
			case 0x00000079:
				EMFEMRColorMatchToTargetWRecord EMRColorMatchToTargetWRecord;
			case 0x0000007A:
				EMFEMRCreateColorSpaceWRecord EMRCreateColorSpaceWRecord;
			default:
				struct Datas = FormatString("EmfUnusedDataCount: %d",Property.EMFUnusedDataCount)
				{
					[Property.EMFUnusedDataCount = 0]
					while EMFRecordWhileLoop[(UINT32(FrameData, FrameOffset) < 0x00000001 || UINT32(FrameData, FrameOffset) > 0x0000007A) && (FrameOffset < FrameLength - 4) && (EMFEOF == "FALSE")]
					{
						[Property.EMFUnusedDataCount = Property.EMFUnusedDataCount + 4]
						UINT32 Data;
					}
				}
		}
	}
}

//2.3.1  Clipping Record Types
struct EMFPlusClippingRecord
{
	UINT16 Type = EMFPlusClippingRecordTable( this );
	switch(Type)
	{
		case 0x4032:
			UINT16 RectFlag
			{
				UINT16 Reserved1:4 = FormatString("Reserved and MUST be ignored");
				UINT16 CM:4 = EMFPlusCombineModeEnumTable( this );
				UINT8 Reserved2 = FormatString("Reserved and MUST be ignored");
			}
		case 0x4033: 
			UINT16 PathFlag
			{
				UINT16 Reserved:4 = FormatString("Reserved and MUST be ignored");
				UINT16 CM:4 = EMFPlusCombineModeEnumTable( this );
				UINT8 ObjectID = MustBeSetToTable(this,"63");
			}
		case 0x4034:
			UINT16 RegionFlag
			{
				UINT16 Reserved:4 = FormatString("Reserved and MUST be ignored");
				UINT16 CM:4 = EMFPlusCombineModeEnumTable( this );
				UINT8 ObjectID = MustBeSetToTable(this,"63");
			}
		default: UINT16 Flags;
	}
	UINT32 Size;
	UINT32 DataSize;
	switch
	{
		case Size == DataSize + 12 :
			struct
			{
				switch(Type)
				{
					case 0x4031 : EmfPlusResetClipRecord EmfPlusResetClip;
					case 0x4032 : EmfPlusSetClipRectRecord EmfPlusSetClipRect;
					case 0x4033 : EmfPlusSetClipPathRecord EmfPlusSetClipPath;
					case 0x4034 : EmfPlusSetClipRegionRecord EmfPlusSetClipRegion;
					case 0x4035 : EmfPlusOffsetClipRecord EmfPlusOffsetClip;
				}
			}
	}
}

//2.3.1.1  EmfPlusOffsetClip Record
struct EmfPlusOffsetClipRecord
{
	UINT32 DX;
	UINT32 DY;
}

//2.3.1.2  EmfPlusResetClip Record
struct EmfPlusResetClipRecord
{
	switch
	{
		case DataSize != 0x00000000 : Blob(DataSize) pad;
	}
}

//2.3.1.3  EmfPlusSetClipPath Record
struct EmfPlusSetClipPathRecord
{
	switch
	{
		case DataSize != 0x00000000 : Blob(DataSize) pad;
	}
}

//2.3.1.4  EmfPlusSetClipRect Record
struct EmfPlusSetClipRectRecord
{
	switch(DataSize)
	{
		case 0x00000010: EmfPlusRectFObject ClipRect;
	}
}

//2.3.1.5  EmfPlusSetClipRegion Record
struct EmfPlusSetClipRegionRecord
{
	switch
	{
		case DataSize != 0x00000000 : Blob(DataSize) pad;
	}
}

//2.2.2.39  EmfPlusRectF Object
struct EmfPlusRectFObject
{
	UINT32 X;
	UINT32 Y;
	UINT32 Width;
	UINT32 Height;
}

table EMFPlusClippingRecordTable( Value )
{
	switch( Value )
	{
		case 0x4031 : "EmfPlusResetClip";
		case 0x4032 : "EmfPlusSetClipRect";
		case 0x4033 : "EmfPlusSetClipPath";
		case 0x4034 : "EmfPlusSetClipRegion";
		case 0x4035 : "EmfPlusOffsetClip";
		default: "Unknow";
	}
}

table EMFPlusCombineModeEnumTable( Value )
{
	switch( Value )
	{
		case 0 : "CombineModeReplace";
		case 1 : "CombineModeIntersect";
		case 2 : "CombineModeUnion";
		case 3 : "CombineModeXOR";
		case 4 : "CombineModeExclude";
		case 5 : "CombineModeComplement";
		default: "Unknow";
	}
}

//2.2.9 Header Object
struct EMFHeaderObject
{
	WMFRectLObject	Bounds;
	WMFRectLObject	Frame;
	UINT32	RecordSignature = EMFFormatSignatureEnumerationTable(this);
	UINT32	Version = FormatString("0x%08X - %s",this,this==0x00000300?"META_FORMAT_WINDOWS":(this==0x00010000?"META_FORMAT_ENHANCED":""));
	UINT32	Bytes;
	UINT32	Records;
	UINT16	Handles;
	UINT16	Reserved = MustBeSetToTable(this, "0x0000");
	[Property.nDescription = this]
	UINT32	Description;
	[Property.OffDescription = this]
	UINT32	OffDescription;
	UINT32	PalEntries;
	WMFSizeLObject	Device;
	WMFSizeLObject	Millimeters;
}

table EMFPixelTypeTable( Value )
{
	switch( Value )
	{
		case 0x00: "PFD_TYPE_RGBA  The pixel format is RGBA.";
		case 0x01: "PFD_TYPE_COLORINDEX  Each pixel is an index in a color table.";
		default: "Unknow";
	}
}

//2.1.26   Point Enumeration
table EMFPointEnumerationTable( Value )
{
	switch( Value )
	{
		case 0x01: "PT_CLOSEFIGURE  The current position is set to the ending point of the closing line.";
		case 0x02: "PT_LINETO  Specifies that a line is to be drawn from the current position to this point, which then becomes the new current position.";
		case 0x03: "PT_BEZIERTO  Specifies that this point is a control point or ending point for a Bezier curve.";
		case 0x04: "PT_MOVETO  Specifies that this point starts a disjoint figure.";
		default: "Unknow";
	}
}

//2.2.27   UniversalFontId Object Checksum table
table EMFUFIChecksumTable( Value )
{
	switch( Value )
	{
		case 0x00000000: FormatString ("0x%08X - The object is a device font.", Value); 
		case 0x00000001: FormatString ("0x%08X - The object is a Type 1 font that has been installed on the client machine and is enumerated by the PostScript printer driver as a device font.", Value); 
		case 0x00000002: FormatString ("0x%08X - The object is not a font but is a Type 1 rasterizer.", Value); 
		default: FormatString ("0x%08X - The object is a bitmap, vector, or TrueType font, or a Type 1 rasterized font that was created by a Type 1 rasterizer.", Value); 
	}
}

//
//2.3.11.20 EMR_SETMAPPERFLAGS Record
//
table EMFEMRSetMapperFlagsTable( Value )
{
	switch( Value )
	{
		case 0x00000001: "The font mapper SHOULD select only fonts that match the aspect ratio of the output device, as it is currently defined in the playback device context.";
		default: "Unknow";
	}
}

//2.2.27   UniversalFontId Object
struct EMFUniversalFontId
{
	UINT32 CheckSum = EMFUFIChecksumTable( this );
	UINT32 Index;
}



struct EMFBitmapBuffer(OffBmiSrc, CbBmiSrc, OffBitsSrc, CbBitsSrc)
{
	switch
	{
		case OffBmiSrc - (FrameOffset - Property.EMFRecordOffset)> 0 : 
			Blob(OffBmiSrc - (FrameOffset - Property.EMFRecordOffset)) UndefinedSpace1;
	}
	switch
	{
		case CbBmiSrc > 0:
			struct BmiSrc
			{
				switch
				{
					case UINT32(FrameData, FrameOffset) == 0x0C:
						struct
						{
							[Property.Width = HeaderCore.Width]
							[Property.Planes = HeaderCore.Planes]
							[Property.BitCount = HeaderCore.BitCount]
							[Property.Height = HeaderCore.Height]
							WMFBitmapCoreHeaderObject HeaderCore;
							[Property.ColorObject = 0]
							while[Property.ColorObject < CbBmiSrc - 40]
							{
								[Property.ColorObject = Property.ColorObject + 4]
								WMFRGBquadObject ColorObject;
							}
						}
					default:
						struct
						{
							[property.Compression = HeaderInfo.Compression]
							[property.ImageSize = HeaderInfo.ImageSize]
							[property.Width = HeaderInfo.Width]
							[property.Planes = HeaderInfo.Planes]
							[property.BitCount = HeaderInfo.BitCount]
							[property.Height = HeaderInfo.Height]
							WMFBitmapInfoHeaderObject HeaderInfo;
							[Property.ColorObject = 0]
							while[Property.ColorObject < CbBmiSrc - 40]
							{
								[Property.ColorObject = Property.ColorObject + 4]
								WMFRGBquadObject ColorObject;
							}
						}
				}
			}
	}
	switch
	{
		case OffBitsSrc - (FrameOffset - Property.EMFRecordOffset) > 0: 
			BLOB(OffBitsSrc - (FrameOffset - Property.EMFRecordOffset)) UndefinedSpace2;
	}
	switch
	{
		case CbBitsSrc > 0:
			struct BitsSrc
			{
				switch
				{
					case UINT32(FrameData, FrameOffset) == 0x0C:
						BLOB((((Property.Width * Property.Planes * Property.BitCount + 31) & ~31) / 8) * Property.Height) CoreaData;
					default:
						struct 
						{
							switch
							{
								case property.Compression != 0x0000 && // BI_RGB
									property.Compression != 0x0003 && // BI_BITFIELDS
									property.Compression != 0x000B: // BI_CMYK
										BLOB(property.ImageSize < (FrameLength - FrameOffset) ? property.ImageSize : (FrameLength - FrameOffset)) aDataC;
								default:
									[Local.size = (((property.Width * property.Planes * property.BitCount + 31) & ~31) / 8) * property.Height]
									BLOB(Local.size < (FrameLength - FrameOffset) ? Local.size : (FrameLength - FrameOffset)) CoreaData;
							}
						}
				}
			}
	}
}
