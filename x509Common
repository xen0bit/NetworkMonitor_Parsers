//#  (c) 2009 CodePlex Foundation
//#
//#  Title:                  X.509 - Public Key Infrastructure Certificate
//#
//#  Details:                
//#
//#  Public References:      RFC 3280 - Internet X.509 Public Key Infrastructure Certificates
//#                          RFC 3281 - An Internet Attribute Certificate Profile for Authorization
//#                          RFC 2560 - X.509 Internet Public Key Infrastructure Online Certificate Status Protocol - OCSP
//#
//#  Comments:               
//#
//#  Revision Class and Date:Minor, 2/5/2010
//#
//####

/**
The top level structure is the
	X509Certificate
This can be called to read an entire Certificate, or individual
members can be read as needed.  

For Attribute Certificates, the top level structure is
	X509AttributeCertificate
There isn't an easy way to distinguish these without knowing
which you want.  
*/

// Explicitly Tagged Module

[DataTypeByteOrder=BigEndian]
struct X509Attribute {
	AsnBerInfo SequenceHeader;
	X509AttributeType Type;
	AsnBerInfo SetOfHeader = "Values";
	[X509AttributeSetEnd = Offset+LengthValue]
	while Values[Offset<X509AttributeSetEnd] {
		X509AttributeValue(property.AsnOid) Value;
	}
}

struct X509AttributeType = Oid.toString {
	AsnBerObjectIdentifier Oid;
}

struct X509AttributeValue(AttrValueId) = Value.toString {
	AsnBerAnyByOid(AttrValueId) Value;
}

[DataTypeByteOrder=BigEndian]
struct X509AttributeTypeAndValue = Value.toString {
	AsnBerInfo SequenceHeader;
	X509AttributeType Type;
	X509AttributeValue(property.AsnOid) Value;
}


struct X520Name = Property.X509Name {
	switch (UINT8(FrameData,Offset)) {
		case 20: struct {
			[X509Name = TeletexString.toString]
			AsnBerTeletexString TeletexString;
		}
		case 19: struct {
			[X509Name = PrintableString.toString]
			AsnBerPrintableString PrintableString;
		}
		case 28: struct {
			[X509Name = UniversalString.toString]
			AsnBerUniversalString UniversalString;
		}
		case 12: struct {
			[X509Name = Utf8String.toString]
			AsnBerUtf8String Utf8String;
		}
		case 30: struct {
			[X509Name = BmpString.toString]
			AsnBerBmpString BmpString;
		}
	}
}

struct X520CommonName = Property.X509Name {
	switch (UINT8(FrameData,Offset)) {
		case 20: struct {
			[X509Name = TeletexString.toString]
			AsnBerTeletexString TeletexString;
		}
		case 19: struct {
			[X509Name = PrintableString.toString]
			AsnBerPrintableString PrintableString;
		}
		case 28: struct {
			[X509Name = UniversalString.toString]
			AsnBerUniversalString UniversalString;
		}
		case 12: struct {
			[X509Name = Utf8String.toString]
			AsnBerUtf8String Utf8String;
		}
		case 30: struct {
			[X509Name = BmpString.toString]
			AsnBerBmpString BmpString;
		}
	}
}

struct X520LocalityName = Property.X509Name {
	switch (UINT8(FrameData,Offset)) {
		case 20: struct {
			[X509Name = TeletexString.toString]
			AsnBerTeletexString TeletexString;
		}
		case 19: struct {
			[X509Name = PrintableString.toString]
			AsnBerPrintableString PrintableString;
		}
		case 28: struct {
			[X509Name = UniversalString.toString]
			AsnBerUniversalString UniversalString;
		}
		case 12: struct {
			[X509Name = Utf8String.toString]
			AsnBerUtf8String Utf8String;
		}
		case 30: struct {
			[X509Name = BmpString.toString]
			AsnBerBmpString BmpString;
		}
	}
}

struct X520StateOrProvinceName = Property.X509Name {
	switch (UINT8(FrameData,Offset)) {
		case 20: struct {
			[X509Name = TeletexString.toString]
			AsnBerTeletexString TeletexString;
		}
		case 19: struct {
			[X509Name = PrintableString.toString]
			AsnBerPrintableString PrintableString;
		}
		case 28: struct {
			[X509Name = UniversalString.toString]
			AsnBerUniversalString UniversalString;
		}
		case 12: struct {
			[X509Name = Utf8String.toString]
			AsnBerUtf8String Utf8String;
		}
		case 30: struct {
			[X509Name = BmpString.toString]
			AsnBerBmpString BmpString;
		}
	}
}

struct X520OrganizationName = Property.X509Name {
	switch (UINT8(FrameData,Offset)) {
		case 20: struct {
			[X509Name = TeletexString.toString]
			AsnBerTeletexString TeletexString;
		}
		case 19: struct {
			[X509Name = PrintableString.toString]
			AsnBerPrintableString PrintableString;
		}
		case 28: struct {
			[X509Name = UniversalString.toString]
			AsnBerUniversalString UniversalString;
		}
		case 12: struct {
			[X509Name = Utf8String.toString]
			AsnBerUtf8String Utf8String;
		}
		case 30: struct {
			[X509Name = BmpString.toString]
			AsnBerBmpString BmpString;
		}
	}
}

struct X520OrganizationalUnitName = Property.X509Name {
	switch (UINT8(FrameData,Offset)) {
		case 20: struct {
			[X509Name = TeletexString.toString]
			AsnBerTeletexString TeletexString;
		}
		case 19: struct {
			[X509Name = PrintableString.toString]
			AsnBerPrintableString PrintableString;
		}
		case 28: struct {
			[X509Name = UniversalString.toString]
			AsnBerUniversalString UniversalString;
		}
		case 12: struct {
			[X509Name = Utf8String.toString]
			AsnBerUtf8String Utf8String;
		}
		case 30: struct {
			[X509Name = BmpString.toString]
			AsnBerBmpString BmpString;
		}
	}
}

struct X520Title = Property.X509Name {
	switch (UINT8(FrameData,Offset)) {
		case 20: struct {
			[X509Name = TeletexString.toString]
			AsnBerTeletexString TeletexString;
		}
		case 19: struct {
			[X509Name = PrintableString.toString]
			AsnBerPrintableString PrintableString;
		}
		case 28: struct {
			[X509Name = UniversalString.toString]
			AsnBerUniversalString UniversalString;
		}
		case 12: struct {
			[X509Name = Utf8String.toString]
			AsnBerUtf8String Utf8String;
		}
		case 30: struct {
			[X509Name = BmpString.toString]
			AsnBerBmpString BmpString;
		}
	}
}

struct X520DnQualifier = DnQualifier.toString {
	AsnBerPrintableString DnQualifier;
}

struct X520CountryName = CountryName.toString {
	AsnBerPrintableString CountryName;
}

struct X520SerialNumber = SerialNumber.toString {
	AsnBerPrintableString SerialNumber;
}

struct X520Pseudonym = Property.X509Name {
	switch (UINT8(FrameData,Offset)) {
		case 20: struct {
			[X509Name = TeletexString.toString]
			AsnBerTeletexString TeletexString;
		}
		case 19: struct {
			[X509Name = PrintableString.toString]
			AsnBerPrintableString PrintableString;
		}
		case 28: struct {
			[X509Name = UniversalString.toString]
			AsnBerUniversalString UniversalString;
		}
		case 12: struct {
			[X509Name = Utf8String.toString]
			AsnBerUtf8String Utf8String;
		}
		case 30: struct {
			[X509Name = BmpString.toString]
			AsnBerBmpString BmpString;
		}
	}
}

struct X509DomainComponent = DomainComponent.toString {
	AsnBerIa5String DomainComponent;
}

struct X509EmailAddress = EmailAddress.toString {
	AsnBerIa5String EmailAddress;
}

[DataTypeByteOrder=BigEndian]
struct X509Name = RdnSequence.toString {
	X509RdnSequence RdnSequence;
}

struct X509RdnSequence = RdnSequenceString {
	[RdnSequenceString = ""] 
	AsnBerInfo SequenceOfHeader;
	[X509RdnSSequenceEnd = Offset+LengthValue]
	switch {
		case (Property.LengthValue != 0): 
		struct {
			[RdnSequenceString = Name.toString]
			X509RelativeDistinguishedName Name;
			while Rdn[(Offset<X509RdnSSequenceEnd)] {
				[RdnSequenceString = FormatString("%s,%s",
						Name.toString, 
						RdnSequenceString)]
				X509RelativeDistinguishedName Name;
			}
		}
	}
}

struct X509DistinguishedName = RdnSequence.toString {
	X509RdnSequence RdnSequence;
}

struct X509RelativeDistinguishedName = RdnString {
	[RdnString = ""]
	AsnBerInfo SetOfHeader;
	[X509RdnSetEnd = Offset+LengthValue]
	switch {
		case(Property.LengthValue != 0):
		struct {
			[RdnString = AttributeTypeAndValue.toString]
			X509AttributeTypeAndValue AttributeTypeAndValue;
			while atv[Offset<X509RdnSetEnd] {
				[RdnString = FormatString("%s+%s",
						RdnString,
						AttributeTypeAndValue.toString)]
				X509AttributeTypeAndValue AttributeTypeAndValue;
			}
		}
	}
}

struct X509DirectoryString = Property.X509Name {
	switch (UINT8(FrameData,Offset)) {
		case 20: struct {
			[X509Name = TeletexString.toString]
			AsnBerTeletexString TeletexString;
		}
		case 19: struct {
			[X509Name = PrintableString.toString]
			AsnBerPrintableString PrintableString;
		}
		case 28: struct {
			[X509Name = UniversalString.toString]
			AsnBerUniversalString UniversalString;
		}
		case 12: struct {
			[X509Name = Utf8String.toString]
			AsnBerUtf8String Utf8String;
		}
		case 30: struct {
			[X509Name = BmpString.toString]
			AsnBerBmpString BmpString;
		}
	}
}

/** Top-Level Structure **/
[DataTypeByteOrder=BigEndian]
struct X509Certificate = TbsCertificate.toString {
	AsnBerInfo SequenceHeader;
	X509TBSCertificate TbsCertificate;
	X509AlgorithmIdentifier SignatureAlgorithm;
	AsnBerBitString Signature;
}

struct X509TBSCertificate = 
	FormatString("Issuer: %s, Subject: %s", 
			Issuer.toString, Subject.toString) {
	AsnBerInfo SequenceHeader;
	switch {
		case(UINT8(FrameData,Offset) == 0xa0):
		struct {
			AsnBerInfo Tag0;
			X509Version Version;
		}
	}
	X509CertificateSerialNumber SerialNumber;
	X509AlgorithmIdentifier Signature;
	X509Name Issuer;
	X509Validity Validity;
	X509Name Subject;
	X509SubjectPublicKeyInfo SubjectPublicKeyInfo;
	switch {
		case(UINT8(FrameData,Offset) == 0xa1):
		struct {
			X509UniqueIdentifier IssuerUniqueId;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 0xa2):
		struct {
			X509UniqueIdentifier SubjectUniqueId;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 0xa3):
		struct {
			AsnBerInfo Tag3;
			X509Extensions Extensions;
		}
	}
}

Table X509VersionTable(verno) {
	switch(verno) {
		case 0: "v1 (0)";
		case 1: "v2 (1)";
		case 2: "v3 (2)";
		default: FormatString("Invalid Version Number (%d)", verno);
	}
}

struct X509Version = X509VersionTable(X509Verno) {
	[post.X509VerNo = AsnIntValue]
	AsnBerInteger Version = X509VersionTable(AsnIntValue);
}

struct X509CertificateSerialNumber = SerialNumber.toString {
	AsnBerInteger SerialNumber = FormatString("%d", property.AsnIntValue);
}

struct X509Validity = 
	FormatString("From: %s To: %s", NotBefore.toString, NotAfter.toString)
{
	AsnBerInfo SequenceHeader;
	X509Time NotBefore;
	X509Time NotAfter;
}

struct X509Time = Property.X509Time {
	switch (UINT8(FrameData,Offset)) {
		case 23: struct {
			[X509Time = UtcTime.toString]
			AsnBerUtcTime UtcTime;
		}
		case 24: struct {
			[X509Time = GenTime.toString]
			AsnBerGeneralizedTime GenTime;
		}
	}
}

struct X509UniqueIdentifier = Id.toString {
	AsnBerBitString Id;
}

struct X509SubjectPublicKeyInfo = Algorithm.toString {
	AsnBerInfo SequenceHeader;
	X509AlgorithmIdentifier Algorithm;
	AsnBerBitString SubjectPublicKey;
}

struct X509Extensions {
	AsnBerInfo SequenceOfHeader = "Extensions";
	[X509ExtnsSequenceEnd = Offset+LengthValue]
	while Extensions[Offset<X509ExtnsSequenceEnd] {
		X509Extension Extension;
	}
}

//struct X509Extension = FormatString("%s (%s)", AsnOidTable(property.AsnObjectIdentifierValue), property.AsnObjectIdentifierValue) {
//	AsnBerInfo SequenceHeader;
//	AsnBerObjectIdentifier ExtnId = FormatString("%s (%s)", AsnOidTable(property.AsnObjectIdentifierValue), property.AsnObjectIdentifierValue);
//	switch {
//		case (UINT8(FrameData,Offset) == 0x01):
//		AsnBerBoolean Crticial;
//	}
//	AsnBerInfo OctetStringHeader;
//	//AsnBerAnyByOid(ExtnId.toString) ExtnValue;
//	AsnBerAnyByOid(property.AsnObjectIdentifierValue) ExtnValue;
//}

struct X509Extension = local.X509ExtensionsSummary
{
	AsnBerInfo SequenceHeader;	
	[post.local.X509ExtensionsSummary = ExtnId.ToString]
	AsnBerObjectIdentifier ExtnId;
	switch {
		case (UINT8(FrameData,Offset) == 0x01):
		AsnBerBoolean Critical;
	}
	AsnBerInfo OctetStringHeader;
	//AsnBerAnyByOid(ExtnId.toString) ExtnValue;
	[DataFieldFrameLength = FrameOffset + LengthValue]
	AsnBerAnyByOid(property.AsnOid) ExtnValue = Property.AnyValue;
}

// CRL structures

struct X509CertificateList {
	AsnBerInfo SequenceHeader;
	X509TBSCertList TbsCertList;
	X509AlgorithmIdentifier SignatureAlgorithm;
	AsnBerBitString Signature;
}

struct X509TBSCertList {
	AsnBerInfo SequenceHeader;
	switch {
		case(UINT8(FrameData,Offset) == 0x02):
		X509Version Version;
	}
	X509AlgorithmIdentifier Signature;
	X509Name Issuer;
	X509Time ThisUpDate;
	switch {
		case(UINT8(FrameData,Offset) == 23 ||
			UINT8(FrameData,Offset) == 24):
		X509Time NextUpDate;
	}
	switch {
		case(UINT8(FrameData,Offset) == 0x30):
		struct {
			AsnBerInfo SequenceOfHeader;
			[X509CertlistSequenceEnd = Offset+LengthValue]
			while seq[Offset<X509CertlistSequenceEnd] {
				AsnBerInfo SequenceHeader;
				X509CertificateSerialNumber
					UserCertificates;
				X509Time RevocationDate;
				switch {
					case(UINT8(FrameData,Offset) == 0x30):
					X509Extensions CrlEntryExtensions;
				}
			}
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 0xa0):
		struct {
			AsnBerInfo Tag0;
			X509Extensions CrlExtensions;
		}
	}
}

[DataTypeByteOrder=BigEndian]
struct X509AlgorithmIdentifier = local.X509AlgorithmIdentifierSummary
{
	AsnBerInfo SequenceHeader;
	[X509AlgorithmIdentifierSequenceEnd = FrameOffset + LengthValue,
	post.local.X509AlgorithmIdentifierSummary = Algorithm.ToString]
	AsnBerObjectIdentifier Algorithm;
	Switch
	{
		case X509AlgorithmIdentifierSequenceEnd > FrameOffset:
			AsnBerAnyByOid(property.AsnOid) Parameters;
	}
}

// X.400 Address syntax starts here

struct X509ORAddress {
	AsnBerInfo SequenceHeader;
	X509BuiltInStandardAttributes BuiltInStandardAttributes;
	switch {
		case(UINT8(FrameData,Offset) == 0x30):
		X509BuiltInDomainDefinedAttributes 
			BuiltInDomainDefinedAttributes;
	}
	switch {
		case(UINT8(FrameData,Offset) == 0x31):
		X509ExtensionAttributes 
			ExtensionAttributes;
	}
}

// Builtin Standard Attributes

struct X509BuiltInStandardAttributes {
	AsnBerInfo SequenceHeader;
	switch {
		case(UINT8(FrameData,Offset) == 0x41):
		struct {
			X509CountryName CountryName;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 0x42):
		struct {
			X509AdministrationDomainName 
				AdministrationDomainName;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 0xa0):
		struct {
			X509NetworkAddress NetworkAddress;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 0xa1):
		struct {
			X509TerminalIdentifier TerminalIdentifier;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 0xa2):
		struct {
			AsnBerInfo Tag2;
			X509PrivateDomainName PrivateDomainName;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 0xa3):
		struct {
			X509OrganizationName OrganizationName;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 0xa4):
		struct {
			X509NumericUserIdentifier NumericUserIdentifier;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 0xa5):
		struct {
			X509PersonalName PersonalName;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 0xa6):
		struct {
			X509OrganizationalUnitNames 
				OrganizationalUnitNames;
		}
	}
}

struct X509CountryName = Property.X509Name {
	AsnBerInfo ApplicationTag;
	switch (UINT8(FrameData,Offset)) {
		case 18: struct {
			[X509Name = X121DccCode.toString]
			AsnBerNumericString X121DccCode;
		}
		case 19: struct{
			[X509Name = Iso3166Alpha2Code.toString]
			AsnBerPrintableString Iso3166Alpha2Code;
		}
	}
}

struct X509AdministrationDomainName = Property.X509Name {
	AsnBerInfo ApplicationTag;
	switch (UINT8(FrameData,Offset)) {
		case 18: struct {
			[X509Name = Numeric.toString]
			AsnBerNumericString Numeric;
		}
		case 19: struct {
			[X509Name = Printable.toString]
			AsnBerPrintableString Printable;
		}
	}
}

struct X509NetworkAddress = Address.toString {
	X509X121Address Address;
}

struct X509X121Address = Address.toString {
	AsnBerNumericString Address;
}

struct X509TerminalIdentifier = Termid.toString {
	AsnBerPrintableString Termid;
}

struct X509PrivateDomainName = Property.X509Name {
	switch (UINT8(FrameData,Offset)) {
		case 18: struct {
			[X509Name = Numeric.toString]
			AsnBerNumericString Numeric;
		}
		case 19: struct {
			[X509Name = Printable.toString]
			AsnBerPrintableString Printable;
		}
	}
}

struct X509OrganizationName = Name.toString {
	AsnBerPrintableString Name;
}

struct X509NumericUserIdentifier = Userid.toString {
	AsnBerNumericString Userid;
}

struct X509PersonalName = Property.X509Name {
	AsnBerInfo SetHeader;
	[X509Name = SurName.toString]
	AsnBerPrintableString SurName;
	switch {
		case(UINT8(FrameData,Offset) == 0xa1):
		struct {
			[X509Name = FormatString("%s, %s", X509Name, GivenName.toString)]
			AsnBerPrintableString GivenName;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 0xa2):
		struct {
			AsnBerPrintableString Initials;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 0xa3):
		struct {
			AsnBerPrintableString GenerationQualifier;
		}
	}
}

struct X509OrganizationalUnitNames {
	AsnBerInfo SequenceOfHeader;
	[X509OrgUNamesSequenceEnd = Offset+LengthValue]
	while string[Offset<X509OrgUNamesSequenceEnd] {
		X509OrganizationalUnitName UnitName;
	}
}

struct X509OrganizationalUnitName = OrganizationalUnitName.toString {
	AsnBerPrintableString OrganizationalUnitName;
}

// Built-in Domain-defined Attributes

struct X509BuiltInDomainDefinedAttributes {
	AsnBerInfo SequenceOfHeader;
	[X509BltInDomDefAttrSequenceEnd = Offset+LengthValue]
	while Attr[Offset<X509BltInDomDefAttrSequenceEnd] {
		X509BuiltInDomainDefinedAttribute Attribute;
	}
}

struct X509BuiltInDomainDefinedAttribute 
		= FormatString("%s=%s", Type.toString, Value.toString) {
	AsnBerInfo SequenceHeader;
	AsnBerPrintableString Type;
	AsnBerPrintableString Value;
}

// Extension Attributes

struct X509ExtensionAttributes {
	AsnBerInfo SetOfHeader = "ExtensionAttributes";
	[X509ExtnAttrsSetEnd = Offset+LengthValue]
	while ExtensionAttributes[Offset<X509ExtnAttrsSetEnd] {
		X509ExtensionAttribute ExtensionAttribute;
	}
}

struct X509ExtensionAttribute {
	AsnBerInfo SequenceHeader;
	AsnBerInteger ExtensionAttributeType;
	switch (AsnIntValue) {
		case 1: X509CommonName CommonName;
		case 2: X509TeletexCommonName TeletexCommonName;
		case 3: X509TeletexOrganizationName TeletexOrganizationName;
		case 4: X509TeletexPersonalName TeletexPersonalName;
		case 5: X509TeletexOrganizationalUnitNames 
			TeletexOrganizationalUnitNames;
		case 6: X509TeletexDomainDefinedAttributes
 			TeletexDomainDefinedAttributes;
		case 7: X509PDSName PDSName;
		case 8: X509PhysicalDeliveryCountryName 
			PhysicalDeliveryCountryName;
		case 9: X509PostalCode PostalCode;
		case 10: X509PhysicalDeliveryOfficeName 
			PhysicalDeliveryOfficeName;
		case 11: X509PhysicalDeliveryOfficeNumber 
			PhysicalDeliveryOfficeNumber;
		case 12: X509ExtensionORAddressComponents 
			ExtensionORAddressComponents;
		case 13: X509PhysicalDeliveryPersonalName 
			PhysicalDeliveryPersonalName;
		case 14: X509PhysicalDeliveryOrganizationName 
			PhysicalDeliveryOrganizationName;
		case 15: X509ExtensionPhysicalDeliveryAddressComponents 
			ExtensionPhysicalDeliveryAddressComponents;
		case 16: X509UnformattedPostalAddress
			UnformattedPostalAddress;
		case 17: X509StreetAddress StreetAddress;
		case 18: X509PostOfficeBoxAddress PostOfficeBoxAddress;
		case 19: X509PosteRestanteAddress PosteRestanteAddress;
		case 20: X509UniquePostalName UniquePostalName;
		case 21: X509LocalPostalAttributes LocalPostalAttributes;
		case 22: X509ExtendedNetworkAddress ExtendedNetworkAddress;
		case 23: X509TerminalType TerminalType;
		default: AsnBerOctetString ExtensionAttributeValue;
	}
}

// Extension Types and Attribute Values

struct X509CommonName = Name.toString {
	AsnBerPrintableString Name;
}

struct X509TeletexCommonName = Name.toString {
	AsnBerTeletexString Name;
}

struct X509TeletexOrganizationName = Name.toString {
	AsnBerTeletexString Name;
}

// TODO: Come in and fill This out
struct X509TeletexPersonalName {
	AsnBerInfo SetHeader;
	AsnBerTeletexString SurName;
	switch {
		case(UINT8(FrameData,Offset) == 0xa1):
		struct {
			AsnBerTeletexString GivenName;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 0xa2):
		struct {
			AsnBerTeletexString Initials;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 0xa3):
		struct {
			AsnBerTeletexString GenerationQualifier;
		}
	}
}

struct X509TeletexOrganizationalUnitNames {
	AsnBerInfo SequenceOfHeader;
	[X509TltxOrgnlUNamesSequenceEnd = Offset+LengthValue]
	while Name[Offset<X509TltxOrgnlUNamesSequenceEnd] {
		X509TeletexOrganizationalUnitName TeorgName;
	}
}

struct X509TeletexOrganizationalUnitName = Name.toString {
	AsnBerTeletexString Name;
}

struct X509PDSName = Name.toString {
	AsnBerPrintableString Name;
}

struct X509PhysicalDeliveryCountryName = Property.X509Name {
	switch (UINT8(FrameData,Offset)) {
		case 18: struct {
			[X509Name = X121DccCode.toString]
			AsnBerNumericString X121DccCode;
		}
		case 19: struct {
			[X509Name = Iso3166Alpha2Code.toString]
			AsnBerPrintableString Iso3166Alpha2Code;
		}
	}
}

struct X509PostalCode = Property.X509Name {
	switch (UINT8(FrameData,Offset)) {
		case 18: struct {
			[X509Name = NumericCode.toString]
			AsnBerNumericString NumericCode;
		}
		case 19: struct {
			[X509Name = PrintableCode.toString]
			AsnBerPrintableString PrintableCode;
		}
	}
}

struct X509PhysicalDeliveryOfficeName = Name.toString {
	X509PDSParameter Name;
}

struct X509PhysicalDeliveryOfficeNumber = Number.toString {
	X509PDSParameter Number;
}

struct X509ExtensionORAddressComponents = Component.toString {
	X509PDSParameter Component;
}

struct X509PhysicalDeliveryPersonalName = Name.toString {
	X509PDSParameter Name;
}

struct X509PhysicalDeliveryOrganizationName = Name.toString {
	X509PDSParameter Name;
}

struct X509ExtensionPhysicalDeliveryAddressComponents = Components.toString {
	X509PDSParameter Components;
}

struct X509UnformattedPostalAddress {
	AsnBerInfo SetHeader;
	switch {
		case(UINT8(FrameData,Offset) == 0x30):
		struct {
			AsnBerInfo SequenceOfHeader = "PrintableAddress";
			[X509UnfPstlAddrSequenceEnd = Offset+LengthValue]
			while PrintableAddress[Offset<X509UnfPstlAddrSequenceEnd] {
				AsnBerPrintableString PrintableString;
			}
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 20):
		AsnBerTeletexString TeletexString;
	}
}

struct X509StreetAddress = Address.toString {
	X509PDSParameter Address;
}

struct X509PostOfficeBoxAddress = Address.toString {
	X509PDSParameter Address;
}

struct X509PosteRestanteAddress = Address.toString {
	X509PDSParameter Address;
}

struct X509UniquePostalName = Name.toString {
	X509PDSParameter Name;
}

struct X509LocalPostalAttributes = Attributes.toString {
	X509PDSParameter Attributes;
}

struct X509PDSParameter = X509PDSParameter {
	AsnBerInfo SetHeader;
	switch {
		case(UINT8(FrameData,Offset) == 19):
		struct {
			[X509PDSParameter = PrintableString.toString]
			AsnBerPrintableString PrintableString;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 20):
		struct {
			[X509PDSParameter = TeletexString.toString]
			AsnBerTeletexString TeletexString;
		}
	}
}

struct X509ExtendedNetworkAddress {
	switch (UINT8(FrameData,Offset)) {
		case 0x30: struct {
			AsnBerInfo SequenceHeader;
			AsnBerNumericString Number;
			switch {
				case (UINT8(FrameData,Offset) == 0xa1):
				AsnBerNumericString SubAddress;
			}
		}
		case 0xa0: X509PresentationAddress PsapAddress;
	}
}

struct X509PresentationAddress {
	AsnBerInfo SequenceHeader;
	switch {
		case(UINT8(FrameData,Offset) == 0xa0):
		struct {
			AsnBerInfo Tag0;
			AsnBerOctetString PSelector;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 0xa1):
		struct {
			AsnBerInfo Tag1;
			AsnBerOctetString SSelector;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 0xa2):
		struct {
			AsnBerInfo Tag2;
			AsnBerOctetString TSelector;
		}
	}
	AsnBerInfo Tag3;
	AsnBerInfo SetOfHeader = "NAddresses";
	[X509nAddrsSetEnd = Offset+LengthValue]
	while NAddresses[Offset<X509nAddrsSetEnd] {
		AsnBerOctetString NAddress;
	}
}

Table X509TermTypeTable(TerminalType) {
	switch(TerminalType) {
		case 3: "telex (3)";
		case 4: "Teletex (4)";
		case 5: "g3-fascimile (5)";
		case 6: "g4-fascimile (6)";
		case 7: "ia5-Terminal (7)";
		case 8: "videotex (8)";
		default: FormatString("Unknown terminal type (%d)", TerminalType);
	}
}

struct X509TerminalType = X509TermTypeTable(Property.TerminalType) {
	[post.Property.TerminalType = AsnIntValue]
	AsnBerInteger Type = X509TermTypeTable(AsnIntValue);
}

// Extension Domain-defined Attributes

// Value 6
struct X509TeletexDomainDefinedAttributes {
	AsnBerInfo SequenceOfHeader;
	[X509TltxDmnDfndAttrsSequenceEnd = Offset+LengthValue]
	while Attr[Offset<X509TltxDmnDfndAttrsSequenceEnd] {
		X509TeletexDomainDefinedAttribute Attribute;
	}
}

struct X509TeletexDomainDefinedAttribute 
		= FormatString("%s=%s", Type, Value) {
	AsnBerInfo SequenceHeader;
	AsnBerTeletexString Type;
	AsnBerTeletexString Value;
}

// Implicity Tagged Module

struct X509AuthorityKeyIdentifier
{
	AsnBerInfo SequenceHeader;
	switch {
		case(UINT8(FrameData,Offset) == 0x80):
		struct {
//			[X509AuthKeyId = KeyIdentifier.toString]
//			X509KeyIdentifier KeyIdentifier;
			AsnBerInfo AsnOctetStringHeader;
			Blob(Property.LengthValue) KeyIdentifier;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 0xa1):
		struct {
			[X509AuthKeyId = AuthorityCertIssuer.toString]
			X509GeneralNames AuthorityCertIssuer;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 0x82):
		struct {
			[X509AuthKeyId = AuthorityCertSerialNumber.toString]
			X509CertificateSerialNumber AuthorityCertSerialNumber;
		}
	}
}


//struct X509KeyIdentifier = Id.toString {
//	AsnBerOctetString Id;
//}
//
struct X509SubjectKeyIdentifier
{
//	X509KeyIdentifier Id;
	AsnBerInfo AsnOctetStringHeader;
	Blob(Property.LengthValue) KeyIdentifier;
}

/** TODO:  Clean This up!!  **/
struct X509KeyUsage {
	AsnBerInfo BitStringHeader;
	switch {
		case LengthValue>2: struct {
			UINT8 Padding[LengthValue-2];
		}
	}
	UINT16 usage {
		UINT16 DigitalSignature:1 = FormatString("(%s) %s", this.ToBitString, this ? "Subject public key is used with a digital signature mechanism to support security services other than certificate signing, or CRL signing" : "");
		UINT16 NonRepudiation:1 = FormatString("  (%s) %s", this.ToBitString, this ? "Subject public key is used to verify digital signatures used to provide a non-repudiation service which protects against the signing entity falsely denying some action, excluding certificate or CRL signing" : "");
		UINT16 KeyEncipherment:1 = FormatString(" (%s) %s", this.ToBitString, this ? "Subject public key is used for key transport" : "");
		UINT16 DataEncipherment:1 = FormatString("(%s) %s", this.ToBitString, this ? "Subject public key is used for enciphering user data, other than cryptographic keys" : "");
		[X509KeyUsageKeyAgreement]
		UINT16 KeyAgreement:1 = FormatString("    (%s) %s", this.ToBitString, this ? "Subject public key is used for key agreement" : "");
		UINT16 KeyCertSign:1 = FormatString("     (%s) %s", this.ToBitString, this ? "Subject public key is used for verifying a signature on public key certificates" : "");
		UINT16 CrlSign:1 = FormatString("         (%s) %s", this.ToBitString, this ? "Subject public key is used for verifying a signature on certificate revocation list " : "");
		[X509KeyUsageEncipherOnly]
		UINT16 EncipherOnly:1 = (X509KeyUsageKeyAgreement & X509KeyUsageEncipherOnly) ? FormatString("    (%s) %s", this.ToBitString, this ? "Subject public key may be used only for enciphering data while performing key agreement" : "") : FormatString("    (%s) %s", this.ToBitString, "");
		[X509KeyUsageDecipherOnly]
		UINT16 DecipherOnly:1 = (X509KeyUsageKeyAgreement & X509KeyUsageDecipherOnly) ? FormatString("    (%s) %s", this.ToBitString, this ? "Subject public key may be used only for deciphering data while performing key agreement" : "") : FormatString("    (%s) %s", this.ToBitString, "");
		UINT16 Unused:7 = FormatString("          (%s)", this.ToBitString);
	};
}

struct X509PrivateKeyUsagePeriod {
	AsnBerInfo SequenceHeader;
	switch {
		case(UINT8(FrameData,Offset) == 0xa0):
		struct {
			AsnBerGeneralizedTime NotBefore;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 0xa1):
		struct {
			AsnBerGeneralizedTime NotAfter;
		}
	}
}

struct X509CertificatePolicies {
	AsnBerInfo SequenceOfHeader = "CertificatePolicies";
	[X509CertPolsSequenceEnd = Offset+LengthValue]
	while CertificatePolicies[Offset<X509CertPolsSequenceEnd] {
		X509PolicyInformation Policy;
	}
}

struct X509PolicyInformation {
	AsnBerInfo SequenceHeader;
	X509CertPolicyId PolicyIdentifier;
	switch {
		case(UINT8(FrameData,Offset) == 0x30):
		struct {
			AsnBerInfo SequenceOfHeader = "PolicyQualifiers";
			[X509PolQualInfosSequenceEnd = Offset+LengthValue]
			while PolicyQualifiers[Offset<X509PolQualInfosSequenceEnd] {
				X509PolicyQualifierInfo PolicyQualifier;
			}
		}
	}
}

struct X509CertPolicyId = Id.toString {
	AsnBerObjectIdentifier Id;
}

struct X509PolicyQualifierInfo {
	AsnBerInfo SequenceHeader;
	X509PolicyQualifierId PolicyQualifierId;
	AsnBerAnyByOid(property.AsnOid) Qualifier;
}

struct X509PolicyQualifierId = Id.toString {
	AsnBerObjectIdentifier Id;
}

struct X509CPSUri = Uri.toString {
	AsnBerIa5String Uri;
}

struct X509UserNotice {
	AsnBerInfo SequenceInfo;
	switch {
		case(UINT8(FrameData,Offset) == 0x30):
		struct {
			X509NoticeReference NoticeRef;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 22 ||
			UINT8(FrameData,Offset) == 26 ||
			UINT8(FrameData,Offset) == 30 ||
			UINT8(FrameData,Offset) == 12):
		struct {
			X509DisplayText ExplicitText;
		}
	}
}

struct X509NoticeReference {
	AsnBerInfo SequenceHeader;
	X509DisplayText Organization;
	AsnBerInfo SequenceOfHeader = "NoticeNumbers";
	[X509NotRefSequenceEnd = Offset+LengthValue]
	while NoticeNumbers[Offset<X509NotRefSequenceEnd] {
		AsnBerInteger NoticeNumber;
	}
}

struct X509DisplayText = X509DisplayText {
	switch (UINT8(FrameData,Offset)) {
		case 22: struct {
			[X509DisplayText = Ia5String.toString]
			AsnBerIa5String Ia5String;
		}
		case 26: struct {
			[X509DisplayText = VisibleString.toString]
			AsnBerVisibleString VisibleString;
		}
		case 30: struct {
			[X509DisplayText = BmpString.toString]
			AsnBerBmpString BmpString;
		}
		case 12: struct {
			[X509DisplayText = Utf8String.toString]
			AsnBerUtf8String Utf8String;
		}
	}
}

struct X509PolicyMappings {
	AsnBerInfo SequenceOfHeader = "PolicyMappings";
	[X509PolMapsSequenceEnd = Offset+LengthValue]
	while PolicyMappings[Offset<X509PolMapsSequenceEnd] {
		AsnBerInfo SequenceHeader;
		X509CertPolicyId IssuerDomainPolicy;
		X509CertPolicyId SubjectDomainPolicy;
	}
}

struct X509SubjectAltName {
	X509GeneralNames Name;
}

struct X509GeneralNames {
	AsnBerInfo SequenceOfHeader = "GeneralNames";
	[X509GenNamesSequenceEnd = Offset+LengthValue]
	while GeneralNames[Offset<X509GenNamesSequenceEnd ] {
		X509GeneralName GeneralName;
	}
}

struct X509GeneralName = X509GeneralName {	
	switch (UINT8(FrameData,Offset)&0x1F) {
		case 0: struct {
			[X509GeneralName = OtherName.toString]
			X509AnOtherName OtherName;
		}
		case 1: struct {
			[X509GeneralName = Rfc822Name.toString]
			AsnBerIa5String Rfc822Name;
		}
		case 2: struct {
			[X509GeneralName = DnsName.toString]
			AsnBerIa5String DnsName;
		}
		case 3: struct {
			[X509GeneralName = x400Address.toString]
			X509ORAddress X400Address;
		}
		case 4: struct {
			[X509GeneralName = DirectoryName.toString]
			X509Name DirectoryName;
		}
		case 5: struct {
			[X509GeneralName = EdiPartyName.toString]
			X509EDIPartyName EdiPartyName;
		}
		case 6: struct {
			[X509GeneralName = UniformResourceIdentifier.toString]
			AsnBerIa5String UniformResourceIdentifier;
		}
		case 7: struct {
			[X509GeneralName = IpAddress.toString]
			AsnBerOctetString IPAddress;
		}
		case 8: struct {
			[X509GeneralName = RegisteredId.toString]
			AsnBerObjectIdentifier RegisteredId;
		}
	}
}

struct X509AnOtherName {
	AsnBerInfo SequenceHeader;
	AsnBerObjectIdentifier TypeId;
	AsnBerInfo Tag0;
	AsnBerAnyByOid(property.AsnOid) Value;
}

struct X509EDIPartyName = Property.X509EDIPartyName {
	[Property.X509EDIPartyName = ""]
	AsnBerInfo SequenceHeader;
	switch {
		case (UINT8(FrameData,Offset) == 0xa0): 
			[Property.X509EDIPartyName = NameAssigner.toString]
			X509DirectoryString NameAssigner;
	}
	[Property.X509EDIPartyName = FormatString("%s, %s", 
			Property.X509EDIPartyName, PartyName.toString)]
	X509DirectoryString PartyName;
}

struct X509IssuerAltName {
	X509GeneralNames Name;
}

struct X509SubjectDirectoryAttributes {
	AsnBerInfo SequenceOfHeader;
	[X509SubjDirAttrsSequenceEnd = Offset+LengthValue]
	while Attrs[Offset<X509SubjDirAttrsSequenceEnd] {
		X509Attribute Attribute;
	}
}

struct X509BasicConstraints {
	AsnBerInfo SequenceHeader;
	switch {
		case(UINT8(FrameData,Offset) == 0x01):
		struct {
			AsnBerBoolean CA;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 0x02):
		struct {
			AsnBerInteger PathLenConstraint;
		}
	}
}

struct X509NameConstraints {
	AsnBerInfo SequenceHeader;
	switch {
		case(UINT8(FrameData,Offset) == 0x30):
		struct {
			AsnBerInfo Tag0;
			X509GeneralSubTrees PermittedSubTrees;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 0x30):
		struct {
			AsnBerInfo Tag0;
			X509GeneralSubTrees ExcludedSubTrees;
		}
	}
}

struct X509GeneralSubTrees {
	AsnBerInfo SequenceOfHeader = "SubTrees";
	[X509GenSubtrsSequenceEnd = Offset+LengthValue]
	while SubTrees[Offset<X509GenSubtrsSequenceEnd] {
		X509GeneralSubTree SubTree;
	}
}

struct X509GeneralSubTree {
	AsnBerInfo SequenceHeader;
	X509GeneralName Base;
	switch {
		case(UINT8(FrameData,Offset) == 0xa0):
		struct {
			X509BaseDistance Minimum;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 0xa1):
		struct {
			X509BaseDistance Maximum;
		}
	}
}

struct X509BaseDistance = Distance.toString {
	AsnBerInteger Distance;
}

struct X509PolicyConstraints {
	AsnBerInfo SequenceHeader;
	switch {
		case(UINT8(FrameData,Offset) == 0x80):
		struct {
			X509SkipCerts RequireExplicitPolicy;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 0x81):
		struct {
			X509SkipCerts InhibitPolicyMapping;
		}
	}
}

struct X509SkipCerts = Skip.toString {
	AsnBerInteger Skip;
}

struct X509CrlDistributionPoints {
	AsnBerInfo SequenceOfHeader = "Points";
	[X509CrlDstrPntsSequenceEnd = Offset+LengthValue]
	while Points[Offset<X509CrlDstrPntsSequenceEnd] {
		X509DistributionPoint Point;
	}
}

struct X509DistributionPoint {
	AsnBerInfo SequenceHeader;
	switch {
		case(UINT8(FrameData,Offset) == 0xa0):
		struct {
			X509DistributionPointName DistributionPoint;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 0xa1):
		struct {
			X509ReasonFlags Reasons;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 0xa2):
		struct {
			X509GeneralNames CrlIssuer;
		}
	}
}

struct X509DistributionPointName {
	switch (UINT8(FrameData,Offset)) {
		case 0xa0: struct {
			AsnBerInfo Tag0;
			X509GeneralNames FullName;
		}
		case 0xa1: struct {
			AsnBerInfo Tag1;
			X509RelativeDistinguishedName NameRelativeToCrlIssuer;
		}
	}
}

struct X509ReasonFlags = flags {
	AsnBerInfo BitStringHeader;
	switch {
		case LengthValue>2:
			UINT8 Padding[LengthValue-2];
	}
	UINT16 flags {
		UINT16 Unused:1 = FormatString("              (%s)", this.ToBitString);
		UINT16 KeyCompromise:1 = FormatString("       (%s) %s", this.ToBitString,  this ? "KeyCompromise is set" : "");
		UINT16 CACompromise:1 = FormatString("        (%s) %s", this.ToBitString,  this ? "CACompromise is set" : "");
		UINT16 AffiliationChanged:1 = FormatString("  (%s) %s", this.ToBitString,  this ? "AffiliationChanged is set" : "");
		UINT16 Superseded:1 = FormatString("          (%s) %s", this.ToBitString,  this ? "Superseded is set" : "");
		UINT16 CessationOfOperation:1 = FormatString("(%s) %s", this.ToBitString,  this ? "CessationOfOperation is set" : "");
		UINT16 CertificateHold:1 = FormatString("     (%s) %s", this.ToBitString,  this ? "CertificateHold is set" : "");
		UINT16 PrivilegeWithdrawn:1 = FormatString("  (%s) %s", this.ToBitString,  this ? "PrivilegeWithdrawn is set" : "");
		UINT16 AACompromise:1 = FormatString("        (%s) %s", this.ToBitString,  this ? "AACompromise is set" : "");
		UINT16 Unused7:7 = FormatString("             (%s)", this.ToBitString);
	};
}

struct X509ExtKeyUsageSyntax {
	AsnBerInfo SequenceOfHeader = "ExtKeyUsageSyntax";
	[X509EKUSyntaxSequenceEnd = Offset+LengthValue]
	while ExtKeyUsageSyntax[Offset<X509EKUSyntaxSequenceEnd] {
		X509KeyPurposeId Id;
	}
}

struct X509KeyPurposeId = Id.toString {
	AsnBerObjectIdentifier Id;
}

struct X509InhibitAnyPolicy = Iap.toString {
	X509SkipCerts Iap;
}

struct X509FreshestCrl {
	X509CrlDistributionPoints Points;
}

struct X509AuthorityInfoAccessSyntax {
	AsnBerInfo SequenceOfHeader;
	[X509AuthIASyntaxSequenceEnd = Offset+LengthValue]
	while descs[Offset<X509AuthIASyntaxSequenceEnd] {
		X509AccessDescription Description;
	}
}

struct X509AccessDescription {
	AsnBerInfo SequenceHeader;
	AsnBerObjectIdentifier AccessMethod;
	X509GeneralName AccessLocation;
}

struct X509SubjectInfoAccessSyntax {
	AsnBerInfo SequenceOfHeader;
	[X509SubjIASyntaxSequenceEnd = Offset+LengthValue]
	while AccessDescription[Offset<X509SubjIASyntaxSequenceEnd] {
		X509AccessDescription Description;
	}
}

struct X509CrlNumber = Number.toString {
	AsnBerInteger Number;
}

struct X509IssuingDistributionPoint {
	AsnBerInfo SequenceHeader;
	switch {
		case(UINT8(FrameData,Offset) == 0xa0):
		struct {
			X509DistributionPointName DistributionPoint;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 0xa1):
		struct {
			AsnBerBoolean OnlyContainsUserCerts;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 0xa2):
		struct {
			AsnBerBoolean OnlyContainsCACerts;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 0xa3):
		struct {
			X509ReasonFlags OnlySomeReasons;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 0xa4):
		struct {
			AsnBerBoolean InDirectCrl;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 0xa5):
		struct {
			AsnBerBoolean OnlyContainsAttributeCerts;
		}
	}
}

struct X509BaseCrlNumber = Number.toString {
	X509CrlNumber Number;
}

Table X509CrlReasonTable(Reason) {
	switch(Reason) {
		case 0: "Unspecified (0)";
		case 1: "KeyCompromise (1)";
		case 2: "CACompromise (2)";
		case 3: "AffiliationChanged (3)";
		case 4: "Superseded (4)";
		case 5: "CessationOfOperation (5)";
		case 6: "CertificateHold (6)";
		case 8: "RemoveFromCrl (8)";
		case 9: "PrivilegeWithdrawn (9)";
		case 10: "AACompromise (10)";
		default: FormatString("Unknown Reason (%d)", Reason);
	}
}

struct X509CrlReason = X509CrlReasonTable(CrlReason) {
	[post.CrlReason = AsnIntValue]
	AsnBerEnumerated Reason;
}

struct X509CertificateIssuer {
	X509GeneralNames Issuer;
}

struct X509HoldInstructionCode = Code.toString {
	AsnBerObjectIdentifier Code;
}

struct X509InValidityDate = Date.toString {
	AsnBerGeneralizedTime Date;
}


/** RFC 3281:  Attribute Certificate Profile */

// implicit tags

[DataTypeByteOrder=BigEndian]
struct X509AttributeCertificate {
	AsnBerInfo SequenceHeader;
	X509AttributeCertificateInfo acinfo;
	X509AlgorithmIdentifier SignatureAlgorithm;
	AsnBerBitString SignatureValue;
}

struct X509AttributeCertificateInfo {
	AsnBerInfo SequenceHeader;
	X509AttCertVersion Version;
	X509Holder holder;
	X509AttCertIssuer Issuer;
	X509AlgorithmIdentifier Signature;
	X509CertificateSerialNumber SerialNumber;
	X509AttCertValidityPeriod AttrCertValidityPeriod;
	AsnBerInfo SequenceOfHeader = "Attributes";
	[X509AttrCrtInfSequenceEnd = Offset+LengthValue]
	while Attributes[Offset<X509AttrCrtInfSequenceEnd] {
		X509Attribute Attribute;
	}
	switch {
		case(UINT8(FrameData,Offset) == 0x03):
		struct {
			X509UniqueIdentifier IssuerUniqueId;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 0x30):
		struct {
			X509Extensions Extensions;
		}
	}
}

struct X509AttCertVersion = X509VersionTable(X509VerNo) {
	[post.X509VerNo = AsnIntValue]
	AsnBerInteger Version = X509VersionTable(AsnIntValue);
}

struct X509Holder {
	AsnBerInfo SequenceHeader;
	switch {
		case(UINT8(FrameData,Offset) == 0xa0):
		struct {
			X509IssuerSerial BaseCertificateId;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 0xa1):
		struct {
			X509GeneralNames EntityName;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 0xa2):
		struct {
			X509ObjectDigestInfo ObjectDigestInfo;
		}
	}
}

Table X509ObjDigInfTable(Type) {
	switch(Type) {
		case 0: "publicKey (0)";
		case 1: "publicKeyCert (1)";
		case 2: "OtherObjectTypes (2)";
		default: FormatString("InValid Digested Object Type (%d)", Type);
	}
}

struct X509ObjectDigestInfo {
	AsnBerInfo SequenceHeader;
	AsnBerInteger DigestedObjectType = X509ObjDigInfTable(AsnIntValue);
	switch {
		case(UINT8(FrameData,Offset) == 0x06):
		struct {
			AsnBerObjectIdentifier OtherObjectTypeId;
		}
	}
	X509AlgorithmIdentifier DigestAlgorithm;
	AsnBerBitString ObjectDigest;
}

struct X509AttCertIssuer {
	switch (UINT8(FrameData,Offset)) {
		case 0xa0: X509V2Form V2Form;
		default: X509GeneralNames V1Form;
	}
}

struct X509V2Form {
	AsnBerInfo SequenceHeader;
	switch {
		case(UINT8(FrameData,Offset) == 0x30):
		struct {
			X509GeneralNames IssuerName;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 0xa0):
		struct {
			X509IssuerSerial BaseCertificateId;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 0xa1):
		struct {
			X509ObjectDigestInfo ObjectDigestInfo;
		}
	}
}

struct X509IssuerSerial {
	AsnBerInfo SequenceHeader;
	X509GeneralNames Issuer;
	X509CertificateSerialNumber Serial;
	switch {
		case(UINT8(FrameData,Offset) == 0x03):
		struct {
			X509UniqueIdentifier IssuerUid;
		}
	}
}

struct X509AttCertValidityPeriod {
	AsnBerInfo SequenceHeader;
	AsnBerGeneralizedTime NotBeforeTime;
	AsnBerGeneralizedTime NotAfterTime;
}

struct X509Targets {
	AsnBerInfo SequenceOfHeader = "Targets";
	[X509TgtsSequenceEnd = Offset+LengthValue]
	while Targets[Offset<X509TgtsSequenceEnd] {
		X509Target Target;
	}
}

struct X509Target {
	switch (UINT8(FrameData,Offset)) {
		case 0xa0: X509GeneralName TargetName;
		case 0xa1: X509GeneralName TargetGroup;
		case 0xa2: X509TargetCert TargetCert;
	}
}

struct X509TargetCert {
	AsnBerInfo SequenceHeader;
	X509IssuerSerial TargetCertificate;
	switch {
		case((UINT8(FrameData,Offset)^0xa0) <= 0x08):
		struct {
			X509GeneralName TargetName;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 0x30):
		struct {
			X509ObjectDigestInfo CertDigestInfo;
		}
	}
}

struct X509IetfAttrSyntax {
	AsnBerInfo SequenceHeader;
	switch {
		case(UINT8(FrameData,Offset) == 0xa0):
		struct {
			X509GeneralNames PolicyAuthority;
		}
	}
	AsnBerInfo SequenceOfHeader = "Values";
	[X509IETFAttrSequenceEnd = Offset+LengthValue]
	while Values[Offset<X509IETFAttrSequenceEnd] {
		switch(UINT8(FrameData,Offset)) {
			case 0x04: AsnBerOctetString Octets;
			case 0x06: AsnBerObjectIdentifier Oid;
			case 0x0c: AsnBerUtf8String string;
		}
	}
}

struct X509SvceAuthInfo {
	AsnBerInfo SequenceHeader;
	X509GeneralName Service;
	X509GeneralName Ident;
	switch {
		case(UINT8(FrameData,Offset) == 0x06):
		struct {
			AsnBerOctetString AuthInfo;
		}
	}
}

struct X509RoleSyntax {
	AsnBerInfo SequenceHeader;
	switch {
		case(UINT8(FrameData,Offset) == 0xa0):
		struct {
			X509GeneralNames RoleAuthority;
		}
	}
	X509GeneralName RoleName;
}

struct X509Clearance {
	AsnBerInfo SequenceHeader;
	AsnBerObjectIdentifier PolicyId;
	switch {
		case(UINT8(FrameData,Offset) == 0xa1):
		struct {
			X509ClassList ClassList;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 0xa2):
		struct {
			AsnBerInfo SetOfHeader = "SecurityCategories";
			[X509ClrncSetEnd = Offset+LengthValue]
			while SecurityCategories[Offset<X509ClrncSetEnd] {
				X509SecurityCategory SecurityCategory;
			}
		}
	}
}

struct X509ClassList {
	AsnBerInfo stringHeader;
	UINT8 ClassList {
		UINT8 Unmarked:1 = FormatString("    (%s) %s", this.ToBitString,  this ? "Security classification: unmarked" : "");
		UINT8 UnClassified:1 = FormatString("(%s) %s", this.ToBitString,  this ? "Security classification: unclassified" : "");
		UINT8 Restricted:1 = FormatString("  (%s) %s", this.ToBitString,  this ? "Security classification: restricted" : "");
		UINT8 Confidential:1 = FormatString("(%s) %s", this.ToBitString,  this ? "Security classification: confidential" : "");
		UINT8 Secret:1 = FormatString("      (%s) %s", this.ToBitString,  this ? "Security classification: secret" : "");
		UINT8 TopSecret:1 = FormatString("   (%s) %s", this.ToBitString,  this ? "Security classification: topsecret" : "");
		UINT8 Unused67:2 = FormatString("    (%s)", this.ToBitString);
	 };
}

struct X509SecurityCategory {
	AsnBerInfo SequenceHeader;
	AsnBerObjectIdentifier Type;
	AsnBerAnyByOid(property.AsnOid) Value;
}

struct X509AAControls {
	AsnBerInfo SequenceHeader;
	switch {
		case(UINT8(FrameData,Offset) == 0x03):
		struct {
			AsnBerInteger PathLenConstraint;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 0xa0):
		struct {
			X509AttrSpec PermittedAttrs;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 0xa1):
		struct {
			X509AttrSpec ExcludedAttrs;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 0x01):
		struct {
			AsnBerBoolean PermitUnSpecified;
		}
	}
}

struct X509AttrSpec {
	AsnBerInfo SequenceOfHeader = "AttrSpec";
	[X509AttrSpcSequenceEnd = Offset+LengthValue]
	while Oids[Offset<X509AttrSpcSequenceEnd] {
		AsnBerObjectIdentifier AttrSpec;
	}
}

/*
//ACClearAttrs(http://www.tools.ietf.org/id/draft-ietf-tls-ac509prof-00.txt)embeded in ContentInfo(pkcs7.npl) but Object Identifiers(ietf-ac) isn't mention in Doc(http://tools.ietf.org/html/draft-ietf-tls-ac509prof-00)
// when we get value of ietf-ac ,then we can hook up this sturct
struct X509ACClearAttrs {
	AsnBerInfo SequenceHeader;
	X509GeneralName AcIssuer;
	AsnBerInteger acSerial;
	AsnBerInfo SequenceOfHeader = "Attrs";
	[X509ACClrAttrSequenceEnd = Offset+LengthValue]
	while Attrs[Offset<X509ACClrAttrSequenceEnd] {
		X509Attribute Attr;
	}
}
*/

struct X509ProxyInfo {
	AsnBerInfo SequenceOfHeader = "Targets";
	[X509PrxInfSequenceEnd = Offset+LengthValue]
	while Targets[Offset<X509PrxInfSequenceEnd] {
		X509Targets Target;
	}
}


/** RFC 2560:  Online Certificate Status Protocol - OCSP */

struct OcspOcspRequest {
	AsnBerInfo SequenceHeader;
	OcspTbsRequest TbsRequest;
	switch {
		case(UINT8(FrameData,Offset) == 0xa0):
		struct {
			AsnBerInfo Tag0;
			OcspSignature OptionalSignature;
		}
	}
}

struct OcspTbsRequest {
	[OCSPVer = OcspVersionTable(0)]
	AsnBerInfo SequenceHeader;
	switch {
		case(UINT8(FrameData,Offset) == 0xa0):
		struct {
			AsnBerInfo Tag0;
			[OCSPVer = Version.ToString]
			OcspVersion Version;
		}
		default:
			Null DefaultVersion = OcspVersionTable(0);
	}
	switch {
		case(UINT8(FrameData,Offset) == 0xa1):
		struct {
			AsnBerInfo Tag1;
			[OCSPRequestorName = RequestorName.ToString]
			X509GeneralName RequestorName;
		}
	}
	AsnBerInfo SequenceofHeader = "RequestList";
	[OcspRequestSequenceEnd = Offset+LengthValue]
	while RequestList[Offset<OcspRequestSequenceEnd] {
		OcspRequest Request;
	}
	switch {
		case(UINT8(FrameData,Offset) == 0xa2):
		struct {
			AsnBerInfo Tag2;
			X509Extensions RequestExtensions;
		}
	}
}

struct OcspSignature {
	AsnBerInfo SequenceHeader;
	X509AlgorithmIdentifier SignatureAlgorithm;
	AsnBerBitString Signature;
	switch {
		case(UINT8(FrameData,Offset) == 0xa0):
		struct {
			AsnBerInfo Tag0;
			AsnBerInfo SequenceOfHeader = "Certs";
			[OcspCertsSequenceEnd = Offset+LengthValue]
			while Certs[Offset<OcspCertsSequenceEnd] {
				X509Certificate Cert;
			}
		}
	}
}

Table OcspVersionTable(Version) {
	switch(Version) {
		case 0: "v1 (0)";
		default: FormatString("Unknown version (%d)", Version);
	}
}

struct OcspVersion {
	AsnBerInteger Version = OcspVersionTable(AsnIntValue);
}

struct OcspRequest {
	AsnBerInfo SequenceHeader;
	OcspCertID ReqCert;
	switch {
		case(UINT8(FrameData,Offset) == 0xa0):
		struct {
			AsnBerInfo Tag0;
			X509Extensions SingleRequestExtensions;
		}
	}
}

struct OcspCertID {
	AsnBerInfo SequenceHeader;
	X509AlgorithmIdentifier HashAlgorithm;
	AsnBerOctetString IssuerNameHash = "Hash of Issuer's DN";
	AsnBerOctetString IssuerKeyHash = "Hash of Issuer's public key";
	X509CertificateSerialNumber SerialNumber;
}

struct OcspResponse = FormatString("%s; %s", ResponseStatus.toString, ResponseBytes.toString) {
	AsnBerInfo SequenceHeader;
	[OCSPRespStatus = ResponseStatus.ToString]
	OcspResponseStatus ResponseStatus;
	switch {
		case(UINT8(FrameData,Offset) == 0xa0):
		struct {
			AsnBerInfo Tag0;
			OcspResponseBytes ResponseBytes;
		}
	}
}

Table OcspResponseStatusTable(Status) {
	switch(Status) {
		case 0: "Response has valid confirmations (0)";
		case 1: "Illegal confirmation request (1)";
		case 2: "Internal error in issuer (2)";
		case 3: "Try again later (3)";
		case 4: "(4) is not used";
		case 5: "Must sign the request (5)";
		case 6: "Request unauthorized (6)";
		default: FormatString("Unknown Response Status (%d)", Status);
	}
}

struct OcspResponseStatus = ResponseStatus.toString {
	AsnBerInteger ResponseStatus = OcspResponseStatusTable(AsnIntValue);
}

struct OcspResponseBytes = Response.toString {
	AsnBerInfo SequenceHeader;
	AsnBerObjectIdentifier ResponseType;
	AsnBerInfo OctetStringHeader;
	AsnBerAnyByOid(property.AsnOid) Response;
}

struct OcspBasicOcspResponse = FormatString("%s; SignatureAlgorithm: %s", TbsResponseData.toString, SignatureAlgorithm.toString) {
	AsnBerInfo SequenceHeader;
	OcspResponseData TbsResponseData;
	X509AlgorithmIdentifier SignatureAlgorithm;
	AsnBerBitString Signature;
	switch {
		case(UINT8(FrameData,Offset) == 0xa0):
		struct {
			AsnBerInfo Tag0;
			AsnBerInfo SequenceOfHeader = "Certs";
			[OcspCertsSequenceEnd = Offset+LengthValue]
			while Certs[Offset<OcspCertsSequenceEnd] {
				X509Certificate Cert;
			}
		}
	}
}

struct OcspResponseData = Property.OcspResponsesSummary {
	[OCSPVer = OcspVersionTable(0)]
	AsnBerInfo SequenceHeader;
	switch {
		case(UINT8(FrameData,Offset) == 0xa0):
		struct {
			AsnBerInfo Tag0;
			[OCSPVer = Version.ToString]
			OcspVersion Version;
		}
		default:
			Null DefaultVersion = OcspVersionTable(0);
	}
	OcspResponderID ResponderID;
	AsnBerGeneralizedTime ProducedAt;
	AsnBerInfo SequenceOfHeader = "Responses";
	[OcspResponsesSequenceEnd = Offset+LengthValue]
	while Reponses[Offset<OcspResponsesSequenceEnd] {
		[OcspResponsesSummary = this.toString]
		OcspSingleResponse Response;
	}
	switch {
		case(UINT8(FrameData,Offset) == 0xa1):
		struct {
			AsnBerInfo Tag1;
			X509Extensions ResponseExtensions;
		}
	}
}
	
struct OcspResponderID = OcspResponderIdValue {
	switch (UINT8(FrameData,Offset)) {
		case 0xa1: struct {
			AsnBerInfo Tag1;
			[OcspResponderIdValue = this.toString]
			X509Name ByName;
		}
		case 0xa2: struct {
			AsnBerInfo Tag2;
			[OcspResponderIdValue = this.toString]
			OcspKeyHash ByKey;
		}
	}
}

struct OcspKeyHash = KeyHash.toString {
	AsnBerOctetString KeyHash = "SHA-1 has of responder's public key";
}

struct OcspSingleResponse = FormatString("Cert Status = %s", CertStatus.toString) {
	AsnBerInfo SequenceHeader;
	OcspCertID CertID;
	OcspCertStatus CertStatus;
	AsnBerGeneralizedTime ThisUpdate;
	switch {
		case(UINT8(FrameData,Offset) == 0xa0):
		struct {
			AsnBerInfo Tag0;
			AsnBerGeneralizedTime NextUpdate;
		}
	}
	switch {
		case(UINT8(FrameData,Offset) == 0xa1):
		struct {
			AsnBerInfo Tag1;
			X509Extensions SingleExtensions;
		}
	}
}

struct OcspCertStatus = Property.OcspCertStatusSummary {
	switch (UINT8(FrameData,Offset)) {
		case 0x80: [OcspCertStatusSummary = this.toString]
			   AsnBerNull Good = "Good";
		case 0xa1: [OcspCertStatusSummary = this.toString]
			   OcspRevokedInfo Revoked = "Revoked";
		case 0xa2: [OcspCertStatusSummary = this.toString]
			   OcspUnknownInfo Unknown = "Unknown";
	}
}

struct OcspRevokedInfo {
	AsnBerInfo SequenceHeader;
	AsnBerGeneralizedTime RevocationTime;
	switch {
		case(UINT8(FrameData,Offset) == 0xa0):
		struct {
			AsnBerInfo Tag0;
			X509CrlReason RevocationReason;
		}
	}
}

struct OcspUnknownInfo {
	AsnBerNull UnknownInfo;
}

struct OcspArchiveCutoff {
	AsnBerGeneralizedTime ArchiveCutoff;
}

struct OcspAcceptableResponses {
	AsnBerInfo SequenceOfHeader = "AcceptableResponses";
	[OcspAcceptableResponsesSequenceEnd = Offset+LengthValue]
	while AcceptableResponses[Offset<OcspAcceptableResponsesSequenceEnd] {
		AsnBerObjectIdentifier AcceptableResponse;
	}
}

struct OcspServiceLocator {
	AsnBerInfo SequenceHeader;
	X509Name Issuer;
	X509AuthorityInfoAccessSyntax Locator;
}

struct OcspCrlId {
	AsnBerInfo SequenceHeader;
	switch {
		case (UINT8(FrameData,Offset) == 0xa0): struct {
			AsnBerInfo Tag0;
			AsnBerIa5String CrlUrl;
		}
	}
	switch {
		case (UINT8(FrameData,Offset) == 0xa1): struct {
			AsnBerInfo Tag1;
			AsnBerInteger CrlNum;
		}
	}
	switch {
		case (UINT8(FrameData,Offset) == 0xa2): struct {
			AsnBerInfo Tag2;
			AsnBerGeneralizedTime CrlTime;
		}
	}
}
