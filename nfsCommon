//#  (c) 2009 CodePlex Foundation
//#
//#  Title:                  Network File System Protocol
//#
//#  Details:                
//#
//#  Public References:      RFC 1094, 1813, 3530
//#
//#  Comments:               
//#
//#  Revision Class and Date:Minor, 2/4/2010
//#
//####

Protocol NFS = FormatString("%s %s %s%s",
							NFSCallTable(conversation.ProgramVersion,conversation.ProcedureNumber),
							SunRPCMsgTypeTable(Property.SunRPCMessageType),
							Property.NFSReturnStatusExist ? ", Status = " + NFSReturnStatusTable(conversation.ProgramVersion,Property.NFSReturnStatus) : "",
							Property.NFSFileModeExist ? ", FileMode = " + NFSFileModeTable(Property.NFSFileMode) + ", UID = " + FormatString("%d",Property.NFSUID) + ", GID = " + FormatString("%d", Property.NFSGID) : ""
							)
{
	switch( conversation.ProgramVersion )
	{
		case  2:
			switch( Property.SunRPCMessageType )
			{
				case  0:
					switch( conversation.ProcedureNumber )
					{
						case  1:
						case  5:
						case 17:NFSV2FileHandle Object;
						case  2:NFSV2SetFileAttributes SetAttributesCall;
						case  4:NFSV2LookUp LookupCall;
						case  6:NFSV2Read ReadCall;
						case  8:NFSV2Write WriteCall;
						case  9:NFSV2Create CreateCall;
						case 10:NFSV2Remove RemoveCall;
						case 11:NFSV2Rename RenameCall;
						case 12:NFSV2Link LinkCall;
						case 13:NFSV2SymLink SymLinkCall;
						case 14:NFSV2MakeDirectory MkDirCall;
						case 15:NFSV2RemoveDirectory RmDirCall;
						case 16:NFSV2ReadFromDirectory ReadDirCall;
					};
					
				case  1:
					switch
					{
						case Property.SunRPCReplyStatus == 0 && UINT32(FrameData,offset) == 0  :
							switch( conversation.ProcedureNumber )
							{
								case  1:
								case  2:
								case  8:
									_struct FileAttributesReply
									{
										[NFSReturnStatusExist = 1, NFSReturnStatus]
										UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(2,this), this, this);
										NFSV2FileAttributes Attributes;
									};
								case  4:
								case  9:
								case 14:
									_struct FileHandleAttrReply
									{
										[NFSReturnStatusExist = 1, NFSReturnStatus]
										UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(2,this), this, this);
										NFSV2FileHandle File;
										NFSV2FileAttributes Attributes;
									};
								case  5:
									_struct ReadSymbolicLinkReply
									{
										[NFSReturnStatusExist = 1, NFSReturnStatus]
										UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(2,this), this, this);
										RPCFileName PathName;
									};
								case  6:
									_struct ReadFileReply
									{
										[NFSReturnStatusExist = 1, NFSReturnStatus]
										UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(2,this), this, this);
										NFSV2FileAttributes Attributes;
										NFSV2Data Data;
									};
								case 13:
									_struct SymLinkReply
									{
										[NFSReturnStatusExist = 1, NFSReturnStatus]
										UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(2,this), this, this);
									}
								case 16:
									_struct ReadDirReply
									{
										[NFSReturnStatusExist = 1, NFSReturnStatus]
										UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(2,this), this, this);
										NFSV2ReadDirectoryReply ReadDirReply;
									};
								case 17:
									_struct GetFilesystemAttrReply
									{
										[NFSReturnStatusExist = 1, NFSReturnStatus]
										UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(2,this), this, this);
										NFSV2StatfsReply StatfsReply;
									};
								default:
									_struct OtherReply
									{
										[NFSReturnStatusExist = 1, NFSReturnStatus]
										UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(2,this), this, this);
									}
							}
						default:
							switch
								{
									case conversation.ProcedureNumber != 0 &&
										 conversation.ProcedureNumber != 3 &&
										 conversation.ProcedureNumber != 7:
											[NFSReturnStatusExist = 1, NFSReturnStatus]
											UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(2,this), this, this);
								}
					};
			}
		case  3:
				switch( Property.SunRPCMessageType )
				{
					case  0:
						switch( conversation.ProcedureNumber )
						{
							case  1:
							case  5:NFSV3FileHandle Object;
							case  2:NFSV3SetFileAttributesCall SetAttributesCall;
							case  3:NFSV3LookUpCall LookUpCall;
							case  4:NFSV3AccessCall AccessCall;
							case  6:NFSV3ReadCall ReadCall;
							case  7:NFSV3WriteCall WriteCall;
							case  8:NFSV3CreateCall CreateCall;
							case  9:NFSV3MKDIRCall MKDIRCall;
							case 10:NFSV3SYMLINKCall SymlinkCall;
							case 11:NFSV3MKNODCall MKNODCall;
							case 12:NFSV3RemoveCall RemoveCall;
							case 13:NFSV3RMDIRCall RMDIRCall;
							case 14:NFSV3RenameCall RenameCall;
							case 15:NFSV3LinkCall LinkCall;
							case 16:NFSV3READDIRCall READDIRCall;
							case 17:NFSV3READDIRPLUSCall READDIRPLUSCall;
							case 18:NFSV3FSSTATCall FSSTATCall;
							case 19:NFSV3FSINFOCall FSINFOCall;
							case 20:NFSV3PATHCONFCall PATHCONFCall;
							case 21:NFSV3CommitCall CommitCall;
						}
					case  1:
						switch
						{
							case conversation.ProcedureNumber ==  1 && UINT32(FrameData,offset) == 0:NFSV3GetFileAttributesReplyOK GetAttributesOK;
							case conversation.ProcedureNumber ==  2: NFSV3SetAttributesReply SetAttrReply;
							case conversation.ProcedureNumber ==  3 && UINT32(FrameData,offset) == 0:NFSV3LookUpReplyOK LookUpOK;
							case conversation.ProcedureNumber ==  3 && !(UINT32(FrameData,offset) == 0):NFSV3LookUpReplyFail LookUpFail;
							case conversation.ProcedureNumber ==  4 && UINT32(FrameData,offset) == 0:NFSV3AccessReplyOK AccessOK;
							case conversation.ProcedureNumber ==  4 && !(UINT32(FrameData,offset) == 0):NFSV3AccessReplyFail AccessFail;
							case conversation.ProcedureNumber ==  5 && UINT32(FrameData,offset) == 0:NFSV3ReadLinkReplyOK ReadLinkOK;
							case conversation.ProcedureNumber ==  5 && !(UINT32(FrameData,offset) == 0):NFSV3ReadLinkReplyFail ReadLinkFail;
							case conversation.ProcedureNumber ==  6 && UINT32(FrameData,offset) == 0:NFSV3ReadReplyOK ReadOK;
							case conversation.ProcedureNumber ==  6 && !(UINT32(FrameData,offset) == 0):NFSV3ReadReplyFail ReadFail;
							case conversation.ProcedureNumber ==  7 && UINT32(FrameData,offset) == 0:NFSV3WriteReplyOK WriteOK;
							case conversation.ProcedureNumber ==  7 && !(UINT32(FrameData,offset) == 0):NFSV3WriteReplyFail WriteFail;
							case conversation.ProcedureNumber ==  8 && UINT32(FrameData,offset) == 0:NFSV3CreateReplyOK CreateOK;
							case conversation.ProcedureNumber ==  8 && !(UINT32(FrameData,offset) == 0):NFSV3CreateReplyFail CreateFail;
							case conversation.ProcedureNumber ==  9 && UINT32(FrameData,offset) == 0:NFSV3MKDIRReplyOK MKDIROK;
							case conversation.ProcedureNumber ==  9 && !(UINT32(FrameData,offset) == 0):NFSV3MKDIRReplyFail MKDIRFail;
							case conversation.ProcedureNumber == 10 && UINT32(FrameData,offset) == 0:NFSV3SYMLINKReplyOK SymlinkOK;
							case conversation.ProcedureNumber == 10 && !(UINT32(FrameData,offset) == 0):NFSV3SYMLINKReplyFail SymlinkFail;
							case conversation.ProcedureNumber == 11 && UINT32(FrameData,offset) == 0:NFSV3MKNODReplyOK MKNODOK;
							case conversation.ProcedureNumber == 11 && !(UINT32(FrameData,offset) == 0):NFSV3MKNODReplyFail MKNODFail;
							case conversation.ProcedureNumber == 12                                 :NFSV3RemoveReply RemoveReply;
							case conversation.ProcedureNumber == 13                                 :NFSV3RMDIRReply RMDIRReply;
							case conversation.ProcedureNumber == 14                                 :NFSV3RenameReply RenameReply;
							case conversation.ProcedureNumber == 15                                 :NFSV3LinkReply LinkReply;
							case conversation.ProcedureNumber == 16 && UINT32(FrameData,offset) == 0:NFSV3READDIRReplyOK READDIROK;
							case conversation.ProcedureNumber == 16 && !(UINT32(FrameData,offset) == 0):NFSV3READDIRReplyFail READDIRFail;
							case conversation.ProcedureNumber == 17 && UINT32(FrameData,offset) == 0:NFSV3READDIRPLUSReplyOK READDIRPLUSOK;
							case conversation.ProcedureNumber == 17 && !(UINT32(FrameData,offset) == 0):NFSV3READDIRPLUSReplyFail READDIRPLUSFail;
							case conversation.ProcedureNumber == 18 && UINT32(FrameData,offset) == 0:NFSV3FSSTATReplyOK FSSTATOK;
							case conversation.ProcedureNumber == 18 && !(UINT32(FrameData,offset) == 0):NFSV3FSSTATReplyFail FSSTATFail;
							case conversation.ProcedureNumber == 19 && UINT32(FrameData,offset) == 0:NFSV3FSINFOReplyOK FSINFOCall;
							case conversation.ProcedureNumber == 19 && !(UINT32(FrameData,offset) == 0):NFSV3FSINFOReplyFail FSINFOFail;
							case conversation.ProcedureNumber == 20 && UINT32(FrameData,offset) == 0:NFSV3PATHCONFReplyOK PATHCONFOK;
							case conversation.ProcedureNumber == 20 && !(UINT32(FrameData,offset) == 0):NFSV3PATHCONFReplyFail PATHCONFFail;
							case conversation.ProcedureNumber == 21: NFSV3CommitReply CommitReply;
							default                                                                :[NFSReturnStatusExist = 1, NFSReturnStatus]
																									UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(3,this), this, this);
						}
				}
		case  4:
				switch( Property.SunRPCMessageType )
				{
					case  0:
						switch
						{
							case conversation.ProcedureNumber == 1:NFSV4COMPOUNDCall CompoundCall;
						}
					case  1:
						switch
						{
							case conversation.ProcedureNumber == 1:NFSV4COMPOUNDReply CompoundReply;
						}
				}
		default:
			switch
			{
				case FrameLength > FrameOffset:
					_struct UnhandledVersion
					{
						ReportParserError(ParserErrorProtocolClassPublic, "NFS", "NFS Version Error") NFSVersionError;
						BLOB( FrameLength - FrameOffset ) UnknownData;
					}
			}
					
	}
}
UnsignedNumber INT96
{
	Size = 12,
	DisplayFormat = FormatString("0x%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X",
								 this[11],this[10],this[9],this[8],this[7],this[6],this[5],
								 this[4],this[3],this[2],this[1],this[0]);
}
Table NFSV4StableHowTable( value )
{
	switch( value )
	{
		case  0:"UNSTABLE";
		case  1:"DATA_SYNC";
		case  2:"FILE_SYNC";
		default:"Undefined value";
	}
}

Table NFSV4RPCServiceTable( value )
{
	switch( value )
	{
		case  1:"RPC_GSS_SVC_NONE";
		case  2:"RPC_GSS_SVC_INTEGRITY";
		case  3:"RPC_GSS_SVC_PRIVACY";
		default:"Undefined value";
	}
}

Table NFSV4OpenClaimTypeTable( value )
{
	switch( value )
	{
		case  0:"CLAIM_NULL";
		case  1:"CLAIM_PREVIOUS";
		case  2:"CLAIM_DELEGATE_CUR";
		case  3:"CLAIM_DELEGATE_PREV";
		default:"Undefined value";
	}
}

Table NFSV4CreateModeTable( value )
{
	switch( value )
	{
		case  0:"UNCHECKED";
		case  1:"GUARDED";
		case  2:"EXCLUSIVE";
		default:"Undefined value";
	}
}

Table NFSV4ACEMaskTable(Type)
{
	switch
	{
		case (Type & 0x00120081) == 0x00120081:"ACE4_GENERIC_READ";
		case (Type & 0x00160106) == 0x00160106:"ACE4_GENERIC_WRITE";
		case (Type & 0x001200A0) == 0x001200A0:"ACE4_GENERIC_EXECUTE";
		default                             :"";
	}
}

Table NFSV4ACETypeTable(Type)
{
	switch(Type)
	{
		case  0:"ACE4_ACCESS_ALLOWED_ACE_TYPE";
		case  1:"ACE4_ACCESS_DENIED_ACE_TYPE";
		case  2:"ACE4_SYSTEM_AUDIT_ACE_TYPE";
		case  3:"ACE4_SYSTEM_ALARM_ACE_TYPE";
		default:"Undefined value";
	}
}

Table NFSV4OpenDelegationType(Type)
{
	switch(Type)
	{
		case  0:"OPEN_DELEGATE_NONE";
		case  1:"OPEN_DELEGATE_READ";
		case  2:"OPEN_DELEGATE_WRITE";
		default:"Undefined value";
	}
}

Table NFSV4LockTypeTable( value )
{
	switch( value )
	{
		case  1:"Read Lock Type";
		case  2:"Write Lock Type";
		case  3:"Blocking Read Lock Type";
		case  4:"Blocking Write Lock Type";
		default:"Undefined value";
	}
}

Table NFSV4FileTypeTable( value )
{
	switch( value )
	{
		case  1:"Regular File";
		case  2:"Directory";
		case  3:"Special File - block device";
		case  4:"Special File - Character device";
		case  5:"Symbolic Link";
		case  6:"Special File - socket";
		case  7:"Special File - fifo";
		case  8:"Attribute Directory";
		case  9:"Named Attribute";
		default:"Undefined value";
	}
}

Table NFSV4OperationCodeTable( value )
{
	switch( value )
	{
		case     3:"ACCESS - Check Access Rights";
		case     4:"CLOSE - Close File";
		case     5:"COMMIT - Commit Cached Data";
		case     6:"CREATE - Create a Non-Regular File Object";
		case     7:"DELEGPURGE - Purge Delegations Awaiting Recovery";
		case     8:"DELEGRETURN - Return Delegation";
		case     9:"GETATTR - Get Attributes";
		case    10:"GETFH - Get Current Filehandle";
		case    11:"LINK - Create Link to a File";
		case    12:"LOCK - Create Lock";
		case    13:"LOCKT - Test For Lock";
		case    14:"LOCKU - Unlock File";
		case    15:"LOOKUP - Lookup Filename";
		case    16:"LOOKUPP - Lookup Parent Directory";
		case    17:"NVERIFY - Verify Difference in Attributes";
		case    18:"OPEN - Open a Regular File";
		case    19:"OPENATTR - Open Named Attribute Directory";
		case    20:"OPEN_CONFIRM - Confirm Open";
		case    21:"OPEN_DOWNGRADE - Reduce Open File Access";
		case    22:"PUTFH - Set Current Filehandle";
		case    23:"PUTPUBFH - Set Public Filehandle";
		case    24:"PUTROOTFH - Set Root Filehandle";
		case    25:"READ - Read from File";
		case    26:"READDIR - Read Directory";
		case    27:"READLINK - Read Symbolic Link";
		case    28:"REMOVE - Remove Filesystem Object";
		case    29:"RENAME - Rename Directory Entry";
		case    30:"RENEW - Renew a Lease";
		case    31:"RESTOREFH - Restore Saved Filehandle";
		case    32:"SAVEFH - Save Current Filehandle";
		case    33:"SECINFO - Obtain Available Security";
		case    34:"SETATTR - Set Attributes";
		case    35:"SETCLIENTID - Negotiate ClientID";
		case    36:"SETCLIENTID_CONFIRM - Confirm ClientID";
		case    37:"VERIFY - Verify Same Attributes";
		case    38:"WRITE - Write to File";
		case    39:"RELEASE_LOCKOWNER - Release Lockowner State";
		case 10044:"ILLEGAL - Illegal operation";
		default   :"Undefined value";
	}
}

Table NFSV3CreateModeTable( value )
{
	switch( value )
	{
		case  0:"UNCHECKED";
		case  1:"GUARDED";
		case  2:"EXCLUSIVE";
		default:"Undefined value";
	}
}

Table NFSV3StableTable( value )
{
	switch( value )
	{
		case  0:"UNSTABLE";
		case  1:"DATA_SYNC";
		case  2:"FILE_SYNC";
		default:"Undefined value";
	}
}

Table NFSV3TimeHowTable( value )
{
	switch( value )
	{
		case  0:"Don't change";
		case  1:"Set to server time";
		case  2:"Set to client time";
		default:"Undefined value";
	}
}

Table NFSV2FileTypesTable(value)
{
	switch( value )
	{
		case  0:"Non-file";
		case  1:"Regular File";
		case  2:"Directory";
		case  3:"Block-special Device";
		case  4:"Character-special Device";
		case  5:"Symbolic Link";
		default:"Undefined value";
	}
}

Table NFSV3FileTypesTable(value)
{
	switch( value )
	{
		case  1:"Regular File";
		case  2:"Directory";
		case  3:"Block-special Device";
		case  4:"Character-special Device";
		case  5:"Symbolic Link";
		case  6:"Socket";
		case  7:"Named Pipe";
		default:"Undefined value";
	}
}

Table PermFileTypesTable(value)
{
	switch( value )
	{
		case  0:"File Type Unspecified";
		case  1:"Character-special Device";
		case  2:"Directory";
		case  3:"Block-special Device";
		case  4:"Regular File";
		case  5:"Symbolic Link File";
		case  6:"Named Socket";
		default:"Undefined value";
	}
}

Table NFSReturnStatusTable(version,value)
{
	switch
	{
		case version == 2 && value ==     0:"Success";
		case version == 2 && value ==     1:"Not Owner";
		case version == 2 && value ==     2:"No Such File or Directory";
		case version == 2 && value ==     5:"Hard Error";
		case version == 2 && value ==     6:"No Such Device or Address";
		case version == 2 && value ==    13:"Permission Denied";
		case version == 2 && value ==    17:"File Exists";
		case version == 2 && value ==    19:"No Such Device";
		case version == 2 && value ==    20:"Not a Directory";
		case version == 2 && value ==    21:"Is a Directory";
		case version == 2 && value ==    27:"File Too Large";
		case version == 2 && value ==    28:"No Space Left On Device";
		case version == 2 && value ==    30:"Read-Only File System";
		case version == 2 && value ==    63:"Name Too INT32";
		case version == 2 && value ==    66:"Directory Not Empty";
		case version == 2 && value ==    69:"Disk Quota Exceeded";
		case version == 2 && value ==    70:"Invalid FHandle";
		case version == 2 && value ==    99:"Write Cache Flushed To Disk";
		case version == 3 && value ==     0:"OK";
		case version == 3 && value ==     1:"ERR_PERM";
		case version == 3 && value ==     2:"ERR_NOENT";
		case version == 3 && value ==     5:"ERR_IO";
		case version == 3 && value ==     6:"ERR_NX_IO";
		case version == 3 && value ==    13:"ERR_ACCES";
		case version == 3 && value ==    17:"ERR_EXIST";
		case version == 3 && value ==    18:"ERR_XDEV";
		case version == 3 && value ==    19:"ERR_NODEV";
		case version == 3 && value ==    20:"ERR_NOTDIR";
		case version == 3 && value ==    21:"ERR_ISDIR";
		case version == 3 && value ==    22:"ERR_INVAL";
		case version == 3 && value ==    27:"ERR_FBIG";
		case version == 3 && value ==    28:"ERR_NOSPC";
		case version == 3 && value ==    30:"ERR_ROFS";
		case version == 3 && value ==    31:"ERR_MLINK";
		case version == 3 && value ==    63:"ERR_NAMETOOLONG";
		case version == 3 && value ==    66:"ERR_NOTEMPTY";
		case version == 3 && value ==    69:"ERR_DQUOT";
		case version == 3 && value ==    70:"ERR_STALE";
		case version == 3 && value ==    71:"ERR_REMOTE";
		case version == 3 && value == 10001:"ERR_BADHANDLE";
		case version == 3 && value == 10002:"ERR_NOT_SYNC";
		case version == 3 && value == 10003:"ERR_BAD_COOKIE";
		case version == 3 && value == 10004:"ERR_NOTSUPP";
		case version == 3 && value == 10005:"ERR_TOOSMALL";
		case version == 3 && value == 10006:"ERR_SERVERFAULT";
		case version == 3 && value == 10007:"ERR_BADTYPE";
		case version == 3 && value == 10008:"ERR_JUKEBOX";
		case version == 4 && value ==     0:"NFS4_OK(everything is okay)";
		case version == 4 && value ==     1:"NFS4ERR_PERM(caller not privileged)";
		case version == 4 && value ==     2:"NFS4ERR_NOENT(no such file/directory)";
		case version == 4 && value ==     5:"NFS4ERR_IO(hard I/O error)";
		case version == 4 && value ==     6:"NFS4ERR_NXIO(no such device)";
		case version == 4 && value ==    13:"NFS4ERR_ACCESS(access denied)";
		case version == 4 && value ==    17:"NFS4ERR_EXIST(file already exists)";
		case version == 4 && value ==    18:"NFS4ERR_XDEV(different file systems)";
		case version == 4 && value ==    19:"Unused/reserved";
		case version == 4 && value ==    20:"NFS4ERR_NOTDIR(should be a directory)";
		case version == 4 && value ==    21:"NFS4ERR_ISDIR(should not be a directory)";
		case version == 4 && value ==    22:"NFS4ERR_INVAL(invalid argument)";
		case version == 4 && value ==    27:"NFS4ERR_FBIG(file exceeds server max)";
		case version == 4 && value ==    28:"NFS4ERR_NOSPC(no space on filesystem)";
		case version == 4 && value ==    30:"NFS4ERR_ROFS(read-only filesystem)";
		case version == 4 && value ==    31:"NFS4ERR_MLINK(too many hard links)";
		case version == 4 && value ==    63:"NFS4ERR_NAMETOOLONG(name exceeds server max)";
		case version == 4 && value ==    66:"NFS4ERR_NOTEMPTY(directory not empty)";
		case version == 4 && value ==    69:"NFS4ERR_DQUOT(hard quota limit reached)";
		case version == 4 && value ==    70:"NFS4ERR_STALE(file no longer exists)";
		case version == 4 && value == 10001:"NFS4ERR_BADHANDLE(Illegal filehandle)";
		case version == 4 && value == 10003:"NFS4ERR_BAD_COOKIE(READDIR cookie is stale)";
		case version == 4 && value == 10004:"NFS4ERR_NOTSUPP(operation not supported)";
		case version == 4 && value == 10005:"NFS4ERR_TOOSMALL(response limit exceeded)";
		case version == 4 && value == 10006:"NFS4ERR_SERVERFAULT(undefined server error)";
		case version == 4 && value == 10007:"NFS4ERR_BADTYPE(type invalid for CREATE)";
		case version == 4 && value == 10008:"NFS4ERR_DELAY(file 'busy' - retry)";
		case version == 4 && value == 10009:"NFS4ERR_SAME(nverify says attrs same)";
		case version == 4 && value == 10010:"NFS4ERR_DENIED(lock unavaliable)";
		case version == 4 && value == 10011:"NFS4ERR_EXPIRED(lock lease expired)";
		case version == 4 && value == 10012:"NFS4ERR_LOCKED(I/O failed due to lock)";
		case version == 4 && value == 10013:"NFS4ERR_GRACE(in grace period)";
		case version == 4 && value == 10014:"NFS4ERR_FHEXPIRED(filehandle expired)";
		case version == 4 && value == 10015:"NFS4ERR_SHARE_DENIED(share reserve denied)";
		case version == 4 && value == 10016:"NFS4ERR_WRONGSEC(wrong security flavor)";
		case version == 4 && value == 10017:"NFS4ERR_CLID_INUSE(clientid in use)";
		case version == 4 && value == 10018:"NFS4ERR_RESOURCE(resource exhaustion)";
		case version == 4 && value == 10019:"NFS4ERR_MOVED(filesystem relocated)";
		case version == 4 && value == 10020:"NFS4ERR_NOFILEHANDLE(current FH is not set)";
		case version == 4 && value == 10021:"NFS4ERR_MINOR_VERS_MISMATCH(minor vers not supp)";
		case version == 4 && value == 10022:"NFS4ERR_STALE_CLIENTID(server has rebooted)";
		case version == 4 && value == 10023:"NFS4ERR_STALE_STATEID(server has rebooted)";
		case version == 4 && value == 10024:"NFS4ERR_OLD_STATEID(state is out of sync)";
		case version == 4 && value == 10025:"NFS4ERR_BAD_STATEID((incorrect stateid)";
		case version == 4 && value == 10026:"NFS4ERR_BAD_SEQID(request is out of seq)";
		case version == 4 && value == 10027:"NFS4ERR_NOT_SAME(verify - attrs not same)";
		case version == 4 && value == 10028:"NFS4ERR_LOCK_RANGE(lock range not supported)";
		case version == 4 && value == 10029:"NFS4ERR_SYMLINK(should be file/directory)";
		case version == 4 && value == 10030:"NFS4ERR_RESTOREFH(no saved filehandle)";
		case version == 4 && value == 10031:"NFS4ERR_LEASE_MOVED(some filesystem moved)";
		case version == 4 && value == 10032:"NFS4ERR_ATTRNOTSUPP(recommended attr not sup)";
		case version == 4 && value == 10033:"NFS4ERR_NO_GRACE(reclaim outside of grace)";
		case version == 4 && value == 10034:"NFS4ERR_RECLAIM_BAD(reclaim error at server)";
		case version == 4 && value == 10035:"NFS4ERR_RECLAIM_CONFLICT(conflict on reclaim)";
		case version == 4 && value == 10036:"NFS4ERR_BADXDR(XDR decode failed)";
		case version == 4 && value == 10037:"NFS4ERR_LOCKS_HELD(file locks held at CLOSE)";
		case version == 4 && value == 10038:"NFS4ERR_OPENMODE(conflict in OPEN and I/O)";
		case version == 4 && value == 10039:"NFS4ERR_BADOWNER(owner translation bad)";
		case version == 4 && value == 10040:"NFS4ERR_BADCHAR(utf-8 char not supported)";
		case version == 4 && value == 10041:"NFS4ERR_BADNAME(name not supported)";
		case version == 4 && value == 10042:"NFS4ERR_BAD_RANGE(lock range not supported)";
		case version == 4 && value == 10043:"NFS4ERR_LOCK_NOTSUPP(no atomic up/downgrade)";
		case version == 4 && value == 10044:"NFS4ERR_OP_ILLEGAL(undefined operation)";
		case version == 4 && value == 10045:"NFS4ERR_DEADLOCK(file locking deadlock)";
		case version == 4 && value == 10046:"NFS4ERR_FILE_OPEN(open file blocks op.)";
		case version == 4 && value == 10047:"NFS4ERR_ADMIN_REVOKED(lockowner state revoked)";
		case version == 4 && value == 10048:"NFS4ERR_CB_PATH_DOWN(callback path down)";
		default                            :FormatString("%d",value);
	}
}

Table NFSFileModeTable(mode)
{
	switch
	{
		default: FormatString("-%c%c%c%c%c%c%c%c%c",
							 mode & 0x100 ? "r" : "-",
							 mode & 0x080 ? "w" : "-",
							 mode & 0x040 ? "x" : "-",
							 mode & 0x020 ? "r" : "-",
							 mode & 0x010 ? "w" : "-",
							 mode & 0x008 ? "x" : "-",
							 mode & 0x004 ? "r" : "-",
							 mode & 0x002 ? "w" : "-",
							 mode & 0x001 ? "x" : "-"
							 );
	}
}

//# Calendar for leap year
Table LeapYearCalendarTable(year, day)
{
	switch
	{
		case  day <  31:FormatString("%d-Jan-%d", day + 1, year);
		case  day <  60:FormatString("%d-Feb-%d", day - 31 + 1, year);
		case  day <  91:FormatString("%d-Mar-%d", day - 60 + 1, year);
		case  day < 121:FormatString("%d-Apr-%d", day - 91 + 1, year);
		case  day < 152:FormatString("%d-May-%d", day - 121 + 1, year);
		case  day < 182:FormatString("%d-Jun-%d", day - 152 + 1, year);
		case  day < 213:FormatString("%d-Jul-%d", day - 182 + 1, year);
		case  day < 244:FormatString("%d-Aug-%d", day - 213 + 1, year);
		case  day < 274:FormatString("%d-Sep-%d", day - 244 + 1, year);
		case  day < 305:FormatString("%d-Oct-%d", day - 274 + 1, year);
		case  day < 335:FormatString("%d-Nov-%d", day - 305 + 1, year);
		case  day < 366:FormatString("%d-Dec-%d", day - 335 + 1, year);
	}
}

//# Calendar for normal year
Table NormalYearCalendarTable(year, day)
{
	switch
	{
		case  day <  31:FormatString("%d-Jan-%d", day + 1, year);
		case  day <  59:FormatString("%d-Feb-%d", day - 31 + 1, year);
		case  day <  90:FormatString("%d-Mar-%d", day - 60 + 1, year);
		case  day < 120:FormatString("%d-Apr-%d", day - 90 + 1, year);
		case  day < 151:FormatString("%d-May-%d", day - 120 + 1, year);
		case  day < 181:FormatString("%d-Jun-%d", day - 151 + 1, year);
		case  day < 212:FormatString("%d-Jul-%d", day - 181 + 1, year);
		case  day < 243:FormatString("%d-Aug-%d", day - 212 + 1, year);
		case  day < 273:FormatString("%d-Sep-%d", day - 243 + 1, year);
		case  day < 304:FormatString("%d-Oct-%d", day - 273 + 1, year);
		case  day < 334:FormatString("%d-Nov-%d", day - 304 + 1, year);
		case  day < 365:FormatString("%d-Dec-%d", day - 334 + 1, year);
	}
}

Table CalendarTable(year, day)
{
	switch
	{
		case year%100 == 0 && year%400 > 0:NormalYearCalendarTable(year, day);
		case year%4 == 0                  :LeapYearCalendarTable(year, day);
		default                           :NormalYearCalendarTable(year, day);
	}
}

//# 1970 - 1968 - 1 = 1
//# 1970 - 1900 - 1 = 69
//# 1970 - 1600 - 1 = 369
Table DayFrom1970Table(day)
{
	switch
	{
		case (day/365 + 1)/4 - (day/365 + 69)/100 +
			 (day/365 + 369)/400 > day%365:
				CalendarTable(1970 + day/365 -1, 365 + day%365 -
				(day/365 + 1)/4 + (day/365 + 69)/100 - (day/365 + 369)/400);
		default :
			CalendarTable(1970 + day/365, day%365 - (day/365 + 1)/4 + (day/365 + 69)/100 - (day/365 + 369)/400);
	}
}

//# hh:mm:ss
Table TimeTable(seconds)
{
	switch
	{
		default: FormatString("%02d:%02d:%02d", seconds/(60*60),
							 (seconds%(60*60))/60, (seconds%(60*60))%60);
	}
}

Table NFSTimeTable(seconds)
{
	switch
	{
		default:
			"Greenwich Mean Time: " + DayFrom1970Table(seconds/(60*60*24)) +
			" " + TimeTable(seconds%(60*60*24));
	}
}
Table NFSV4ShareAccessTable(value)
{
	switch(value)
	{
		case  1:"OPEN4_SHARE_ACCESS_READ";
		case  2:"OPEN4_SHARE_ACCESS_WRITE";
		case  3:"OPEN4_SHARE_ACCESS_BOTH";
		default:"Unknown";
	}
}
Table NFSV4ShareDenyTable(value)
{
	switch(value)
	{
		case  0:"OPEN4_SHARE_DENY_NONE";
		case  1:"OPEN4_SHARE_DENY_READ";
		case  2:"OPEN4_SHARE_DENY_WRITE";
		case  3:"OPEN4_SHARE_DENY_BOTH ";
		default:"Unknown";
	}
}
struct NFSV2Time = FormatString("%s.%08d", NFSTimeTable(Seconds), MicroSeconds)
{
	UINT32 Seconds;
	UINT32 MicroSeconds;
}

struct NFSV3Time = FormatString("%s.%08d",NFSTimeTable(Seconds), NanoSeconds)
{
	UINT32 Seconds;
	UINT32 NanoSeconds;
}

struct NFSV4Time = FormatString("%s.%08d",NFSTimeTable(Seconds),NanoSeconds)
{
	INT64 Seconds;
	UINT32 NanoSeconds;
}

struct NFSV3SpecData = FormatString("%u,%u",SpecData1,SpecData2)
{
	UINT32 SpecData1;
	UINT32 SpecData2;
}

struct NFSV4SpecData = FormatString("%u,%u",SpecData1,SpecData2)
{
	UINT32 SpecData1;
	UINT32 SpecData2;
}

struct NFSV3Guard = Check.ToString
{
	UINT32 Check = this ? ( this == 1 ? "Value Follows":""):"No Value";
	switch
	{
		case Check == 1:NFSV3Time ObjectCreateTime;
		default: 
			switch
			{
				case FrameLength > FrameOffset:
					_struct UnhandledValue
					{
						ReportParserError(ParserErrorProtocolClassPublic, "NFS", "NFSV3Guard Value Error") NFSV3GuardValueError;
						BLOB( FrameLength - FrameOffset ) UnknownData;
					}
			}
	}
}

//reference rfc1094,page 17
struct NFSV2SetAttribute
{
	[NFSFileModeExist = 1, NFSFileMode]
	UINT32 FileMode = this == 0xFFFFFFFF ? "No Value" : FormatString("0x%08X", this)
	{
		switch
		{
			case !(UINT32(frameData, offset) == 0xFFFFFFFF):
				struct FileModeMask
				{
					UINT32 Reserved1:16    = FormatString("    (%s)",this.toBitString);
					UINT32 PermFileTypes:3 = FormatString("(%s) %s",this.ToBitString,PermFileTypesTable(this));
					UINT32 Reserved2:1     = FormatString("    (%s)",this.toBitString);
					UINT32 SetUID:1        = FormatString("       (%s) %s",this.ToBitString,this 	? "Set User ID On Execution"
													: "Do Not Set User ID On Execution");
					UINT32 SetGID:1        = FormatString("       (%s) %s",this.ToBitString,this 	? "Set Group ID on Execution"
													: "Do Not Set Group ID on Execution" );
					UINT32 SaveText:1      = FormatString("     (%s) %s",this.ToBitString,this 	? "Save Program Image After Execution Completes"
													: "Do Not Save Program Image After Execution Completes" );
					UINT32 OwnerRead:1     = FormatString("    (%s) %s",this.ToBitString,this 	? "Owner Has Read Privileges"
													: "Owner Denied Read Access");
					UINT32 OwnerWrite:1    = FormatString("   (%s) %s",this.ToBitString,this 	? "Owner Has Write Privileges"
													: "Owner Denied Write Access" );
					UINT32 OwnerExecute:1  = FormatString(" (%s) %s",this.ToBitString,this 	? "Owner Has Execute/Search Privileges"
													: "Owner Denied Execute Access");
					UINT32 GroupRead:1     = FormatString("    (%s) %s",this.ToBitString,this 	? "Group Has Read Privileges"
													: "Group Denied Read Access" );
					UINT32 GroupWrite:1    = FormatString("   (%s) %s",this.ToBitString,this 	? "Group Has Write Privileges"
													: "Group Denied Write Access" );
					UINT32 GroupExecute:1  = FormatString(" (%s) %s",this.ToBitString,this 	? "Group Has Execute/Search Privileges"
													: "Group Denied Execute/Search Access");
					UINT32 OthersRead:1    = FormatString("   (%s) %s",this.ToBitString,this 	? "All Others Have Read Privileges"
													: "All Others Denied Read Access" );
					UINT32 OthersWrite:1   = FormatString("  (%s) %s",this.ToBitString,this	? "All Others Have Write Privileges "
													: "All Others Denied Write Access " );
					UINT32 OthersExecute:1 = FormatString("(%s) %s",this.ToBitString,this    ? "All Others Have Execute/Search Privileges "
													: "All Others Denied Execute/Search Access " );
				};
		};
	};

	[NFSUID]
	UINT32 OwnerUID = this == 0xFFFFFFFF ? "No Value" : FormatString("%u",this);
	[NFSGID]
	UINT32 OwnerGID = this == 0xFFFFFFFF ? "No Value" : FormatString("%u",this);
	UINT32 FileSize = this == 0xFFFFFFFF ? "No Value" : FormatString("%u",this);
	switch
	{
		case UINT32(FrameData,offset) == 0xFFFFFFFF:struct NoValueAccessTime { INT64 AccessTime = "No Value"; };
		default                                    :NFSV2Time AccessTime;
	}
	switch
	{
		case UINT32(FrameData,offset) == 0xFFFFFFFF:struct NoValueModifyTime { INT64 ModifyTime = "No Value"; };
		default                                    :NFSV2Time ModifyTime;
	}
}

struct NFSV3SetAttribute
{
	struct FileMode = SetIt.ToString
	{
		UINT32 SetIt = this == 1 ? "Value Follows": ( this == 0 ? "No Value":"");
		switch
		{
			case SetIt == 1:
				[NFSFileModeExist = 1, NFSFileMode]
				UINT32 FileMode
				{
					UINT32 Reserved:20     = FormatString("     (%s)",this.toBitString);
					UINT32 SetUID:1        = FormatString("       (%s) %s",this.ToBitString,this 	? "Set User ID On Execution"
													: "Do Not Set User ID On Execution" );
					UINT32 SetGID:1        = FormatString("       (%s) %s",this.ToBitString,this 	? "Set Group ID on Execution"
													: "Do Not Set Group ID on Execution" );
					UINT32 SaveText:1      = FormatString("     (%s) %s",this.ToBitString,this 	? "Save Program Image After Execution Completes"
													: "Do Not Save Program Image After Execution Completes");
					UINT32 OwnerRead:1     = FormatString("    (%s) %s",this.ToBitString,this 	? "Owner Has Read Privileges"
													: "Owner Denied Read Access" );
					UINT32 OwnerWrite:1    = FormatString("   (%s) %s",this.ToBitString,this 	? "Owner Has Write Privileges" 
													: "Owner Denied Write Access");
					UINT32 OwnerExecute:1  = FormatString(" (%s) %s",this.ToBitString,this 	? "Owner Has Execute/Search Privileges"
													: "Owner Denied Execute Access");
					UINT32 GroupRead:1     = FormatString("    (%s) %s",this.ToBitString,this 	? "Group Has Read Privileges" 
													: "Group Denied Read Access");
					UINT32 GroupWrite:1    = FormatString("   (%s) %s",this.ToBitString,this 	? "Group Has Write Privileges"
													: "Group Denied Write Access");
					UINT32 GroupExecute:1  = FormatString(" (%s) %s",this.ToBitString,this 	? "Group Has Execute/Search Privileges"
													: "Group Denied Execute/Search Access");
					UINT32 OthersRead:1    = FormatString("   (%s) %s",this.ToBitString,this 	? "All Others Have Read Privileges"
													: "All Others Denied Read Access" );
					UINT32 OthersWrite:1   = FormatString("  (%s) %s",this.ToBitString,this 	? "All Others Have Write Privileges "
													: "All Others Denied Write Access ");
					UINT32 OthersExecute:1 = FormatString("(%s) %s",this.ToBitString,this 	? "All Others Have Execute/Search Privileges " 
													: "All Others Denied Execute/Search Access ");
				};
		}
	};
	struct UID = SetIt.ToString
	{
		UINT32 SetIt = this == 1 ? "Value Follows": ( this == 0 ? "No Value":"");
		switch
		{
			case SetIt == 1:UINT32 UID;
		}
	};

	struct GID = SetIt.ToString
	{
		UINT32 SetIt = this == 1 ? "Value Follows": ( this == 0 ? "No Value":"");
		switch
		{
			case SetIt == 1:UINT32 GID;
		}
	};

	struct Size = SetIt.ToString
	{
		UINT32 SetIt = this == 1 ? "Value Follows": ( this == 0 ? "No Value":"");
		switch
		{
			case SetIt == 1:INT64 Size;
		}
	};

	struct AccessTime = SetIt.ToString
	{
		UINT32 SetIt = FormatString("%s,%d(0x%X)",NFSV3TimeHowTable(this),this,this);
		switch
		{
			case SetIt == 2:NFSV3Time AccessTime;
		}
	};

	struct ModifyTime = SetIt.ToString
	{
		UINT32 SetIt = FormatString("%s,%d(0x%X)",NFSV3TimeHowTable(this),this,this);
		switch
		{
			case SetIt == 2:NFSV3Time ModifyTime;
		}
	};
}

struct NFSV2FileHandle
{
	switch
	{
		case UINT16(FrameData,offset + 4) == 0 &&
			 UINT16(FrameData,offset + 8) +
				UINT16(FrameData,offset +
				UINT16(FrameData,offset +
				8) + 10) == 20 :
					struct FileHandle
						{
						UINT32 FileSystemID = FormatString("%d,%d",Major,Minor)
						{
							UINT32 Major:14 = FormatString("(%s) %d",this.ToBitString,this);
							UINT32 Minor:18 = FormatString("(%s) %d",this.ToBitString,this);
						};
						UINT32 FileSystemType;
						struct FileNumber = Inode
						{
							UINT16 Length;
							UINT16 Reserved;
							UINT32 Inode;
							UINT32 Generation;
						};
						struct ExportedFileNumber = Inode
						{
							UINT16 Length;
							UINT16 Reserved;
							UINT32 Inode;
							UINT32 Generation;
						};
					};
		default                :
			BLOB(32) FileHandleData = formatString("%X", this);
		}
}
struct NFSV3DirOpArgs
{
	NFSV3FileHandle Directory;
	RPCFileName Name;
}

struct NFSV3FileHandle
{
	UINT32 Length;
	switch
	{
		case UINT16(FrameData,offset + 4) == 0 &&
			 UINT16(FrameData,offset + 8) + UINT16(FrameData, offset + UINT16(FrameData,offset + 8) + 10) == 20 :
					struct FileHandle
					{
						UINT32 FileSystemID = FormatString("%d,%d",Major,Minor)
						{
							UINT32 Major:14 = FormatString("(%s) %d",this.ToBitString,this);
							UINT32 Minor:18 = FormatString("(%s) %d",this.ToBitString,this);
						};
						UINT32 FileSystemType;
						
						struct FileNumber = Inode
						{
							UINT16 Length;
							UINT16 Reserved;
							UINT32 Inode;
							UINT32 Generation;
						};
						
						struct ExportedFileNumber = Inode
						{
							UINT16 Length;
							UINT16 Reserved;
							UINT32 Inode;
							UINT32 Generation;
						};
					};
		default :
			BLOB(Length) FileHandleData = FormatString("%X",this);
	}
	switch
	{
		case Length%4:
			BLOB(4 - Length%4) Padding = FormatString("%d bytes",(4-Length%4));
	}
}


struct NFSV4FileHandle
{
	UINT32 Length;
	switch
	{
		case UINT16(FrameData,offset + 4) == 0 &&
			 UINT16(FrameData,offset + 8) +
				UINT16(FrameData,offset +
				UINT16(FrameData,offset + 8) +
				10) == 20  :
					struct FileHandle
					{
						UINT32 FileSystemID = FormatString("%d,%d",Major,Minor)
						{
							UINT32 Major:14 = FormatString("(%s) %d",this.ToBitString,this);
							UINT32 Minor:18 = FormatString("(%s) %d",this.ToBitString,this);
						};
						UINT32 FileSystemType;
						
						struct FileNumber = Inode
						{
							UINT16 Length;
							UINT16 Reserved;
							UINT32 Inode;
							UINT32 Generation;
						};
						
						struct ExportedFileNumber = Inode
						{
							UINT16 Length;
							UINT16 Reserved;
							UINT32 Inode;
							UINT32 Generation;
						};
					};
		default :
			BLOB(Length) FileHandleData = FormatString("%X",this);
	}
	switch
	{
		case Length%4:
			BLOB(4 - Length%4) Padding = FormatString("%d bytes",(4-Length%4));
	}
}

struct RPCFileName = FName
{
	UINT32 NameLength;
	switch
	{
		case NameLength:
			AsciiString(NameLength > 255 ? 255:NameLength) FName;
	}
	switch
	{
		case NameLength % 4 != 0:
			BLOB(4 - NameLength%4) FillBytes = "opaque data";
	}
}

//reference rfc1094,page 18
struct NFSV2LookUp
{
	NFSV2FileHandle Directory;
	RPCFileName Name;
}

struct NFSV2RemoveDirectory
{
	NFSV2FileHandle Directory;
	RPCFileName Name;
}

struct NFSV2StatfsReply
{
	UINT32 TransferSize;
	UINT32 BlockSize;
	UINT32 BlockNumber;
	UINT32 FreeBlocks;
	UINT32 AvailableBlocks;
}

//reference rfc1094,page 11
struct NFSV2ReadFromDirectory
{
	NFSV2FileHandle Directory;
	UINT32 Cookie;
	UINT32 DirectoryCount;
}

//reference rfc1094,page 10
struct NFSV2MakeDirectory
{
	NFSV3DirOpArgs Where;
	NFSV2SetAttribute Attributes;
}

//reference rfc1094,page 10
struct NFSV2SymLink
{
	NFSV2DirOpArgs From;
	RPCFileName To;
	NFSV2SetAttribute Attributes;
}

//reference rfc1094,page 9
struct NFSV2Link
{
	NFSV2FileHandle From;
	NFSV2DirOpArgs To;
}

//reference rfc1094,page 9
struct NFSV2Rename
{
	NFSV2DirOpArgs From;
	NFSV2DirOpArgs To;
}

struct NFSV2Remove
{
	NFSV2FileHandle Directory;
	RPCFileName Name;
}

struct NFSV2DirOpArgs
{
	NFSV2FileHandle Directory;
	RPCFileName Name;
}
//reference rfc1094,page 8
struct NFSV2Create
{
	NFSV2DirOpArgs Where;
	NFSV2SetAttribute Attributes;
}
struct NFSV2Data
{
	UINT32 ByteCount;
	Blob(ByteCount) NFSData;
	switch
	{
		case ByteCount%4 != 0:
			BLOB(4 - ByteCount%4) FillBytes = "opaque data";
	}
}

struct NFSV2Write
{
	NFSV2FileHandle File;
	UINT32 BeginOffset;
	UINT32 Offset;
	UINT32 TotalByteCount;
	NFSV2Data Data;
}

//reference rfc1094 ,page 7
struct NFSV2Read
{
	NFSV2FileHandle File;
	UINT32 Offset;
	UINT32 Count;
	UINT32 TotalCount;
}

//reference rfc1094,page 6
struct NFSV2SetFileAttributes
{
	NFSV2FileHandle File;
	NFSV2SetAttribute Attributes;
}

struct NFSV2FileAttributes
{
	UINT32 FileType = FormatString("%s,%d(0x%X)",NFSV2FileTypesTable(this),this,this);
	[NFSFileModeExist = 1, NFSFileMode]
	UINT32 FileMode
	{
		UINT32 Reserved1:16 = FormatString("    (%s)",this.toBitString);
		UINT32 PermFileTypes:3 = FormatString("(%s) %s",this.ToBitString,PermFileTypesTable(this));
		UINT32 Reserved2:1      = FormatString("    (%s)",this.toBitString);
		UINT32 SetUID:1        = FormatString("       (%s) %s",this.ToBitString,this 	? "Set User ID On Execution"
										: "Do Not Set User ID On Execution" );
		UINT32 SetGID:1        = FormatString("       (%s) %s",this.ToBitString,this 	? "Set Group ID on Execution" 
										: "Do Not Set Group ID on Execution" );
		UINT32 SaveText:1      = FormatString("     (%s) %s",this.ToBitString,this 	? "Save Program Image After Execution Completes"
										: "Do Not Save Program Image After Execution Completes" );
		UINT32 OwnerRead:1     = FormatString("    (%s) %s",this.ToBitString,this 	? "Owner Has Read Privileges"
										: "Owner Denied Read Access" );
		UINT32 OwnerWrite:1    = FormatString("   (%s) %s",this.ToBitString,this 	? "Owner Has Write Privileges"
										: "Owner Denied Write Access" );
		UINT32 OwnerExecute:1  = FormatString(" (%s) %s",this.ToBitString,this 	? "Owner Has Execute/Search Privileges" 
										: "Owner Denied Execute Access" );
		UINT32 GroupRead:1     = FormatString("    (%s) %s",this.ToBitString,this 	? "Group Has Read Privileges" 
										: "Group Denied Read Access");
		UINT32 GroupWrite:1    = FormatString("   (%s) %s",this.ToBitString,this 	? "Group Has Write Privileges"
										: "Group Denied Write Access" );
		UINT32 GroupExecute:1  = FormatString(" (%s) %s",this.ToBitString,this 	? "Group Has Execute/Search Privileges"
										: "Group Denied Execute/Search Access" );
		UINT32 OthersRead:1    = FormatString("   (%s) %s",this.ToBitString,this 	? "All Others Have Read Privileges" 
										: "All Others Denied Read Access" );
		UINT32 OthersWrite:1   = FormatString("  (%s) %s",this.ToBitString,this 	? "All Others Have Write Privileges " 
										: "All Others Denied Write Access " );
		UINT32 OthersExecute:1 = FormatString("(%s) %s",this.ToBitString,this 	? "All Others Have Execute/Search Privileges "
										: "All Others Denied Execute/Search Access " );
	};
	UINT32 NumberOfLinks;
	[NFSUID]
	UINT32 OwnerUID;
	[NFSGID]
	UINT32 OwnerGID;
	UINT32 FileSize;
	UINT32 BlockSize;
	UINT32 FileDeviceNumber;
	UINT32 FileBlocks;
	UINT32 FileSystemID;
	UINT32 FileID;
	NFSV2Time AccessTime;
	NFSV2Time ModifyTime;
	NFSV2Time CreateTime;
}
struct NFSV3Path = Content
{
	UINT32 Length;
	AsciiString(Length) Content;
	switch
	{
		case Length % 4 != 0:
			BLOB(4 - Length%4) FillBytes = "opaque data";
	}
}

struct NFSV3FileAttributes
{
	UINT32 FileType = FormatString("%s,%d(0x%X)",NFSV3FileTypesTable(this),this,this);
	[NFSFileModeExist = 1, NFSFileMode]
	UINT32 FileMode
	{
		UINT32 Reserved:20 = FormatString("     (%s)",this.toBitString);
/*
		UINT32 PermFileTypes:3 = PermFileTypesTable(this) + " (" + this.ToBitString+")";
		UINT32 Reserved:1      = " (" + this.ToBitString+")";
*/
		UINT32 SetUID:1        = FormatString("       (%s) %s",this.ToBitString,this 	? "Set User ID On Execution"
										: "Do Not Set User ID On Execution" );
		UINT32 SetGID:1        = FormatString("       (%s) %s",this.ToBitString,this 	? "Set Group ID on Execution" 
										: "Do Not Set Group ID on Execution" );
		UINT32 SaveText:1      = FormatString("     (%s) %s",this.ToBitString,this 	? "Save Program Image After Execution Completes" 
										: "Do Not Save Program Image After Execution Completes" );
		UINT32 OwnerRead:1     = FormatString("    (%s) %s",this.ToBitString,this 	? "Owner Has Read Privileges" 
										: "Owner Denied Read Access" );
		UINT32 OwnerWrite:1    = FormatString("   (%s) %s",this.ToBitString,this 	? "Owner Has Write Privileges" 
										: "Owner Denied Write Access" );
		UINT32 OwnerExecute:1  = FormatString(" (%s) %s",this.ToBitString,this 	? "Owner Has Execute/Search Privileges" 
										: "Owner Denied Execute Access" );
		UINT32 GroupRead:1     = FormatString("    (%s) %s",this.ToBitString,this 	? "Group Has Read Privileges" 
										: "Group Denied Read Access" );
		UINT32 GroupWrite:1    = FormatString("   (%s) %s",this.ToBitString,this 	? "Group Has Write Privileges" 
										: "Group Denied Write Access" );
		UINT32 GroupExecute:1  = FormatString(" (%s) %s",this.ToBitString,this 	? "Group Has Execute/Search Privileges" 
										: "Group Denied Execute/Search Access" );
		UINT32 OthersRead:1    = FormatString("   (%s) %s",this.ToBitString,this 	? "All Others Have Read Privileges" 
										: "All Others Denied Read Access" );
		UINT32 OthersWrite:1   = FormatString("  (%s) %s",this.ToBitString,this 	? "All Others Have Write Privileges "
										: "All Others Denied Write Access " );
		UINT32 OthersExecute:1 = FormatString("(%s) %s",this.ToBitString,this 	? "All Others Have Execute/Search Privileges " 
										: "All Others Denied Execute/Search Access " );
	};
	UINT32 NumberOfLinks;
	[NFSUID]
	UINT32 UID;
	[NFSGID]
	UINT32 GID;
	INT64 Size;
	INT64 Used;
	NFSV3SpecData FileDeviceNumber;
	INT64 FileSystemID;
	INT64 FileID;
	NFSV3Time AccessTime;
	NFSV3Time ModifyTime;
	NFSV3Time CreateTime;
}

struct NFSV2ReadDirectoryReply
{
	while option[ UINT32(FrameData,Offset) == 1]
	{
		UINT32 ValueFollow = this == 1 ? "Yes":"No";
		struct Entry = FormatString("File ID is %d,File Name is %s",FileID,FileName.ToString)
		{
			UINT32 FileID;
			RPCFileName FileName;
			UINT32 Cookie;
		};
	}
	UINT32 ValueFollow = this == 1 ? "Yes"  : "No" ;
	UINT32 ReadEOF;
}
struct NFSV3GetFileAttributesReplyOK = NFSReturnStatusTable(3, ReturnStatus)
{
	[NFSReturnStatusExist = 1, NFSReturnStatus]
	UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(3,this), this, this);
	NFSV3FileAttributes Attributes;
}

struct NFSV3SetFileAttributesCall
{
	NFSV3FileHandle Object;
	NFSV3SetAttribute NewAttributes;
	NFSV3Guard Guard;
}

struct NFSV3PreOpAttr
{
	UINT32 AttributesFollow = this ? ( this == 1 ? "Value Follows":""):"No Value";
	switch
	{
		case AttributesFollow ==  1:
			struct Attributes
			{
				INT64 Size;
				NFSV3Time ModifyTime;
				NFSV3Time CreateTime;
			};
	}
}

struct NFSV3PostOpAttr
{
	UINT32 AttributesFollow = this ? ( this == 1 ? "Value Follows":""):"No Value";
	switch
	{
		case AttributesFollow == 1:NFSV3FileAttributes Attributes;
	}
}

struct NFSV3PostOpFileHanlde
{
	UINT32 AttributesFollow = this ? ( this == 1 ? "Value Follows":""):"No Value";
	switch
	{
		case AttributesFollow == 1:NFSV3FileHandle Handle;
	}
}

struct NFSV3WCCData
{
	NFSV3PreOpAttr Before;
	NFSV3PostOpAttr After;
}

struct NFSV3SetAttributesReply = NFSReturnStatusTable(3, ReturnStatus)
{
	[NFSReturnStatusExist = 1, NFSReturnStatus]
	UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(3,this), this, this);
	NFSV3WCCData ObjectWCC;
}

struct NFSV3LookUpCall
{
	struct What
	{
		NFSV3FileHandle Directory;
		RPCFileName Name;
	};
}
struct NFSV3LookUpReplyOK = NFSReturnStatusTable(3, ReturnStatus)
{
	[NFSReturnStatusExist = 1, NFSReturnStatus]
	UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(3,this), this, this);
	NFSV3FileHandle Object;
	NFSV3PostOpAttr ObjectAttributes;
	NFSV3PostOpAttr DirectoryAttributes;
}

struct NFSV3LookUpReplyFail = NFSReturnStatusTable(3, ReturnStatus)
{
	[NFSReturnStatusExist = 1, NFSReturnStatus]
	UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(3,this), this, this);
	NFSV3PostOpAttr DirectoryAttributes;
}

struct NFSV3AccessCall
{
	NFSV3FileHandle Object;
	UINT32 Access
	{
		UINT32 Reserved:26 = FormatString("(%s)",this.toBitString);
		UINT32 Execute:1 = FormatString(" (%s) %s",this.ToBitString,this ? "Execute Allow"
							 : "Execute not Allow");
		UINT32 Delete:1 = FormatString("  (%s) %s",this.ToBitString,this ? "Delete Allow"
							 : "Delete not Allow");
		UINT32 Extend:1 = FormatString("  (%s) %s",this.ToBitString,this ? "Extend Allow"
							 : "Extend not Allow");
		UINT32 Modify:1 = FormatString("  (%s) %s",this.ToBitString,this ? "Modify Allow"
							 : "Modify not Allow");
		UINT32 Lookup:1 = FormatString("  (%s) %s",this.ToBitString,this ? "Lookup Allow"
							 : "Lookup not Allow");
		UINT32 Read:1 = FormatString("    (%s) %s",this.ToBitString,this ? "Read Allow"
							 : "Read not Allow");
	};
}

struct NFSV3AccessReplyOK = NFSReturnStatusTable(3, ReturnStatus)
{
	[NFSReturnStatusExist = 1, NFSReturnStatus]
	UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(3,this), this, this);
	NFSV3PostOpAttr ObjectAttributes;
	UINT32 Access
	{
		UINT32 Reserved:26 = FormatString("(%s)",this.toBitString);
		UINT32 Execute:1 = FormatString(" (%s) %s",this.ToBitString,this ? "Execute Allow"
							 : "Execute not Allow");
		UINT32 Delete:1 = FormatString("  (%s) %s",this.ToBitString,this ? "Delete Allow"
							 : "Delete not Allow");
		UINT32 Extend:1 = FormatString("  (%s) %s",this.ToBitString,this ? "Extend Allow"
							 : "Extend not Allow");
		UINT32 Modify:1 = FormatString("  (%s) %s",this.ToBitString,this ? "Modify Allow"
							 : "Modify not Allow");
		UINT32 Lookup:1 = FormatString("  (%s) %s",this.ToBitString,this ? "Lookup Allow"
							 : "Lookup not Allow");
		UINT32 Read:1 = FormatString("    (%s) %s",this.ToBitString,this ? "Read Allow"
							 : "Read not Allow");
	};
}

struct NFSV3AccessReplyFail = NFSReturnStatusTable(3, ReturnStatus)
{
	[NFSReturnStatusExist = 1, NFSReturnStatus]
	UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(3,this), this, this);
	NFSV3PostOpAttr ObjectAttributes;
}

struct NFSV3ReadLinkReplyOK = NFSReturnStatusTable(3, ReturnStatus)
{
	[NFSReturnStatusExist = 1, NFSReturnStatus]
	UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(3,this), this, this);
	NFSV3PostOpAttr SymLinkAttributes;
	NFSV3Path Data;
}

struct NFSV3ReadLinkReplyFail = NFSReturnStatusTable(3, ReturnStatus)
{
	[NFSReturnStatusExist = 1, NFSReturnStatus]
	UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(3,this), this, this);
	NFSV3PostOpAttr SymLinkAttributes;
}

struct NFSV3ReadCall
{
	NFSV3FileHandle File;
	INT64  FileOffset;
	UINT32 Count;
}
struct NFSOpaque = Content.ToString
{
	UINT32 Length;
	AsciiString(Length) Content;
	switch
	{
		case Length % 4 != 0:
			BLOB(4 - Length % 4) FillBytes = "opaque data";
	}
}

struct NFSV3ReadReplyOK = NFSReturnStatusTable(3, ReturnStatus)
{
	[NFSReturnStatusExist = 1, NFSReturnStatus]
	UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(3,this), this, this);
	NFSV3PostOpAttr FileAttributes;
	UINT32 Count;
	UINT32 EOF = this ? "TRUE":"FALSE";
	NFSOpaque Data;
}

struct NFSV3ReadReplyFail = NFSReturnStatusTable(3, ReturnStatus)
{
	[NFSReturnStatusExist = 1, NFSReturnStatus]
	UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(3,this), this, this);
	NFSV3PostOpAttr FileAttributes;
}

struct NFSV3WriteCall
{
	NFSV3FileHandle File;
	INT64  FileOffset;
	UINT32 Count;
	UINT32 Stable = FormatString("%s, %d(0x%X)",NFSV3StableTable(this), this, this);
	NFSOpaque Data;
}

struct NFSV3WriteReplyOK = NFSReturnStatusTable(3, ReturnStatus)
{
	[NFSReturnStatusExist = 1, NFSReturnStatus]
	UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(3,this), this, this);
	NFSV3WCCData FileWCC;
	UINT32 Count;
	UINT32 Committed = FormatString("%s, %d(0x%X)",NFSV3StableTable(this), this, this);
	INT64 Verifier = "Opaque Data";
}

struct NFSV3WriteReplyFail = NFSReturnStatusTable(3, ReturnStatus)
{
	[NFSReturnStatusExist = 1, NFSReturnStatus]
	UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(3,this), this, this);
	NFSV3WCCData FileWCC;
}

struct NFSV3CreateCall
{
	NFSV3DirOpArgs Where;
	UINT32 CreateMode = FormatString("%s, %d(0x%X)", NFSV3CreateModeTable(this), this, this);
	switch(CreateMode)
	{
		case 0 :
		case 1 :NFSV3SetAttribute ObjectAttributes;
		case 2 :INT64 Verifier = "Opaque data";
		default:
			switch
			{
				case FrameLength > FrameOffset:
					_struct UnhandledMode
					{
						ReportParserError(ParserErrorProtocolClassPublic, "NFS", "NFSV3CreateCall Mode Error") NFSV3CreateCallModeError;
						BLOB( FrameLength - FrameOffset ) UnknownData;
					}
			}
	}
}

struct NFSV3CreateReplyOK = NFSReturnStatusTable(3, ReturnStatus)
{
	[NFSReturnStatusExist = 1, NFSReturnStatus]
	UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(3,this), this, this);
	NFSV3PostOpFileHanlde Object;
	NFSV3PostOpAttr ObjectAttributes;
	NFSV3WCCData DirectoryWCC;
}

struct NFSV3CreateReplyFail = NFSReturnStatusTable(3, ReturnStatus)
{
	[NFSReturnStatusExist = 1, NFSReturnStatus]
	UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(3,this), this, this);
	NFSV3WCCData DirectoryWCC;
}

struct NFSV3MKDIRCall
{
	NFSV3DirOpArgs Where;
	NFSV3SetAttribute Attributes;
}

struct NFSV3MKDIRReplyOK = NFSReturnStatusTable(3, ReturnStatus)
{
	[NFSReturnStatusExist = 1, NFSReturnStatus]
	UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(3,this), this, this);
	NFSV3PostOpFileHanlde Object;
	NFSV3PostOpAttr ObjectAttributes;
	NFSV3WCCData DirectoryWCC;
}

struct NFSV3MKDIRReplyFail = NFSReturnStatusTable(3, ReturnStatus)
{
	[NFSReturnStatusExist = 1, NFSReturnStatus]
	UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(3,this), this, this);
	NFSV3WCCData DirectoryWCC;
}

struct NFSV3DeviceData
{
	NFSV3SetAttribute Attributes;
	NFSV3SpecData Spec;
}

struct NFSV3SymlinkData
{
	NFSV3SetAttribute SymlinkAttributes;
	NFSV3Path SymlinkData;
}

struct NFSV3SYMLINKCall
{
	NFSV3DirOpArgs Where;
	NFSV3SymlinkData Symlink;
}

struct NFSV3SYMLINKReplyOK = NFSReturnStatusTable(3, ReturnStatus)
{
	[NFSReturnStatusExist = 1, NFSReturnStatus]
	UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(3,this), this, this);
	NFSV3PostOpFileHanlde Object;
	NFSV3PostOpAttr ObjectAttributes;
	NFSV3WCCData DirectoryWCC;
}

struct NFSV3SYMLINKReplyFail = NFSReturnStatusTable(3, ReturnStatus)
{
	[NFSReturnStatusExist = 1, NFSReturnStatus]
	UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(3,this), this, this);
	NFSV3WCCData DirectoryWCC;
}

struct NFSV3MKNODCall
{
	NFSV3DirOpArgs Where;
	UINT32 FileType = NFSV3FileTypesTable(this);
	switch( FileType )
	{
		case 3:
		case 4:NFSV3DeviceData Device;
		case 6:
		case 7:NFSV3SetAttribute PipeAttributes;
		default:
			switch
			{
				case FrameLength > FrameOffset:
					_struct UnhandledType
					{
						ReportParserError(ParserErrorProtocolClassPublic, "NFS", "NFSV3MKNODCall Type Error") NFSV3MKNODCallTypeError;
						BLOB( FrameLength - FrameOffset ) UnknownData;
					}
			}
	}
}

struct NFSV3MKNODReplyOK = NFSReturnStatusTable(3, ReturnStatus)
{
	[NFSReturnStatusExist = 1, NFSReturnStatus]
	UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(3,this), this, this);
	NFSV3PostOpFileHanlde Object;
	NFSV3PostOpAttr ObjectAttributes;
	NFSV3WCCData DirectoryWCC;
}

struct NFSV3MKNODReplyFail = NFSReturnStatusTable(3, ReturnStatus)
{
	[NFSReturnStatusExist = 1, NFSReturnStatus]
	UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(3,this), this, this);
	NFSV3WCCData DirectoryWCC;
}

struct NFSV3RemoveCall
{
	NFSV3DirOpArgs Object;
}

struct NFSV3RemoveReply = NFSReturnStatusTable(3, ReturnStatus)
{
	[NFSReturnStatusExist = 1, NFSReturnStatus]
	UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(3,this), this, this);
	NFSV3WCCData DirectoryWCC;
}

struct NFSV3RMDIRCall
{
	NFSV3DirOpArgs Object;
}

struct NFSV3RMDIRReply = NFSReturnStatusTable(3, ReturnStatus)
{
	[NFSReturnStatusExist = 1, NFSReturnStatus]
	UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(3,this), this, this);
	NFSV3WCCData DirectoryWCC;
}

struct NFSV3RenameCall
{
	NFSV3DirOpArgs From;
	NFSV3DirOpArgs To;
}

struct NFSV3RenameReply = NFSReturnStatusTable(3, ReturnStatus)
{
	[NFSReturnStatusExist = 1, NFSReturnStatus]
	UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(3,this), this, this);
	NFSV3WCCData FromDirWCC;
	NFSV3WCCData ToDirWCC;
}

struct NFSV3LinkCall
{
	NFSV3FileHandle File;
	NFSV3DirOpArgs Link;
}

struct NFSV3LinkReply = NFSReturnStatusTable(3, ReturnStatus)
{
	[NFSReturnStatusExist = 1, NFSReturnStatus]
	UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(3,this), this, this);
	NFSV3PostOpAttr FileAttributes;
	NFSV3WCCData LinkDieWCC;
}

struct NFSV3Entry
{
	INT64 FileID;
	RPCFileName Name;
	INT64 Cookie;
}

struct NFSV3READDIRCall
{
	NFSV3FileHandle Directory;
	INT64  Cookie;
	INT64  CookieVerf = "Opaque data";
	UINT32 Count;
}

struct NFSV3READDIRReplyOK = NFSReturnStatusTable(3, ReturnStatus)
{
	[NFSReturnStatusExist = 1, NFSReturnStatus]
	UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(3,this), this, this);
	NFSV3PostOpAttr DirectoryAttributes;
	INT64 CookieVerf = "Opaque data";
	[ValueFollow]
	UINT32 ValueFollow = this == 1 ? "Yes":"No";
	while Condition[Property.ValueFollow == 1]
	{
		NFSV3Entry Entry;
		[ValueFollow]
		UINT32 ValueFollow = this == 1 ? "Yes":"No";
	}
	UINT32 EOF;
}

struct NFSV3READDIRReplyFail = NFSReturnStatusTable(3, ReturnStatus)
{
	[NFSReturnStatusExist = 1, NFSReturnStatus]
	UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(3,this), this, this);
	NFSV3PostOpAttr DirectoryAttributes;
}

struct NFSV3READDIRPLUSCall
{
	NFSV3FileHandle Directory;
	INT64  Cookie;
	INT64  CookieVerf = "Opaque data";
	UINT32 DirCount;
	UINT32 MaxCount;
}

struct NFSV3EntryPlus = this.Name.ToString
{
	INT64 FileID;
	RPCFileName Name;
	INT64 Cookie;
	NFSV3PostOpAttr NameAttributes;
	NFSV3PostOpFileHanlde NameHandle;
}

struct NFSV3READDIRPLUSReplyOK = NFSReturnStatusTable(3, ReturnStatus)
{
	[NFSReturnStatusExist = 1, NFSReturnStatus]
	UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(3,this), this, this);
	NFSV3PostOpAttr DirectoryAttributes;
	INT64 CookieVerf = "Opaque data";
	[ValueFollow]
	UINT32 ValueFollow = this == 1 ? "Yes":"No";
	while Entries[Property.ValueFollow == 1]
	{
		NFSV3EntryPlus EntryPlus;
		[ValueFollow]
		UINT32 ValueFollow = this == 1 ? "Yes":"No";
	}
	UINT32 EOF;
}

struct NFSV3READDIRPLUSReplyFail = NFSReturnStatusTable(3, ReturnStatus)
{
	[NFSReturnStatusExist = 1, NFSReturnStatus]
	UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(3,this), this, this);
	NFSV3PostOpAttr DirectoryAttributes;
}

struct NFSV3FSSTATCall
{
	NFSV3FileHandle Object;
}

struct NFSV3FSSTATReplyOK = NFSReturnStatusTable(3, ReturnStatus)
{
	[NFSReturnStatusExist = 1, NFSReturnStatus]
	UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(3,this), this, this);
	NFSV3PostOpAttr ObjectAttributes;
	INT64  TotalBytes;
	INT64  FreeBytes;
	INT64  AvailableBytes;
	INT64  TotalFileSlots;
	INT64  FreeFileSlots;
	INT64  AvailableFreeFileSlots;
	UINT32 Invarsec;
}

struct NFSV3FSSTATReplyFail = NFSReturnStatusTable(3, ReturnStatus)
{
	[NFSReturnStatusExist = 1, NFSReturnStatus]
	UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(3,this), this, this);
	NFSV3PostOpAttr ObjectAttributes;
}

struct NFSV3FSINFOCall
{
	NFSV3FileHandle Object;
}

struct NFSV3FSINFOReplyOK = NFSReturnStatusTable(3, ReturnStatus)
{
	[NFSReturnStatusExist = 1, NFSReturnStatus]
	UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(3,this), this, this);
	NFSV3PostOpAttr ObjectAttributes;
	UINT32 RtMax;
	UINT32 RtPref;
	UINT32 RtMult;
	UINT32 WtMax;
	UINT32 WtPref;
	UINT32 WtMult;
	UINT32 DtPref;
	INT64  MaxFileSize;
	NFSV3Time TimeDelta;
	UINT32 Properties
	{
		UINT32 Reserved:27 = FormatString("      (%s)",this.toBitString);
		UINT32 SETATTR:1 = FormatString("       (%s) %s",this.ToBitString,this ? "SETATTR can set time on server"
							 : "SETATTR can't set time on server");
		UINT32 PATHCONF:1 = FormatString("      (%s) %s",this.ToBitString ,this ? "PATHCONF is valid for all files"
							 :  "PATHCONF should be get for every single file");
		UINT32 BIT2:1 =    FormatString("          (%s)",this.toBitString);
		UINT32 symbolic_links:1 = FormatString("(%s) %s",this.ToBitString ,this ? "File System supports symbolic links"
							 :  "File System does not support symbolic links");
		UINT32 hard_links:1 = FormatString("    (%s) %s",this.ToBitString ,this ? "File System supports hard links"
							 :  "File System does not support hard links");
	};
}

struct NFSV3FSINFOReplyFail = NFSReturnStatusTable(3, ReturnStatus)
{
	[NFSReturnStatusExist = 1, NFSReturnStatus]
	UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(3,this), this, this);
	NFSV3PostOpAttr ObjectAttributes;
}

struct NFSV3PATHCONFCall
{
	NFSV3FileHandle Object;
}

struct NFSV3PATHCONFReplyOK = NFSReturnStatusTable(3, ReturnStatus)
{
	[NFSReturnStatusExist = 1, NFSReturnStatus]
	UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(3,this), this, this);
	NFSV3PostOpAttr ObjectAttributes;
	UINT32 LinkMax;
	UINT32 NameMax;
	UINT32 NoTrunc= this ? "Yes":"No";
	UINT32 ChownRestricted = this ? "Yes":"No";
	UINT32 CaseInsensitive = this ? "Yes":"No";
	UINT32 CasePreserving = this ? "Yes":"No";
}

struct NFSV3PATHCONFReplyFail = NFSReturnStatusTable(3, ReturnStatus)
{
	[NFSReturnStatusExist = 1, NFSReturnStatus]
	UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(3,this), this, this);
	NFSV3PostOpAttr ObjectAttributes;
}

struct NFSV3CommitCall
{
	NFSV3FileHandle File;
	INT64  FileOffset;
	UINT32 Count;
}

struct NFSV3CommitReply = NFSReturnStatusTable(3, ReturnStatus)
{
	[NFSReturnStatusExist = 1, NFSReturnStatus]
	UINT32 ReturnStatus = FormatString("%s, %d(0x%X)", NFSReturnStatusTable(3,this), this, this);
	NFSV3WCCData FileWCC;
	switch
	{
		case ReturnStatus == 0: INT64 Verifier;
		default:
			switch
			{
				case FrameLength > FrameOffset:
					_struct UnhandledStatus
					{
						ReportParserError(ParserErrorProtocolClassPublic, "NFS", "NFSV3CommitReply Status Error") NFSV3CommitReplyStatusError;
						BLOB( FrameLength - FrameOffset ) UnknownData;
					}
			}
	}
}

//----------------------------------------version 4 start-------------------------------------------------------

struct NFSV4PathName
{
	[PathNameCount]
	UINT32 Count;
	while condition[Property.PathNameCount > 0]
	{
		[PathNameCount = Property.PathNameCount - 1]
		RPCFileName PathName;
	}
}

struct NFSV4StateID
{
	UINT32 SeqID;
	INT96  Other;
}

struct NFSData
{
	UINT32 Length;
	AsciiString(Length) Data;
	switch
	{
		case Length % 4 != 0:
			BLOB(4 - Length%4) FillBytes = "opaque data";
	}
}

struct NFSV4FileAttributes
{
	NFSV4BitMap AttrMask;
	NFSV4AttributeList AttrValues;
}

struct NFSV4OpCreateCall
{
	UINT32 CreateType = FormatString("%s, %d(0x%X)", NFSV4FileTypeTable(this), this, this);
	switch( CreateType )
	{
		case 5:RPCFileName LinkData;
		case 3:
		case 4:NFSV4SpecData DevData;
	}
	RPCFileName ObjectName;
	NFSV4FileAttributes CreateAttributes;
}

struct NFSV4ChangeInformation
{
	UINT32 Atomic = this ? "True":"False";
	INT64  Before;
	INT64  After;
}

struct NFSV4OpCreateReplyOK
{
	NFSV4ChangeInformation ChangeInformation;
	NFSV4BitMapOnly AttributesSet;
}

struct NFSV4OpCommitCall
{
	INT64  FileOffset;
	UINT32 Count;
}

struct NFSV4OpCloseCall
{
	UINT32 SeqID;
	NFSV4StateID OpenStateID;
}

struct NFSV4OpAccessReplyOK
{
	UINT32 Supported
	{
		UINT32 Reserved:26 = FormatString("(%s)",this.toBitString);
		UINT32 Execute:1 = FormatString(" (%s) %s",this.ToBitString,this ? "Execute Allow"
							 : "Execute not Allow");
		UINT32 Delete:1 = FormatString("  (%s) %s",this.ToBitString,this ? "Delete Allow"
							 : "Delete not Allow");
		UINT32 Extend:1 = FormatString("  (%s) %s",this.ToBitString,this ? "Extend Allow"
							 : "Extend not Allow");
		UINT32 Modify:1 = FormatString("  (%s) %s",this.ToBitString,this ? "Modify Allow"
							 : "Modify not Allow");
		UINT32 Lookup:1 = FormatString("  (%s) %s",this.ToBitString,this ? "Lookup Allow"
							 : "Lookup not Allow");
		UINT32 Read:1 = FormatString("    (%s) %s",this.ToBitString,this ? "Read Allow"
							 : "Read not Allow");
	};
	UINT32 Access
	{
		UINT32 Reserved:26 = FormatString("(%s)",this.toBitString);
		UINT32 Execute:1 = FormatString(" (%s) %s",this.ToBitString,this ? "Execute Allow"
							 : "Execute not Allow");
		UINT32 Delete:1 = FormatString("  (%s) %s",this.ToBitString,this ? "Delete Allow"
							 : "Delete not Allow");
		UINT32 Extend:1 = FormatString("  (%s) %s",this.ToBitString,this ? "Extend Allow"
							 : "Extend not Allow");
		UINT32 Modify:1 = FormatString("  (%s) %s",this.ToBitString,this ? "Modify Allow"
							 : "Modify not Allow");
		UINT32 Lookup:1 = FormatString("  (%s) %s",this.ToBitString,this ? "Lookup Allow"
							 : "Lookup not Allow");
		UINT32 Read:1 = FormatString("    (%s) %s",this.ToBitString,this ? "Read Allow"
							 : "Read not Allow");
	};
}

struct NFSV4LockOwner
{
	INT64 ClientID;
	NFSData Data;
}

struct NFSV4OpenOwner
{
	INT64 ClientID;
	NFSData Data;
}

struct NFSV4OpenToLockOwner
{
	UINT32 OpenSeqID;
	NFSV4StateID OpenStateID;
	UINT32 LockSeqID;
	NFSV4LockOwner LockOwner;
}

struct NFSV4ExistLockOwner
{
	NFSV4StateID LockStateID;
	UINT32 LockSeqID;
}

struct NFSV4Locker
{
	UINT32 NewLockOwner = this ? "True":"False";
	switch
	{
		case NewLockOwner:NFSV4OpenToLockOwner OpenOwner;
		default          :NFSV4ExistLockOwner LockOwner;
	}
}

struct NFSV4OpLockCall
{
	UINT32 LockType = FormatString("%s, %d(0x%X)",NFSV4LockTypeTable(this), this, this);
	UINT32 Reclaim = this ? "True":"false";
	INT64  FileOffset;
	INT64  Length;
	NFSV4Locker Locker;
}

struct NFSV4OpLockReplyDeny
{
	INT64  FileOffset;
	INT64  Length;
	UINT32 LockType = FormatString("%s, %d(0x%X)",NFSV4LockTypeTable(this), this, this);
	NFSV4LockOwner LockOwner;
}

struct NFSV4OpLOCKTCall
{
	UINT32 LockType = FormatString("%s, %d(0x%X)",NFSV4LockTypeTable(this), this, this);
	INT64  FileOffset;
	INT64  Length;
	NFSV4LockOwner Owner;
}

struct NFSV4OpLOCKTReplyDeny
{
	INT64  FileOffset;
	INT64  Length;
	UINT32 LockType = FormatString("%s, %d(0x%X)",NFSV4LockTypeTable(this), this, this);
	NFSV4LockOwner Owner;
}

struct NFSV4OpLOCKUCall
{
	UINT32 LockType = FormatString("%s, %d(0x%X)",NFSV4LockTypeTable(this), this, this);
	UINT32 SeqID;
	NFSV4StateID StateID;
	INT64  FileOffset;
	INT64  Length;
}

struct NFSV4CreateHow
{
	UINT32 CreateMode = FormatString("%s, %d(0x%X)",NFSV4CreateModeTable(this), this, this);
	switch( CreateMode )
	{
		case 0:
		case 1:NFSV4FileAttributes CreateAttributes;
		case 2:INT64 CreateVerf;
	}
}

Table NFSV4OpenFlagTypeTable(type)
{
	switch(type)
	{
		case  0:FormatString("OPEN4_NOCREATE, %u(0x%X)", type, type);
		case  1:FormatString("OPEN4_CREATE, %u(0x%X)", type, type);
		default:FormatString("%u(0x%X)", type, type);
	}
}

struct NFSV4OpenFlag
{
	UINT32 OpenType = NFSV4OpenFlagTypeTable(this);
	switch
	{
		case OpenType == 1:NFSV4CreateHow How;
	}
}

struct NFSV4OpenClaimDelegate
{
	NFSV4StateID DelegateStateID;
	RPCFileName File;
}

struct NFSV4OpenClaim
{
	UINT32 ClaimType = FormatString("%s, %d(0x%X)",NFSV4OpenClaimTypeTable(this), this, this);
	switch( ClaimType )
	{
		case 0:RPCFileName File;
		case 1:UINT32 DelegationType = FormatString("%s, %d(0x%X)",NFSV4OpenDelegationType(this), this, this);
		case 2:NFSV4OpenClaimDelegate DelegateCurInfo;
		case 3:RPCFileName FileDelegatePrev;
	}
}

struct NFSV4OpOpenCall
{
	UINT32 SeqID;
	UINT32 ShareAccess = FormatString("%s, %d(0x%X)", NFSV4ShareAccessTable(this), this, this);
	UINT32 ShareDeny =  FormatString("%s, %d(0x%X)", NFSV4ShareDenyTable(this), this, this);
	NFSV4OpenOwner Owner;
	NFSV4OpenFlag OpenHow;
	NFSV4OpenClaim Claim;
}

struct NFSV4ACL
{
	[ArrayNumber]
	UINT32 Number;
	while condition[Property.ArrayNumber > 0]
	{
		[ArrayNumber = Property.ArrayNumber - 1]
		NFSV4ACE ACE;
	}
}

struct NFSV4ACE
{
	UINT32 ACEType = FormatString("%s, %d(0x%X)", NFSV4ACETypeTable(this), this, this);
	
	UINT32 ACEFlag
	{
		UINT32 Reserved:25 = FormatString("                       (%s)",this.ToBitString);
		UINT32 ACE4_IDENTIFIER_GROUP:1 = FormatString("          (%s) %s",this.ToBitString,this ?  "ACE4_IDENTIFIER_GROUP" : "");							
		UINT32 ACE4_FAILED_ACCESS_ACE_FLAG:1 = FormatString("    (%s) %s",this.ToBitString,this ?  "ACE4_FAILED_ACCESS_ACE_FLAG" : "");
		UINT32 ACE4_SUCCESSFUL_ACCESS_ACE_FLAG:1 = FormatString("(%s) %s",this.ToBitString,this ?  "ACE4_SUCCESSFUL_ACCESS_ACE_FLAG" : "");
		UINT32 ACE4_INHERIT_ONLY_ACE:1 = FormatString("          (%s) %s",this.ToBitString,this ?  "ACE4_INHERIT_ONLY_ACE" : "");
		UINT32 ACE4_NO_PROPAGATE_INHERIT_ACE:1 = FormatString("  (%s) %s",this.ToBitString,this ?  "ACE4_NO_PROPAGATE_INHERIT_ACE" : "");
		UINT32 ACE4_DIRECTORY_INHERIT_ACE:1 = FormatString("     (%s) %s",this.ToBitString,this ?  "ACE4_DIRECTORY_INHERIT_ACE" : "");
		UINT32 ACE4_FILE_INHERIT_ACE:1 = FormatString("          (%s) %s",this.ToBitString,this ?  "ACE4_FILE_INHERIT_ACE" : "");
	};
	
	UINT32 AccessMask = NFSV4ACEMaskTable(this)
	{
		UINT32 Reserved:11 = FormatString("                           (%s)",this.ToBitString );
		UINT32 ACE4_SYNCHRONIZE:1 = FormatString("                   (%s) %s",this.ToBitString,this ?  "ACE4_SYNCHRONIZE" : "");
		UINT32 ACE4_WRITE_OWNER:1 = FormatString("                   (%s) %s",this.ToBitString,this ?  "ACE4_WRITE_OWNER" : "");
		UINT32 ACE4_WRITE_ACL:1 = FormatString("                     (%s) %s",this.ToBitString,this ?  "ACE4_WRITE_ACL" : "");
		UINT32 ACE4_READ_ACL:1 = FormatString("                      (%s) %s",this.ToBitString,this ?  "ACE4_READ_ACL" : "");
		UINT32 ACE4_DELETE:1 = FormatString("                        (%s) %s",this.ToBitString,this ?  "ACE4_DELETE" : "");
		UINT32 Unuse:7 = FormatString("                              (%s)",this.ToBitString );
		UINT32 ACE4_WRITE_ATTRIBUTES:1 = FormatString("              (%s) %s",this.ToBitString,this ?  "ACE4_WRITE_ATTRIBUTES" : "");
		UINT32 ACE4_READ_ATTRIBUTES:1 = FormatString("               (%s) %s",this.ToBitString,this ?  "ACE4_READ_ATTRIBUTES" : "");
		UINT32 ACE4_DELETE_CHILD:1 = FormatString("                  (%s) %s",this.ToBitString,this ?  "ACE4_DELETE_CHILD" : "");
		UINT32 ACE4_EXECUTE:1 = FormatString("                       (%s) %s",this.ToBitString,this ?  "ACE4_EXECUTE" : "");
		UINT32 ACE4_WRITE_NAMED_ATTRS:1 = FormatString("             (%s) %s",this.ToBitString,this ?  "ACE4_WRITE_NAMED_ATTRS" : "");
		UINT32 ACE4_READ_NAMED_ATTRS:1 = FormatString("              (%s) %s",this.ToBitString,this ?  "ACE4_READ_NAMED_ATTRS" : "");
		UINT32 ACE4_ADD_FILE_ACE4_ADD_SUBDIRECTORY:1 = FormatString("(%s) %s",this.ToBitString,this ?  "ACE4_ADD_FILE/ACE4_ADD_SUBDIRECTORY" : "");
		UINT32 ACE4_WRITE_DATA_ACE4_ADD_FILE:1 = FormatString("      (%s) %s",this.ToBitString,this ?  "ACE4_WRITE_DATA/ACE4_ADD_FILE" : "");
		UINT32 ACE4_READ_DATA_ACE4_LIST_DIRECTORY:1 = FormatString(" (%s) %s",this.ToBitString,this ?  "ACE4_READ_DATA/ACE4_LIST_DIRECTORY" : "");
	};
	
	RPCFileName Who;
}

struct NFSV4ModifiedLimit
{
	UINT32 NumberBlocks;
	UINT32 BytesPerBlock;
}

struct NFSV4SpaceLimit
{
	UINT32 LimitBy = this == 1 ? "NFS_LIMIT_SIZE":( this == 2 ? "NFS_LIMIT_BLOCKS":"");
	switch( LimitBy )
	{
		case  1:INT64 FileSize;
		case  2:NFSV4ModifiedLimit ModifiedBlocks;
	}
}

struct NFSV4OpenReadDelegation
{
	NFSV4StateID StateID;
	UINT32 Recall = this ? "True": "False";
	NFSV4ACE Permissions;
}

struct NFSV4OpenWriteDelegation
{
	NFSV4StateID StateID;
	UINT32 Recall = this ? "True" : "False";
	NFSV4SpaceLimit SpaceLimit;
	NFSV4ACE Permissions;
}

struct NFSV4OpenDelegation
{
	UINT32 DelegationType = FormatString("%s, %d(0x%X)",NFSV4OpenDelegationType(this), this, this);
	switch(DelegationType)
	{
		case 1:NFSV4OpenReadDelegation Read;
		case 2:NFSV4OpenWriteDelegation Write;
	}
}

struct NFSV4OpOpenReplyOK
{
	NFSV4StateID StateID;
	NFSV4ChangeInformation ChangeInformation;
	UINT32 ResultFlag=""
	{
		UINT32 Reserved:29 = FormatString("                   (%s)",this.ToBitString );
		UINT32 OPEN4_RESULT_LOCKTYPE_POSIX:1 = FormatString("(%s) %s",this.ToBitString,this ?  "OPEN4_RESULT_LOCKTYPE_POSIX" : "");
		UINT32 OPEN4_RESULT_CONFIRM:1 = FormatString("       (%s) %s",this.ToBitString,this ?  "OPEN4_RESULT_CONFIRM" : "");
		UINT32 OPEN4_RESULT_MLOCK:1 = FormatString("         (%s) %s",this.ToBitString,this ?  "OPEN4_RESULT_MLOCK" : "");
	};
	NFSV4BitMapOnly AttributeSet;
	NFSV4OpenDelegation Delegation;
}


struct NFSV4OpConfirmCall
{
	NFSV4StateID OpenStateID;
	UINT32 SeqID;
}

struct NFSV4OpDownGradeCall
{
	NFSV4StateID OpenStateID;
	UINT32 SeqID;
	UINT32 ShareAccess=NFSV4ShareAccessTable(this) + FormatString(", %d(0x%X)",this,this);
	UINT32 ShareDeny=NFSV4ShareDenyTable(this) + FormatString(", %d(0x%X)",this,this);
}

struct NFSV4OpReadCall
{
	NFSV4StateID StateID;
	INT64 FileOffset;
	INT64 Count;
}

struct NFSV4OpReadReplyOK
{
	UINT32 EOF = this ? "True":"False";
	NFSOpaque Data;
}

struct NFSV4OpREADDIRCall
{
	INT64  Cookie;
	INT64  CookieVerf = "Opaque data";
	UINT32 DirectoryCount;
	UINT32 MaxCount;
	NFSV4BitMapOnly AttrRequest;
}

struct NFSV4Entry = this.Name.ToString
{
	INT64 Cookie;
	RPCFileName Name;
	NFSV4FileAttributes Attributes;
}

struct NFSV4DirectoryList
{
	[ValueFollow]
	UINT32 ValueFollow = this == 1 ? "Yes":"No";
	while Entries[Property.ValueFollow == 1]
	{
		NFSV4Entry Entry;
		[ValueFollow]
		UINT32 ValueFollow = this == 1 ? "Yes":"No";
	}
	UINT32 EOF = this ? "True":"False";
}

struct NFSV4OpREADDIRReplyOK
{
	INT64 CookieVerf = "Opaque data";
	NFSV4DirectoryList Reply;
}

struct NFSV4OpRenameCall
{
	RPCFileName OldName;
	RPCFileName NewName;
}

struct NFSV4OpRenameReplyOK
{
	NFSV4ChangeInformation SourceChangeInformation;
	NFSV4ChangeInformation TargetChangeInformation;
}

struct NFSRPCSecGssInfo
{
	NFSData OID;
	UINT32 QOP;
	UINT32 Service = FormatString("%s, %d(0x%X)", NFSV4RPCServiceTable(this), this, this);
}

struct NFSV4OpSECINFOReplyOK
{
	[StructNum]
	UINT32 Number;
	while Condition[Property.StructNum > 0]
	{
		[StructNum = Property.StructNum - 1]
		UINT32 Flavor;
		switch(Flavor)
		{
			case 6:NFSRPCSecGssInfo FlavorInfo;
		}
	}
}

struct NFSV4OpSETATTRCall
{
	NFSV4StateID StateID;
	NFSV4FileAttributes ObjectAttributes;
}

struct NFSV4ClientAddress
{
	NFSData NetworkID;
	NFSData UniversalAddress;
}

struct NFSV4ClientID
{
	INT64 Verifier;
	NFSData ID;
}

struct NFSV4CBClient
{
	UINT32 CBProgram;
	NFSV4ClientAddress CBLocation;
}

struct NFSV4OpSETCLIENTIDCall
{
	NFSV4ClientID Client;
	NFSV4CBClient Callback;
	UINT32 CallbackIdent;
}

struct NFSV4OpSETCLIENTIDReplyOK
{
	INT64 ClientID;
	INT64 Verifier;
}

struct NFSV4OpSETCLIENTIDCONFIRMCall
{
	INT64 ClientID;
	INT64 SetClientIDConfirm;
}

struct NFSV4OpWriteCall
{
	NFSV4StateID StateID;
	INT64 FileOffset;
	UINT32 StableHow = FormatString("%s, %d(0x%X)",NFSV4StableHowTable(this), this, this);
	NFSData data;
}

struct NFSV4OpWriteReplyOK
{
	UINT32 Count;
	UINT32 StableHow = FormatString("%s, %d(0x%X)",NFSV4StableHowTable(this), this, this);
	INT64 WriteVerfier;
}

struct NFSV4SetTime
{
	UINT32 SetIt;
	switch
	{
		case SetIt == 1:NFSV4Time time;
	}
}

Table NFSAttrExistTable(bit)
{
	switch(bit)
	{
		case  0:"Absent";
		default:"Exist";
	}
}

struct NFSV4BitMapOnly
{
	UINT32 BitMapLength;
	switch
	{
		case BitMapLength >= 1 :
			UINT32 BitMapMask1 = "(" + this.ToBitString + ")"
			{
				UINT32 FATTR4_MAXWRITE:1 = FormatString("        (%s) %s",this.ToBitString,"recc_attr: FATTR4_MAXWRITE(31) " + NFSAttrExistTable(this));
				UINT32 FATTR4_MAXREAD:1 = FormatString("         (%s) %s",this.ToBitString , "recc_attr: FATTR4_MAXREAD(30) " + NFSAttrExistTable(this));
				UINT32 FATTR4_MAXNAME:1 =FormatString("         (%s) %s", this.ToBitString , "recc_attr: FATTR4_MAXNAME(29) " + NFSAttrExistTable(this));
				UINT32 FATTR4_MAXLINK:1 =FormatString("         (%s) %s", this.ToBitString, "recc_attr: FATTR4_MAXLINK(28) " + NFSAttrExistTable(this));
				UINT32 FATTR4_MAXFILESIZE:1 = FormatString("     (%s) %s", this.ToBitString, "recc_attr: FATTR4_MAXFILESIZE(27) " + NFSAttrExistTable(this));
				UINT32 FATTR4_HOMOGENEOUS:1 =FormatString("     (%s) %s", this.ToBitString, "recc_attr: FATTR4_HOMOGENEOUS(26) " + NFSAttrExistTable(this));
				UINT32 FATTR4_HIDDEN:1 =FormatString("          (%s) %s", this.ToBitString, "recc_attr: FATTR4_HIDDEN(25) " + NFSAttrExistTable(this));
				UINT32 FATTR4_FS_LOCATIONS:1 =FormatString("    (%s) %s", this.ToBitString , "recc_attr: FATTR4_FS_LOCATIONS(24) " + NFSAttrExistTable(this));
				UINT32 FATTR4_FILES_TOTAL:1 =FormatString("     (%s) %s", this.ToBitString , "recc_attr: FATTR4_FILES_TOTAL(23) " + NFSAttrExistTable(this));
				UINT32 FATTR4_FILES_FREE:1 =FormatString("      (%s) %s", this.ToBitString , "recc_attr: FATTR4_FILES_FREE(22) " + NFSAttrExistTable(this));
				UINT32 FATTR4_FILES_AVAIL:1 =FormatString("     (%s) %s", this.ToBitString, "recc_attr: FATTR4_FILES_AVAIL(21) " + NFSAttrExistTable(this));
				UINT32 FATTR4_FILEID:1 =FormatString("          (%s) %s", this.ToBitString, "recc_attr: FATTR4_FILEID(20) " + NFSAttrExistTable(this));
				UINT32 FATTR4_FILEHANDLE:1 =FormatString("      (%s) %s", this.ToBitString, "mand_attr: FATTR4_FILEHANDLE(19) " + NFSAttrExistTable(this));
				UINT32 FATTR4_CHOWN_RESTRICTED:1 =FormatString("(%s) %s",  this.ToBitString, "recc_attr: FATTR4_CHOWN_RESTRICTED(18) " + NFSAttrExistTable(this));
				UINT32 FATTR4_CASE_PRESERVING:1 =FormatString(" (%s) %s",  this.ToBitString,"recc_attr: FATTR4_CASE_PRESERVING(17) " + NFSAttrExistTable(this));
				UINT32 FATTR4_CASE_INSENSITIVE:1 =FormatString("(%s) %s",  this.ToBitString, "recc_attr: FATTR4_CASE_INSENSITIVE(16) " + NFSAttrExistTable(this));
				UINT32 FATTR4_CANSETTIME:1 =FormatString("      (%s) %s",  this.ToBitString , "recc_attr: FATTR4_CANSETTIME(15) " + NFSAttrExistTable(this));
				UINT32 FATTR4_ARCHIVE:1 =FormatString("         (%s) %s",  this.ToBitString , "recc_attr: FATTR4_ARCHIVE(14) " + NFSAttrExistTable(this));
				UINT32 FATTR4_ACLSUPPORT:1 =FormatString("      (%s) %s",  this.ToBitString , "recc_attr: FATTR4_ACLSUPPORT(13) " + NFSAttrExistTable(this));
				UINT32 FATTR4_ACL:1 =FormatString("             (%s) %s",  this.ToBitString , "recc_attr: FATTR4_ACL(12) " + NFSAttrExistTable(this));
				UINT32 FATTR4_RDATTR_ERROR:1 =FormatString("    (%s) %s",  this.ToBitString, "mand_attr: FATTR4_RDATTR_ERROR(11) " + NFSAttrExistTable(this));
				UINT32 FATTR4_LEASE_TIME:1 =FormatString("      (%s) %s",  this.ToBitString , "mand_attr: FATTR4_LEASE_TIME(10) " + NFSAttrExistTable(this));
				UINT32 FATTR4_UNIQUE_HANDLES:1 =FormatString("  (%s) %s",  this.ToBitString ,"mand_attr: FATTR4_UNIQUE_HANDLES(9) " + NFSAttrExistTable(this));
				UINT32 FATTR4_FSID:1 =FormatString("            (%s) %s",  this.ToBitString , "mand_attr: FATTR4_FSID(8) " + NFSAttrExistTable(this));
				UINT32 FATTR4_NAMED_ATTR:1 = FormatString("      (%s) %s",  this.ToBitString, "mand_attr: FATTR4_NAMED_ATTR(7) " + NFSAttrExistTable(this));
				UINT32 FATTR4_SYMLINK_SUPPORT:1 =FormatString(" (%s) %s",  this.ToBitString , "mand_attr: FATTR4_SYMLINK_SUPPORT(6) " + NFSAttrExistTable(this));
				UINT32 FATTR4_LINK_SUPPORT:1 = FormatString("    (%s) %s",  this.ToBitString , "mand_attr: FATTR4_LINK_SUPPORT(5) " + NFSAttrExistTable(this));
				UINT32 FATTR4_SIZE:1 =FormatString("            (%s) %s",  this.ToBitString , "mand_attr: FATTR4_SIZE(4) " + NFSAttrExistTable(this));
				UINT32 FATTR4_CHANGE:1 =FormatString("          (%s) %s",  this.ToBitString, "mand_attr: FATTR4_CHANGE(3) " + NFSAttrExistTable(this));
				UINT32 FATTR4_FH_EXPIRE_TYPE:1 =FormatString("  (%s) %s",  this.ToBitString , "mand_attr: FATTR4_FH_EXPIRE_TYPE(2) " + NFSAttrExistTable(this));
				UINT32 FATTR4_TYPE:1 = FormatString("            (%s) %s", this.ToBitString , "mand_attr: FATTR4_TYPE(1) " + NFSAttrExistTable(this));
				UINT32 FATTR4_SUPPORTED_ATTRS:1 =FormatString(" (%s) %s", this.ToBitString , "mand_attr: FATTR4_SUPPORTED_ATTRS(0) " + NFSAttrExistTable(this));
			};
	}
	switch
	{
		case BitMapLength >= 2 :
			UINT32 BitMapMask2 = "(........" + this.ToBitString(2,0,24) + ")"
			{
				UINT32 Reserved:8 = FormatString("                (%s)",this.ToBitString);
				UINT32 FATTR4_MOUNTED_ON_FILEID:1 = FormatString("(%s) %s",this.ToBitString , "recc_attr: FATTR4_MOUNTED_ON_FILEID(55) " + NFSAttrExistTable(this));
				UINT32 FATTR4_TIME_MODIFY_SET:1 = FormatString("  (%s) %s",this.ToBitString , "recc_attr: FATTR4_TIME_MODIFY_SET(54) " + NFSAttrExistTable(this));
				UINT32 FATTR4_TIME_MODIFYIT21:1 = FormatString("  (%s) %s",this.ToBitString , "recc_attr: FATTR4_TIME_MODIFY(53) " + NFSAttrExistTable(this));
				UINT32 FATTR4_TIME_METADATA:1 =FormatString("    (%s) %s", this.ToBitString , "recc_attr: FATTR4_TIME_METADATA(52) " + NFSAttrExistTable(this));
				UINT32 FATTR4_TIME_DELTA:1 =FormatString("       (%s) %s", this.ToBitString , "recc_attr: FATTR4_TIME_DELTA(51) " + NFSAttrExistTable(this));
				UINT32 FATTR4_TIME_CREATE:1 =FormatString("      (%s) %s",this.ToBitString, "recc_attr: FATTR4_TIME_CREATE(50) " + NFSAttrExistTable(this));
				UINT32 FATTR4_TIME_BACKUP:1 =FormatString("      (%s) %s", this.ToBitString , "recc_attr: FATTR4_TIME_BACKUP(49) " + NFSAttrExistTable(this));
				UINT32 FATTR4_TIME_ACCESS_SET:1 = FormatString("  (%s) %s", this.ToBitString , "recc_attr: FATTR4_TIME_ACCESS_SET(48) " + NFSAttrExistTable(this));
				UINT32 FATTR4_TIME_ACCESS:1 =FormatString("      (%s) %s", this.ToBitString, "recc_attr: FATTR4_TIME_ACCESS(47) " + NFSAttrExistTable(this));
				UINT32 FATTR4_SYSTEM:1 =FormatString("           (%s) %s", this.ToBitString , "recc_attr: FATTR4_SYSTEM(46) "+ NFSAttrExistTable(this));
				UINT32 FATTR4_SPACE_USED:1 = FormatString("       (%s) %s", this.ToBitString, "recc_attr: FATTR4_SPACE_USED(45) " + NFSAttrExistTable(this));
				UINT32 FATTR4_SPACE_TOTAL:1 =FormatString("      (%s) %s", this.ToBitString, "recc_attr: FATTR4_SPACE_TOTAL(44) " + NFSAttrExistTable(this));
				UINT32 FATTR4_SPACE_FREE:1 =FormatString("       (%s) %s", this.ToBitString , "recc_attr: FATTR4_SPACE_FREE(43) " + NFSAttrExistTable(this));
				UINT32 FATTR4_SPACE_AVAIL:1 =FormatString("      (%s) %s", this.ToBitString, "recc_attr: FATTR4_SPACE_AVAIL(42) " + NFSAttrExistTable(this));
				UINT32 FATTR4_RAWDEV:1 =FormatString("           (%s) %s", this.ToBitString, "recc_attr: FATTR4_RAWDEV(41) " + NFSAttrExistTable(this));
				UINT32 FATTR4_QUOTA_USED:1 =FormatString("       (%s) %s",this.ToBitString , "recc_attr: FATTR4_QUOTA_USED(40) " + NFSAttrExistTable(this));
				UINT32 FATTR4_QUOTA_AVAIL_SOFT:1 =FormatString(" (%s) %s", this.ToBitString, "recc_attr: FATTR4_QUOTA_AVAIL_SOFT(39) " + NFSAttrExistTable(this));
				UINT32 FATTR4_QUOTA_AVAIL_HARD:1 =FormatString(" (%s) %s", this.ToBitString , "recc_attr: FATTR4_QUOTA_AVAIL_HARD(38) " + NFSAttrExistTable(this));
				UINT32 FATTR4_OWNER_GROUP:1 =FormatString("      (%s) %s", this.ToBitString , "recc_attr: FATTR4_OWNER_GROUP(37) " + NFSAttrExistTable(this));
				UINT32 FATTR4_OWNER:1 = FormatString("            (%s) %s", this.ToBitString , "recc_attr: FATTR4_OWNER(36) " + NFSAttrExistTable(this));
				UINT32 FATTR4_NUMLINKS:1 = FormatString("         (%s) %s", this.ToBitString, "recc_attr: FATTR4_NUMLINKS(35) " + NFSAttrExistTable(this));
				UINT32 FATTR4_NO_TRUNC:1 =FormatString("         (%s) %s",this.ToBitString , "recc_attr: FATTR4_NO_TRUNC(34) " + NFSAttrExistTable(this));
				UINT32 FATTR4_MODE:1 =FormatString("             (%s) %s", this.ToBitString , "recc_attr: FATTR4_MODE(33) " + NFSAttrExistTable(this));
				UINT32 FATTR4_MIMETYPE:1 =FormatString("         (%s) %s",this.ToBitString , "recc_attr: FATTR4_MIMETYPE(32) " + NFSAttrExistTable(this));
			};
	}
	switch
	{
		case BitMapLength >= 3 :UINT32 BitMapMask[BitMapLength-2];
	}
}


//#? NullTable is in LDAP parser, it just return a null string.
//#? if you comment out the formatstring of NFSV4BitMap, the three properties' value will always ZERO!
struct NFSV4BitMap = NullTable(BitMapLength) + NullTable(BitMapMask1) + NullTable(BitMapMask2)
{
	[BitMapLength]
	UINT32 BitMapLength;
	switch
	{
		case BitMapLength >= 1 :
			[BitMapMask1]
			UINT32 BitMapMask1 = "(" + this.ToBitString + ")"
			{
				UINT32 FATTR4_MAXWRITE:1 = FormatString("        (%s) %s",this.ToBitString ,"recc_attr: FATTR4_MAXWRITE(31)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_MAXREAD:1 = FormatString("         (%s) %s",this.ToBitString ,"recc_attr: FATTR4_MAXREAD(30)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_MAXNAME:1 = FormatString("         (%s) %s",this.ToBitString ,"recc_attr: FATTR4_MAXNAME(29)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_MAXLINK:1 = FormatString("         (%s) %s",this.ToBitString ,"recc_attr: FATTR4_MAXLINK(28)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_MAXFILESIZE:1 = FormatString("     (%s) %s",this.ToBitString ,"recc_attr: FATTR4_MAXFILESIZE(27)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_HOMOGENEOUS:1 = FormatString("     (%s) %s",this.ToBitString ,"recc_attr: FATTR4_HOMOGENEOUS(26)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_HIDDEN:1 = FormatString("          (%s) %s",this.ToBitString ,"recc_attr: FATTR4_HIDDEN(25)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_FS_LOCATIONS:1 = FormatString("    (%s) %s",this.ToBitString ,"recc_attr: FATTR4_FS_LOCATIONS(24)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_FILES_TOTAL:1 = FormatString("     (%s) %s",this.ToBitString ,"recc_attr: FATTR4_FILES_TOTAL(23)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_FILES_FREE:1 = FormatString("      (%s) %s",this.ToBitString ,"recc_attr: FATTR4_FILES_FREE(22)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_FILES_AVAIL:1 = FormatString("     (%s) %s",this.ToBitString ,"recc_attr: FATTR4_FILES_AVAIL(21)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_FILEID:1 = FormatString("          (%s) %s",this.ToBitString ,"recc_attr: FATTR4_FILEID(20)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_FILEHANDLE:1 = FormatString("      (%s) %s",this.ToBitString ,"mand_attr: FATTR4_FILEHANDLE(19)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_CHOWN_RESTRICTED:1 = FormatString("(%s) %s",this.ToBitString ,"recc_attr: FATTR4_CHOWN_RESTRICTED(18)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_CASE_PRESERVING:1 = FormatString(" (%s) %s",this.ToBitString ,"recc_attr: FATTR4_CASE_PRESERVING(17)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_CASE_INSENSITIVE:1 = FormatString("(%s) %s",this.ToBitString ,"recc_attr: FATTR4_CASE_INSENSITIVE(16)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_CANSETTIME:1 = FormatString("      (%s) %s",this.ToBitString ,"recc_attr: FATTR4_CANSETTIME(15)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_ARCHIVE:1 = FormatString("         (%s) %s",this.ToBitString ,"recc_attr: FATTR4_ARCHIVE(14)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_ACLSUPPORT:1 = FormatString("      (%s) %s",this.ToBitString ,"recc_attr: FATTR4_ACLSUPPORT(13)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_ACL:1 = FormatString("             (%s) %s",this.ToBitString ,"recc_attr: FATTR4_ACL(12)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_RDATTR_ERROR:1 = FormatString("    (%s) %s",this.ToBitString ,"mand_attr: FATTR4_RDATTR_ERROR(11)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_LEASE_TIME:1 = FormatString("      (%s) %s",this.ToBitString ,"mand_attr: FATTR4_LEASE_TIME(10)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_UNIQUE_HANDLES:1 = FormatString("  (%s) %s",this.ToBitString ,"mand_attr: FATTR4_UNIQUE_HANDLES(9)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_FSID:1 = FormatString("            (%s) %s",this.ToBitString ,"mand_attr: FATTR4_FSID(8)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_NAMED_ATTR:1 = FormatString("      (%s) %s",this.ToBitString ,"mand_attr: FATTR4_NAMED_ATTR(7)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_SYMLINK_SUPPORT:1 = FormatString(" (%s) %s",this.ToBitString ,"mand_attr: FATTR4_SYMLINK_SUPPORT(6)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_LINK_SUPPORT:1 = FormatString("    (%s) %s",this.ToBitString ,"mand_attr: FATTR4_LINK_SUPPORT(5)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_SIZE:1 = FormatString("            (%s) %s",this.ToBitString ,"mand_attr: FATTR4_SIZE(4)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_CHANGE:1 = FormatString("          (%s) %s",this.ToBitString ,"mand_attr: FATTR4_CHANGE(3)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_FH_EXPIRE_TYPE:1 = FormatString("  (%s) %s",this.ToBitString ,"mand_attr: FATTR4_FH_EXPIRE_TYPE(2)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_TYPE:1 = FormatString("            (%s) %s",this.ToBitString ,"mand_attr: FATTR4_TYPE(1)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_SUPPORTED_ATTRS:1 = FormatString(" (%s) %s",this.ToBitString ,"mand_attr: FATTR4_SUPPORTED_ATTRS(0)" + " " + NFSAttrExistTable(this));
			};
	}
	switch
	{
		case BitMapLength >= 2 :
			[BitMapMask2]
			UINT32 BitMapMask2 = "(........" + this.ToBitString(2,0,24) + ")"
			{
				UINT32 Reserved:8 = FormatString("                (%s)",this.ToBitString );
				UINT32 FATTR4_MOUNTED_ON_FILEID:1 = FormatString("(%s) %s",this.ToBitString ,"recc_attr: FATTR4_MOUNTED_ON_FILEID(55)"+ " " + NFSAttrExistTable(this));
				UINT32 FATTR4_TIME_MODIFY_SET:1 = FormatString("  (%s) %s",this.ToBitString ,"recc_attr: FATTR4_TIME_MODIFY_SET(54)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_TIME_MODIFY:1 = FormatString("      (%s) %s",this.ToBitString ,"recc_attr: FATTR4_TIME_MODIFY(53)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_TIME_METADATA:1 = FormatString("    (%s) %s",this.ToBitString ,"recc_attr: FATTR4_TIME_METADATA(52)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_TIME_DELTA:1 = FormatString("       (%s) %s",this.ToBitString ,"recc_attr: FATTR4_TIME_DELTA(51)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_TIME_CREATE:1 = FormatString("      (%s) %s",this.ToBitString ,"recc_attr: FATTR4_TIME_CREATE(50)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_TIME_BACKUP:1 = FormatString("      (%s) %s",this.ToBitString ,"recc_attr: FATTR4_TIME_BACKUP(49)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_TIME_ACCESS_SET:1 = FormatString("  (%s) %s",this.ToBitString ,"recc_attr: FATTR4_TIME_ACCESS_SET(48)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_TIME_ACCESS:1 = FormatString("      (%s) %s",this.ToBitString ,"recc_attr: FATTR4_TIME_ACCESS(47)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_SYSTEM:1 = FormatString("           (%s) %s",this.ToBitString ,"recc_attr: FATTR4_SYSTEM(46)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_SPACE_USED:1 = FormatString("       (%s) %s",this.ToBitString ,"recc_attr: FATTR4_SPACE_USED(45)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_SPACE_TOTAL:1 = FormatString("      (%s) %s",this.ToBitString ,"recc_attr: FATTR4_SPACE_TOTAL(44)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_SPACE_FREE:1 = FormatString("       (%s) %s",this.ToBitString ,"recc_attr: FATTR4_SPACE_FREE(43)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_SPACE_AVAIL:1 = FormatString("      (%s) %s",this.ToBitString ,"recc_attr: FATTR4_SPACE_AVAIL(42)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_RAWDEV:1 = FormatString("           (%s) %s",this.ToBitString ,"recc_attr: FATTR4_RAWDEV(41)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_QUOTA_USED:1 = FormatString("       (%s) %s",this.ToBitString ,"recc_attr: FATTR4_QUOTA_USED(40)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_QUOTA_AVAIL_SOFT:1 = FormatString(" (%s) %s",this.ToBitString ,"recc_attr: FATTR4_QUOTA_AVAIL_SOFT(39)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_QUOTA_AVAIL_HARD:1 = FormatString(" (%s) %s",this.ToBitString ,"recc_attr: FATTR4_QUOTA_AVAIL_HARD(38)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_OWNER_GROUP:1 = FormatString("      (%s) %s",this.ToBitString ,"recc_attr: FATTR4_OWNER_GROUP(37)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_OWNER:1 = FormatString("            (%s) %s",this.ToBitString ,"recc_attr: FATTR4_OWNER(36)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_NUMLINKS:1 = FormatString("         (%s) %s",this.ToBitString ,"recc_attr: FATTR4_NUMLINKS(35)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_NO_TRUNC:1 = FormatString("         (%s) %s",this.ToBitString ,"recc_attr: FATTR4_NO_TRUNC(34)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_MODE:1 = FormatString("             (%s) %s",this.ToBitString ,"recc_attr: FATTR4_MODE(33)" + " " + NFSAttrExistTable(this));
				UINT32 FATTR4_MIMETYPE:1 = FormatString("         (%s) %s",this.ToBitString ,"recc_attr: FATTR4_MIMETYPE(32)" + " " + NFSAttrExistTable(this));
			};
	}
	switch
	{
		case BitMapLength >= 3: UINT32 BitMapMask[BitMapLength-2];
	}
}

struct NFSV4AttributeList
{
	[ AttributeEndOffset = ( Offset + this + 4 ) < FrameLength ? ( Offset + this + 4 ) : FrameLength,
	  PaddingEndOffset = this%4 ? ( Offset + this + 8 - this%4 ) : ( Offset + this + 4 ) ]
	UINT32 AttributeLength;
	switch
	{
		case BitMapLength >= 1:
			while condition[offset < AttributeEndOffset && BitMapMask1]
			{
				switch
				{
					case BitMapMask1 & 0x00000001 :
						[ BitMapMask1 = BitMapMask1 & ~0x00000001 ]
						NFSV4BitMapOnly SupportedAttributes;
					case BitMapMask1 & 0x00000002 :
						[ BitMapMask1 = BitMapMask1 & ~0x00000002 ]
						UINT32 FileType = FormatString("%s, %d(0x%X)", NFSV4FileTypeTable(this), this, this);
					case BitMapMask1 & 0x00000004 :
						[ BitMapMask1 = BitMapMask1 & ~0x00000004 ]
						UINT32 ExpireType = this ? "":"FH4_PERSISTENT"
						{
							UINT32 Reserved:28 = FormatString("              (%s)",this.ToBitString );
							UINT32 FH4_VOL_RENAME:1 = FormatString("        (%s) %s",this.ToBitString,this ? "FH4_VOL_RENAME":"");
							UINT32 FH4_VOL_MIGRATION:1 = FormatString("     (%s) %s",this.ToBitString,this ? "FH4_VOL_MIGRATION":"");
							UINT32 FH4_VOLATILE_ANY:1 = FormatString("      (%s) %s",this.ToBitString,this ?  "FH4_VOLATILE_ANY":"");
							UINT32 FH4_NOEXPIRE_WITH_OPEN:1 = FormatString("(%s) %s",this.ToBitString,this ?  "FH4_NOEXPIRE_WITH_OPEN":"");
						};
					case BitMapMask1 & 0x00000008 :
						[BitMapMask1 = BitMapMask1 & ~0x00000008 ]INT64 ChangeID;
					case BitMapMask1 & 0x00000010 :
						[BitMapMask1 = BitMapMask1 & ~0x00000010 ]INT64 Size;
					case BitMapMask1 & 0x00000020 :
						[BitMapMask1 = BitMapMask1 & ~0x00000020 ]UINT32 LinkSupport = this ? "True":"False";
					case BitMapMask1 & 0x00000040 :
						[BitMapMask1 = BitMapMask1 & ~0x00000040 ]UINT32 SymlinkSupport = this ? "True":"False";
					case BitMapMask1 & 0x00000080 :
						[BitMapMask1 = BitMapMask1 & ~0x00000080 ]UINT32 NamedAttributes = this ? "True":"False";
					case BitMapMask1 & 0x00000100 :
						[BitMapMask1 = BitMapMask1 & ~0x00000100 ]
						struct FileSystemID
						{
							INT64 FSIDMajor;
							INT64 FSIDMinor;
						};
					case BitMapMask1 & 0x00000200 :
						[BitMapMask1 = BitMapMask1 & ~0x00000200 ]UINT32 UniqueHandles = this ? "True":"False";
					case BitMapMask1 & 0x00000400 :
						[BitMapMask1 = BitMapMask1 & ~0x00000400 ]UINT32 LeaseTime;
					case BitMapMask1 & 0x00000800 :
						[BitMapMask1 = BitMapMask1 & ~0x00000800 ]UINT32 ReadAttributeError = NFSReturnStatusTable(4,this) + FormatString(", %d(0x%X)",this,this);
					case BitMapMask1 & 0x00001000 :
						[BitMapMask1 = BitMapMask1 & ~0x00001000 ]NFSV4ACL ACL;
					case BitMapMask1 & 0x00002000 :
						[BitMapMask1 = BitMapMask1 & ~0x00002000 ]UINT32 ACLSupport;
					case BitMapMask1 & 0x00004000 :
						[BitMapMask1 = BitMapMask1 & ~0x00004000 ]UINT32 Archive = this ? "True":"False";
					case BitMapMask1 & 0x00008000 :
						[BitMapMask1 = BitMapMask1 & ~0x00008000 ]UINT32 CanSetTime = this ? "True":"False";
					case BitMapMask1 & 0x00010000 :
						[BitMapMask1 = BitMapMask1 & ~0x00010000 ]UINT32 CaseInsensitive = this ? "True" : "False";
					case BitMapMask1 & 0x00020000 :
						[BitMapMask1 = BitMapMask1 & ~0x00020000 ]UINT32 CasePreserving = this ? "True" : "False";
					case BitMapMask1 & 0x00040000 :
						[BitMapMask1 = BitMapMask1 & ~0x00040000 ]UINT32 ChownRestricted = this ? "True" : "False";
					case BitMapMask1 & 0x00080000 :
						[BitMapMask1 = BitMapMask1 & ~0x00080000 ]NFSV4FileHandle FileHandle;
					case BitMapMask1 & 0x00100000 :
						[BitMapMask1 = BitMapMask1 & ~0x00100000 ]INT64 FileID;
					case BitMapMask1 & 0x00200000 :
						[BitMapMask1 = BitMapMask1 & ~0x00200000 ]INT64 FilesAvail;
					case BitMapMask1 & 0x00400000 :
						[BitMapMask1 = BitMapMask1 & ~0x00400000 ]INT64 FilesFree;
					case BitMapMask1 & 0x00800000 :
						[BitMapMask1 = BitMapMask1 & ~0x00800000 ]INT64 FilesTotal;
					case BitMapMask1 & 0x01000000 :
						[BitMapMask1 = BitMapMask1 & ~0x01000000 ]
						struct NFSV4Locations
						{
							NFSV4PathName PathNames;
							[ValueFollow]
							UINT32 ValueFollows = this ? ( this == 1 ? "Value Follows":""):"No Value Follows";
							while Entries[Property.ValueFollow]
							{
								RPCFileName NFSV4Location;
								[ValueFollow]
								UINT32 ValueFollows = this ? ( this == 1 ? "Value Follows":""):"No Value Follows";
							}
						};
					case BitMapMask1 & 0x02000000 :
						[BitMapMask1 = BitMapMask1 & ~0x02000000 ]UINT32 Hidden = this ? "True" : "False";
					case BitMapMask1 & 0x04000000 :
						[BitMapMask1 = BitMapMask1 & ~0x04000000 ]UINT32 Homogeneous = this ? "True":"False";
					case BitMapMask1 & 0x08000000 :
						[BitMapMask1 = BitMapMask1 & ~0x08000000 ]INT64 MaxFileSize;
					case BitMapMask1 & 0x10000000 :
						[BitMapMask1 = BitMapMask1 & ~0x10000000 ]UINT32 MaxLink;
					case BitMapMask1 & 0x20000000 :
						[BitMapMask1 = BitMapMask1 & ~0x20000000 ]UINT32 MaxName;
					case BitMapMask1 & 0x40000000 :
						[BitMapMask1 = BitMapMask1 & ~0x40000000 ]INT64 MaxRead;
					case BitMapMask1 & 0x80000000 :
						[BitMapMask1 = BitMapMask1 & ~0x80000000 ]INT64 MaxWrite;
					default :
						_struct Exit1{};
				}
			}//End of While condition
	}
	
	switch
	{
		case BitMapLength >= 2:
			while cond1[ offset < AttributeEndOffset && BitMapMask2 ]
			{
				switch
				{
					case BitMapMask2 & 0x000001  :
						[BitMapMask2 = BitMapMask2 & ~0x000001] RPCFileName MimeType;
					case BitMapMask2 & 0x000002  :
						[BitMapMask2 = BitMapMask2 & ~0x000002, NFSFileModeExist = 1, NFSFileMode]
						UINT32 FileMode
						{
							UINT32 Reserved1:16 = FormatString("    (%s)", this.ToBitString );
							UINT32 PermFileTypes:3 = FormatString("(%s) %s",this.ToBitString,PermFileTypesTable(this) ) ;
							UINT32 Reserved2:1 = FormatString("    (%s)", this.ToBitString );
							UINT32 SetUID:1 = FormatString("       (%s) %s",this.ToBitString, this        ? "Set User ID On Execution" 
														  : "Do Not Set User ID On Execution" );
							UINT32 SetGID:1 = FormatString("       (%s) %s",this.ToBitString, this        ? "Set Group ID on Execution" 
														  : "Do Not Set Group ID on Execution" );
							UINT32 SaveText:1 = FormatString("     (%s) %s",this.ToBitString, this      ? "Save Program Image After Execution Completes" 
														  : "Do Not Save Program Image After Execution Completes" );
							UINT32 OwnerRead:1 = FormatString("    (%s) %s",this.ToBitString, this     ? "Owner Has Read Privileges" 
														  : "Owner Denied Read Access" );
							UINT32 OwnerWrite:1 = FormatString("   (%s) %s",this.ToBitString, this    ? "Owner Has Write Privileges" 
														  : "Owner Denied Write Access" );
							UINT32 OwnerExecute:1 = FormatString(" (%s) %s",this.ToBitString, this  ? "Owner Has Execute/Search Privileges" 
														  : "Owner Denied Execute Access" );
							UINT32 GroupRead:1 = FormatString("    (%s) %s",this.ToBitString, this     ? "Group Has Read Privileges" 
														  : "Group Denied Read Access" );
							UINT32 GroupWrite:1 = FormatString("   (%s) %s",this.ToBitString, this    ? "Group Has Write Privileges" 
														  : "Group Denied Write Access" );
							UINT32 GroupExecute:1 = FormatString(" (%s) %s",this.ToBitString, this  ? "Group Has Execute/Search Privileges" 
														  : "Group Denied Execute/Search Access" );
							UINT32 OthersRead:1 = FormatString("   (%s) %s",this.ToBitString, this    ? "All Others Have Read Privileges" 
														  : "All Others Denied Read Access" );
							UINT32 OthersWrite:1 = FormatString("  (%s) %s",this.ToBitString, this   ? "All Others Have Write Privileges " 
														  : "All Others Denied Write Access " );
							UINT32 OthersExecute:1 = FormatString("(%s) %s",this.ToBitString, this ? "All Others Have Execute/Search Privileges " 
														  : "All Others Denied Execute/Search Access " );
						};
					case BitMapMask2 & 0x000004  :
						[BitMapMask2 = BitMapMask2 & ~0x000004]UINT32 NoTrunc = this ? "True":"False";
					case BitMapMask2 & 0x000008  :
						[BitMapMask2 = BitMapMask2 & ~0x000008]UINT32 NumLinks;
					case BitMapMask2 & 0x000010  :
						[BitMapMask2 = BitMapMask2 & ~0x000010]RPCFileName Owner;
					case BitMapMask2 & 0x000020  :
						[BitMapMask2 = BitMapMask2 & ~0x000020]RPCFileName OwnerGroup;
					case BitMapMask2 & 0x000040  :
						[BitMapMask2 = BitMapMask2 & ~0x000040]INT64 QuotaAvailHard;
					case BitMapMask2 & 0x000080  :
						[BitMapMask2 = BitMapMask2 & ~0x000080]INT64 QuotaAvailSoft;
					case BitMapMask2 & 0x000100  :
						[BitMapMask2 = BitMapMask2 & ~0x000100]INT64 QuotaUsed;
					case BitMapMask2 & 0x000200  :
						[BitMapMask2 = BitMapMask2 & ~0x000200]NFSV4SpecData RawDevice;
					case BitMapMask2 & 0x000400  :
						[BitMapMask2 = BitMapMask2 & ~0x000400]INT64 SpaceAvail;
					case BitMapMask2 & 0x000800  :
						[BitMapMask2 = BitMapMask2 & ~0x000800]INT64 SpaceFree;
					case BitMapMask2 & 0x001000  :
						[BitMapMask2 = BitMapMask2 & ~0x001000]INT64 SpaceTotal;
					case BitMapMask2 & 0x002000:
						[BitMapMask2 = BitMapMask2 & ~0x002000]INT64 SpaceUsed;
					case BitMapMask2 & 0x004000  :
						[BitMapMask2 = BitMapMask2 & ~0x004000]UINT32 system = this ? "True" : "False";
					case BitMapMask2 & 0x008000  :
						[BitMapMask2 = BitMapMask2 & ~0x008000]NFSV4Time TimeAccess;
					case BitMapMask2 & 0x010000  :
						[BitMapMask2 = BitMapMask2 & ~0x010000]NFSV4SetTime TimeAccessSet;
					case BitMapMask2 & 0x020000  :
						[BitMapMask2 = BitMapMask2 & ~0x020000]NFSV4Time TimeBackup;
					case BitMapMask2 & 0x040000  :
						[BitMapMask2 = BitMapMask2 & ~0x040000]NFSV4Time TimeCreate;
					case BitMapMask2 & 0x080000  :
						[BitMapMask2 = BitMapMask2 & ~0x080000]NFSV4Time TimeDelta;
					case BitMapMask2 & 0x100000  :
						[BitMapMask2 = BitMapMask2 & ~0x100000]NFSV4Time TimeMetaData;
					case BitMapMask2 & 0x200000  :
						[BitMapMask2 = BitMapMask2 & ~0x200000]NFSV4Time TimeModify;
					case BitMapMask2 & 0x400000  :
						[BitMapMask2 = BitMapMask2 & ~0x400000]NFSV4SetTime TimeModifySet;
					case BitMapMask2 & 0x800000  :
						[BitMapMask2 = BitMapMask2 & ~0x800000]INT64 MountedOnFileID;
					default :
						_struct Exit2{};
				}
			}//End of While cond1
	}
	
	switch
	{
		case offset < Property.AttributeEndOffset:BLOB(Property.AttributeEndOffset - offset) UnknownAttributes;
	}
	switch
	{	
		case offset < FrameLength && offset < Property.PaddingEndOffset:BLOB(Property.PaddingEndOffset - offset) Padding = FormatString("%d bytes",Property.PaddingEndOffset - offset);
	}
}

struct NFSV4COMPOUNDCall = FormatString("Minor Version is %d , Operation is %s",
										MinorVersion , Property.CallDescription)
{
	RPCFileName Tag;
	UINT32 MinorVersion;
	[OpCount,CallDescription = ""]
	UINT32 OperationCount;
	while Condition[Property.OpCount > 0 && Offset < FrameLength]
	{
		[CallDescription = Property.CallDescription + this.ToString + " " , OpCount = Property.OpCount - 1]
		UINT32 OperationCode = NFSV4OperationCodeTable(this) + FormatString(", %d(0x%X)",this,this);
		switch( OperationCode )
		{
			case  3:
				UINT32 Access
				{
					UINT32 Reserved:26 = FormatString("(%s)",this.ToBitString );
					UINT32 Execute:1 = FormatString(" (%s) %s",this.ToBitString, this ? "Execute Allow"
										 : "Execute not Allow");
					UINT32 Delete:1 = FormatString("  (%s) %s",this.ToBitString, this ? "Delete Allow"
										 : "Delete Not Allow");
					UINT32 Extend:1 = FormatString("  (%s) %s",this.ToBitString, this ? "Extend Allow"
										 : "Extend Not Allow");
					UINT32 Modify:1 = FormatString("  (%s) %s",this.ToBitString, this ? "Modify Allow"
										 : "Modfify Not Allow");
					UINT32 Lookup:1 = FormatString("  (%s) %s",this.ToBitString, this ? "Lookup Allow"
										 : "Lookup Not Allow");
					UINT32 Read:1 = FormatString("    (%s) %s",this.ToBitString, this ? "Read Allow"
										 : "Read Not Allow");
				};
			case  4:
				NFSV4OpCloseCall CloseCall;
			case  5:
				NFSV4OpCommitCall CommitCall;
			case  6:
				NFSV4OpCreateCall CreateCall;
			case  7:
			case 30:
				INT64 ClientID;
			case  8:
				NFSV4StateID StateID;
			case  9:
				NFSV4BitMapOnly AttributesRequest;
			case 11:
				RPCFileName NewName;
			case 12:
				NFSV4OpLockCall LockCall;
			case 13:
				NFSV4OpLOCKTCall LOCKTCall;
			case 14:
				NFSV4OpLOCKUCall LOCKUCall;
			case 15:
				RPCFileName ObjectName;
			case 17:
			case 37:
				NFSV4FileAttributes ObjectAttributes;
			case 18:
				NFSV4OpOpenCall OpenCall;
			case 19:
				UINT32 CreateDirectory = this ? "True":"False";
			case 20:
				NFSV4OpConfirmCall ConfirmCall;
			case 21:
				NFSV4OpDownGradeCall DownGradeCall;
			case 22:
				NFSV4FileHandle Object;
			case 25:
				NFSV4OpReadCall ReadCall;
			case 26:
				NFSV4OpREADDIRCall READDIRCall;
			case 28:
				RPCFileName Target;
			case 29:
				NFSV4OpRenameCall RenameCall;
			case 33:
				RPCFileName Name;
			case 34:
				NFSV4OpSETATTRCall SETATTRCall;
			case 35:
				NFSV4OpSETCLIENTIDCall SETCLIENTIDCall;
			case 36:
				NFSV4OpSETCLIENTIDCONFIRMCall SETCLIENTIDCONFIRMCall;
			case 38:
				NFSV4OpWriteCall WriteCall;
			case 39:
				NFSV4LockOwner LockOwner;
		}
	}
}

struct NFSV4COMPOUNDReply = Property.ReplyDescription
{
	[NFSReturnStatusExist = 1, NFSReturnStatus]
	UINT32 LastStatus=NFSReturnStatusTable(4,this) + FormatString(", %d(0x%X)",this,this);
	RPCFileName Tag;
	[OpCount,ReplyDescription = ""]
	UINT32 OperationCount;
	while condition[Property.OpCount > 0 && Offset < FrameLength]
	{
		[ReplyDescription = Property.ReplyDescription + this.ToString + ",",OpCount = Property.OpCount - 1]
		UINT32 OperationCode = NFSV4OperationCodeTable(this) + FormatString(", %d(0x%X)",this,this);
		[ReplyDescription = Property.ReplyDescription + " " + this.ToString ]
		UINT32 Status = NFSReturnStatusTable(4,this) + FormatString(", %d(0x%X)",this,this);
		switch
		{
			case OperationCode ==  3 && Status == 0    :NFSV4OpAccessReplyOK AccessOK;
			case OperationCode ==  4 && Status == 0    :
			case OperationCode == 20 && Status == 0    :
			case OperationCode == 21 && Status == 0    :NFSV4StateID OpenStateID;
			case OperationCode ==  5 && Status == 0    :INT64 WriteVerf;
			case OperationCode ==  6 && Status == 0    :NFSV4OpCreateReplyOK CreateOK;
			case OperationCode ==  9 && Status == 0    :NFSV4FileAttributes ObjectAttributes;
			case OperationCode == 10 && Status == 0    :NFSV4FileHandle Object;
			case OperationCode == 11 && Status == 0    :
			case OperationCode == 28 && Status == 0    :NFSV4ChangeInformation ChangeInformation;
			case OperationCode == 12 && Status == 0    :NFSV4StateID LockStateID;
			case OperationCode == 12 && Status == 10010:NFSV4OpLockReplyDeny LockDeny;
			case OperationCode == 13 && Status == 10010:NFSV4OpLOCKTReplyDeny LOCKTDeny;
			case OperationCode == 14 && Status == 0    :NFSV4StateID StateID;
			case OperationCode == 18 && Status == 0    :NFSV4OpOpenReplyOK OpenOK;
			case OperationCode == 25 && Status == 0    :NFSV4OpReadReplyOK ReadOK;
			case OperationCode == 26 && Status == 0    :NFSV4OpREADDIRReplyOK READDIROK;
			case OperationCode == 27 && Status == 0    :RPCFileName Link;
			case OperationCode == 29 && Status == 0    :NFSV4OpRenameReplyOK RenameOK;
			case OperationCode == 33 && Status == 0    :NFSV4OpSECINFOReplyOK SECINFOOK;
			case OperationCode == 34                   :NFSV4BitMapOnly AttributeSet;
			case OperationCode == 35 && Status == 0    :NFSV4OpSETCLIENTIDReplyOK SETCLIENTIDOK;
			case OperationCode == 35 && Status == 10017:NFSV4ClientAddress ClientUsing;
			case OperationCode == 38 && Status == 0    :NFSV4OpWriteReplyOK WriteOK;
		}
	}
}


