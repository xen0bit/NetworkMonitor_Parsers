//#  (c) 2009 CodePlex Foundation
//#
//#  Title:                  Microsoft SQL Server Tabular Data Stream (TDS) Protocol
//#
//#  Details:                Tabular Data Stream is the protocol used for communication between a Microsoft SQL Server RDBMS and a corresponding client
//#
//#  Microsoft References:   [MS-TDS]: Tabular Data Stream Protocol Specification (1.0)
//#                          [MS-SSTDS]: Tabular Data Stream Protocol Version 4.2 (0.1)
//#
//#  Comments:               
//#
//#  Revision Class and Date:Major, 10/27/2009
//#                          Minor, 3/23/2010
//#
//####
[RegisterBefore(SMB2ResponseRead.PipePayload, TDS, contains(Property.SMBFileName, "sql\\query") && UINT8(Framedata, FrameOffset) != 0x53)]
[RegisterBefore(SMB2RequestWrite.PipePayload, TDS, contains(Property.SMBFileName, "sql\\query") && UINT8(Framedata, FrameOffset) != 0x53)]
[RegisterBefore(SMBComWriteRequestAndXRequest.PipePayload, TDS, contains(Property.SMBFileName, "sql\\query") && UINT8(Framedata, FrameOffset) != 0x53)]
[RegisterBefore(SMBComReadResp.PipePayload, TDS, contains(Property.SMBFileName, "sql\\query") && UINT8(Framedata, FrameOffset) != 0x53)]
[RegisterBefore(SMBComReadAndXResp.PipePayload, TDS, contains(Property.SMBFileName, "sql\\query") && UINT8(Framedata, FrameOffset) != 0x53)]
[DataTypeByteOrder = (IsValueNone(Conversation.TCP.TDSIsLittleEndian) ||  Conversation.TCP.TDSIsLittleEndian) ? LittleEndian : BigEndian]
// TDS packet format
Protocol TDS = TLSSSLData ? "TLS SSL Data" : FormatString("%s%s, %sVersion = %s, %s",
	Property.TDSContinuation ? "Continuous " : "",
	TDSPacketTypeTable(TDSPacketType) == "Undefined" ? "Data" : TDSPacketTypeTable(TDSPacketType),
	TDSPacketType == 0x02 || TDSPacketType == 0x10 ? "Negotiating " : "",
	IsValueNone(Conversation.Tcp.TDSVersionCon) ? ConstTDSVersion + "(No version information available, using the default version)": TDSVersionTable(Conversation.Tcp.TDSVersionCon),
	PacketHeader ? FormatString("SPID = %d, PacketID = %d, Flags=%s, SrcPort=%d, DstPort=%d, PayloadLen=%u, Seq=%s, Ack=%u, Win=%u", 
						Property.TDSSPID, 
						Property.TDSPacketID,
						Property.TCPFlags,
						Property.SourcePort,
						Property.DestinationPort,
						Property.TCPPayloadLength,
						Property.TCPSequenceRange,
						Property.TCPAckNumber,
						Property.WindowSize) : "Reassembled Packet")
{
	switch
	{
		case !Conversation.tds.ID:
			[ BuildConversationWithParent ] struct{}
	}
	
	switch
	{
		case HighestReassembledProtocol == "TDS":
			[TDSIsFirst = true, TDSIsLast = true] struct{}
		case UINT8( Framedata, Offset ) == 0x17
			&& (
				//SSL Version
				(UINT8( Framedata, Offset + 1 ) == 0x02 && UINT8( Framedata, Offset + 2 ) == 0x00) ||	//SSL 2.0
				(UINT8( Framedata, Offset + 1 ) == 0x03 && UINT8( Framedata, Offset + 2 ) == 0x00) ||	//SSL 3.0
				(UINT8( Framedata, Offset + 1 ) == 0x03 && UINT8( Framedata, Offset + 2 ) == 0x01) ||	//SSL 3.1 (TLS 1.0)
				(UINT8( Framedata, Offset + 1 ) == 0x03 && UINT8( Framedata, Offset + 2 ) == 0x02)	//TLS 1.1
			):
			[DataFieldByteOrder = BigEndian]
			SSLVersionSelector  TLSSSLData;
		case (!(UINT8(FrameData, FrameOffset) == 1) && !(UINT8(FrameData, FrameOffset) == 2) &&  !(UINT8(FrameData, FrameOffset) == 3) 
			 &&  !(UINT8(FrameData, FrameOffset) == 4)  &&  !(UINT8(FrameData, FrameOffset) == 6)  &&  !(UINT8(FrameData, FrameOffset) == 7)
			 &&  !(UINT8(FrameData, FrameOffset) == 0xe)  &&  !(UINT8(FrameData, FrameOffset) == 0x10)  &&  !(UINT8(FrameData, FrameOffset) == 0x11) 
			 &&  !(UINT8(FrameData, FrameOffset) == 0x12))
			 || (UINT8(FrameData, FrameOffset + 1) & 0xE0) || UINT8(FrameData, FrameOffset + 7) 
			 || ((UINT8(FrameData, FrameOffset) == 2 || UINT8(FrameData, FrameOffset) == 0x10) &&  !(UINT8(FrameData, FrameOffset + 6) == 1)):
			BLOB(FrameLength - FrameOffset) TDSContinuationPacket;//TDS Continuation Packet
		case FrameLength > FrameOffset:
			TDSHeader PacketHeader;
	}	
	
	//0x02 means (From client to server) Ignore this event (0x01 MUST also be set).
	switch
	{
		case Property.IsIgnoreEventData:
			BLOB(FrameLength - FrameOffset) IgnoreEventData;
	}
	
	//Negotiation, login, prelogin frames which do not need be reassembled
	switch
	{
		case TDSPacketType == 0x02:
		case TDSPacketType == 0x10:
		case TDSPacketType == 0x11:
		case TDSPacketType == 0x12:
		case TDSPacketType == 0x17:
		case TDSPacketType == 0x04 && Property.TDSSPID == 0 && UINT8(FrameData, FrameOffset) == 0x00:
		case TDSPacketType == 0x04 && Property.TDSSPID == 0 && UINT8(FrameData, FrameOffset) == 0x01:
		case TDSPacketType == 0x04 && Property.TDSSPID == 0 && UINT8(FrameData, FrameOffset) == 0x02:
		case TDSPacketType == 0x04 && Property.TDSSPID == 0 && UINT8(FrameData, FrameOffset) == 0x03:
		case TDSPacketType == 0x04 && Property.TDSSPID == 0 && UINT8(FrameData, FrameOffset) == 0x04:
		case TDSPacketType == 0x04 && Property.TDSSPID == 0 && UINT8(FrameData, FrameOffset) == 0x14:
		case TDSPacketType == 0x04 && Property.TDSSPID == 0 && UINT8(FrameData, FrameOffset) == 0x16:
		case TDSPacketType == 0x04 && Property.TDSSPID == 0 && UINT8(FrameData, FrameOffset) == 0xed:
		case TDSPacketType == 0x04 && Property.TDSSPID == 0 && UINT8(FrameData, FrameOffset) == 0xad:
		case TDSPacketType == 0x04 && UINT8(FrameData, FrameOffset) == 0xe3:
			[Property.IsNegotiationFrame = true] 
			[Property.TDSIsFirst = true, Property.TDSIsLast = true]
			struct{};
	}
			
	[
		Property.TDSPacketNextId = Property.TDSPacketID == 255 ? 0 : (Property.TDSPacketID + 1),
		PayloadStart(
			NetworkDirection, // direction
			Property.TDSSPID, // identifier
			0, // sequence token
			0, // next sequence
			0, // total payload length
			TDSIsFirst, // is first
			TDSIsLast, // is last
			RssmblyIndStartBit + RssmblyIndEndBit + RssmblySelfBit, // has start, length and self indication
			/* Properties... */
			0x0000,
			Property.TDSPacketType
			)
	]
	[
		Post.Conversation.ConversationDescription = 
			( Conversation.TDSSPIDCon ? FormatString("( SPID: %d ) ", Conversation.TDSSPIDCon) : "") +
			( FormatString("ConvID = %d", ConvID) )
	]
	[DataFieldFrameLength = HighestReassembledProtocol == "TDS" ? FrameLength : (FrameOffset + Property.TDSPacketLength - 8)]
	switch
	{
		case (Property.TDSIsFirst || Property.IsNegotiationFrame) && FrameOffset < FrameLength:
		
			struct
			{
				[
					Conversation.Tcp.TDSVersionTable$[FrameNumber] = Conversation.Tcp.TDSVersionCon,
					Conversation.TDSHasSprocNameTable$[FrameNumber] = Conversation.HasSprocName,
					Conversation.TDSSprocNameTable$[FrameNumber] = Conversation.SprocName,
					Property.TDSVersionValue = Conversation.Tcp.TDSVersionTable$[FrameNumber],
					Property.HasStoredProcedureName = Conversation.TDSHasSprocNameTable$[FrameNumber],
					Property.StoredProcedureName = Conversation.TDSSprocNameTable$[FrameNumber]
				]
				//Using the default version(defined in constant.npl) when tds conversations are umcompleted(missing version informations)
				[Property.TDSVersion = IsValueNone(Property.TDSVersionValue) ? ConstTDSVersion : TDSVersionShortNameTable(Property.TDSVersionValue)]
				//Most string fields are Ascii type in [MS-SSTDS] while Unicode type in [MS-TDS]
				[	
					Property.TDSStringUnitLen = (Property.TDSVersion < 7.0) ? 1 : 2, 
					Property.TDSStringType = (Property.TDSVersion < 7.0) ? 0 : 1
				]
				switch
				{ 
					case TDSPacketType != 0x04:
						[HasStoredProcedureName = FALSE, StoredProcedureName = ""] 
						struct {}
				}
				
				[
					Post.Conversation.Tcp.TDSVersionCon = Property.TDSVersionValue,
					Post.Conversation.HasSprocName = Property.HasStoredProcedureName,
					Post.Conversation.SprocName = Property.StoredProcedureName
				]
				// rest of header must be read in each packet because we have no way of passing packet size to structures below.
				switch( TDSPacketType )
				{ 
					case 0x01: TDSSqlBatch TDSSqlBatchData;
					case 0x02: TDSLoginPacket TDSLoginPacketData;
					case 0x03: TDSRPCRequest  TDSRPCRequest;
					case 0x04: TDSServerResponse TDSServerResponseData;
					case 0x06: TDSAttention TDSAttention;
					case 0x07: TDSBulkLoadBCP TDSBulkLoadBCPData;
					case 0x0E: TDSTransMgrReq TDSTransMgrReqData;
					case 0x10: TDSLoginPacket7 TDSLoginPacket7Data;
					//SSPIMessage	:=	SSPIData;
					//SSPIData	:=	BYTESTREAM;
					case 0x11:
						Blob(FrameLength-FrameOffset)  SSPIMessage
						{
							switch
							{
								case AsciiString( FrameData, Offset, 7 ) == "Ntlmssp":
									NLMP NLMP;
							}
						};
					case 0x12: TDSPreLoginPacket(0) PreLoginPacketData;
					default:   ReportParserError(ParserErrorProtocolClassWindows, "TDS", "Unrecognized TDS Packet Type") PacketTypeError;
				}
				
				Switch
				{
					case FrameLength > FrameOffset:
						BLOB(FrameLength - FrameOffset) RemainData;
				}
			}
		default:
			switch
			{
				case FrameLength - FrameOffset > 0:
					[Property.TDSContinuation = true]
					Blob(FrameLength - FrameOffset) TDSContinuationData;
			}
	}
}

Table TDSPacketTypeTable( value )
{
	switch( value )
	{
		case 0x01: "SQLBatch";
		case 0x02: "PreTDS7Login";
		case 0x03: "RPCRequest";
		case 0x04: "Response";
		case 0x06: "Attention";
		case 0x07: "BulkLoadBCP";
		case 0x0E: "TransMgrReq";
		case 0x10: "Login7";
		case 0x11: "SSPIMessage";
		case 0x12: "Prelogin";
		case 0x17: "SSL";
		default:   "Undefined";
	}
}

UnsignedNumber TDSHeaderStatus
{
	Size = 1;
	DisplayFormat = FormatString ("End of message %s, ignore event %s, reset connection %s",
		(this & 0x01) ? "true" : "false",
		(this & 0x02) ? "true" : "false",
		(this & 0x08) ? "true" : "false"
	)
}


// Helper to dump a transaction descriptor field.
// The transaction descriptor field is a 64-bit unsigned little endian value
// Length is needed for envchange because new value or old value can be zero length.
UnsignedNumber TDSTransactionDescriptor(Length)
{
	Size = Length;
	ByteOrder = LittleEndian;
	DisplayFormat = FormatString( "%I64u (0x%I64X)", this, this );
}

// Helper function to hex dump data for a type.
UnsignedNumber TDSHexDump( Length )
{
	Size = Length;
	DisplayFormat = FormatString( "0x%I64X (%u Bytes)", this, Length );
}

// Helper function to dump TDS guid (datatype uniqueidentifier).
// Length can be zero meaning guid is null or 16 meaning guid has value.
UnsignedNumber TDSGuidDump ( Length )
{
	Size = Length;
	ByteOrder = BigEndian;
	// GuidDump
	// String form of guid:
	// {11223344-5566-7788-9900-AABBCCDDEEFF}
	// TDS wire format of guid, this is same as Windows memory layout of guid.
	// 44 33 22 11 66 55 88 77 99 00 AA BB CC DD EE FF
	DisplayFormat = FormatString( "{%02X%02X%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
									this[12], this[13], this[14], this[15], this[10], this[11], this[8], this[9],
										this[7], this[6], this[5], this[4], this[3], this[2], this[1], this[0] );
}

Table TDSHeaderTypeTable (value)
{
	switch( value ) 
	{
		case  1: FormatString("Query Notification Header");
		case  2: FormatString("MARS Header");
		default: FormatString("Invalid Header");
	}
}

table TDSDataTypeTable (value)
{
	switch (value)
	{
		case 0x1F: FormatString ("NULLTYPE");
		case 0x30: FormatString ("INT1TYPE");
		case 0x32: FormatString ("BITTYPE");
		case 0x34: FormatString ("INT2TYPE");
		case 0x38: FormatString ("INT4TYPE");
		case 0x3A: FormatString ("DATETIM4TYPE");
		case 0x3B: FormatString ("FLT4TYPE");
		case 0x3C: FormatString ("MONEYTYPE");
		case 0x3D: FormatString ("DATETIMETYPE");
		case 0x3E: FormatString ("FLT8TYPE");
		case 0x7A: FormatString ("MONEY4TYPE");
		case 0x7F: FormatString ("INT8TYPE");
		case 0x24: FormatString ("GUIDTYPE");
		case 0x26: FormatString ("INTNTYPE");
		case 0x37: FormatString ("DECIMALTYPE");
		case 0x3F: FormatString ("NUMERICTYPE");
		case 0x68: FormatString ("BITNTYPE");
		case 0x6A: FormatString ("DECIMALN");
		case 0x6C: FormatString ("NUMERICNTYPE");
		case 0x6D: FormatString ("FLTNTYPE");
		case 0x6E: FormatString ("MONEYNTYPE");
		case 0x6F: FormatString ("DATETIMNTYPE");
		case 0x2F: FormatString ("CHARTYPE");
		case 0x27: FormatString ("VARCHARTYPE");
		case 0x2D: FormatString ("BINARYTYPE");
		case 0x25: FormatString ("VARBINARYTYPE");
		case 0xA5: FormatString ("BIGVARBINTYPE");
		case 0xA7: FormatString ("BIGVARCHRTYPE");
		case 0xAD: FormatString ("BIGBINARYTYPE");
		case 0xAF: FormatString ("BIGCHARTYPE");
		case 0xE7: FormatString ("NVARCHARTYPE");
		case 0xEF: FormatString ("NCHARTYPE");
		case 0xF1: FormatString ("XMLTYPE");
		case 0xF0: FormatString ("UDTTYPE");
		case 0x23: FormatString ("TEXTTYPE");
		case 0x22: FormatString ("IMAGETYPE");
		case 0x63: FormatString ("NTEXTTYPE");
		case 0x62: FormatString ("SSVARIANTTYPE");
	}
}

struct  TDSALLHeaders = FormatString("Head Type = %s", TDSHeaderTypeTable(Property.TDSHeaderType))
{
	// ALL_HEADERS	:=TotalLength, {Header};
	// TotalLength  :=UINT32; //including itself
	// HeaderLength :=UINT32; //including itself
	// HeaderType	:=UINT16;
	// HeaderData	:={UINT8};
	// Header	:=HeaderLength, HeaderType, HeaderData;

	[AllHeadersPosition = FrameOffset]
	UINT32 TotalLength;

	while Option[FrameOffset < AllHeadersPosition + TotalLength] // we are in header space
	{
		UINT32 HeaderLength;
		[Property.TDSHeaderType]
		UINT16 HeaderType = TDSHeaderTypeTable(this);

		switch (HeaderType)
		{
			case 0x01:
				struct QueryNotificationHeader
				{
					// Query Notification Header
					// Header Data    := NotifyId,
					//              SSBDeployment,
					//            [NotifyTimeout];
					// NotifyId       := UINT16, UNICODESTREAM;
					// SSBDeployment  := UINT16, UNICODESTREAM;
					// NotifyTimeout  := UINT32;

					UINT16 NotifyIdLength;
					[DataFieldByteOrder = LittleEndian]
					UnicodeString(NotifyIdLength) NotifyId;
					UINT16 SSBDeploymentLength;
					[DataFieldByteOrder = LittleEndian]
					UnicodeString(SSBDeploymentLength) SSBDeployment;
					switch ((NotifyIdLength+SSBDeploymentLength+2)*2 + 4 == HeaderLength)
					{
						// remaining field must be timeout; otherwise, timeout not present
						case 0: UINT32 NotifyTimeout; 
					}
				}
			case 0x02:
				struct MARSHeader
				{
					// MARS Header
					// Header Data    := TransactionDescriptor,
					//              OutstandingRequestCount;
					// OutstandingRequestCount 	:= UINT32;
					// TransactionDescriptor 	:= UINT64;
					UINT64 TransactionDescriptor;
					UINT32 OutstandingRequestCount;
				}
			// default is invalid - nothing to read.
		}
	}
}

//[MS-SSTDS] 2.2.6.3   LOGIN
struct TDSLoginPacket
{
	Switch
	{
		case Property.TDSPacketLength == 71 && Property.TDSIsLast:
			struct
			{
				BLOB(6)	RemainedLanguage;	// Initial language	
				UINT8	llanglen;	// Length of language	
				UINT8	lsetlang = TDSlsetlangTable(this);	// Notify on language change	
				BLOB(45) Reserved5;	//45FRESERVEDBYTE
				AsciiString(6)	lpacketsize;	// length of TDS packet	
				UINT8	lpacketsizelen;	// length of lpacketsize
				UINT8	Dummy[3];	// dummy to make length right
			}
		default:
			struct
			{
				AsciiString( 30 )  lhostname;
				UINT8  lhostnlen; // hostname len
				AsciiString( 30 )  lusername;
				UINT8  lusernlen; // username len
				AsciiString( 30 )  lpw; // password
				UINT8  lpwnlen; // pwd len
				BLOB(8)  lhostproc; // host process id
				BLOB(16) Reserved1;//16FRESERVEDBYTE
				BLOB(6)  AppType;
				UINT8  lhplen;    // hostproc id len
				[Conversation.TCP.TDSIsLittleEndian = (this == 3)]
				UINT8	lint2 = TDSlint2Table(this);	// type of int2
				UINT8	lint4;    // type of int4
				UINT8	lchar = TDSlcharTable(this);    // type of char
				UINT8	lflt = TDSlfltTable(this);	 // type of float
				BLOB(1) Reserved2;	//FRESERVEDBYTE
				UINT8	lusedb = TDSlusedbTable(this);   // notify on exec of use SQL command
				UINT8	ldmpld = TDSldmpldTable(this);   // disallow use of dump/load and bulk insert
				UINT8	linterface = TDSlinterfaceTable(this); // interface type - SQL, TI, etc
				UINT8	ltype = TDSltypeTable(this);	// network type (server/client)
				BLOB(6) Reserved3;	//6FRESERVEDBYTE
				UINT8	DBLIBFlags = TDSDBLIBFlagsTable(this); // Application specific
				AsciiString( 30 )  lappname; // app name
				UINT8  lappnlen;
				[Conversation.TDSServerName]
				AsciiString( 30 )  lservname; // servername
				UINT8  lservnlen;
				AsciiString(255)	lrempw; 	// remote passwords
				UINT8	lrempwlen;	// length of lrempw
				[DataFieldByteOrder = BigEndian]
				[Property.TDSVersionValue]
				[Property.TDSVersion = TDSVersionShortNameTable(TDSVersion)]
				[Property.TDSStringUnitLen = (Property.TDSVersion < 7.0) ? 1 : 2, 
					Property.TDSStringType = (Property.TDSVersion < 7.0) ? 0 : 1]
				UINT32	ltds = TDSVersionTable( this );	// tds version
				AsciiString(10)	lprogname; // client DBLib name
				UINT8	lprognlen;	// length of lprogname
				UINT32	lprogvers;	// client version
				BLOB(3) Reserved4;	//3FRESERVEDBYTE
				BLOB(30 > framelength - frameoffset ? framelength - frameoffset : 30)	llanguage;	// Initial language	
				UINT8	llanglen;	// Length of language	
				UINT8	lsetlang = TDSlsetlangTable(this);	// Notify on language change	
				BLOB(45) Reserved5;	//45FRESERVEDBYTE
				AsciiString(6)	lpacketsize;	// length of TDS packet	
				UINT8	lpacketsizelen;	// length of lpacketsize
				UINT8	Dummy[8];	// dummy to make length right	
			}
	}
}

//[MS-SSTDS]
Table TDSlsetlangTable(value)
{
	switch(value)
	{
		case 0: "SET_LANG_OFF";
		case 1: "SET_LANG_ON";
	}
}

//[MS-SSTDS]
Table TDSDBLIBFlagsTable(value)
{
	switch(value)
	{
		case 0x01: "SSPI negotiation is required";
	}
}

//[MS-SSTDS]
Table TDSltypeTable(value)
{
	switch(value)
	{
		case 0: "normal user connecting directly";
		case 2: "user login through another server";
		case 4: "replication login";
		case 8: "integrated security user login";
	}
}

//[MS-SSTDS]
Table TDSlinterfaceTable(value)
{
	switch(value)
	{
		case 0: "LDEFSQL (Default language. For SQL Server; that is, Transact-SQL)";
		case 1: "LXSQL (Explicitly referencing Transact-SQL)";
	}
}

//[MS-SSTDS]
Table TDSldmpldTable(value)
{
	switch(value)
	{
		case 0: "DUMPLOAD_ON";
		case 1: "DUMPLOAD_OFF";
	}
}

//[MS-SSTDS]
Table TDSlusedbTable(value)
{
	switch(value)
	{
		case 0: "USE_DB_OFF";
		case 1: "USE_DB_ON";
	}
}

//[MS-SSTDS]
Table TDSlfltTable(value)
{
	switch(value)
	{
		case 5: "FLOAT_VAX";
		case 10: "FLOAT_IEEE_754";
		case 11: "ND5000";
	}
}

//[MS-SSTDS]
Table TDSlint2Table(value)
{
	switch(value)
	{
		case 2: "lsb is the hi byte (680x0), big-endian";
		case 3: "lsb is the low byte (VAX, 80x86), little-endian";
	}
}

//[MS-SSTDS]
Table TDSlcharTable(value)
{
	switch(value)
	{
		case 6: "CHARSET_ASCII";
		case 7: "CHARSET_EBCDIC";
	}
}

Table TDSVersionTable( value )
{
	switch( value )
	{
		// Depending upon direction (client -> server, server -> client), the version bytes can be reversed.
		case 0x04020000: FormatString("4.2 (%#x)",value);//big-endian [MS-SSTDS]
		case 0x04060000: FormatString("4.6 (%#x)",value);
		
		//SQL Server 7.0
		case 0x70000000: FormatString("7.0 (%#x)",value);
		case 0x07000000: FormatString("7.0 (%#x)",value);
		
		//SQL Server 2000
		case 0x71000000: FormatString("7.1 (%#x)",value);
		case 0x07010000: FormatString("7.1 (%#x)",value);
		
		//SQL Server 2000 SP1
		case 0x71000001: FormatString("7.1 (%#x)",value);
		
		//SQL Server 2005
		case 0x72090002: FormatString("7.2 (%#x)",value);
		
		//SQL Server *2008
		case 0x730A0003: FormatString("7.3 (%#x)",value);
		
		//SQL Server 2008
		case 0x730B0003: FormatString("7.3 (%#x)",value);
		
		default:         FormatString("Undefined TDS version(%#x)",value);
	}
}

Table TDSVersionShortNameTable( value )
{
	switch( value )
	{
		// Depending upon direction (client -> server, server -> client), the version bytes can be reversed.
		case 0x04020000: 4.2;//big-endian [MS-SSTDS]
		case 0x04060000: 4.6;
		case 0x00000070: 7.0;
		case 0x70000000: 7.0;
		case 0x71000000: 7.1;
		case 0x71000001: 7.1;
		case 0x07010000: 7.1;
		case 0x07000000: 7.1;
		case 0x02000972: 7.2;
		case 0x72090002: 7.2;
		case 0x730A0003: 7.3;
		case 0x730B0003: 7.3;
		default:         FormatString("Undefined TDS version(%#x)",value);
	}
}

struct TDSLoginPacket7
{
	// Login7	:=	Length,
	//	TDSVersion,
	//	PacketSize,
	//	ClientProgVer,
	//	ClientPID,
	//	ConnectionID,
	//	OptionFlags1,
	//	OptionFlags2,
	//	TypeFlags,
	//	OptionFlags3,
	//	ClientTimZone,
	//	ClientLCID,
	//	OffsetLength,
	//	Data;

	// Length	:=	UINT32;
	// TDSVersion	:=	UINT32;
	// PacketSize	:=	UINT32;
	// ClientProgVer	:=	UINT32;
	// ClientPID	:=	UINT32;
	// ConnectionID	:=	UINT32;

	[Login7Position = FrameOffset]
	UINT32 Length;
	// Last byte of TDSVersion (the previous field) is the TDS major version since data is sent in little endian form.
	[Property.TDSVersionValue]
	[Property.TDSVersion = TDSVersionShortNameTable(TDSVersion)]
	[Property.TDSStringUnitLen = (Property.TDSVersion < 7.0) ? 1 : 2, 
		Property.TDSStringType = (Property.TDSVersion < 7.0) ? 0 : 1]
	UINT32 TDSVersion = TDSVersionTable( this );		
	UINT32 TDSPacketSize;
	UINT32 ClientProgramVersion;
	UINT32 ClientPID;
	UINT32 ConnectionID;

	// fByteorder	:=	BIT;
	// fChar	:=	BIT;
	// fFloat	:=	BIT, BIT;
	// fDumpLoad	:=	BIT;
	// fUseDB	:=	BIT;
	// fDatabase	:=	BIT;
	// fSetLang	:=	BIT;
	// OptionFlags1	:=	fByteorder, fChar, fFloat, fDumpLoad, fUseDB, fDatabase, fSetLang;

	UINT8   OptionFlags1
	{
		UINT8 fByteorder:1 = FormatString("(%s) %s", this.ToBitString, this ? "ORDER_68000" : "ORDER_X86");
		UINT8 fChar:1 = FormatString("     (%s) %s", this.ToBitString, this ? "CHARSET_EBDDIC" : "CHARSET_ASCII");
		UINT8 fFloat:2 = FormatString("    (%s) %s", this.ToBitString, this == 0 ? "FLOAT_IEEE_754" : ( this == 1 ? "FLOAT_VAX" : "ND5000"));
		UINT8 fDumpLoad:1 = FormatString(" (%s) %s", this.ToBitString, this ? "DUMPLOAD_OFF" : "DUMPLOAD_ON");
		UINT8 fUseDB:1 = FormatString("    (%s) %s", this.ToBitString, this ? "USE_DB_OFF" : "USE_DB_ON");
		UINT8 fDatabase:1 = FormatString(" (%s) %s", this.ToBitString, this ? "INIT_DB_FATAL" : "INIT_DB_WARN");
		UINT8 fSetLang:1 = FormatString("  (%s) %s", this.ToBitString, this ? "SET_LANG_ON" : "SET_LANG_OFF");
	};

	// fLanguage	:=	BIT;
	// fODBC	:=	BIT;
	// fUserType	:=	BIT, BIT, BIT;
	// fIntSecurity	:=	BIT;
	// OptionFlags2	:=	fLanguage, fODBC, FRESERVEDBIT, FRESERVEDBIT, fUserType, fIntSecurity;

	UINT8   OptionFlags2
	{
		UINT8 fLanguage:1 = FormatString("   (%s) %s", this.ToBitString, this ? "INIT_LANG_FATAL" : "INIT_LANG_WARN");
		UINT8 fODBC:1 = FormatString("       (%s) %s", this.ToBitString, this ? "ODBC_ON" : "ODBC_OFF");
		UINT8 FRESERVEDBIT:2 = FormatString("(%s) %s", this.toBitString, "Unused Bit");
		UINT8 fUserType:3 = FormatString("   (%s) %s", this.ToBitString, this == 0 ? "USER_NORMAL！regular logins" : ( this == 1 ? "USER_SERVER！reserved" : (this == 2 ? "USER_REMUSER！DQ login" :"USER_SQLREPL！replication logi")));
		UINT8 fIntSecurity:1 = FormatString("(%s) %s", this.ToBitString, this ? "INTEGRATED_SECURITY_ON" : "INTEGRATED_SECURTY_OFF");
	};

	// fSQLType	:=	BIT, BIT, BIT, BIT;
	// fOLEDB	:=	BIT;
	// TypeFlags	:=	fSQLType, fOLEDB, FRESERVEDBIT, FRESERVEDBIT, FRESERVEDBIT;

	UINT8   TypeFlags
	{
		UINT8 fSQLType:4 = FormatString("    (%s) %s", this.ToBitString, this ? "SQL_TSQL" : "SQL_DFLT");
		UINT8 fOLEDB:1 = FormatString("      (%s) %s", this.ToBitString, this ? "OLEDB_ON" : "OLEDB_OFF");
		UINT8 FRESERVEDBIT:3 = FormatString("(%s) %s",this.toBitString,"Unused Bit");
	};

	// fChangePassword		:= BIT;
	// fUserInstance			:= BIT;
	// fSendYukonBinaryXML	:= BIT;

	// OptionFlags3	:=	fChangePassword, fSendYukonBinaryXML,
	// 	fUserInstance, FRESERVEDBIT,
	// 	FRESERVEDBIT, FRESERVEDBIT,
	// 	FRESERVEDBIT, FRESERVEDBIT;

	UINT8   OptionFlags3
	{
		UINT8 fChangePassword:1 = FormatString("          (%s) %s", this.ToBitString, this ? "Request to change login¨s password" : "No change request");
		UINT8 fSendYukonBinaryXML:1 = FormatString("      (%s) %s", this.ToBitString, this ? "XML data type instances are returned as binary XML" : "XML data type instances are NOT returned as binary XML");
		UINT8 fUserInstance:1 = FormatString("            (%s) %s", this.ToBitString, this ? "Client is requesting separate process to be spawned as user instance" : "Client is NOT requesting separate process to be spawned as user instance");
		UINT8 fUnknownCollationHandling:1 = FormatString("(%s) %s", this.ToBitString, this ? "The server MAY send any collation that fits in the storage space" : "The server MUST restrict the collations sent to a specific set of collations");
		UINT8 FRESERVEDBIT:4 = FormatString("             (%s) %s",this.toBitString,"Unused Bit");
	};

	// ClientTimeZone	:=	UINT32;
	UINT32   ClientTimeZone;

	// ClientLCID	:=	LCID, ColFlags, Version;
	// LCID	:=	20 * BIT;
	// ColFlags	:=	fIgnoreCase, fIgnoreAccent, fIgnoreWidth, fIgnoreKana, fBinary, FRESERVEDBIT, FRESERVEDBIT, FRESERVEDBIT;
	// Version	:=	4 * BIT;
	struct   ClientLCID
	{
		UINT24 LCID:20;
		UINT24 fIgnoreCase:1;
		UINT24 fIgnoreAccent:1;
		UINT24 fIgnoreWidth:1;
		UINT24 fIgnoreKana:1;
		UINT8 fBinary:1;
		UINT8 FRESERVEDBIT:3;
		UINT8 Version:4;
	};

	// OffsetLength	:=	ibHostName,
	//	cchHostName,
	//	ibUserName,
	//	cchUserName,
	//	ibPassword,
	//	cchPassword,
	//	ibAppName,
	//	cchAppName,
	//	ibServerName,
	//	cchServerName,
	//	ibUnused,
	//	cchUnused,
	//	ibCltIntName,
	//	cchCltIntName,
	//	ibLanguage,
	//	cchLanguage,
	//	ibDatabase,
	//	cchDatabase,
	//	ClientID,
	//	ibSSPI,
	//	cbSSPI,
	//	ibAtchDBFile,
	//	cchAtchDBFile,
	//	ibChangePassword,
	//	cchChangePassword,
	//	cbSSPILong;

	struct TDSOffsetLength
	{
		// remember offset/lengths in attributes in order to reuse them in the data section
		// ibHostName	:=	UINT16;
		// cchHostName	:=	UINT16;
		[ibHostName]
		UINT16   ibHostName;
		[cchHostName]
		UINT16   cchHostName;

		// ibUserName	:=	UINT16;
		// cchUserName	:=	UINT16;
		[ibUserName]
		UINT16   ibUserName;
		[cchUserName]
		UINT16   cchUserName;

		// ibPassword	:=	UINT16;
		// cchPassword	:=	UINT16;
		[ibPassword]
		UINT16   ibPassword;
		[cchPassword]
		UINT16   cchPassword;

		// ibAppName	:=	UINT16;
		// cchAppName	:=	UINT16;
		[ibAppName]
		UINT16   ibAppName;
		[cchAppName]
		UINT16   cchAppName;

		// ibServerName	:=	UINT16;
		// cchServerName	:=	UINT16;
		[ibServerName]
		UINT16   ibServerName;
		[cchServerName]
		UINT16   cchServerName;

		// ibUnused	:=	UINT16;
		// cchUnused	:=	UINT16;
		[ibUnused]
		UINT16   ibUnused;
		[cchUnused]
		UINT16   cchUnused;

		// ibCltIntName	:=	UINT16;
		// cchCltIntName	:=	UINT16;
		[ibCltIntName]
		UINT16   ibCltIntName;
		[cchCltIntName]
		UINT16   cchCltIntName;

		// ibLanguage	:=	UINT16;
		// cchLanguage	:=	UINT16;
		[ibLanguage]
		UINT16   ibLanguage;
		[cchLanguage]
		UINT16   cchLanguage;

		// ibDatabase	:=	UINT16;
		// cchDatabase	:=	UINT16;
		[ibDatabase]
		UINT16   ibDatabase;
		[cchDatabase]
		UINT16   cchDatabase;

		// ClientID	:=	UINT8, UINT8, UINT8, UINT8, UINT8, UINT8;
		UINT8  ClientID[6];

		// ibSSPI	:=	UINT16;
		// cbSSPI	:=	UINT16;
		[ibSSPI]
		UINT16   ibSSPI;
		[cbSSPI]
		UINT16   cbSSPI;

		// ibAtchDBFile	:=	UINT16;
		// cchAtchDBFile	:=	UINT16;
		[ibAtchDBFile]
		UINT16   ibAtchDBFile;
		[cchAtchDBFile]
		UINT16   cchAtchDBFile;

		switch
		{
			case Property.TDSVersion >= 7.2:
				// These next three fields were extensions to fixed portion of 
				// login record introduced in TDS 7.2.
				_struct
				{
					//ibChangePassword:=UINT16;	
					//cchChangePassword:=UINT16;
					[ibChangePassword]
					UINT16   ibChangePassword;
					[cchChangePassword]
					UINT16   cchChangePassword;

					//cbSSPILong	:=UINT32;
					[cbSSPILong]
					UINT32   cbSSPILong;
				}
			default:
				// With TDS 7.1 and earlier login record these fields are missing, 
				// set them all to zeros.
				[ibChangePassword = 0]
				[cchChangePassword = 0]
				[cbSSPILong = 0]
				_struct {}
		}
	}

	// Now dump the non-fixed login fields in data portion of login packet.
	[DataFieldByteOrder = LittleEndian]
	_struct
	{
		UnicodeString(Property.cchHostName) HostName;
		UnicodeString(Property.cchUserName) UserName;
		UINT8 Password[Property.cchPassword*2] = FormatString("Length=%u", Property.cchPassword*2);
		UnicodeString(Property.cchAppName) AppName;
		UnicodeString(Property.cchUnused) Unused;
		UnicodeString(Property.cchServerName) ServerName;
		UnicodeString(Property.cchCltIntName) CltIntName;
		UnicodeString(Property.cchLanguage) Language;
		UnicodeString(Property.cchDatabase) Database;
		UnicodeString(Property.cchAtchDBFile) AttachDbFileName;
		UINT8 ChangePassword[Property.cchChangePassword*2] = FormatString("Length=%u", Property.cchChangePassword*2);
	}
	
	// Trailing sspi bytes length is cbSSPI if cbSSPI < 0xFFFF, otherwise it is cbSSPILong.
	[cbSSPIActual = (Property.cbSSPI == 0xFFFF) ? Property.cbSSPILong : Property.cbSSPI]
	UINT8 SSPI[Property.cbSSPIActual] = FormatString("Length=%u", Property.cbSSPIActual);
}

Table TDSPreLoginOptionTypeTable(value)
{
	switch (value) 
	{
		//			VERSION		0x00	PL_OPTION_DATA :=  UL_VERSION, US_SUBBUILD;
		case 0x00: FormatString("Version %d (%#x)",value,value);
		//			ENCRYPTION	0x01	PL_OPTION_DATA :=  B_FENCRYPTION;
		case 0x01: FormatString("Encryption %d (%#x)",value,value);
		//			INSTOPT		0x02	PL_OPTION_DATA :=  B_INSTVALIDITY;
		case 0x02: FormatString("InstOpt %d (%#x)",value,value);
		//			THREADID	0x03	PL_OPTION_DATA :=  UL_THREADID;
		case 0x03: FormatString("ThreadId %d (%#x)",value,value);
		//			MARS		0x04	PL_OPTION_DATA :=  B_MARS;
		case 0x04: FormatString("MARS %d (%#x)",value,value);
		//			TERMINATOR	0xFF	TERMINATOR does not include length and offset specifiers.
		case 0xFF: FormatString("Terminator %d (%#x)",value,value);
		default:   FormatString("Undefined %d (%#x)",value,value);     
	}
}

Table TDSEncryptOptions(value)
{
	switch (value) 
	{
		case 0x00: FormatString("ENCRYPT_OFF %d (%#x)",value,value);
		case 0x01: FormatString("ENCRYPT_ON %d (%#x)",value,value);
		case 0x02: FormatString("ENCRYPT_NOT_SUP %d (%#x)",value,value);
		case 0x03: FormatString("ENCRYPT_REQ %d (%#x)",value,value);
		case 0x04: FormatString("ENCRYPT_LOGIN %d (%#x)",value,value);
		default:   FormatString("Undefined encryption option %d (%#x)",value,value);     
	}
}

struct TDSPreLoginPacket(PreloginAdjustmentByte)
{
	// Caller may pass in non-zero PreloginAdjustmentByte to adjust the offset of where to start
	// parsing the data portion of this packet.  Depends on whether or not caller sniffed in one byte
	// to detect the packet type (response parsing will do this).
	[FrameOffset = FrameOffset-PreloginAdjustmentByte]
	[PreloginStart = FrameOffset-PreloginAdjustmentByte]

	// PRELOGIN		:=	{ PRELOGIN_OPTION },
	// { PL_OPTION_DATA };

	switch (UINT8( Framedata, Offset ))
	{
		// If first byte is 0x00 -> 0x04, we know this is a prelogin options packet.
		// Any other bytes here means we have prelogin ssl payload packet.
		case 0x00:
		case 0x01:
		case 0x02:
		case 0x03:
		case 0x04:
			struct PreloginOptions
			{
				// PRELOGIN_OPTION	:=	PL_OPTION_TOKEN,
				//						PL_OFFSET,
				//						PL_OPTION_LENGTH;
				struct PreloginOptionTokens = ""
				{
					[DataFieldByteOrder = BigEndian]
					while Option[!(UINT8( Framedata, Offset ) == 0xFF)] 
					{ // read options until terminator is reached
						UINT8 TokenType = TDSPreLoginOptionTypeTable(this);
						switch (TokenType)
						{
							case 0x00:
								// version
								struct VersionOffsetLength
								{
									[VersionOffset]
									UINT16 VersionOffset;
									[VersionLength]
									UINT16 VersionLength;
								}
							case 0x01:
								// encryption
								struct EncryptionOffsetLength
								{
									[EncryptionOffset]
									UINT16 EncryptionOffset;
									[EncryptionLength]
									UINT16 EncryptionLength;
								}
							case 0x02:
								// instance
								struct InstOptOffsetLength
								{
									[InstOptOffset]
									UINT16 InstOptOffset;
									[InstOptLength]
									UINT16 InstOptLength;
								}
							case 0x03:
								// thread id
								struct ThreadIDOffsetLength
								{
									[ThreadIDOffset]
									UINT16 ThreadIDOffset;
									[ThreadIDLength]
									UINT16 ThreadIDLength;
								}
							case 0x04:
								// mars
								struct MARSOffsetLength
								{
									[MARSOffset]
									UINT16 MARSOffset;
									[MARSLength]
									UINT16 MARSLength;
								} // default - if we get here stream is invalid
							default: UINT8 InvalidPreloginOption;
						}
					}
					UINT8 Terminator; // consume the UINT8 at which the loop above stopped
				} // PreloginOptionTokens

				// Now display all the prelogin tokens that we read given the offsets from above.
				// We are now in the "data" portion of the prelogin packet in other words.
				// Note the server will send these tokens in order as listed below, but this is not 
				// required by the spec.
				struct PreloginOptionData
				{
					switch
					{
						case !IsValueNone(Property.VersionLength) && Property.VersionLength != 0:
							struct VersionData
							{
								//  PL_OPTION_DATA :=  UL_VERSION, US_SUBBUILD;
								//	UL_VERSION		:=	UINT32;
								//  US_SUBBUILD		:=	UINT16;
								UINT32 Version;
								UINT16 SubBuild;
							}
					}

					switch
					{
						case !IsValueNone(Property.EncryptionLength) && Property.EncryptionLength != 0:
							struct EncryptionData
							{
								//	B_FENCRYPTION	:=	UINT8;
								UINT8 Encryption = TDSEncryptOptions(UINT8(FrameData, PreloginStart+Property.EncryptionOffset));
							}
					}

					switch
					{
						case !IsValueNone(Property.InstOptLength) && Property.InstOptLength != 0:
							struct InstOptData
							{
								//	B_INSTVALIDITY	:=	{ UINT8 }, 0x00;
								AsciiString(Property.InstOptLength) InstanceValidity;
							}
					}

					switch
					{
						case !IsValueNone(Property.ThreadIDLength) && Property.ThreadIDLength != 0:
							struct ThreadIDData
							{
								//	UL_THREADID		:=	UINT32;
								UINT32 ThreadId;
							}
					}

					switch
					{
						case !IsValueNone(Property.MARSLength) && Property.MARSLength != 0:
							struct MARSData
							{
								//	B_MARS		:=	UINT8;
								UINT8 MARS;
							}
					}
				} // struct PreloginOptionData
			} // struct PreloginOptions
		default:
			// All other prelogin packets are SSL negotiation packets.
			[DataFieldByteOrder = BigEndian]
			SSLVersionSelector TLSSSLData;
	}
}

Table TDSEnvChangeTable( value )
{
	switch( value )
	{
		case 1: "Database";
		case 2: "Language";
		case 3: "Character set";
		case 4: "Packet size";
		case 5: "Unicode data sorting local id";
		case 6: "Unicode data sorting comparison flags";
		case 7: "SQL Collation";
		case 8: "Begin Transaction";
		case 9: "Commit Transaction";
		case 10: "Rollback Transaction";
		case 11: "Enlist DTC Transaction";
		case 12: "Defect Transaction";
		case 13: "Real Time Log Shipping";
		case 15: "Promote Transaction";
		case 16: "Transaction Manager Address";
		case 17: "Transaction ended";
		case 18: "Sp_resetconnection Completion Acknowledgement";
		case 19: "Name of user instance started per login request";
	}
}

Table TDSResponseTypeTable( value )
{
	switch( value )
	{
		// Prelogin response will always start with one of tokens 0x00..0x04.
		// The current server implementations alway responds with 0x00 first but 
		// tds spec is more flexible and allows any of 0x00 -> 0x04 to start (in any order).
		case 0x00: "PRELOGIN";
		case 0x01: "PRELOGIN";
		case 0x02: "PRELOGIN";
		case 0x03: "PRELOGIN";
		case 0x04: "PRELOGIN";

		// 0x14 and 0x16 are common PRELOGIN SSL header bytes.
		case 0x14: "PRELOGIN";
		case 0x16: "PRELOGIN";

		case 0x60: "DEBUG_CMD"; 
		case 0x88: "ALTMETADATA"; 
		case 0x78: "OFFSET"; 
		case 0x79: "RETURNSTATUS"; 
		case 0x81: "COLMETADATA"; 
		case 0xA4: "TABNAME"; 
		case 0xA5: "COLINFO"; 
		case 0xA9: "ORDER"; 
		case 0xAA: "ERROR"; 
		case 0xAB: "INFO"; 
		case 0xAC: "RETURNVALUE"; 
		case 0xAD: "LOGINACK"; 
		case 0xD1: "ROW"; 
		case 0xD3: "ALTROW"; 
		case 0xE3: "ENVCHANGE";
		case 0xED: "SSPI";
		case 0xFD: "DONE";  
		case 0xFE: "DONEPROC"; 
		case 0xFF: "DONEINPROC"; 
		// [MS-SSTDS]
		case 0xa0: "COLNAME";
		case 0xa1: "COLFMT";
		case 0xa7: "ALTNAME";
		case 0xa8: "ALTFMT";

		default:   FormatString("Undefined %d (%#x)",value,value);     
	}
}

// Returns status code string for CurCmd
Table TDSCurCmdType(value)
{
	switch( value )
	{
		case 0x03: "COLDEF";
		case 0x05: "CNST";
		case 0x08: "NOP";
		case 0x09: "AOPCNTB";
		case 0x0a: "AOPCNTBU";
		case 0x0b: "ISNOT";
		case 0x0d: "EQ_ANSI";
		case 0x1a: "REFERENCES";
		case 0x1b: "SIG_HANDLER";
		case 0x1c: "TM_REQUEST";
		case 0x1d: "VARCHEQ";
		case 0x1e: "VARCHNE";
		case 0x1f: "CKPT_SLEEP";
		case 0x20: "OPENCURSOR";
		case 0x21: "FETCHCURSOR";
		case 0x23: "LOCK_MONITOR";
		case 0x24: "DB_MIRROR";
		case 0x26: "DB_STARTUP";
		case 0x28: "VAR";
		case 0x29: "LOADTABLE";
		case 0x2a: "COLFMTOLD";
		case 0x2b: "CLOSECURSOR";
		case 0x2c: "DEALLOCCURSOR";
		case 0x2d: "LOG_WRITER";
		case 0x2e: "CNST_CREATE";
		case 0x30: "AOPSTDEV";
		case 0x31: "AOPSTDEVP";
		case 0x32: "AOPVAR";
		case 0x33: "AOPVARP";
		case 0x34: "TASK_MGR";
		case 0x39: "DUMPTABLE";
		case 0x3b: "GHOSTCLEANUP";
		case 0x3e: "AUTOSHRINK";
		case 0x3f: "AUTOBPL";
		case 0x41: "MINUS";
		case 0x42: "NOT";
		case 0x43: "CNVTI1";
		case 0x44: "CNVTI2";
		case 0x45: "CNVTI4";
		case 0x46: "BUILTIN";
		case 0x47: "CNVTF8";
		case 0x48: "CNVTVBINARY";
		case 0x49: "CNVTBINARY";
		case 0x4a: "AOPONCEU";
		case 0x4b: "AOPCNT";
		case 0x4c: "AOPCNTU";
		case 0x4d: "AOPSUM";
		case 0x4e: "AOPSUMU";
		case 0x4f: "AOPAVG";
		case 0x50: "AOPAVGU";
		case 0x51: "AOPMIN";
		case 0x52: "AOPMAX";
		case 0x53: "AOPANY";
		case 0x54: "AOPONCE";
		case 0x55: "AOPASSIGN";
		case 0x56: "CNVTMONEY4";
		case 0x57: "CNVTDATE4";
		case 0x58: "CNVTF4";
		case 0x59: "CNVTBIT";
		case 0x5a: "BOOLNOT";
		case 0x5b: "CNVTNUME";
		case 0x5c: "CNVTDECML";
		case 0x5d: "SQLCASE";
		case 0x5e: "TABREF";
		case 0x5f: "CNVTI8";
		case 0x60: "DEBUG_CMD";
		case 0x61: "AOPANYNULL";
		case 0x62: "AOPGETRID";
		case 0x63: "AOPGROUPING";
		case 0x64: "CNVTNCHAR";
		case 0x65: "CNVTNVCHAR";
		case 0x66: "CNVTTEXT";
		case 0x67: "CNVTIMAGE";
		case 0x68: "CNVTDATTIM";
		case 0x69: "CNVTMONEY";
		case 0x6a: "CNVTSSVARIANT";
		case 0x6b: "CNVTNTEXT";
		case 0x6e: "AOPSCOREPROBAGG";
		case 0x6f: "AOPSCOREDETAGG";
		case 0x70: "SECOPT";
		case 0x71: "CNVTVCHAR";
		case 0x72: "AOPCHECKSUMAGG";
		case 0x73: "CNVTCHAR";
		case 0x74: "AOPCHECKSUMAGGU";
		case 0x75: "TPE";
		case 0x76: "COMPHD";
		case 0x77: "SETUSER";
		case 0x78: "OFFSET";
		case 0x79: "RETURNSTATUS";
		case 0x7a: "AOPCHECKINDEX";
		case 0x7b: "CONSTRAINT";
		case 0x7c: "PROCID";
		case 0x7d: "UPDATECURSOR";
		case 0x7e: "DELETECURSOR";
		case 0x7f: "AOPSTATMAN";
		case 0x80: "RESDOM";
		case 0x81: "EQ";
		case 0x82: "LT";
		case 0x83: "LE";
		case 0x84: "GT";
		case 0x85: "GE";
		case 0x86: "NE";
		case 0x87: "IS";
		case 0x88: "AND";
		case 0x89: "OR";
		case 0x8a: "ADD";
		case 0x8b: "SUB";
		case 0x8c: "MUL";
		case 0x8d: "DIV";
		case 0x8e: "BYHEAD";
		case 0x8f: "AGHEAD";
		case 0x90: "CONCAT";
		case 0x91: "MOD";
		case 0x92: "ALL";
		case 0x93: "CHANGETRACK";
		case 0x94: "UNION";
		case 0x95: "EXCEPTSET";
		case 0x96: "INTERSECT";
		case 0x98: "RULE";
		case 0x99: "DENY";
		case 0x9a: "SEQUENCE";
		case 0x9c: "BOOLAND";
		case 0x9d: "BOOLOR";
		case 0x9e: "GETBIT";
		case 0x9f: "BOOLXOR";
		case 0xa0: "COLNAME";
		case 0xa1: "COLFMT";
		case 0xa2: "ASSIGN";
		case 0xa4: "TABNAME";
		case 0xa5: "COLINFO";
		case 0xa6: "MULTARG";
		case 0xa7: "ALTNAME";
		case 0xa8: "ALTFMT";
		case 0xa9: "ORDER";
		case 0xaa: "ERROR";
		case 0xab: "INFO";
		case 0xac: "RETURNVALUE";
		case 0xad: "LOGINACK";
		case 0xae: "SQL_CONTROL";
		case 0xaf: "ALTCONTROL";
		case 0xb0: "DROPSCHEMA";
		case 0xb1: "INVOKE";
		case 0xb2: "FUNCCREATE";
		case 0xb3: "FUNCDESTROY";
		case 0xb4: "ROOT";
		case 0xb5: "ASMCREATE";
		case 0xb6: "CMD";
		case 0xb7: "SETIDENTON";
		case 0xb8: "SETIDENTOFF";
		case 0xb9: "SETON";
		case 0xba: "SETOFF";
		case 0xbb: "SETSTATON";
		case 0xbc: "SETSTATOFF";
		case 0xbd: "SETRCON";
		case 0xbe: "SETTSIZE";
		case 0xbf: "SHUTDOWN";
		case 0xc0: "COND";
		case 0xc1: "SELECT";
		case 0xc2: "SELECT_INTO";
		case 0xc3: "INSERT";
		case 0xc4: "DELETE_STMT";
		case 0xc5: "UPDATE";
		case 0xc6: "TABCREATE";
		case 0xc7: "TABDESTROY";
		case 0xc8: "INDCREATE";
		case 0xc9: "INDDESTROY";
		case 0xca: "GOTO";
		case 0xcb: "DBCREATE";
		case 0xcc: "DBDESTROY";
		case 0xcd: "GRANT";
		case 0xce: "REVOKE";
		case 0xcf: "VIEWCREATE";
		case 0xd0: "VIEWDESTROY";
		case 0xd1: "ROW";
		case 0xd2: "ABORT";
		case 0xd3: "ALTROW";
		case 0xd4: "BEGINXACT";
		case 0xd5: "ENDXACT";
		case 0xd6: "SAVEXACT";
		case 0xd7: "DBEXTEND";
		case 0xd8: "ALTERTAB";
		case 0xd9: "AUDIT";
		case 0xda: "AUDIT_INTO";
		case 0xdb: "RETURN";
		case 0xdc: "CONFIG";
		case 0xdd: "TRIGCREATE";
		case 0xde: "PROCCREATE";
		case 0xdf: "PROCDESTROY";
		case 0xe0: "EXECUTE";
		case 0xe1: "TRIGDESTROY";
		case 0xe2: "DBOPEN";
		case 0xe3: "ENVCHANGE";
		case 0xe4: "DUMPDB";
		case 0xe5: "LOADDB";
		case 0xe6: "DBCC_CMD";
		case 0xe7: "CHECKPOINT";
		case 0xe8: "DECLARE";
		case 0xe9: "DEFAULTCREATE";
		case 0xea: "TRUNCATETABLE";
		case 0xeb: "DUMPXACT";
		case 0xec: "RULECREATE";
		case 0xed: "RULEDESTROY";
		case 0xee: "DEFAULTDESTROY";
		case 0xef: "LOADXACT";
		case 0xf0: "BULKINSERT";
		case 0xf1: "UPDATESTATS";
		case 0xf2: "DISKBUILD";
		case 0xf3: "WAITFOR";
		case 0xf4: "UDF";
		case 0xf5: "KILL";
		case 0xf6: "RAISERROR";
		case 0xf7: "PRINT";
		case 0xf8: "UPDATETEXT";
		case 0xf9: "SET";
		case 0xfa: "LOADVOL";
		case 0xfb: "READTEXT";
		case 0xfc: "WRITETEXT";
		case 0xfd: "DONE";
		case 0xfe: "DONEPROC";
		case 0xff: "LAZYWRITER";
		case 0x100: "STATSDESTROY";
		case 0x101: "SETXCTLVL";
		case 0x103: "TRACECREATE";
		case 0x104: "TRACESETSTATUS";
		case 0x105: "TRACESETEVENT";
		case 0x106: "TRACESETFILTER";
		case 0x107: "TRACEINFO";
		case 0x108: "TRACEEVENTINFO";
		case 0x109: "TRACEFILTERINFO";
		case 0x10a: "TRACEDATA";
		case 0x10b: "TRACEGENEVENT";
		case 0x10c: "OBJIDUPDATE";
		case 0x10d: "TRACETABLE";
		case 0x10e: "ASMDESTROY";
		case 0x10f: "ASMALTER";
		case 0x110: "TYPEDESTROY";
		case 0x111: "TYPECREATE";
		case 0x112: "CLRPROCEDURECREATE";
		case 0x113: "CLRFUNCTIONCREATE";
		case 0x114: "SERVICEALTER";
		case 0x115: "MSGTYPECREATE";
		case 0x116: "MSGTYPEDESTROY";
		case 0x117: "MERGE_STMT";
		case 0x118: "BRKRCMPLTNHDLR";
		case 0x119: "CONTRACTCREATE";
		case 0x11a: "CONTRACTDESTROY";
		case 0x11b: "SERVICECREATE";
		case 0x11c: "SERVICEDESTROY";
		case 0x11d: "QUEUECREATE";
		case 0x11e: "QUEUEDESTROY";
		case 0x11f: "QUEUEALTER";
		case 0x120: "BEGINMONOLOG";
		case 0x121: "BEGINDIALOG";
		case 0x122: "ENDCONVERSATION";
		case 0x123: "MOVECONVERSATION";
		case 0x124: "RECEIVE";
		case 0x125: "SEND";
		case 0x126: "FTXTINDEX_CREATE";
		case 0x127: "FTXTINDEX_ALTER";
		case 0x128: "FTXTINDEX_DROP";
		case 0x129: "PRTFUNCTIONCREATE";
		case 0x12a: "PRTFUNCTIONDROP";
		case 0x12b: "PRTSCHEMECREATE";
		case 0x12c: "PRTSCHEMEDROP";
		case 0x12d: "ENABLETRIGGER";
		case 0x12e: "DISABLETRIGGER";
		case 0x130: "FTXTCATALOG_CREATE";
		case 0x131: "FTXTCATALOG_ALTER";
		case 0x132: "FTXTCATALOG_DROP";
		case 0x135: "XMLSCHEMACREATE";
		case 0x136: "XMLSCHEMAALTER";
		case 0x137: "XMLSCHEMADROP";
		case 0x138: "ENDPOINTCREATE";
		case 0x139: "ENDPOINTALTER";
		case 0x13a: "ENDPOINTDROP";
		case 0x13b: "USERCREATE";
		case 0x13c: "USERALTER";
		case 0x13d: "USERDROP";
		case 0x13e: "BRKRMSGXMITTER";
		case 0x13f: "ROLECREATE";
		case 0x140: "ROLEALTER";
		case 0x141: "ROLEDROP";
		case 0x142: "APPROLECREATE";
		case 0x143: "APPROLEALTER";
		case 0x144: "APPROLEDROP";
		case 0x145: "LOGINCREATE";
		case 0x146: "LOGINALTER";
		case 0x147: "LOGINDROP";
		case 0x148: "SYNONYMCREATE";
		case 0x149: "SYNONYMDROP";
		case 0x14a: "CREATESCHEMA";
		case 0x14b: "ALTERSCHEMA";
		case 0x14c: "AGGCREATE";
		case 0x14d: "AGGDESTROY";
		case 0x14e: "CLRTRIGGERCREATE";
		case 0x14f: "PRTFUNCTIONALTER";
		case 0x150: "PRTSCHEMEALTER";
		case 0x151: "INDALTER";
		case 0x152: "GET_CONVGROUP";
		case 0x153: "BRKRMSGDSPTCHR";
		case 0x154: "BRKREVENTHNDLR";
		case 0x155: "BRKRINITIALIZER";
		case 0x156: "BRKRTASK";
		case 0x157: "ROUTECREATE";
		case 0x158: "ROUTEALTER";
		case 0x159: "CONVTIMERBEGIN";
		case 0x15a: "ROUTEDESTROY";
		case 0x15b: "XE_DISPATCHER";
		case 0x15c: "RESOURCEMONITOR";
		case 0x15d: "BEGINTRY";
		case 0x15e: "BEGINCATCH";
		case 0x15f: "ENDTRYCATCH";
		case 0x160: "EVENTNOTIFICATIONCREATE";
		case 0x161: "EVENTNOTIFICATIONDROP";
		case 0x162: "XMLINDEXCREATE";
		case 0x163: "XE_TIMER";
		case 0x164: "BROKER_PRIORITY_CREATE";
		case 0x165: "DMLINTERNAL";
		case 0x166: "BINDINGCREATE";
		case 0x167: "BINDINGALTER";
		case 0x168: "BINDINGDESTROY";
		case 0x169: "TRCQUEUETASK";
		case 0x16a: "FTXT_CATMON_TASK";
		case 0x16b: "FTXT_IGATH_TASK";
		case 0x16c: "FTXT_AUTOPROP_TASK";
		case 0x16d: "FTXT_AUTOPROPMON_TASK";
		case 0x16e: "MSGTYPEALTER";
		case 0x170: "CERTCREATE";
		case 0x171: "CERTDROP";
		case 0x172: "CERTALTER";
		case 0x173: "FAKEGOTO";
		case 0x174: "SYSCACHEOBJECTS";
		case 0x175: "EXECUTEAS";
		case 0x176: "REVERT";
		case 0x177: "CERTDUMP";
		case 0x178: "RESTOREFILELISTONLY";
		case 0x179: "RESTOREVERIFYONLY";
		case 0x17a: "RESTOREREWINDONLY";
		case 0x17b: "RESTORELABELONLY";
		case 0x17c: "FLUSH_LAZY_COMMIT_CMD";
		case 0x17d: "SECDESCCREATE";
		case 0x17e: "SECDESCDROP";
		case 0x17f: "SECDESCALTER";
		case 0x182: "OBFUSKEYCREATE";
		case 0x183: "OBFUSKEYALTER";
		case 0x184: "OBFUSKEYDROP";
		case 0x185: "OBFUSKEYOPEN";
		case 0x186: "OBFUSKEYCLOSE";
		case 0x187: "OBFUSKEYCLOSEALL";
		case 0x188: "SRVMASTERKEYALTER";
		case 0x189: "SRVMASTERKEYDUMP";
		case 0x18a: "SRVMASTERKEYLOAD";
		case 0x18b: "ADDDROPCRYPTO";
		case 0x18c: "ALTERAUTHORIZATION";
		case 0x18d: "SELECTWITHOUTQUERY";
		case 0x18e: "DBCC_TABLE_CHECK";
		case 0x18f: "DBCC_TABLE_REPAIR";
		case 0x190: "DBCC_ALLOC_CHECK";
		case 0x191: "DBCC_ALLOC_REPAIR";
		case 0x192: "DBCC_SYSTABLE_CHECK";
		case 0x193: "DBCC_SYSTABLE_REPAIR";
		case 0x194: "DBCC_SSB_CHECK";
		case 0x195: "DBCC_CATALOG_CHECK";
		case 0x196: "DBCC_INDEXEDVIEW_CHECK";
		case 0x197: "DBCC_INDEXEDVIEW_REPAIR";
		case 0x198: "CREDENTIALCREATE";
		case 0x199: "CREDENTIALALTER";
		case 0x19a: "CREDENTIALDROP";
		case 0x19b: "MASTERKEYCREATE";
		case 0x19c: "MASTERKEYDROP";
		case 0x19d: "MASTERKEYOPEN";
		case 0x19e: "MASTERKEYCLOSE";
		case 0x19f: "MASTERKEYLOAD";
		case 0x1a0: "MASTERKEYDUMP";
		case 0x1a1: "MASTERKEYALTER";
		case 0x1a2: "MASTERKEYALLCLOSE";
		case 0x1a3: "ASYMKEYCREATE";
		case 0x1a4: "ASYMKEYDROP";
		case 0x1a5: "ASYMKEYOPEN";
		case 0x1a6: "ASYMKEYCLOSE";
		case 0x1a7: "ASYMKEYLOAD";
		case 0x1a8: "ASYMKEYDUMP";
		case 0x1a9: "ASYMKEYALTER";
		case 0x1aa: "ASYMKEYALLCLOSE";
		case 0x1ab: "DBM_MSGXMITTER";
		case 0x1ac: "DBCC_SHRINK_RECLAIM_SPACE";
		case 0x1ad: "DBCC_SHRINK_COMPACT_FILES";
		case 0x1ae: "DBCC_SHRINK_COMPACT_LOBS";
		case 0x1af: "RDB_DBCC_TABLE_CHECK";
		case 0x1b0: "RDB_DBCC_TABLE_REPAIR";
		case 0x1b1: "RDB_DBCC_ALLOC_CHECK";
		case 0x1b2: "RDB_DBCC_ALLOC_REPAIR";
		case 0x1b3: "RDB_DBCC_SYSTABLE_CHECK";
		case 0x1b4: "RDB_DBCC_SYSTABLE_REPAIR";
		case 0x1b5: "RDB_DBCC_SSB_CHECK";
		case 0x1b6: "RDB_DBCC_CATALOG_CHECK";
		case 0x1b7: "RDB_DBCC_INDEXEDVIEW_CHECK";
		case 0x1b8: "RDB_DBCC_INDEXEDVIEW_REPAIR";
		case 0x1b9: "USEDB";
		case 0x1ba: "UTPRINTF";
		case 0x1bb: "SECURITYAUDIT";
		case 0x1bc: "FSAGENT";
		case 0x1bd: "XEVENT_CREATE";
		case 0x1be: "XEVENT_ALTER";
		case 0x1bf: "XEVENT_DROP";
		case 0x1c0: "CREATE_RESOURCE_POOL";
		case 0x1c1: "ALTER_RESOURCE_POOL";
		case 0x1c2: "DROP_RESOURCE_POOL";
		case 0x1c3: "CREATE_RESOURCE_GROUP";
		case 0x1c4: "ALTER_RESOURCE_GROUP";
		case 0x1c5: "DROP_RESOURCE_GROUP";
		case 0x1c6: "ALTER_RESOURCE_GOVERNOR";
		case 0x1c7: "CRYPTOPROVCREATE";
		case 0x1c8: "CRYPTOPROVALTER";
		case 0x1c9: "CRYPTOPROVDROP";
		case 0x1ca: "DEK_CREATE";
		case 0x1cb: "DEK_ALTER";
		case 0x1cc: "DEK_DROP";
		case 0x1cd: "BROKER_PRIORITY_ALTER";
		case 0x1ce: "BROKER_PRIORITY_DROP";
		case 0x1cf: "CLONEREFRESH";
		case 0x1d0: "FAILUREMONITOR_HEARTBEAT";
		case 0x1d1: "MATRIXTCM";
		case 0x1d2: "FILTER_EXPRS";
		case 0x1d3: "COMPUTED_COLS";
		case 0x1d4: "SERVER_AUDIT_CREATE";
		case 0x1d5: "SERVER_AUDIT_ALTER";
		case 0x1d6: "SERVER_AUDIT_DROP";
		case 0x1d7: "AUDITSPECIFICATIONCREATE";
		case 0x1d8: "AUDITSPECIFICATIONALTER";
		case 0x1d9: "AUDITSPECIFICATIONDROP";
		case 0x1da: "FTXTSTOPLIST_CREATE";
		case 0x1db: "FTXTSTOPLIST_ALTER";
		case 0x1dc: "FTXTSTOPLIST_DROP";
		case 0x1dd: "TABVARCREATE";
		case 0x1de: "NOPFORCTE";
		case 0x1df: "INSERTEXEC";
		default: "Undefined";
	}
}

// Handles single part or multi-part TableName token.
// TDS 7.1 used a single part table name with dotted separators, i.e. "master.dbo.sysprocesses".
// TDS 7.2 and later send the table name in parts with one part for each section.
struct TDSMultiPartTableName
{
	UINT8 TableNameParts;
	struct TablePart[TableNameParts]
	{
		UINT16 TableNamePartLength;
		[DataFieldByteOrder = LittleEndian]
		UnicodeString (TableNamePartLength) TableNamePart;
	}
}

struct TDSSinglePartTableName
{
	UINT16 TableNameLength;
	[DataFieldByteOrder = LittleEndian]
	String(Property.TDSStringType, TableNameLength) TableName;
}

Table TDSAggregateOp( value )
{
	switch (value)
	{
		case 0x30 : FormatString("AOPSTDEV");	// Standard deviation (STDEV)
		case 0x31 : FormatString("AOPSTDEVP");	// Standard deviation of population (STDEVP)
		case 0x32 : FormatString("AOPVAR");		// Variance (VAR)
		case 0x33 : FormatString("AOPVARP");	// Variance of population (VARP)
		case 0x4b : FormatString("AOPCNT");		// Count of rows (COUNT)
		case 0x4d : FormatString("AOPSUM");		// Sum of the values in the rows (SUM)
		case 0x4f : FormatString("AOPAVG");		// Average of the values in the rows (AVG)
		case 0x51 : FormatString("AOPMIN");		// Minimum value of the rows (MIN)
		case 0x52 : FormatString("AOPMAX");		// Maximum value of the rows (MAX)
		default: FormatString("Undefined %d (%#x)",value,value);
	}
}

// ComputeData is used in the ALTMETADATA and ALTFMT token, part of the server response.
struct TDSComputeData 
{
	// ComputeData	:=	Op,
	// 		Operand,
	// 		UserType,
	// 		Flags,
	// 		TYPE_INFO,
	// 		[TableName],	
	// 		ColName;

	// Op	:=	UINT8;
	// Operand	:=	UINT16;
	// UserType	:=	UINT32;
	UINT8 Op = TDSAggregateOp(this);
	switch
	{
		case Property.TDSVersion >= 7.0:
			UINT16 Operand;
		default:
			UINT8 Operand8;
	}

	switch
	{
		case Property.TDSVersion >= 7.2:
			UINT32 UserType;
		default:
			UINT16 UserType16;
	}

	// fNullable	:=	BIT;
	// fCaseSen	:=	BIT;
	// usUpdateable	:=	BIT, BIT; //2-bit value
	// 0 = ReadOnly
	// 1 = ReadWrite
	// 2 = Unknown (maybe readonly, maybe readwrite)
	// fIdentity	:=	BIT;
	// fComputed	:=	BIT;
	// usReservedODBC:= BIT, BIT;
	// fFixedLenCLRType:= BIT;
	// usReserved	:= BIT, BIT, BIT, BIT, BIT, BIT;
	// Flags	:=	fNullable, fCaseSen, usUpdateable, fIdentity, fComputed, usReservedODBC, fFixedLenCLRType, usReserved, fUnset;

	switch
	{
		case Property.TDSVersion >= 7.2:
			UINT16 Flags72
			{
				UINT16 fNullable:1 = FormatString("       (%s) %s",this.toBitString, this ? "The column is nullable" : "The column is NOT nullable");
				UINT16 fCaseSen:1 = FormatString("        (%s) %s",this.toBitString, this ? "The column is case sensitive for searches" : "The column is NOT case sensitive for searches");
				UINT16 usUpdateable:2 = FormatString("    (%s) %s",this.toBitString, this == 0 ? "Column is read-only" : ( this == 1 ? "Column is read/write" : "Updateable is unknown"));
				UINT16 fIdentity:1 = FormatString("       (%s) %s",this.toBitString, this ? "The column is an identity column" : "The column is NOT an identity column");
				UINT16 fComputed:1 = FormatString("       (%s) %s",this.toBitString, this ? "The column is a COMPUTED column" : "The column is NOT a COMPUTED column");
				UINT16 usReservedODBC:2 = FormatString("  (%s) %s",this.toBitString, this ? "ODS gateways supporting the ODBC ODS gateway driver" : "ODS gateways NOT supporting the ODBC ODS gateway driver");
				UINT16 fFixedLenCLRType:1 = FormatString("(%s) %s",this.toBitString, this ? "The column is a fixed-length CLR UDT" : "The column is NOT a fixed-length CLR UDT");
				UINT16 usReserved:7 = FormatString("      (%s) %s",this.toBitString,"Unused Bit");
			};
		case Property.TDSVersion < 7.2 && Property.TDSVersion >= 7.0:
			UINT16 Flags70
			{
				UINT16 fNullable:1 = FormatString("       (%s) %s",this.toBitString, this ? "The column is nullable" : "The column is NOT nullable");
				UINT16 fCaseSen:1 = FormatString("        (%s) %s",this.toBitString, this ? "The column is case sensitive for searches" : "The column is NOT case sensitive for searches");
				UINT16 usUpdateable:2 = FormatString("    (%s) %s",this.toBitString, this == 0 ? "Column is read-only" : ( this == 1 ? "Column is read/write" : "Updateable is unknown"));
				UINT16 fIdentity:1 = FormatString("       (%s) %s",this.toBitString, this ? "The column is an identity column" : "The column is NOT an identity column");
				UINT16 FRESERVEDBIT1:1 = FormatString("   (%s) %s",this.toBitString, "SHOULD be set to %b0 and MUST be ignored on receipt.");
				UINT16 usReservedODBC:2 = FormatString("  (%s) %s",this.toBitString, this ? "ODS gateways supporting the ODBC ODS gateway driver" : "ODS gateways NOT supporting the ODBC ODS gateway driver");
				UINT16 FRESERVEDBIT2:1 = FormatString("   (%s) %s",this.toBitString, "SHOULD be set to %b0 and MUST be ignored on receipt.");
				UINT16 usReserved:7 = FormatString("      (%s) %s",this.toBitString,"Unused Bit");
			};
		default://[MS-SSTDS]
			UINT16 RowFlags42
			{
				UINT16 fNullable:1 = FormatString("     (%s) %s",this.toBitString, this ? "The column is nullable" : "The column is NOT nullable");
				UINT16 fCaseSen:1 = FormatString("      (%s) %s",this.toBitString, this ? "The column is case sensitive for searches" : "The column is NOT case sensitive for searches");
				UINT16 usUpdateable:2 = FormatString("  (%s) %s",this.toBitString, this == 0 ? "Column is read-only" : ( this == 1 ? "Column is read/write" : "Updateable is unknown"));
				UINT16 fIdentity:1 = FormatString("     (%s) %s",this.toBitString, this ? "The column is an identity column" : "The column is NOT an identity column");
				UINT16 FRESERVEDBIT:1 = FormatString("  (%s) %s",this.toBitString,"Unused Bit");
				UINT16 usReservedODBC:2 = FormatString("(%s) %s",this.toBitString, this ? "ODS gateways supporting the ODBC ODS gateway driver" : "ODS gateways NOT supporting the ODBC ODS gateway driver");
				UINT16 usReserved:8 = FormatString("    (%s) %s",this.toBitString,"Unused Bit");
			};
	}
	
	[Property.ALTMETADATATYPES$[Property.ALTMETADATAId, Property.ALTMETADATACOUNTER] = UINT8( Framedata, Offset )]
	[Property.ALTFMTTYPES$[Property.ALTFMTId] = UINT8( Framedata, Offset )]
	[Property.TDSComputerDataType = UINT8( Framedata, Offset )]
	switch (UINT8( Framedata, Offset ))
	{
		case 0xA5:
			[ALTMETADATALENGTH$[Property.ALTMETADATAId, Property.ALTMETADATACOUNTER] = UINT16(FrameData, FrameOffset +1)]
			[ALTFMTLENGTH$[Property.ALTFMTId] = UINT16(FrameData, FrameOffset +1)]struct{};
		case 0xA7:
			[ALTMETADATALENGTH$[Property.ALTMETADATAId, Property.ALTMETADATACOUNTER] = UINT16(FrameData, FrameOffset +1)]
			[ALTFMTLENGTH$[Property.ALTFMTId] = UINT16(FrameData, FrameOffset +1)]struct{};
		case 0xAD:
			[ALTMETADATALENGTH$[Property.ALTMETADATAId, Property.ALTMETADATACOUNTER] = 0]
			[ALTFMTLENGTH$[Property.ALTFMTId] = 0]struct{};
		case 0xAF:
			[ALTMETADATALENGTH$[Property.ALTMETADATAId, Property.ALTMETADATACOUNTER] = 0]
			[ALTFMTLENGTH$[Property.ALTFMTId] = 0]struct{};
		case 0xE7:
			[ALTMETADATALENGTH$[Property.ALTMETADATAId, Property.ALTMETADATACOUNTER] = UINT16(FrameData, FrameOffset +1)]
			[ALTFMTLENGTH$[Property.ALTFMTId] = UINT16(FrameData, FrameOffset +1)]struct{};
		case 0xEF:
			[ALTMETADATALENGTH$[Property.ALTMETADATAId, Property.ALTMETADATACOUNTER] = 0]
			[ALTFMTLENGTH$[Property.ALTFMTId] = 0]struct{};
		case 0xF1: 
			[ALTMETADATALENGTH$[Property.ALTMETADATAId, Property.ALTMETADATACOUNTER] = 0xFFFF]
			[ALTFMTLENGTH$[Property.ALTFMTId] = 0xFFFF]struct{};
		case 0xF0: 
			[ALTMETADATALENGTH$[Property.ALTMETADATAId, Property.ALTMETADATACOUNTER] = 0xFFFF]
			[ALTFMTLENGTH$[Property.ALTFMTId] = 0xFFFF]struct{};
	}
	TDSTypeInfo TDSTypeInfo;
	Switch
	{
		case Property.TDSComputerDataType == 0x22 || Property.TDSComputerDataType == 0x23 || Property.TDSComputerDataType == 0x63:
			switch
			{
				case Property.TDSTokenType == 0xA8:
					struct TableName42
					{
						UINT8 TableNameLength;
						[DataFieldByteOrder = LittleEndian]
						String(Property.TDSStringType, TableNameLength) TableName;
					}
				case Property.TDSVersion >= 7.2:
					TDSMultiPartTableName TDSMultiPartTableName;
				default:
					TDSSinglePartTableName TDSSinglePartTableName;
			}
	}
	[Property.ALTMETADATACOUNTER = Property.ALTMETADATACOUNTER + 1]
	switch
	{
		case Property.TDSVersion >= 7.0:
			struct
			{
				// ColName	:=	B_VARCHAR;
				UINT8 ColNameLength;
				[DataFieldByteOrder = LittleEndian]
				UnicodeString(ColNameLength) ColName;
			}
	}
}

struct TDSColumnData
{
	// ColumnData	:=	UserType,
	//	Flags,
	//	TYPE_INFO,
	//	TableName, // only if type is TEXT, NTEXT or IMAGE
	//	ColName
	switch
	{
		case Property.TDSVersion >= 7.2:
			UINT32 UserType;
		default:
			UINT16 UserType16;
	}
	// fNullable	:=	BIT;
	// fCaseSen	:=	BIT;
	// usUpdateable	:=	BIT, BIT; //2-bit value
	// 0 = ReadOnly
	// 1 = ReadWrite
	// 2 = Unknown (maybe readonly, maybe readwrite)
	// fIdentity	:=	BIT;
	// fComputed	:=	BIT;
	// usReservedODBC:= BIT, BIT;
	// fFixedLenCLRType:= BIT;
	// usReserved	:= BIT, BIT, BIT, BIT, BIT, BIT;
	// Flags	:=	fNullable, fCaseSen, usUpdateable, fIdentity, fComputed, usReservedODBC, fFixedLenCLRType, usReserved, fUnset;
	UINT16 Flags
	{
		UINT16 fNullable:1 = FormatString("       (%s) %s",this.toBitString, this ? "Column is nullable" : "Column is NOT nullable");
		UINT16 fCaseSen:1 = FormatString("        (%s) %s",this.toBitString, this ? "The column is case sensitive for searches" : "The column is NOT case sensitive for searches");
		UINT16 usUpdateable:2 = FormatString("    (%s) %s",this.toBitString, this == 0 ? "Column is read-only" : ( this == 1 ? "Column is read/write" : "Updateable is unknown"));
		UINT16 fIdentity:1 = FormatString("       (%s) %s",this.toBitString, this ? "The column is an identity column" : "The column is NOT an identity column");
		UINT16 fComputed:1 = FormatString("       (%s) %s",this.toBitString, this ? "The column is a COMPUTED column" : "The column is NOT a COMPUTED column");
		UINT16 usReservedODBC:2 = FormatString("  (%s) %s",this.toBitString, this ? "ODS gateways supporting the ODBC ODS gateway driver" : "ODS gateways NOT supporting the ODBC ODS gateway driver");
		UINT16 fFixedLenCLRType:1 = FormatString("(%s) %s",this.toBitString, this ? "The column is a fixed-length CLR UDT" : "The column is NOT a fixed-length CLR UDT");
		UINT16 usReserved:6 = FormatString("      (%s) %s",this.toBitString,"Unused Bit");
		UINT16 fUnset:1 = FormatString("          (%s) %s",this.toBitString,"Unused Bit");
	};
	
	[Property.COLMETADATATYPES$[Property.COLMETADATACOUNTER] = UINT8( Framedata, Offset )]
	[Property.TDSColmetDataType = UINT8( Framedata, Offset )]
	switch (UINT8( Framedata, Offset ))
	{
		case 0xA5:
			[COLMETADATALENGTH$[COLMETADATACOUNTER] = UINT16(FrameData, FrameOffset +1)]struct{};
		case 0xA7:
			[COLMETADATALENGTH$[COLMETADATACOUNTER] = UINT16(FrameData, FrameOffset +1)]struct{};
		case 0xAD:
			[COLMETADATALENGTH$[COLMETADATACOUNTER] = 0]struct{};
		case 0xAF:
			[COLMETADATALENGTH$[COLMETADATACOUNTER] = 0]struct{};
		case 0xE7:
			[COLMETADATALENGTH$[COLMETADATACOUNTER] = UINT16(FrameData, FrameOffset +1)]struct{};
		case 0xEF:
			[COLMETADATALENGTH$[COLMETADATACOUNTER] = 0]struct{};
		case 0xF1: 
			[COLMETADATALENGTH$[COLMETADATACOUNTER] = 0xFFFF]struct{};
		case 0xF0: 
			[COLMETADATALENGTH$[COLMETADATACOUNTER] = 0xFFFF]struct{};
	}
	TDSTypeInfo TDSTypeInfo;
	Switch
	{
		case Property.TDSColmetDataType == 0x22 || Property.TDSColmetDataType == 0x23 || Property.TDSColmetDataType == 0x63:
			switch
			{
				case Property.TDSVersion >= 7.2:
					TDSMultiPartTableName TDSMultiPartTableName;
				default:
					TDSSinglePartTableName TDSSinglePartTableName;
			}
	}
	[Property.COLMETADATACOUNTER = Property.COLMETADATACOUNTER + 1]
	UINT8 ColNameLength;
	[DataFieldByteOrder = LittleEndian]
	UnicodeString(ColNameLength) ColName;
}

//[MS-SSTDS]
// ColFmtData is used in the COLFMT token
struct TDSColFmtData
{
	//ColumnData	:= UserType,
	//			Flags,
	//			TYPE_INFO,
	//			[TableName];
	
	//			UserType	:=UINT16;
	UINT16 UserType;
	
	// fNullable	:=	BIT;
	// fCaseSen	:=	BIT;
	// usUpdateable	:=	BIT, BIT; //2-bit value
	// 0 = ReadOnly
	// 1 = ReadWrite
	// 2 = Unknown (maybe readonly, maybe readwrite)
	// fIdentity	:=	BIT;
	// fComputed	:=	BIT;
	// usReservedODBC:= BIT, BIT;
	// Flags	:=	fNullable, fCaseSen, usUpdateable, fIdentity, FRESERVEDBIT, usReservedODBC, 8FRESERVEDBIT;
	UINT16 Flags
	{
		UINT16 fNullable:1 = FormatString("      (%s) %s",this.toBitString, this ? "Column is nullable" : "Column is NOT nullable");
		UINT16 fCaseSen:1 = FormatString("       (%s) %s",this.toBitString, this ? "The column is case sensitive for searches" : "The column is NOT case sensitive for searches");
		UINT16 usUpdateable:2 = FormatString("   (%s) %s",this.toBitString, this == 0 ? "Column is read-only" : ( this == 1 ? "Column is read/write" : "Updateable is unknown"));
		UINT16 fIdentity:1 = FormatString("      (%s) %s",this.toBitString, this ? "The column is an identity column" : "The column is NOT an identity column");
		BLOB(1) afIdentity = FormatString("      (%s) %s",this.toBitString,"Unused Bit");
		UINT16 usReservedODBC:2 = FormatString(" (%s) %s",this.toBitString, this ? "ODS gateways supporting the ODBC ODS gateway driver" : "ODS gateways NOT supporting the ODBC ODS gateway driver");
		BLOB(8) afusReservrdODBC = FormatString("(%s) %s",this.toBitString,"Unused Bit");
	};
	
	[Property.FMTMETADATATYPES$[Property.FMTMETADATACOUNTER] = UINT8( Framedata, Offset )]
	[Property.FMTMetaDataType = UINT8( Framedata, Offset )]
	switch (UINT8( Framedata, Offset ))
	{
		case 0xA5:
			[FMTMETADATALENGTH$[FMTMETADATACOUNTER] = UINT16(FrameData, FrameOffset +1)]struct{};
		case 0xA7:
			[FMTMETADATALENGTH$[FMTMETADATACOUNTER] = UINT16(FrameData, FrameOffset +1)]struct{};
		case 0xAD:
			[FMTMETADATALENGTH$[FMTMETADATACOUNTER] = 0]struct{};
		case 0xAF:
			[FMTMETADATALENGTH$[FMTMETADATACOUNTER] = 0]struct{};
		case 0xE7:
			[FMTMETADATALENGTH$[FMTMETADATACOUNTER] = UINT16(FrameData, FrameOffset +1)]struct{};
		case 0xEF:
			[FMTMETADATALENGTH$[FMTMETADATACOUNTER] = 0]struct{};
		case 0xF1: 
			[FMTMETADATALENGTH$[FMTMETADATACOUNTER] = 0xFFFF]struct{};
		case 0xF0: 
			[FMTMETADATALENGTH$[FMTMETADATACOUNTER] = 0xFFFF]struct{};
	}
	[Post.Property.FMTMETADATACOUNTER = Property.FMTMETADATACOUNTER + 1]
	TDSTypeInfo TDSTypeInfo;
	Switch
	{
		case Property.FMTMetaDataType == 0x22 || Property.FMTMetaDataType == 0x23 || Property.FMTMetaDataType == 0x63:
			TDSSinglePartTableName TDSSinglePartTableName;
	}
}
struct TDSColInfo
{
	// ColInfo	:=	ColNum,
	// 		TableNum,
	// 		Status,
	// 		[ColName]; // present only if status has 6th bit set
	// ColNum	:=	UINT8;	
	// TableNum	:=	UINT8;
	// Status	:=	UINT8;
	// ColName	:=	US_VARCHAR;
	UINT8 ColNum;
	UINT8 TableNum;
	[Status]
	UINT8 Status
	{
		UINT8 fReserved:2 = FormatString("     (%s) %s",this.toBitString,"Unused Bit");
		UINT8 EXPRESSION:1 = FormatString("    (%s) %s",this.toBitString, this ? "Result of an expression" : "Not result of an expression");
		UINT8 KEY:1 = FormatString("           (%s) %s",this.toBitString, this ? "The column is part of a key for the associated table" : "The column is NOT part of a key for the associated table");
		UINT8 HIDDEN:1 = FormatString("        (%s) %s",this.toBitString, this ? "Hidden" : "Not Hidden");
		UINT8 DIFFERENT_NAME:1 = FormatString("(%s) %s",this.toBitString, this ? "Different column name from the selected list column name in the case of a column alias" : "The same column name as the selected list column name in the case of a column alias");
		UINT8 fReserved2:2 = FormatString("    (%s) %s",this.toBitString,"Unused Bit");
	};
	switch
	{
		case (Property.Status & 0x20):
			struct ColName
			{
				UINT8 ColNameLength;
				[DataFieldByteOrder = LittleEndian]
				UnicodeString (ColNameLength) ColName;
			}
	}
}

struct TDSServerResponse
{
	switch
	{
		//
		// Here is the entry point for Sproc protocols.
		//
		// Example:
		// [RegisterBefore(TDSServerResponse.Option, Sproc, Conversation.HasSProcName)]
		case Property.TDSPacketID > 1:
			Blob(FrameLength - FrameOffset) ContinualTokenData;
		default:
			while Option[FrameOffset < FrameLength]
			{
				[Property.TDSTokenType]
				UINT8   TokenType = TDSResponseTypeTable( this );
				TDSResponseTokenData(TokenType) TokenData;
			} // while
	}
}

// TDSValueData generically handles the data portion of an individual data cell value
// inside of a ROW, ALTROW, Parameter, RETURNVALUE token.
// ExpectedTokenType - TDS token type
// PlpLength - Length of PLP header if type is PLP.
// IsRowData - Set to 1 if this token will emit ROW/ALTROW style LOB format (with TextPointer and Timestamp).
struct TDSValueData(ExpectedTokenType, PlpLength, IsRowData)
{
	switch (ExpectedTokenType)
		{
			// case 0x1F: // no more data
			case 0x30: 
				UINT8 INT1Value;
			case 0x32: 
				UINT8 BITValue;
			case 0x34: 
				UINT16 INT2Value;
			case 0x38: 
				UINT32 INT4Value;
			case 0x3A: 
				UINT32 DATETIM4Value;
			case 0x3B: 
				UINT32 FLT4Value;
			case 0x3C: 
				UINT64 MONEYValue;
			case 0x3D: 
				UINT64 DATETIMEValue;
			case 0x3E: 
				UINT64 FLT8Value;
			case 0x7A: 
				UINT32 MONEY4Value;
			case 0x7F: 
				UINT64 INT8Value;
			case 0x24:
				// one-UINT8 length
				struct GUID_VARBYTE
				{
					UINT8 GUID_VARLEN;
					TDSGuidDump(GUID_VARLEN) GUID_VALUE;
				}
			case 0x26:
				// one-UINT8 length
				struct INTN_VARBYTE
				{
					UINT8 INTN_VARLEN;
					TDSHexDump(INTN_VARLEN) INTN_VALUE;
				}
			case 0x37:
				// one-UINT8 length
				struct DECIMAL_VARBYTE
				{
					UINT8 DECIMAL_VARLEN;
					TDSHexDump(DECIMAL_VARLEN) DECIMAL_VALUE;
				}
			case 0x3F:
				// one-UINT8 length
				struct NUMERIC_VARBYTE
				{
					UINT8 NUMERIC_VARLEN;
					TDSHexDump(NUMERIC_VARLEN) NUMERIC_VALUE;
				};
			case 0x68:
				// one-UINT8 length
				struct BITN_VARBYTE
				{
					UINT8 BITN_VARLEN;
					TDSHexDump(BITN_VARLEN) BITN_VALUE;
				}
			case 0x6A:
				// one-UINT8 length
				struct DECIMALN_VARBYTE
				{
					UINT8 DECIMALN_VARLEN;
					TDSHexDump(DECIMALN_VARLEN) DECIMALN_VALUE;
				};
			case 0x6C:
				// one-UINT8 length
				struct NUMERICN_VARBYTE
				{
					UINT8 NUMERICN_VARLEN;
					TDSHexDump(NUMERICN_VARLEN) NUMERICN_VALUE;
				};
			case 0x6D:
				// one-UINT8 length
				struct FLTN_VARBYTE
				{
					UINT8 FLTN_VARLEN;
					TDSHexDump(FLTN_VARLEN) FLTN_VALUE;
				};
			case 0x6E:
				// one-UINT8 length
				struct MONEYN_VARBYTE
				{
					UINT8 MONEYN_VARLEN;
					TDSHexDump(MONEYN_VARLEN) MONEYN_VALUE;
				};
			case 0x6F:
				// one-UINT8 length
				struct DATETIMEN_VARBYTE
				{
					UINT8 DATETIMEN_VARLEN;
					TDSHexDump(DATETIMEN_VARLEN) DATETIMEN_VALUE;
				};
			case 0x2F:
				// one-UINT8 length
				struct CHAR_VARBYTE
				{
					UINT8 CHAR_VARLEN;
					AsciiString(CHAR_VARLEN) CHAR_VALUE;
				};
			case 0x27:
				// one-UINT8 length
				struct VARCHAR_VARBYTE
				{
					UINT8 VARCHAR_VARLEN;
					AsciiString(VARCHAR_VARLEN) VARCHAR_VALUE;
				};
			case 0x2D:
				// one-UINT8 length
				struct BINARY_VARBYTE
				{
					UINT8 BINARY_VARLEN;
					Blob(BINARY_VARLEN) BINARY_VALUE;
				};
			case 0x25:
				// one-UINT8 length
				struct VARBINARY_VARBYTE
				{
					UINT8 VARBINARY_VARLEN;
					Blob(VARBINARY_VARLEN) VARBINARY_VALUE;
				};
			case 0xA5:
				// two-UINT8 length
				TDSPLPVarbyte(0, PlpLength) BIGVARBINARY_VALUE;
			case 0xA7:
				// two-UINT8 length
				TDSPLPVarbyte(1, PlpLength) BIGVARCHR_VALUE;
			case 0xAD:
				// two-UINT8 length
				TDSPLPVarbyte(0, PlpLength) BIGBINARY_VALUE;
			case 0xAF:
				// two-UINT8 length
				TDSPLPVarbyte(1, PlpLength) BIGCHAR_VALUE;
			case 0xE7:
				// two-UINT8 length
				TDSPLPVarbyte(2, PlpLength) NVARCHAR_VALUE;
			case 0xEF:
				// two-UINT8 length
				TDSPLPVarbyte(2, PlpLength) NCHAR_VALUE;
			case 0xF1:
				// plp
				TDSPLPVarbyte(0, PlpLength) XML_VALUE;
			case 0xF0:
				// plp
				TDSPLPVarbyte(0, PlpLength) UDT_VALUE;

			case 0x23:
				// four-UINT8 length
				struct TEXT_VARBYTE
				{
					switch (IsRowData)
					{
						case 1:
							// Row based LOB.
							struct LOB_WITH_TEXTPOINTER
							{
								switch (UINT8( Framedata, Offset ))
								{
									case 0: 
										UINT8 NullLength;
									default:
										struct NON_NULL_TEXT_VARBYTE
										{
											UINT8 TextPointerLength;
											AsciiString(TextPointerLength) TextPointer;
											UINT8 Timestamp[8];
											UINT32 TEXT_VARLEN;
											AsciiString(TEXT_VARLEN) TEXT_VALUE;
										}
								}
							}
						default:
							// Non-row based LOB (Parameter or ReturnValue).
							struct LOB_WITHOUT_TEXTPOINTER
							{
								switch (UINT32(FrameData, FrameOffset))
								{
									case 0xFFFFFFFF: 
										UINT32 NullLength;
									default: // non-null
										struct NON_NULL_TEXT_VARBYTE
										{
											UINT32 TEXT_VARLEN;
											AsciiString(TEXT_VARLEN) TEXT_VALUE;
										}
								}		
							}
					} // switch (IsRowData)
				};
				
			case 0x22:
				// four-UINT8 length
				struct IMAGE_VARBYTE
				{
					switch (IsRowData)
					{
						case 1:
							// Row based LOB.
							struct LOB_WITH_TEXTPOINTER
							{
								switch (UINT8( Framedata, Offset ))
								{
									case 0: 
										UINT8 NullLength;
									default: // non-null
										struct NON_NULL_IMAGE_VARBYTE
										{
											UINT8 TextPointerLength;
											AsciiString(TextPointerLength) TextPointer;
											UINT8 Timestamp[8];
											UINT32 IMAGE_VARLEN;
											BLOB( FrameLength - FrameOffset < IMAGE_VARLEN ? FrameLength - FrameOffset : IMAGE_VARLEN) IMAGE_VALUE;
										}
								}
							}
						default:
							// Non-row based LOB (Parameter or ReturnValue).
							struct LOB_WITHOUT_TEXTPOINTER
							{
								switch (UINT32(FrameData, FrameOffset))
								{
									case 0xFFFFFFFF:
										UINT32 NullLength;
									default: // non-null
										struct NON_NULL_IMAGE_VARBYTE
										{
											UINT32 IMAGE_VARLEN;
											Blob(IMAGE_VARLEN) IMAGE_VALUE;
										}
								}
							}						
					} // switch (IsRowData)
				};
			
			case 0x63:
				// four-UINT8 length
				struct NTEXT_VARBYTE
				{
					switch (IsRowData)
					{
						case 1:
							// Row based LOB.
							struct LOB_WITH_TEXTPOINTER
							{				
								switch (UINT8( Framedata, Offset ))
								{
									case 0: 
										UINT8 NullLength;
									default: // non-null
										struct NON_NULL_NTEXT_VARBYTE
										{
											UINT8 TextPointerLength;
											AsciiString(TextPointerLength) TextPointer;
											UINT8 Timestamp[8];
											UINT32 NTEXT_VARLEN;
											[DataFieldByteOrder = LittleEndian]
											UnicodeString(NTEXT_VARLEN/2) NTEXT_VALUE;
										}
								}
							}
						default:
							// Non-row based LOB (Parameter or ReturnValue).
							struct LOB_WITHOUT_TEXTPOINTER
							{
								switch (UINT32(FrameData, FrameOffset))
								{
									case 0xFFFFFFFF: 
										UINT32 NullLength;
									default: // non-null
										struct NON_NULL_NTEXT_VARBYTE
										{
											UINT32 NTEXT_VARLEN;
											[DataFieldByteOrder = LittleEndian]
											UnicodeString(NTEXT_VARLEN/2) NTEXT_VALUE;
										}
								}
							}
					} // switch (IsRowData)
				};
			case 0x62:
				// four-UINT8 length
				struct SSVARIANT_VARBYTE
				{
					UINT32 SSVARIANT_VARLEN;
					TDSHexDump(SSVARIANT_VARLEN) SSVARIANT_VALUE;
				};
		} // switch
}

struct TDSResponseTokenData(TokenType)
{
	[ROWCOUNTER = 0]
	[ALTROWCOUNTER = 0]
	switch (TokenType)
	{
		case 0x00:
		case 0x01:
		case 0x02:
		case 0x03:
		case 0x04:
		case 0x14:
		case 0x16:
			// Passing in a 1 here to adjust for the one byte eaten by the TokenType switch.
			TDSPreLoginPacket(1) PreLoginPacketData;
		case 0xD1: 
			struct ROW
			{ 
				switch
				{
					case Property.TDSVersion == 4.2://[MS-SSTDS]
						while Option[ROWCOUNTER < Property.FMTMETADATACOUNTER]
						{
							[Post.ROWCOUNTER = ROWCOUNTER + 1]
							TDSValueData(Property.FMTMETADATATYPES$[ROWCOUNTER], FMTMETADATALENGTH$[ROWCOUNTER], 1) FMTRowData;
						}
					default:
						while Option[ROWCOUNTER < Property.COLMETADATACOUNTER]
						{
							[Post.ROWCOUNTER = ROWCOUNTER + 1]
							TDSValueData(COLMETADATATYPES$[ROWCOUNTER], COLMETADATALENGTH$[ROWCOUNTER], 1) COLMETARowData;
							// parse TYPE_VARBYTE based on current type in COLMETADATATYPES
						}
				}
			}
		case 0x88:
			// ALTMETADATA	:=	TokenType,
			// 		Count,
			// 		Id,
			// 		ByCols,
			// 		{ColNum},
			// 		{ComputeData};

			// 
			// 
			[Property.ALTMETADATACOUNTER = 0]
			struct ALTMETADATA = FormatString(" Id = %u", Id)
			{
				// Count	:=	UINT16;
				// Id	:=	UINT16;
				// ByCols	:=	UINT8;
				// ColNum	:=	UINT16;
				UINT16 Count;
				[Property.ALTMETADATAId]
				UINT16 Id;
				UINT8 ByCols;
				UINT16 ColNum[ByCols];
				TDSComputeData TDSComputeData[Count];
			};

		case 0xa0://[MS-SSTDS]
			struct COLNAME
			{
				UINT16 Length;
				[DataFieldFrameLength = FrameOffset + Length]
				switch
				{
					default:
					// Now, parse parameters unless delimiter or end-of-stream is reached
					// if delimiter is reached, do not consume it - this is done in COLNAME.
						
						while Option[FrameOffset < FrameLength]
						{
							UINT8 ColNameDataLength;
							[DataFieldByteOrder = LittleEndian]
							String(Property.TDSStringType,ColNameDataLength) ColNameData;
						}
				}
			}

		case 0xa1://[MS-SSTDS]
			
			struct COLFMT = FormatString("%u Bytes column data for ROWs", Length)
			{
				UINT16 Length;
				[Property.FMTMETADATACOUNTER = 0]
				[DataFieldFrameLength = FrameOffset + Length]
				while Option[FrameOffset < FrameLength]
				{
					TDSColFmtData TDSColFmtData;
				}
			}
			
		case 0xa7://[MS-SSTDS]
			
			struct ALTNAME = FormatString(" Id = %u", Id)
			{
				UINT16 Length;
				UINT16 Id;
				UINT8 ColNameDataLength;
				[DataFieldByteOrder = LittleEndian]
				String(Property.TDSStringType,ColNameDataLength) ColNameData;
			}
		
		case 0xa8://[MS-SSTDS]
			struct ALTFMT = FormatString(" Id = %u", Id)
			{
				UINT16 Length;
				[DataFieldFrameLength = FrameOffset + Length]
				struct
				{
					[Property.ALTFMTId]
					UINT16 Id;
					UINT8 CAltCols;
					TDSComputeData TDSComputeData[CAltCols];
					UINT8 ByCols;
					UINT8 ColNum[ByCols];
				}
			}
			
		case 0xD3:
			struct ALTROW = FormatString(" Id = %u", Id)
			{
				// ALTROW	:=	TokenType,
				// 		Id,
				// 		{ComputeData};
				// Id	:=	UINT16;
				UINT16 Id;
				switch
				{
					case Property.TDSVersion == 4.2:
						TDSValueData(Property.ALTFMTTYPES$[Id], Property.ALTFMTLENGTH$[Id], 1) FMTRowData;
					default:
						while Option[!IsValueNone(Property.ALTMETADATATYPES$[Id, ALTROWCOUNTER])]
						{
							[Post.ALTROWCOUNTER = ALTROWCOUNTER + 1]
							TDSValueData(Property.ALTMETADATATYPES$[Id, ALTROWCOUNTER], ALTMETADATALENGTH$[Id, ALTROWCOUNTER], 1) ALTMETARowData;
							//parse TYPE_VARBYTE based on current type in ALTMETADATATYPES
						}
				}
			}

		case 0x81:
			struct COLMETADATA = FormatString(" Count = %u", Count)
			{
				// COLMETADATA	:=	TokenType,
				// 		NoMetaData
				// 		|
				// 		(Count, {ColumnData});
				// NoMetaData	:=	
				[ColumnCount = Count]
				UINT16  Count;
				switch (Count == 0xFFFF)
				{
					case 0: 
						[Property.COLMETADATACOUNTER = 0]
						TDSColumnData TDSColumnData[Property.ColumnCount] = Property.COLMETADATACOUNTER;
						// default is no metadata present - nothing to read.
				}
			}

		case 0xA5:
			struct COLINFO
			{
				// COLINFO	:=	TokenType,
				// 		Length,
				// 		ColInfo; // repeated for each column in the rowset.
				// Length	:=	UINT16;	
				UINT16 Length;
				[DataFieldFrameLength = FrameOffset + Length]
				while[FrameOffset < FrameLength]
				{
					TDSColInfo TDSColInfo;
				}
			}

		case 0x60:
			struct DEGUG_CMD
			{
				// DEBUG_CMD	:=	TokenType,
				// 		Length,
				// 		Zero,
				// 		Page;
				// Length	:=	INT32;	
				// Zero	:=	INT32;
				// Page	:=	2048 * UINT8;
				INT32 Length;
				INT32 Zero;
				UINT8 Page[2048];
			}

		case 0xFD:
			struct DONE
			{
				// TokenType	:=	UINT8;
				// Status	:=	UINT16;		
				// CurCmd	:=	UINT16;
				// DoneRowCount	:=	UINT64;
				UINT16 Status
				{
					UINT16 DONE_MORE:1 = FormatString("      (%s) %s",this.toBitString, this ? "More command follow" : "No More command follow");
					UINT16 DONE_ERROR:1 = FormatString("     (%s) %s",this.toBitString, this ? "Error occurred on the current command" : "No Error occurred on the current command");
					UINT16 DONE_INXACT:1 = FormatString("    (%s) %s",this.toBitString, this ? "A transaction is in progress" : "Is not a transaction is in progress");
					UINT16 DONE_PROC:1 = FormatString("      (%s) %s",this.toBitString,"Unused Bit");
					UINT16 DONE_COUNT:1 = FormatString("     (%s) %s",this.toBitString, this ? "An initialized variable)." : "DoneRowCount");
					UINT16 DONE_ATTN:1 = FormatString("    (%s) %s",this.toBitString, this ? "A server acknowledgement of a client ATTENTION message" : "Not a server acknowledgement of a client ATTENTION message");
					UINT16 UNUSED:2 = FormatString("       (%s) %s",this.toBitString,"Unused Bit");
					UINT16 DONE_SRVERROR:1 = FormatString("(%s) %s",this.toBitString, this ? "An error occurred on the current command" : "No error occurred on the current command");
					UINT16 UNUSED2:7 = FormatString("      (%s) %s",this.toBitString,"Unused Bit");
				};
				UINT16 CurCmd = TDSCurCmdType(CurCmd);
				switch
				{
					case Property.TDSVersion  >= 7.2:
						UINT64 DoneRowCount;
					default:
						UINT32 DoneRowCount32;
				}
			}

		case 0xFF:
			struct DONEINPROC
			{
				// TokenType	:=	UINT8;
				// Status	:=	UINT16;		
				// CurCmd	:=	UINT16;
				// DoneRowCount	:=	UINT64;
				UINT16 Status
				{
					UINT16 DONE_MORE:1 = FormatString("      (%s) %s",this.toBitString, this ? "More command follow" : "No More command follow");
					UINT16 DONE_ERROR:1 = FormatString("     (%s) %s",this.toBitString, this ? "Error occurred on the current command" : "No Error occurred on the current command");
					UINT16 DONE_INXACT:1 = FormatString("    (%s) %s",this.toBitString, this ? "A transaction is in progress" : "Is not a transaction is in progress");
					UINT16 DONE_PROC:1 = FormatString("      (%s) %s",this.toBitString,"Unused Bit");
					UINT16 DONE_COUNT:1 = FormatString("     (%s) %s",this.toBitString, this ? "An initialized variable)." : "DoneRowCount");
					UINT16 UNUSED:1 = FormatString("         (%s) %s",this.toBitString,"Unused Bit");
					UINT16 DONE_INPROC:1 = FormatString("    (%s) %s",this.toBitString,"Unused Bit");
					UINT16 DONE_RPCINBATCH:1 = FormatString("(%s) %s",this.toBitString, this ? "NOT the last RPC in the batch" : "The last RPC in the batch");
					UINT16 DONE_SRVERROR:1 = FormatString("  (%s) %s",this.toBitString, this ? "Error occurred on the current command" : "No error occurred on the current command");
					UINT16 UNUSED2:7 = FormatString("        (%s) %s",this.toBitString,"Unused Bit");
				};
				UINT16 CurCmd = TDSCurCmdType(CurCmd);
				switch
				{
					case Property.TDSVersion >= 7.2:
						UINT64 DoneRowCount;
					default:
						UINT32 DoneRowCount32;
				}
			}

		case 0xFE:
			struct DONEPROC
			{
				// TokenType	:=	UINT8;
				// Status		:=	UINT16;		
				// CurCmd		:=	UINT16;
				// DoneRowCount	:=	UINT64;
				UINT16 Status
				{
					UINT16 DONE_MORE:1 = FormatString("      (%s) %s",this.toBitString, this ? "More command follow" : "No More command follow");
					UINT16 DONE_ERROR:1 = FormatString("     (%s) %s",this.toBitString, this ? "Error occurred on the current command" : "No Error occurred on the current command");
					UINT16 DONE_INXACT:1 = FormatString("    (%s) %s",this.toBitString, this ? "A transaction is in progress" : "Is not a transaction is in progress");
					UINT16 DONE_PROC:1 = FormatString("      (%s) %s",this.toBitString,"Unused Bit");
					UINT16 DONE_COUNT:1 = FormatString("     (%s) %s",this.toBitString, this ? "An initialized variable)." : "DoneRowCount");
					UINT16 UNUSED:1 = FormatString("         (%s) %s",this.toBitString,"Unused Bit");
					UINT16 DONE_INPROC:1 = FormatString("    (%s) %s",this.toBitString,"Unused Bit");
					UINT16 DONE_RPCINBATCH:1 = FormatString("(%s) %s",this.toBitString, this ? "NOT the last RPC in the batch" : "The last RPC in the batch");
					UINT16 DONE_SRVERROR:1 = FormatString("  (%s) %s",this.toBitString, this ? "Error occurred on the current command" : "No error occurred on the current command");
					UINT16 UNUSED2:7 = FormatString("        (%s) %s",this.toBitString,"Unused Bit");
				};
				UINT16 CurCmd = TDSCurCmdType(CurCmd);
				switch
				{
					case Property.TDSVersion >= 7.2:
						UINT64 DoneRowCount;
					default:
						UINT32 DoneRowCount32;
				}
			}

		case 0xE3:
			struct ENVCHANGE
			{
				// TokenType	:=	UINT8;
				// Length		:=	UINT16;
				// Type			:=	UINT8;
				// NewValue		:=	B_VARBYTE;
				// OldValue		:=	B_VARBYTE;

				// EnvValueData	:=	Type,
				// 		NewValue,
				// 		OldValue;

				UINT16 Length;
				struct EnvValueData
				{
					UINT8 EnvChangeType = TDSEnvChangeTable(this);
					switch (EnvChangeType)
					{
						case 0x07:
							// SQL Collation is in bytes, not unicode
							struct SqlCollationData
							{
								UINT8 NewValueLength;
								TDSHexDump(NewValueLength) NewValue;
								UINT8 OldValueLength;
								TDSHexDump(OldValueLength) OldValue;
							}
						case 0x08:
						case 0x09:
						case 0x0a:
						case 0x0b:
						case 0x0c:
						case 0x11:
							// Transaction envchanges are in bytes, not unicode
							struct TransactionData
							{
								UINT8 NewValueLength;
								TDSTransactionDescriptor(NewValueLength) NewValue;
								UINT8 OldValueLength;
								TDSTransactionDescriptor(OldValueLength) OldValue;
							}
						default:
							// All other types are string.
							[DataFieldByteOrder = LittleEndian]
							struct ValueData
							{
								UINT8 NewValueLength;
								String(Property.TDSStringType, NewValueLength) NewValue;
								UINT8 OldValueLength;
								String(Property.TDSStringType, OldValueLength) OldValue;
							}
					}
				}
			}

		case 0xAA:
			TDSERROR TDSERROR;

		case 0xAB:
			struct INFO
			{
				// TokenType	:=	UINT8;
				// Length	:=	UINT16;
				// Number	:=	UINT32;
				// State	:=	UINT8;
				// Class	:=	UINT8;
				// MsgText	:=	US_VARCHAR;
				// ServerName	:=	B_VARCHAR;
				// ProcName	:=	B_VARCHAR;
				// LineNumber	:=	UINT32/UINT16;
				UINT16 Length;
				[Property.TDSINFOTokenStartOff = FrameOffset]
				UINT32 Number;
				UINT8 State;
				UINT8 Class;
				UINT16 MsgTextLength;
				[DataFieldByteOrder = LittleEndian]
				String(Property.TDSStringType, MsgTextLength) MsgText;
				UINT8 ServerNameLength;
				[DataFieldByteOrder = LittleEndian]
				String(Property.TDSStringType, ServerNameLength) ServerName;
				UINT8 ProcNameLength;
				[DataFieldByteOrder = LittleEndian]
				[Property.HasStoredProcedureName = ProcNameLength > 0]
				[StoredProcedureDboName = String(FrameData, FrameOffset, Property.TDSStringType, ProcNameLength).contains("dbo.") ? String(FrameData, FrameOffset + 4*Property.TDSStringUnitLen, Property.TDSStringType, ProcNameLength - 4) : this ]
				[StoredProcedureName = String(FrameData, FrameOffset, Property.TDSStringType, ProcNameLength).contains("[dbo].[") ? StringTerm(FrameData, FrameOffset + 7*Property.TDSStringUnitLen, Property.TDSStringType, "]", FALSE) : StoredProcedureDboName ]
				String(Property.TDSStringType, ProcNameLength) ProcName;
				switch
				{
					case Property.TDSVersion >= 7.2 && (Length + Property.TDSINFOTokenStartOff - FrameOffset == 4):
						UINT32 LineNumber32;
					case Length + Property.TDSINFOTokenStartOff - FrameOffset == 2:
						UINT16 LineNumber;
				}
			}

		case 0xAD:
			struct LOGINACK
			{
				// LOGINACK	:=	TokenType,
				// 		Length,
				// 		Interface,
				// 		TDSVersion,
				// 		ProgName,
				// 		ProgVersion;

				// TokenType	:=	UINT8;
				// Length		:=	UINT16;
				// Interface	:=	UINT8;
				// TDSVersion	:=	UINT32;
				// ProgName	:=	B_VARCHAR;
				UINT16 Length;
				UINT8 Interface;
				// TDS version in LOGINACK is in big-endian form, sniff the first byte to detect TDS major version.
				[DataFieldByteOrder = BigEndian]
				[Property.TDSVersionValue]
				[Property.TDSVersion = TDSVersionShortNameTable(TDSVersion)]
				[	Property.TDSStringUnitLen = (Property.TDSVersion < 7.0) ? 1 : 2, 
					Property.TDSStringType = (Property.TDSVersion < 7.0) ? 0 : 1]
				UINT32 TDSVersion = TDSVersionTable( this );
				UINT8 ProgNameLength;
				[DataFieldByteOrder = LittleEndian]
				String(Property.TDSStringType, ProgNameLength) ProgName;

				// MajorVer	:=	UINT8;
				// MinorVer	:=	UINT8;
				// BuildNumHi	:=	UINT8;
				// BuildNumLow	:=	UINT8;

				// ProgVersion	:=	MajorVer,
				// 		MinorVer,
				// 		BuildNumHi,
				// 		BuildNumLow;
				struct ProgVersion
				{
					UINT8 MajorVer;
					UINT8 MinorVer;
					UINT8 BuildNumHi;
					UINT8 BuildNumLow;
				}
			}

		case 0x78:
			struct OFFSETTOKEN
			{
				// TokenType	:=	UINT8;
				// Indentifier	:=	UINT16;
				// OffSet	:=	UINT16;
				UINT16 Identifier;
				UINT16 OffSetValue;
			}

		case 0xA9:
			TDSORDER TDSORDER;

		case 0x79:
			struct RETURNSTATUS
			{
				// TokenType	:=	UINT8;
				// Value	:=	INT32;
				INT32 Value;
			}

		case 0xAC:
			TDSRETURNVALUE TDSRETURNVALUE;

		case 0xED:
			struct SSPI
			{
				// TokenType	:=	UINT8;
				// SSPIBuffer	:=	US_VARBYTE;
				UINT16 SSPIBufferLength;
				Blob(SSPIBufferLength)  SSPIBuffer
				{
					switch
					{
						case AsciiString( FrameData, Offset, 7 ) == "Ntlmssp":
							NLMP NLMP;
					}
				};
			}
		case 0xA4:
			struct TABNAME
			{
				// TokenType	:=	UINT8;
				// Length	:=	UINT16;
				UINT16 Length;
				Switch
				{
					case Property.TDSVersion == 4.2://[MS-SSTDS]
						struct TableName42
						{
							UINT8 TableNameLength;
							[DataFieldByteOrder = LittleEndian]
							String(Property.TDSStringType, TableNameLength) TableName;
						}
					case Property.TDSVersion < 7.1:
						TDSSinglePartTableName TDSSinglePartTableName;
					default:
						[TabNameTokenEnd = FrameOffset + Length]
						while [FrameOffset < TabNameTokenEnd]
						{
							TDSMultiPartTableName TDSMultiPartTableName;
						}
				}
			}
		default: // invalid type - don't read anything
			ReportParserError(ParserErrorProtocolClassPublic, "TDS", "Unrecognized TDS Token Type") TokenTypeError;
		// default is invalid token - read nothing; move to the next UINT8.        
	};
}

struct TDSERROR
{
	// TokenType	:=	UINT8;
	// Length	:=	UINT16;
	// Number	:=	UINT32;
	// State	:=	UINT8;
	// Class	:=	UINT8;
	// MsgText	:=	US_VARCHAR;
	// ServerName	:=	B_VARCHAR;
	// ProcName	:=	B_VARCHAR;
	// LineNumber	:=	UINT32/UINT16;
	UINT16 Length;
	UINT32 Number;
	UINT8 State;
	UINT8 Class;
	UINT16 MsgTextLength;
	[DataFieldByteOrder = LittleEndian]
	String(Property.TDSStringType,MsgTextLength) RowMsgText;
	UINT8 ServerNameLength;
	[DataFieldByteOrder = LittleEndian]
	String(Property.TDSStringType,ServerNameLength) RowServerName;
	UINT8 ProcNameLength;
	[DataFieldByteOrder = LittleEndian]
	[HasStoredProcedureName = TRUE]
	[StoredProcedureDboName = String(FrameData, FrameOffset, Property.TDSStringType, ProcNameLength).contains("dbo.") ? String(FrameData, FrameOffset + 4*Property.TDSStringUnitLen, Property.TDSStringType, ProcNameLength - 4) : this ]
	[Post.StoredProcedureName = String(FrameData, FrameOffset, Property.TDSStringType, ProcNameLength).contains("[dbo].[") ? StringTerm(FrameData, FrameOffset + 7*Property.TDSStringUnitLen, Property.TDSStringType, "]", FALSE) : StoredProcedureDboName ]
	String(Property.TDSStringType,ProcNameLength) RowProcName;
	switch
	{
		case Property.TDSVersion >= 7.2:
			UINT32 LineNumber32;
		default:
			UINT16 LineNumber;
	}
}

struct TDSRETURNVALUE
{
	// RETURNVALUE	:=	TokenType,
	// 		ParamOrdinal,
	// 		ParamName,
	// 		Status,
	// 		UserType,
	// 		Flags,
	// 		TypeInfo,
	// 		Value;

	// ParamName			:=	B_VARCHAR;
	// ParamOrdinal			:=	UINT16;
	// Status			:=	UINT8;
	// UserType			:=	UINT32;
	Switch
	{
		case Property.TDSVersion == 4.2://[MS-SSTDS]
			UINT16 Length;
		default:
			UINT16 ParamOrdinal;
	}
	UINT8 ParamNameLength;
	[DataFieldByteOrder = LittleEndian]
	String(Property.TDSStringType,ParamNameLength) RowParamName;
	UINT8 Status;
	switch
	{
		case Property.TDSVersion >= 7.2:
			UINT32 UserType;
		default:
			UINT16 UserType16;
	}
	// fNullable	:=	BIT;
	// fCaseSen	:=	BIT;
	// usUpdateable	:=	BIT, BIT; //2-bit value
	// 0 = ReadOnly
	// 1 = ReadWrite
	// 2 = Unknown (maybe readonly, maybe readwrite)
	// fIdentity	:=	BIT;
	// fComputed	:=	BIT;
	// usReservedODBC:= BIT, BIT;
	// fFixedLenCLRType:= BIT;
	// usReserved	:= BIT, BIT, BIT, BIT, BIT, BIT;
	// Flags	:=	fNullable, fCaseSen, usUpdateable, fIdentity, fComputed, usReservedODBC, fFixedLenCLRType, usReserved, fUnset;
	UINT16 Flags
	{
		UINT16 fNullable:1 = FormatString("       (%s) %s",this.toBitString, this ? "The column is nullable" : "The column is NOT nullable");
		UINT16 fCaseSen:1 = FormatString("        (%s) %s",this.toBitString, this ? "The column is case sensitive for searches" : "The column is NOT case sensitive for searches");
		UINT16 usUpdateable:2 = FormatString("    (%s) %s",this.toBitString, this == 0 ? "Column is read-only" : ( this == 1 ? "Column is read/write" : "Updateable is unknown"));
		UINT16 fIdentity:1 = FormatString("       (%s) %s",this.toBitString, this ? "Identity column": "NOT identity column");
		UINT16 fComputed:1 = FormatString("       (%s) %s",this.toBitString, this ? "COMPUTED column" : "NOT COMPUTED column");
		UINT16 usReservedODBC:2 = FormatString("  (%s) %s",this.toBitString, this ? "Supporting the ODBC ODS gateway driver" : "Not Supporting the ODBC ODS gateway driver");
		UINT16 fFixedLenCLRType:1 = FormatString("(%s) %s",this.toBitString, this ? "Fixed-length CLR UDT" : "Not fixed-length CLR UDT");
		UINT16 usReserved:6 = FormatString("      (%s) %s",this.toBitString,"Unused Bit");
		UINT16 fUnset:1 = FormatString("          (%s) %s",this.toBitString,"Unused Bit");
	};

	[Property.RETURNVALUEType = UINT8( Framedata, Offset )]
	switch (UINT8( Framedata, Offset ))
	{
		case 0xA5:
			[Property.RETURNVALUEPlpLength = UINT16(FrameData, FrameOffset +1)]struct{};
		case 0xA7:
			[Property.RETURNVALUEPlpLength = UINT16(FrameData, FrameOffset +1)]struct{};
		case 0xAD:
			[Property.RETURNVALUEPlpLength = 0]struct{};
		case 0xAF:
			[Property.RETURNVALUEPlpLength = 0]struct{};
		case 0xE7:
			[Property.RETURNVALUEPlpLength = UINT16(FrameData, FrameOffset +1)]struct{};
		case 0xEF:
			[Property.RETURNVALUEPlpLength = 0]struct{};
		case 0xF1: 
			[Property.RETURNVALUEPlpLength = 0xFFFF]struct{};
		case 0xF0: 
			[Property.RETURNVALUEPlpLength = 0xFFFF]struct{};
	}
	TDSTypeInfo TDSTypeInfo;

	TDSValueData(Property.RETURNVALUEType, Property.RETURNVALUEPlpLength, 0) TYPE_VARBYTE;

}

// ORDER BY token representation
struct TDSORDER
{
	// TokenType	:=	UINT8;
	// Length	:=	UINT16;
	// ColNum	:=	{UINT16};
	Switch
	{
		case Property.TDSVersion >= 7.0:
			struct
			{
				UINT16 Length;
				UINT16 ColNum[Length/2]; // length of array is half of total length (length is in bytes)	
			}
		
		default://[MS-SSTDS]
			struct
			{
				UINT16 Length;
				UINT8 ColNum[Length];
			}	
	}
}

Table  TDSDefaultRPCNameTable( value )
{
	switch( value )
	{
		case 1:   FormatString("sp_cursor %d (%#x)",value,value);
		case 2:   FormatString("sp_cursoropen %d (%#x)",value,value);
		case 3:   FormatString("sp_cursorprepare %d (%#x)",value,value);
		case 4:   FormatString("sp_cursorexecute %d (%#x)",value,value);
		case 5:   FormatString("sp_cursorprepexec %d (%#x)",value,value);
		case 6:   FormatString("sp_cursorunprepare %d (%#x)",value,value);
		case 7:   FormatString("sp_cursorfetch %d (%#x)",value,value);
		case 8:   FormatString("sp_cursoroption %d (%#x)",value,value);
		case 9:   FormatString("sp_cursorclose %d (%#x)",value,value);
		case 10:  FormatString("sp_executesql %d (%#x)",value,value);
		case 11:  FormatString("sp_prepare %d (%#x)",value,value);
		case 12:  FormatString("sp_execute %d (%#x)",value,value);
		case 13:  FormatString("sp_prepexec %d (%#x)",value,value);
		case 14:  FormatString("sp_prepexecrpc %d (%#x)",value,value);
		case 15:  FormatString("sp_unprepare %d (%#x)",value,value);
		default:  FormatString("Undefined %d (%#x)",value,value);
	}
}

struct TDSPLPVarbyte(DisplayStyle, PlpLength)
{
	// DisplayStyle represents what type of data is inside the PLP type and how to display it.
	// DisplayStyle = 0 is binary data.
	// DisplayStyle = 1 is single character data displayed using AsciiString.
	// DisplayStyle = 2 is unicode character data displayed using UnicodeString.

	// PLP_BODY		:=	PLP_NULL
	// 				|
	// { ULONGLONGLEN | UNKNOWN_PLP_LEN }, {PLP_CHUNK}, PLP_TERMINATOR
	// PLP_NULL		:=	
	// UNKNOWN_PLP_LEN:=	
	// PLP_CHUNK	:=	ULONGLEN, {UINT8}-
	// PLP_TERMINATOR	:=	
	switch (PlpLength)
	{
		case 0xFFFF:
			struct PLP_BODY
			{
				UINT64 ULONGLONG_LENGTH = (0xFFFFFFFFFFFFFFFF == this) ? FormatString( "NULL (0x%I64X)", this ) : FormatString( "%I64u (0x%I64X)", this, this );
				switch (ULONGLONG_LENGTH)
				{
					case 0xFFFFFFFFFFFFFFFF:
						// 0xFFFFFFFFFFFFFFFF is a special flag called PLP_NULL.  
						// For PLP null value, nothing else follows.
						_struct	{}
					default:
						// ULONGLONG_LENGTH here may either be 0xFFFFFFFFFFFFFFFE indicating UNKNOWN_PLP_LEN
						// or some length up to 0xFFFFFFFFFFFFFFFD bytes.  In both cases we just read
						// chunks of data until we hit a terminator PLP_CHUNK_LENGTH.
						_struct
						{
							while Options[!(UINT32(FrameData, FrameOffset) == 0)]
							{ 
								// Read chunks until terminator is reached.
								[Property.TDSPLPCHUNKLENGTH]
								UINT32 PLP_CHUNK_LENGTH;
								switch (DisplayStyle)
								{
									case 0:
										struct VARBINARY_DATA
										{
											switch
											{
												default:
													Blob(PLP_CHUNK_LENGTH) PLP_CHUNK;
											}
										}
									case 1:
										struct VARCHAR_DATA
										{
											AsciiString(PLP_CHUNK_LENGTH) PLP_CHUNK;
										}
									case 2:
										[DataFieldByteOrder = LittleEndian]
										struct NVARCHAR_DATA
										{
											UnicodeString(PLP_CHUNK_LENGTH/2) PLP_CHUNK;
										}
								}
							}
							UINT32 PLP_TERMINATOR; // consume the terminator
						}
				} // switch (ULONGLONG_LENGTH)
			} // PLP
		default:
			// Type is a USHORTLEN_TYPE (2 bytes USHORT variable length)
			struct USHORTLEN_TYPE
			{
				UINT16 SHORT_LENGTH = (0xFFFF == this) ? FormatString( "NULL (0x%X)", this ) : FormatString( "%u (0x%X)", this, this );
				switch (SHORT_LENGTH)
				{
					case 0xFFFF:	// Null value has a special 0xFFFF header value.
					_struct	{}		// Nothing else to read for null values.
					default:
						switch (DisplayStyle)
						{
							case 0:
								struct VARBINARY_DATA
								{
									Blob(SHORT_LENGTH) SHORT_VALUE;
								}
							case 1:
								struct VARCHAR_DATA
								{
									AsciiString(SHORT_LENGTH) SHORT_VALUE;
								}
							case 2:
								[DataFieldByteOrder = LittleEndian]
								struct NVARCHAR_DATA
								{
									UnicodeString(SHORT_LENGTH/2) SHORT_VALUE;
								}
						}
				}
			}

	}
}


struct TDSParameterData = TDSDataTypeTable(Property.ParameterDataType)
{

	UINT8 ParamNameLength;
	[DataFieldByteOrder = LittleEndian]
	String(Property.TDSStringType,ParamNameLength) RowParamName;

	UINT8 StatusFlags
	{
		UINT8 fByRefValue:1;
		UINT8 fDefaultValue:1;
		UINT8 FRESERVEDBIT:6;
	};

	
	[Property.ParameterDataType = UINT8( Framedata, Offset )]
	switch (UINT8( Framedata, Offset ))
	{
		case 0xA5:
			[Property.ParameterDataPlpLength = UINT16(FrameData, FrameOffset +1)]struct{};
		case 0xA7:
			[Property.ParameterDataPlpLength = UINT16(FrameData, FrameOffset +1)]struct{};
		case 0xAD:
			[Property.ParameterDataPlpLength= 0]struct{};
		case 0xAF:
			[Property.ParameterDataPlpLength = 0]struct{};
		case 0xE7:
			[Property.ParameterDataPlpLength = UINT16(FrameData, FrameOffset +1)]struct{};
		case 0xEF:
			[Property.ParameterDataPlpLength = 0]struct{};
		case 0xF1: 
			[Property.ParameterDataPlpLength = 0xFFFF]struct{};
		case 0xF0: 
			[Property.ParameterDataPlpLength = 0xFFFF]struct{};
	}
	TDSTypeInfo TDSTypeInfo;

	// TYPE_VARBYTE	:=	[TYPE_VARLEN], {UINT8}
	//	|
	//	CHARBIN_NULL
	//	|
	//	GEN_NULL;
	// CHARBIN_NULL	:=	
	// GEN_NULL	:=	
	
	TDSValueData(Property.ParameterDataType , Property.ParameterDataPlpLength, 0) TYPE_VARBYTE;

}

struct TDSRPCRequestBatch
{
	// RPCReqBatch	:=	All_HEADERS,
	//  NameLenProcID,
	//	OptionFlags,
	//	{ParameterData};	
	[Property.TDSVersion = UINT32(FrameData, FrameOffset) == 0x16 ? 7.2 : Property.TDSVersion]
	switch
	{
		case Property.TDSVersion >= 7.2:
			TDSALLHeaders TDSALLHeaders; // only in Yukon
	}

	// 	NameLenProcID	:=	ProcName
	//	|
	//	ProcIDSwitch, ProcID;
	// ProcID	:=	UINT16;
	// ProcIDSwitch	:=	
	// ProcName	:=	US_VARCHAR;
	switch
	{
		case Property.TDSVersion >= 7.0:
			struct NameLenProcId = FormatString("%s", IsValueNone(Property.TDSReqBatchProcID) ? "Name = " + StoredProcedureName : TDSDefaultRPCNameTable(Property.TDSReqBatchProcID))
			{
				switch (UINT16(FrameData,FrameOffset))
				{
					case 0xFFFF:
						struct ProcIDSwitchAndID
						{
							UINT16 ProcIDSwitch;
							[Property.TDSReqBatchProcID]
							UINT16 ProcID = TDSDefaultRPCNameTable(this);
						}
					default:
						struct ProcName = StoredProcedureName
						{
							UINT16 ProcNameLength;
							[DataFieldByteOrder = LittleEndian]
							[HasStoredProcedureName = TRUE]
							[StoredProcedureDboName = UnicodeString(FrameData, FrameOffset, ProcNameLength).contains("dbo.") ? UnicodeString(FrameData, FrameOffset + 4*2, ProcNameLength - 4) : this ]
							[Post.StoredProcedureName = UnicodeString(FrameData, FrameOffset, ProcNameLength).contains("[dbo].[") ? UnicodeStringTerm(FrameData, FrameOffset + 7*2, "]", FALSE) : StoredProcedureDboName ]
							UnicodeString(ProcNameLength) ProcNameString;
						}
				}
			}
		Default://[MS-SSTDS]
			struct
			{
				UINT8 ProcNameLength;
				[DataFieldByteOrder = LittleEndian]
				String(Property.TDSStringType,ProcNameLength) ProcNameString;
			}
	}


	// OptionFlags	:=	fWithRecomp, fNoMetaData, FRESERVEDBIT, FRESERVEDBIT, 
	// FRESERVEDBIT, FRESERVEDBIT, FRESERVEDBIT, FRESERVEDBIT, FRESERVEDBYTE;
	UINT16 OptionFlags
	{
		UINT16 fWithRecomp:1 = FormatString("   (%s) %s",this.toBitString, this ? "RPC is sent with the 'with recompile' option" : "RPC is NOT sent with the 'with recompile' option");
		UINT16 fNoMetaData:1 = FormatString("   (%s) %s",this.toBitString, this ? "No metadata is to be returned for the result set" : "Metadata is to be returned for the result set");
		UINT16 fReuseMetaData:1 = FormatString("(%s) %s",this.toBitString, this ? "the metadata has not changed from the previous call" : "the metadata has changed from the previous call");
		UINT16 fRESERVEDBIT:13 = FormatString(" (%s) %s",this.toBitString,"Unused Bit");
	};

	switch
	{
		//
		// Here is the entry point for Sproc protocols.
		//
		// Example:
		// [RegisterBefore(RPCRequestBatch.Option, Sproc, HasStoredProcedureName)]

		default:
			// Now, parse parameters unless delimiter or end-of-stream is reached
			// if delimiter is reached, do not consume it - this is done in RPCRequest.
			while Option[FrameOffset < FrameLength && !(UINT8( Framedata, Offset ) == 0xFF) && !(UINT8( Framedata, Offset ) == 0xFE)]
			{
				TDSParameterData TDSParameterData;
			}
	}
}

struct  TDSRPCRequest
{
	// RPCRequest	:=	RPCReqBatch,
	//	[{{BatchFlag | NoExecFlag}, RPCReqBatch}];
	TDSRPCRequestBatch TDSRPCRequestBatch;
	while Option[FrameOffset < FrameLength
		&& (UINT8( Framedata, Offset ) == 0xFF || UINT8( Framedata, Offset ) == 0xFE)]
	{ // delimiter plus new request batch follows
		switch (UINT8( Framedata, Offset ))
		{
			case 0xFF: UINT8 BatchFlag;
			case 0xFE: UINT8 NoExecFlag;
			default: UINT8 InvalidFlag; // should not get here
		}
		TDSRPCRequestBatch TDSRPCRequestBatch;
	}
}

struct  TDSSqlBatch
{
	// SQLBatch	:=	ALL_HEADERS, SQLText;
	[Property.TDSVersion = UINT32(FrameData, FrameOffset) == 0x16 ? 7.2 : Property.TDSVersion]
	switch
	{
		case Property.TDSVersion >= 7.2:
			TDSALLHeaders AllHeadersData;
	}

	[DataFieldByteOrder = LittleEndian]
	switch
	{
		case String(FrameData, FrameOffset, Property.TDSStringType, 4) == "exec":
			[HasStoredProcedureName = TRUE]
			[SprocNameOffset = String(FrameData, FrameOffset + 5*Property.TDSStringUnitLen, Property.TDSStringType, 4).contains("dbo.") ? 9*Property.TDSStringUnitLen : 5*Property.TDSStringUnitLen]
			[StoredProcedureName = StringTerm(FrameData, FrameOffset + SprocNameOffset, Property.TDSStringType, " ", FALSE)]			
			_struct {}
		case String(FrameData, FrameOffset, Property.TDSStringType, 4) == "dbo.":
			[HasStoredProcedureName = TRUE]
			[SprocNameOffset = 4*Property.TDSStringUnitLen]
			[StoredProcedureName = StringTerm(FrameData, FrameOffset + SprocNameOffset, Property.TDSStringType, " ", FALSE)]			
			_struct {}
		case String(FrameData, FrameOffset, Property.TDSStringType, 7) == "[dbo].[":
			[HasStoredProcedureName = TRUE]
			[SprocNameOffset = 7*Property.TDSStringUnitLen]
			[StoredProcedureName = StringTerm(FrameData, FrameOffset + SprocNameOffset, Property.TDSStringType, "]", FALSE)]			
			_struct {}
	}

	[DataFieldByteOrder = LittleEndian]
	switch
	{
		//
		// Here is the entry point for Sproc protocols.
		//
		// Example:
		// [RegisterBefore(SqlBatch.SQLText, Sproc, HasStoredProcedureName)]

		default:
			String( Property.TDSStringType, Property.TDSStringType ? (FrameLength - FrameOffset)/2 : (FrameLength - FrameOffset) )  SQLText;
	}
}

struct  TDSTransMgrReq
{
	// TransMgrReq	:=	ALL_HEADERS,
	//	RequestType,
	//	RequestPayload;
	[Property.TDSVersion = UINT32(FrameData, FrameOffset) == 0x16 ? 7.2 : Property.TDSVersion]
	switch
	{
		case Property.TDSVersion >= 7.2:
		TDSALLHeaders TDSAllHeadersData; // only in YUKON!
	}

	// RequestType	:=	UINT16;
	UINT16 RequestType;

	switch (RequestType)
	{
		case 0:
			//	0 = TM_GET_DTC_ADDRESS 
			struct TM_GET_DTC_ADDRESS
			{//RequestPayload  :=   US_VARBYTE;
				UINT16 RequestPayloadLength;
				TDSHexDump(RequestPayloadLength) RequestPayload;
			}

		case 1:
			//	1 = TM_PROPAGATE_XACT 
			struct TM_PROPAGATE_XACT
			{//RequestPayload  :=   US_VARBYTE;
				UINT16 RequestPayloadLength;
				TDSHexDump(RequestPayloadLength) RequestPayload;
			}

		case 5:
			//	5 = TM_BEGIN_XACT
			struct TM_BEGIN_XACT
			{
				// RequestPayload  :=   ISOLATION_LEVEL, BEGIN_XACT NAME;
				// ISOLATION_LEVEL   := UINT8;
				// BEGIN_XACT_NAME   := B_VARCHAR;
				UINT8 ISOLATION_LEVEL;
				UINT8 BEGIN_XACT_NAME_Length;
				TDSHexDump(BEGIN_XACT_NAME_Length) BEGIN_XACT_NAME;
			} 
        	
		case 6:
			//	6 = TM_PROMOTE_PROMOTABLE_XACT 
			struct TM_PROMOTE_PROMOTABLE_XACT
			{ // TM_PROMOTE_PROMOTABLE_XACT - no data
			}

		case 7:
			//	7 = TM_COMMIT_XACT 
			struct TM_COMMIT_XACT
			{
				// RequestPayload  :=   XACT NAME,
				//         XACT_FLAGS,
				//         ISOLATION_LEVEL,
				//         BEGIN_XACT_NAME;
        	
				// XACT_NAME   := B_VARCHAR;
				UINT8 XACT_NAME_Length;
				TDSHexDump (XACT_NAME_Length) XACT_NAME;
        	
				// XACT_FLAGS   :=
				//   fBeginXact,
				//   FRESERVEDBIT,
				//   FRESERVEDBIT,
				//   FRESERVEDBIT,
				//   FRESERVEDBIT,
				//   FRESERVEDBIT,
				//   FRESERVEDBIT,
				//   FRESERVEDBIT;
				// fBeginXact            := BIT;
				UINT8 XACT_FLAGS
				{
					UINT8 fBeginXact:1 = FormatString("  (%s) %s",this.toBitString, this ? "BEGIN_XACT_NAME is nonempty" : "BEGIN_XACT_NAME SHOULD NOT be present");
					UINT8 FRESERVEDBIT:7 = FormatString("(%s) %s",this.toBitString,"Unused Bit");
				};
        	
				// ISOLATION_LEVEL   := UINT8;
				UINT8 ISOLATION_LEVEL;
        	
				// BEGIN_XACT_NAME   := B_VARCHAR;
				UINT8 BEGIN_XACT_NAME_Length;
				TDSHexDump (BEGIN_XACT_NAME_Length) BEGIN_XACT_NAME;
			}
        	
		case 8:
			//	8 = TM_ROLLBACK_XACT 
			struct TM_ROLLBACK_XACT
			{
				// RequestPayload  :=   XACT NAME,
				//         XACT_FLAGS,
				//         ISOLATION_LEVEL,
				//         BEGIN_XACT_NAME;
        	
				// XACT_NAME   := B_VARCHAR;
				UINT8 XACT_NAME_Length;
				AsciiString (XACT_NAME_Length) XACT_NAME;
        	
				// XACT_FLAGS   :=
				//   fBeginXact,
				//   FRESERVEDBIT,
				//   FRESERVEDBIT,
				//   FRESERVEDBIT,
				//   FRESERVEDBIT,
				//   FRESERVEDBIT,
				//   FRESERVEDBIT,
				//   FRESERVEDBIT;
				// fBeginXact            := BIT;
				UINT8 XACT_FLAGS
				{
					UINT8 fBeginXact:1 = FormatString("  (%s) %s",this.toBitString, this ? "BEGIN_XACT_NAME MAY be nonempty" : "BEGIN_XACT_NAME SHOULD NOT be present");
					UINT8 FRESERVEDBIT:7 = FormatString("(%s) %s",this.toBitString,"Unused Bit");
				};
        	
				// ISOLATION_LEVEL   := UINT8;
				UINT8 ISOLATION_LEVEL;
        	
				// BEGIN_XACT_NAME   := B_VARCHAR;
				UINT8 BEGIN_XACT_NAME_Length;
				TDSHexDump (BEGIN_XACT_NAME_Length) BEGIN_XACT_NAME;
			}

		case 9:
			//	9 = TM_SAVE_XACT 
			struct TM_SAVE_XACT
			{
				// RequestPayload  :=   XACT_SAVEPOINT_NAME;
				// XACT_SAVEPOINT_NAME   := B_VARCHAR;
				UINT8 XACT_SAVEPOINT_NAME_Length;
				TDSHexDump (XACT_SAVEPOINT_NAME_Length) XACT_SAVEPOINT_NAME;
			}
		// default - invalid RequestType
	}
}


struct TDSBulkLoadBCP
{
	switch
	{
		case Property.TDSVersion == 4.2: TDSBulkLoadBCPRowData RowData;//[MS-SSTDS]
		default:
			while Option[FrameOffset < FrameLength]
			{
				[Property.TDSTokenType]
				UINT8   TokenType = TDSResponseTypeTable(this);
				TDSResponseTokenData(TokenType) TokenData;
			}
	}
}

//[MS-SSTDS]
struct TDSBulkLoadBCPRowData
{
	[Property.BulkLoadBCPLen]
	UINT16 Length;//TDI 368680
	[DataFieldFrameLength = FrameOffset + Length]
	struct
	{
		TDSBulkLoadBCPColData ColData;
		while Option[FrameOffset < FrameLength]
		{
			UINT16 ImageTextColLenDim;
			UINT8 TiFlag;
			UINT8 ColId;
			UINT16 Reserved;
			TDSValueData(TiFlag, 0, 0) TYPE_VARBYTE;//TDI 368680
		}
	}
}

//[MS-SSTDS]
struct TDSBulkLoadBCPColData
{
	UINT8 NumVarCols;
	UINT8 RowNum;
	[Property.BulkLoadBCPFixedColDataLen = NumVarCols > 0 ? (UINT8(FrameData, FrameOffset + Property.BulkLoadBCPLen - 3) - 4) : (FrameLength - FrameOffset - 3)]
	[Property.BulkLoadBCPVarColDataLen = UINT8(FrameData, FrameOffset + Property.BulkLoadBCPLen - 3 - NumVarCols) - UINT8(FrameData, FrameOffset + Property.BulkLoadBCPLen - 3)]
	[DataFieldFrameLength = NumVarCols > 0 ? (FrameOffset - 2 + UINT8(FrameData, FrameOffset + Property.BulkLoadBCPLen - 3)) : FrameLength]
	struct
	{
		UINT8 FixedColData[Property.BulkLoadBCPFixedColDataLen];//TDI 368680
		//while Paddings[UINT8( Framedata, Offset ) == 0]
		//{
			//UINT8 PadByte;
		//}
		UINT16 RowLen;
	}
	
	switch
	{
		case NumVarCols > 0:
			UINT8 VarColData[Property.BulkLoadBCPVarColDataLen];
	}
	UINT8 Adjust[FrameLength - FrameOffset - NumVarCols - 1];
	UINT8 ColDataOffset[NumVarCols + 1];
}

struct TDSAttention
{ // this packet has only header.
}

struct TDSHeader = FormatString("SPID = %d, Size = %d, PacketID = %d, Window = %d", SPID, Length, PacketID, Window)
{
	[TDSPacketType]
	UINT8 PacketType = FormatString("%s, %d(0x%02X)", TDSPacketTypeTable( this ), this, this);
	[Property.TDSIsLast = (this & 0x01)]
	[Property.IsIgnoreEventData = (this & 0x01) && (this & 0x02)]
	TDSHeaderStatus Status;
	[DatafieldByteOrder = BigEndian]
	[Property.TDSPacketLength]
	UINT16  Length;
	[DatafieldByteOrder = BigEndian]
	[Property.TDSSPID]
	[Conversation.TDSSPIDCon = TDSPacketType == 0x04 ? this : Conversation.TDSSPIDCon]
	UINT16  SPID;
	[Property.TDSPacketID]
	[Conversation.TDSIsPacketIdZero$[TcpSeqNumber + Property.TDSPacketLength] = (this == 0) && !(Status & 0x01) ? true : false]
	[Property.TDSIsFirst = (this == 1) && !(Conversation.TDSIsPacketIdZero$[TcpSeqNumber])]
	UINT8  PacketID;
	UINT8  Window;	
}

struct TDSTypeInfo
{
	UINT8 Type = TDSDataTypeTable(this);

	switch (Type)
	{
		case 0x24:
			// one-UINT8 length
			UINT8 GUID_VARLEN;
		case 0x26:
			// one-UINT8 length
			UINT8 INTN_VARLEN;
		case 0x37:
			// one-UINT8 length
			struct DECIMAL_DATA
			{
				UINT8 DECIMAL_VARLEN;
				UINT8 DECIMAL_PRECISION;
				UINT8 DECIMAL_SCALE;
			};
		case 0x3F:
			// one-UINT8 length
			struct NUMERIC_DATA
			{
				UINT8 NUMERIC_VARLEN;
				UINT8 NUMERIC_PRECISION;
				UINT8 NUMERIC_SCALE;
			};
		case 0x68:
			// one-UINT8 length
			UINT8 BITN_VARLEN;
		case 0x6A:
			// one-UINT8 length
			struct DECIMALN_DATA
			{
				UINT8 DECIMALN_VARLEN;
				UINT8 DECIMALN_PRECISION;
				UINT8 DECIMALN_SCALE;
			};
		case 0x6C:
			// one-UINT8 length
			struct NUMERICN_DATA
			{
				UINT8 NUMERICN_VARLEN;
				UINT8 NUMERICN_PRECISION;
				UINT8 NUMERICN_SCALE;
			};
		case 0x6D:
			// one-UINT8 length
			UINT8 FLTN_VARLEN;
		case 0x6E:
			// one-UINT8 length
			UINT8 MONEYN_VARLEN;
		case 0x6F:
			// one-UINT8 length
			UINT8 DATETIMN_VARLEN;
		case 0x2F:
			// one-UINT8 length
			UINT8 CHAR_VARLEN;
		case 0x27:
			// one-UINT8 length
			UINT8 VARCHAR_VARLEN;
		case 0x2D:
			// one-UINT8 length
			UINT8 BINARY_VARLEN;
		case 0x25:
			// one-UINT8 length
			UINT8 VARBINARY_VARLEN;

		case 0xA5:
			// two-UINT8 length
			UINT16 BIGVARBIN_VARLEN;
		case 0xA7:
			// two-UINT8 length
			struct BIGVARCHRDATA
			{
				UINT16 BIGVARCHR_VARLEN;
				switch
				{
					case Property.TDSVersion >= 7.1:
						UINT8 BIGVARCHRCOLLATION[5];
				}
			};
		case 0xAD:
			// two-UINT8 length
			UINT16 BIGBINARY_VARLEN;
		case 0xAF:
			// two-UINT8 length
			struct BIGCHARDATA
			{
				UINT16 BIGCHAR_VARLEN;
				switch
				{
					case Property.TDSVersion >= 7.1:
						UINT8 BIGCHARCOLLATION[5];
				}
			};
		case 0xE7:
			// two-UINT8 length
			struct NVARCHARDATA
			{
				UINT16 NVARCHAR_VARLEN;
				switch
				{
					case Property.TDSVersion >= 7.1:
						UINT8 NVARCHARCOLLATION[5];
				}
			};
		case 0xEF:
			// two-UINT8 length
			struct NCHARDATA
			{
				UINT16 NCHAR_VARLEN;
				switch
				{
					case Property.TDSVersion >= 7.1:
						UINT8 NCHARCOLLATION[5];
				}
			};
		
		case 0xF1: 
			// SCHEMA_PRESENT		:= UINT8;
			// DBNAME			:= B_VARCHAR;
			// OWNING_SCHEMA			:= B_VARCHAR;
			// XML_SCHEMA_COLLECTION	:= US_VARCHAR;
        	
			// XML_INFO :=	SCHEMA_PRESENT,
			// 	[DBNAME, OWNING_SCHEMA, XML_SCHEMA_COLLECTION]

			struct XML_INFO
			{
				UINT8 SCHEMA_PRESENT;
				switch (SCHEMA_PRESENT)
				{
					case 0x01: // only then are the other attributes present
						struct SCHEMA_INFO
						{
							UINT8 DBNAME_LENGTH;
							[DataFieldByteOrder = LittleEndian]
							UnicodeString(DBNAME_LENGTH) DBNAME;
							UINT8 OWNING_SCHEMA_LENGTH;
							[DataFieldByteOrder = LittleEndian]
							UnicodeString(OWNING_SCHEMA_LENGTH) OWNING_SCHEMA;
							UINT16 XML_SCHEMA_COLLECTION_LENGTH;
							[DataFieldByteOrder = LittleEndian]
							UnicodeString(XML_SCHEMA_COLLECTION_LENGTH) XML_SCHEMA_COLLECTION;
						}
					// default - nothing to read.
				}
			}

		case 0xF0: 
			// UDT_INFO :=		MAX_BYTE_SIZE,
			// 		DB_NAME,
			// 		SCHEMA_NAME,
			// 		TYPE_NAME,
			// 		UDT_METADATA;

			struct UDT_INFO
			{
				// DB_NAME			:=	B_VARCHAR;
				// SCHEMA_NAME			:=	B_VARCHAR;
				// TYPE_NAME			:=	B_VARCHAR;
				// MAX_BYTE_SIZE			:=	UINT16;
				// ASSEMBLY_QUALIFIED_NAME	:=	US_VARCHAR;
				UINT16 MAX_BYTE_SIZE;
				UINT8 DB_NAME_LENGTH;
				[DataFieldByteOrder = LittleEndian]
				UnicodeString(DB_NAME_LENGTH) DB_NAME;
				UINT8 SCHEMA_NAME_LENGTH;
				[DataFieldByteOrder = LittleEndian]
				UnicodeString(SCHEMA_NAME_LENGTH) SCHEMA_NAME;
				UINT8 TYPE_NAME_LENGTH;
				[DataFieldByteOrder = LittleEndian]
				[Property.TDSTypeName]
				UnicodeString (TYPE_NAME_LENGTH) TYPE_NAME;
				UINT16 ASSEMBLY_QUALIFIED_NAME_LENGTH;
				[DataFieldByteOrder = LittleEndian]
				UnicodeString (ASSEMBLY_QUALIFIED_NAME_LENGTH) ASSEMBLY_QUALIFIED_NAME;
			}

		case 0x23:
			// four-UINT8 length
			struct TEXTDATA
			{
				UINT32 TEXT_VARLEN;
				switch
				{
					case Property.TDSVersion >= 7.1:
						UINT8 TEXTCOLLATION[5];
				}
			};
		case 0x22:
			// four-UINT8 length
			struct IMAGEDATA
			{
				UINT32 IMAGE_VARLEN;
			}
		case 0x63:
			// four-UINT8 length
			struct NTEXTDATA
			{
				UINT32 NTEXT_VARLEN;
				switch
				{
					case Property.TDSVersion >= 7.1:
						UINT8 NTEXTCOLLATION[5];
				}
			};
		case 0x62:
			// four-UINT8 length
			UINT32 SSVARIANT_VARLEN;
		//0x28-0x2b are introduced in TDS 7.3
		case 0x28:
			// DATE MUST NOT have a TYPE_VARLEN. The value is either 3 bytes or 0 bytes (null)
			struct DATENTYPE{};
		case 0x29:
			// (VARLENTYPE SCALE)
			struct TIMENTYPE
			{
				UINT8 NUMERICN_SCALE;
			}
		case 0x2a:
			// (VARLENTYPE SCALE)
			struct DATETIME2NTYPE
			{
				UINT8 NUMERICN_SCALE;
			}
		case 0x2b:	
			// (VARLENTYPE SCALE)
			struct DATETIMEOFFSETNTYPE
			{
				UINT8 NUMERICN_SCALE;
			}
		case 0x1F: // no more data
		case 0x30: // no more data
		case 0x32: // no more data
		case 0x34: // no more data
		case 0x38: // no more data
		case 0x3A: // no more data
		case 0x3B: // no more data
		case 0x3C: // no more data
		case 0x3D: // no more data
		case 0x3E: // no more data
		case 0x7A: // no more data
		case 0x7F: // no more data
			struct{};
		default: // invalid type - don't read anything
			ReportParserError(ParserErrorProtocolClassPublic, "TDS", "Unrecognized TDS Type Info") TypeInfoError;
	}
}

