//#  (c) 2009 CodePlex Foundation
//#
//#  Title:                  Disk Management Remote Protocol
//#
//#  Details:                
//#
//#  Microsoft References:   [MS-DMRP]: Disk Management Remote Protocol Specification
//#
//#  Comments:               
//#
//#  Revision Class and Date:Major, 7/1/2009
//#                          Minor, 4/21/2010
//#
//####

//========= PROTOCOL ==============================================================================================
Protocol DMRP //= FormatString( "%s: %s%s%s%s%s", DMRPInterfaceTable( Property.MSRPCIfUuid ), DMRPMethodTable( Property.MSRPCIfUuid, Property.MSRPCOpnum ), Property.MSRPCPType ? " Response" : " Request", DMRPSummary, Property.MSRPCPType ? ", " + "Status = " + ReturnValue : "", Property.ParserError ? ", " + Property.ParserErrorMessage : Property.ParserErrorMessage )
 = FormatString( "%s %s%s%s%s%s", 
	Property.DMRPMethodName,
	Property.MSRPCPType ? "Response" : "Request",
	( Property.MSRPCPfcFlags & 0x03 ) == 0x01 ? ", RPC first fragment" : "",
	Property.MSRPCCompleteFrag == 0 ? ", partial" : "",
	Property.MSRPCEncrypted == ConstEncTypeEncrypted ? ", *Encrypted*" : Property.MSRPCEncrypted == ConstEncTypeUnknown ? ", *Un-Interpreted*": "",
	Property.DMRPSummary && Property.MSRPCEncrypted == ConstEncTypeClearData ? ", " + Property.DMRPSummary : "" )
{
	[Property.DMRPSummary = ""]
	switch ( Property.MSRPCIfUuid )
	{
		case "{D2D79DF7-3400-11D0-B40B-00AA005FF586}":
		[Property.DMRPMethodName = "IDMNotify:" + DMRPIDMNotifyMethodTable( Property.MSRPCOpnum )]
		_Struct DMRPCommonIDMNotify
		{
			switch( Property.MSRPCOpnum )
			{
				case 0x0003:
				_Struct DMRPCommonObjectsChanged
				{
					switch( Property.MSRPCPType )
					{
						case 0x00: //REQUEST
						[IDMNotifySummary = ""]
						_Struct DMRPCommonRequest
						{
							switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										UINT32 ByteCount;
										[DMRPEnd = FrameOffset + LengthConformant.MaxCount] 
										NdrConformant  LengthConformant;
										[PostAfter.DMRPINBYTESTREAM = 0]
										while condition[FrameOffset < DMRPEnd ]
										{
											[DMRPINBYTESTREAM = 1, DataFieldFrameLength = FrameOffset + UINT32(FrameData,FrameOffset)]
											DMRPByteStream ByteStream;
										}
									}
							}
						}

						case 0x02: //RESPONSE
						[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
						_Struct DMRPCommonResponse
						{
							switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										[ReturnValue = this.ToString] 
										HRESULT ReturnValue;
									}
							}
						}
					}
				}
				Default: 
					ReportParserError(ParserErrorProtocolClassWindows, "DMRP", "Unknown IDMNotify method, Opnum:" + Property.MSRPCOpnum ) UnknownMethod;
			}
		}

		case "{D2D79DF5-3400-11D0-B40B-00AA005FF586}":
			[Property.DMRPMethodName = "IVolumeClient:" + DMRPIVolumeClientMethodNameTable( Property.MSRPCOpnum )]
			_Struct DMRPCommonIVolumeClient
			{
				switch( Property.MSRPCOpnum )
				{
					case 3:
						_Struct DMRPCommonEnumDisks
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct DMRPCommonRequest
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct DMRPCommonResponse
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 DiskCount;
													NdrPtr ptr2diskList;
													switch
													{
														case ptr2diskList.ReferentID > 0:
														Struct diskList = FormatString("%d Elements", diskCount)
														{
															NdrConformant diskListConformant;
															[DiskInfoEnterCount = 0]
															switch
															{
																case diskCount>0:
																_struct list
																{
																	ALIGN8 alignDiskInfo; 
																	[DiskInfoEnterCount = 0]  
																	while condition1[ DiskInfoEnterCount < diskCount ]
																	{
																		[DiskInfoEnterCount = DiskInfoEnterCount + 1]
																		[DMRPDiskInfoDeviceType = ""]
																		DMRPDiskInfo diskInfo;
																	}
																	[DiskInfoEnterCount = 0]
																	while condition2[ DiskInfoEnterCount < diskCount ]
																	{
																		[DiskInfoEnterCount = DiskInfoEnterCount + 1]
																		[DMRPDiskInfoDeviceNameValue = ""]
																		DMRPCommonDiskInfoReference DiskInfoReference;
																	}            
																}
															}
														};
													}	
													Align4 dwReturnValueAlign;
													[ReturnValue = this.ToString]
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 4:
						_Struct DMRPCommonEnumDiskRegions
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct DMRPCommonRequest
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId DiskId;
													UINT32 NumRegions;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct DMRPCommonResponse
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 NumRegions;
													NdrPtr ptr2RegionList;
													switch
													{
														case ptr2RegionList.ReferentID > 0:
														Struct DMRPCommonRegionList = FormatString("%d elements", numRegions)
														{
															NdrConformant RegionListConformant;
															switch
															{
																case numRegions>0:
																_struct DMRPCommonRegionList
																{
																	ALIGN8 ALIGN1;
																	[CurrentRegion = 0]
																	while [CurrentRegion < numRegions]
																	{
																		[CurrentRegion = CurrentRegion + 1]
																		DMRPRegionInfo RegionInfo;
																	}   
																}
															}                                
														}
													}
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 5:
						_Struct DMRPCommonCreatePartition
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct DMRPCommonRequest
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPRegionSpec PartitionSpec;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct DMRPCommonResponse
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct Tinfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 6:
						_Struct DMRPCommonCreatePartitionAssignAndFormat
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "Letter=%s", Letter.ToString )]
									_Struct DMRPCommonRequest
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPRegionSpec PartitionSpec;
													WCHAR Letter;
													ALIGN8 ALIGN1;
													HYPER LetterLastKnownState;
													DMRPFileSystemInfo FsSpec;
													boolean QuickFormat = DMRPCreatePartitionAssignAndFormatquickFormatTable( this );
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct DMRPCommonResponse
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct Tinfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 7:
						_Struct DMRPCommonCreatePartitionAssignAndFormatEx
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "Letter=%s CchAccessPath=0x%X AccessPath=%s Flags=0x%X", Letter.ToString, CchAccessPath, Path.ToString, Flags )]
									_Struct DMRPCommonRequest
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPRegionSpec PartitionSpec;
													WCHAR Letter;
													ALIGN8 ALIGN1;           
													HYPER LetterLastKnownState;
													INT32 CchAccessPath;
													NdrConformant AccessPathConformant;
													switch
													{
														case cchAccessPath > 0:
														UnicodeString(cchAccessPath) Path;
													}
													Align8 Align;
													DMRPFileSystemInfo FsSpec;
			    	    	    	
													boolean QuickFormat = DMRPCreatePartitionAssignAndFormatExquickFormatTable( this );
													ALIGN4 ALIGN2;
													UINT32 Flags = DMRPCreatePartitionAssignAndFormatExdwFlagsTable( this );
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct DMRPCommonResponse
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
											struct
											{
												DMRPTaskInfoStruct Tinfo;
												[ReturnValue = this.ToString] 
												HRESULT ReturnValue;
											}
										}
									}
							}
						}

					case 8:
						_Struct DMRPCommonDeletePartition
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct DMRPCommonRequest
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPRegionSpec PartitionSpec;
													boolean Force = DMRPDeletePartitionforceTable( this );
												}
										}
									}
    	    	
								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct DMRPCommonResponse
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct Tinfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 9:
						_Struct DMRPCommonWriteSignature
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct DMRPCommonRequest
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId DiskId;
													hyper DiskLastKnownState;
												}
										}
									}
								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct DMRPCommonResponse
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct Tinfo;
													[ReturnValue = this.ToString]
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 10:
						_Struct DMRPCommonMarkActivePartition
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct DMRPCommonRequest
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId RegionId;
													hyper RegionLastKnownState;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct DMRPCommonResponse
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct Tinfo;
													[ReturnValue = this.ToString]
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 11:
						_Struct DMRPCommonEject
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct DMRPCommonRequest
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId DiskId;
													hyper DiskLastKnownState;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct DMRPCommonResponse
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct Tinfo;
													[ReturnValue = this.ToString]
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

/*
					case 0x000C:
						_Struct RestoreConfiguration
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct Request
									{
										WCHAR letter;
									}
    	    	
								case 0x02: //RESPONSE
									[IVolumeClientSummary = ""]
									_Struct Response
									{
										[ReturnValue = this.ToString]
										HRESULT dwReturnValue;
									}
							}
						}
*/

					case 13:
						_Struct DMRPCommonFTEnumVolumes
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct DMRPCommonRequest
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 VolumnCount;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct DMRPCommonResponse
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 volumeCount;
													NdrPtr ptr2ftVolumeList;
													switch
													{
														case ptr2ftVolumeList.ReferentID > 0:
														Struct VolumeInfoList = FormatString("%d Elements", volumeCount)
														{
															NdrConformant volumeListConformant;
															[CurrentVolume = 0]
															while [CurrentVolume < volumeCount]
															{
																ALIGN8 align1;
																[CurrentVolume = CurrentVolume + 1]
																DMRPVolumeInfo volumeInfo;
															}        
														}
													}
													[ReturnValue = this.ToString]
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 14:
						_Struct DMRPCommonFTEnumLogicalDiskMembers
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct DMRPCommonRequest
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId VolumeId;
													UINT32 MemberCount;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct DMRPCommonResponse
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 memberCount;
													NdrPtr ptr2memberList;
													switch
													{
														case ptr2memberList.ReferentID > 0:
														Struct MembersList = FormatString("%d Elements", memberCount)
														{ 
															NdrConformant memberListConformant;  
															switch
															{
																case memberCount>0:
																_struct member
																{
																	Align8 align;
																	LdmObjectId member[memberCount];
																}
															}
														}
													}
													[ReturnValue = this.ToString]
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 15:
						_Struct DMRPCommonFTDeleteVolume
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct DMRPCommonRequest
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId VolumeId;
													boolean Force = DMRPFTDeleteVolumeforceTable( this );
													ALIGN8 ALIGN1;
													hyper VolumeLastKnownState;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct DMRPCommonResponse
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct Tinfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
									}
												}
										}
							}
						}

					case 16:
						_Struct DMRPCommonFTBreakMirror
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "BForce=0x%X", BForce )]
									_Struct DMRPCommonRequest
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId VolumeId;
													hyper VolumeLastKnownState;
													UINT32 BForce = DMRPFTBreakMirrorbForceTable( this );
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct DMRPCommonResponse
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 17:
						_Struct DMRPCommonFTResyncMirror
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct DMRPCommonRequest
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId VolumeId;
													hyper VolumeLastKnownState;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct DMRPCommonResponse
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 18:
						_Struct DMRPCommonFTRegenerateParityStripe
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct DMRPCommonRequest
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId VolumeId;
													hyper VolumeLastKnownState;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct DMRPCommonResponse
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct Tinfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 19:
						_Struct DMRPCommonFTReplaceMirrorPartition
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "Flags=0x%X", Flags )]
									_Struct DMRPCommonRequest
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId VolumeId;
													hyper VolumeLastKnownState;
													LdmObjectId OldMemberId;
													hyper OldMemberLastKnownState;
													LdmObjectId NewRegionId;
													hyper NewRegionLastKnownState;
													UINT32 Flags = DMRPFTReplaceMirrorPartitionflagsTable( this );
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct DMRPCommonResponse
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct Tinfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 20:
						_Struct DMRPCommonFTReplaceParityStripePartition
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "Flags=0x%X", Flags )]
									_Struct DMRPCommonRequest
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId VolumeId;
													hyper VolumeLastKnownState;            
													LdmObjectId OldMemberId;
													hyper OldMemberLastKnownState;
													LdmObjectId NewRegionId;
													hyper NewRegionLastKnownState;
													UINT32 flags                                                                                                                   
													{    
														UINT32 NotCheckChanges:1 = FormatString("(%s) %s", this.ToBitString,  this ? "Do not check for changes since the last known modification of the partition"
														: "Check for changes since the last known modification of the partition" );                                                                                                                                                                                                                    
														UINT32 DeleteOnFail:1 = FormatString("   (%s) %s", this.ToBitString,  this ? "Delete the new partition if creation fails"                                 
														: "Do not delete the new partition if creation fails" );                         
													
													}
												}
										}
									}
    	    	
								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct DMRPCommonResponse
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct Tinfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 21:
						_Struct DMRPCommonEnumDriveLetters
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct DMRPCommonRequest
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 DriveLetterCount;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct DMRPCommonResponse
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 DriveLetterCount;
													NdrPtr ptr2DriveLetterList;
													switch
													{
														case ptr2DriveLetterList.ReferentID > 0:
														Struct DriveLetterInfoList = FormatString("%d Elements", driveLetterCount)
														{
															NdrConformant DriveLetterListConformant;
															[CurrentLetterInfo = 0]
															while [CurrentLetterInfo < driveLetterCount]
															{
																ALIGN8 align1; 
																[CurrentLetterInfo = CurrentLetterInfo + 1]
																DMRPDriveLetterInfo driveLetterInfo;
															}    
														}
													}
													[ReturnValue = this.ToString]
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 22:
						_Struct DMRPCommonAssignDriveLetter
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "Letter=%s ForceOption=0x%X", Letter.ToString, ForceOption )]
									_Struct DMRPCommonRequest
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													WCHAR Letter;
													ALIGN4 Align1;
													UINT32 ForceOption = DMRPAssignDriveLetterforceOptionTable( this );
													hyper LetterLastKnownState;
													LdmObjectId StorageId;
													hyper StorageLastKnownState;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct DMRPCommonResponse
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct Tinfo;
													[ReturnValue = this.ToString]
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 23:
						_Struct DMRPCommonFreeDriveLetter
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "Letter=%s ForceOption=0x%X", Letter.ToString, ForceOption )]
									_Struct DMRPCommonRequest
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													WCHAR Letter;
													ALIGN4 Align1;
													UINT32 ForceOption = DMRPFreeDriveLetterforceOptionTable( this );
													hyper LetterLastKnownState;
													LdmObjectId StorageId;
													hyper StorageLastKnownState;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct DMRPCommonResponse
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct Tinfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 24:
						_Struct DMRPCommonEnumLocalFileSystems 
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct DMRPCommonRequest
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct DMRPCommonResponse
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 FileSystemCount;
													NdrPtr ptr2FileSystemList;
													switch
													{
														case ptr2FileSystemList.ReferentID > 0:
														struct FileSystemList = FormatString("%d Elements", fileSystemCount)
														{
															NdrConformant fileSystemListConformant;
															[CurrentFileSystem = 0]
															while [CurrentFileSystem < fileSystemCount]
															{
																ALIGN8 ALIGN1;
																[CurrentFileSystem = CurrentFileSystem + 1]
																DMRPFileSystemInfo fileSystemInfo;
															}
															[CurrentFileSystem = 0]
															while [CurrentFileSystem < fileSystemCount]
															{
																[CurrentFileSystem = CurrentFileSystem + 1]
																DMRPCommonFileSystemInfoReference fileSystemInfoReference;
															}
														}
													}
													ALIGN4 ALIGN2;
													[ReturnValue = this.ToString]
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 25:
						_Struct DMRPCommonGetInstalledFileSystems 
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct DMRPCommonRequest
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct DMRPCommonResponse
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 FsCount;
													NdrPtr ptr2fsList;
													switch
													{
														case ptr2fsList.ReferentID > 0:
														struct IFileSystemList = FormatString("%d Elements", fsCount)
														{
															NdrConformant fsListConformant;
															[CurrentFS = 0]
															while [CurrentFS < fsCount]
															{
																[CurrentFS = CurrentFS + 1]
																DMRPIFileSystemInfo IFileSystemInfo;
															}
															[CurrentFS = 0]
															while [CurrentFS < fsCount]
															{
																[CurrentFS = CurrentFS + 1]
																DMRPCommonIFileSystemInfoReference IFileSystemInfoReference;
															}
														}
													}
													ALIGN4 ALIGN3;
													[ReturnValue = this.ToString]
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 26:
						_Struct DMRPCommonFormat
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct DMRPCommonRequest
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId StorageId;
													DMRPFileSystemInfo FsSpec;
													boolean QuickFormat = DMRPFormatquickFormatTable( this );
													boolean Force = DMRPFormatforceTable( this );
													ALIGN8 Align1;
													hyper StorageLastKnownState;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct DMRPCommonResponse
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct Tinfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

/*
					case 27:
						_Struct Grow
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct Request
									{
										LdmObjectId storageId;
										hyper length;   // hyper or INT64 ??
										BOOLEAN force = FormatString("%s", this ? "TRUE : Size change of the file system is forced." 
										: "FALSE : Size change of the file system is not forced.");
										ALIGN8 align1;
										hyper fsLastKnownState;
									}

								case 0x02: //RESPONSE
									[IVolumeClientSummary = ""]
									_Struct Response
									{
										DMRTaskInfoStruct tinfo;
										[ReturnValue = this.ToString] 
										HRESULT dwReturnValue;
									}
							}
						}
*/

					case 28:
						_Struct DMRPCommonEnumVolumes
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct DMRPCommonRequest
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 VolumeCount;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct DMRPCommonResponse
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 VolumeCount;
													NdrPtr ptr2LdmVolumeList;
													switch
													{
														case ptr2LdmVolumeList.ReferentID > 0:
														struct volumeInfoList = FormatString("%d Elements", volumeCount)
														{
															NdrConformant LdmVolumeConformant;
															[CurrentVolume = 0]
															while [CurrentVolume < volumeCount]
															{
																ALIGN8 align1;
																[CurrentVolume = CurrentVolume + 1]
																DMRPVolumeInfo LdmVolume;
															}        
														}
													}
													[ReturnValue = this.ToString]
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 29:
						_Struct DMRPCommonEnumVolumeMembers
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct DMRPCommonRequest
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId VolumeId;
													UINT32 MemberCount;
												}
											
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct DMRPCommonResponse
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 MemberCount;
													NdrPtr ptr2memberList;
													switch
													{
														case ptr2memberList.ReferentID > 0:
														struct MemberList = FormatString("%d Elements", memberCount)
														{
															NdrConformant memberListConformant;
															switch
															{
																case memberCount > 0:
																_struct DMRPCommonMember
																{
																	ALIGN8 ALIGN1;
																	LdmObjectId member[memberCount];
																}
															}            
														}
													}
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 30:
						_Struct DMRPCommonCreateVolume
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "DiskCount=0x%X", DiskCount )]
									_Struct DMRPCommonRequest
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPVolumeSpec VolumeSpec;
													UINT32 DiskCount;
													NdrConformant diskListConformant;
													switch
													{
														case diskCount > 0:   
														struct diskList = FormatString("%d Elements", diskCount)
														{
															[DiskEnter = 0]
															while [DiskEnter < diskCount]
															{
																[DiskEnter = DiskEnter + 1]
																DMRPDiskSpec diskSpec;
															} 
														}
													}
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct DMRPCommonResponse
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct Tinfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 31:
						_Struct DMRPCommonCreateVolumeAssignAndFormat
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "DiskCount=0x%X Letter=%s", DiskCount, Letter.ToString )]
									_Struct DMRPCommonRequest
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPVolumeSpec VolumeSpec;
													UINT32 DiskCount;
													NdrConformant diskListConformant;
													switch
													{
														case diskCount > 0:
														struct diskList  = FormatString("%d Elements", diskCount)
														{
															[DiskEnter = 0]
															while [DiskEnter < diskCount]
															{
																[DiskEnter = DiskEnter + 1]
																DMRPDiskSpec diskSpec;
															} 
														}
													}
													WCHAR Letter;
													ALIGN8 ALIGN1;
													hyper LetterLastKnownState;
													DMRPFileSystemInfo FsSpec;
													boolean QuickFormat = DMRPCreateVolumeAssignAndFormatquickFormatTable( this );
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct DMRPCommonResponse
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct Tinfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 32:
						_Struct DMRPCommonCreateVolumeAssignAndFormatEx
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "DiskCount=0x%X Letter=%s CchAccessPath=0x%X AccessPath=%s Flags=0x%X", DiskCount, Letter.ToString, CchAccessPath, Path.ToString, Flags )]
									_Struct DMRPCommonRequest
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPVolumeSpec VolumeSpec;
													UINT32 DiskCount;
													NdrConformant diskListConformant;
													switch  
													{
														case diskCount>0:
														Struct diskList  = FormatString("%d Elements", diskCount)
														{
															[DiskEnter = 0]
															while [DiskEnter < diskCount]
															{
																[DiskEnter = DiskEnter + 1]
																DMRPDiskSpec diskSpec;
															} 
														}
													}                
													WCHAR Letter;
													ALIGN8 ALIGN1;
													hyper LetterLastKnownState;
													INT32 CchAccessPath;
													NdrConformant AccessPathConformant;  
													switch
													{
														case cchAccessPath > 0:
														UnicodeString(AccessPathConformant.maxCount) Path;
													}
													ALIGN8 ALIGN2;
													DMRPFileSystemInfo FsSpec;
													BOOLEAN quickFormat = FormatString("%s", this ? "TRUE : File system will be quickly formatted" 
													: "FALSE : File system will be fully formatted");
													ALIGN4 ALIGN3;
													UINT32 Flags = DMRPCreateVolumeAssignAndFormatExdwFlagsTable( this );
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct DMRPCommonResponse
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct Tinfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 33:
						_Struct GetVolumeMountName
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct Request
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId VolumeId;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "MountName=%s ReturnValue=%s", MountName.Name.ToString, ReturnValue )]
									_Struct Response
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 CchMountName;
													NdrPtr ptr2MountName;
													switch
													{
														case ptr2MountName.ReferentID > 0:
														struct MountName = DMRPVolumeMountName
														{
															NdrConformant MountNameConformant;                         
															switch
															{
																case cchMountName > 0:
																[DMRPVolumeMountName = this]
																UnicodeString( cchMountName ) Name;
															}
														}
													}
													Align4 Align;
													[ReturnValue = this.ToString]
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 34:
						_Struct GrowVolume
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "DiskCount=0x%X", DiskCount )]
									_Struct Request
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId VolumeId;
													DMRPVolumeSpec VolumeSpec;
													UINT32 DiskCount;
													NdrConformant diskListConformant;
													switch
													{
														case diskCount> 0:
														Struct diskList  = FormatString("%d Elements", diskCount)
														{
															[DiskEnter = 0]
															while [DiskEnter < diskCount]
															{
																[DiskEnter = DiskEnter + 1]
																DMRPDiskSpec diskSpec;
															} 
														};
													}
													boolean Force = DMRPGrowVolumeforceTable( this );
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct Tinfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 35:
						_Struct DeleteVolume
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct Request
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId VolumeId;
													boolean Force = DMRPDeleteVolumeforceTable( this );
													ALIGN8 ALIGN;
													hyper VolumeLastKnownState;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct Tinfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 36:
						_Struct AddMirror
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct Request
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId VolumeId;
													hyper VolumeLastKnownState;
													DMRPDiskSpec DiskSpec;
													UINT32 DiskNumber = "Not used by Windows 2000, Windows XP, or Windows Server 2003 servers.";
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 DiskNumber = "Not used by Windows 2000, Windows XP, or Windows Server 2003 servers.";
													UINT32 PartitionNumber = FormatString("%d(0x%X)  %s", this, this, "If the volumeId parameter is the boot volume, this parameter is a pointer to the partition number of the newly added plex.");
													DMRPTaskInfoStruct Tinfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 37:
						_Struct RemoveMirror
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct Request
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId VolumeId;
													hyper VolumeLastKnownState;
													LdmObjectId DiskId;
													hyper DiskLastKnownState;
												}
										}
										
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct Tinfo;
													[ReturnValue = this.ToString]
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 38:
						_Struct SplitMirror
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "Letter=%s", Letter.ToString )]
									_Struct Request
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId VolumeId;
													hyper VolumeLastKnownState;
													LdmObjectId DiskId;
													hyper DiskLastKnownState;
													WCHAR Letter;
													ALIGN8 ALIGN;
													hyper LetterLastKnownState;
													DMRPTaskInfoStruct TaskInfoStruct;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfoStruct;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 39:
						_Struct InitializeDisk
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct Request
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId DiskId;
													hyper DiskLastKnownState;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 40:
						_Struct UninitializeDisk
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct Request
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId DiskId;
													hyper DiskLastKnownState;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 41:
						_Struct ReConnectDisk
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct Request
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId DiskId;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

/*
					case 42:
						_Struct GetDetachDiskInfo
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct Request
									{
										LdmObjectId diskId;
										hyper diskLastUpdateId;
									}

								case 0x02: //RESPONSE
									[IVolumeClientSummary = ""]
									_Struct Response
									{
										UINT32 affectedVolCount;
										NdrPtr ptr2AffectedVolList;
										switch
										{
											case ptr2AffectedVolList.ReferentID > 0:
											Struct AffectedVolList = FormatString("%d Elements", affectedVolCount)
											{
												NdrConformant affectedVolListConformant;
												[CurrentVol = 0]
												while [CurrentVol < affectedVolCount]
												{
													ALIGN8 ALIGN1;
													[CurrentVol = CurrentVol + 1]
													VolumeInfo affectedVol;
												}
											}
										}
										ALIGN8 ALIGN2;
										DMRTaskInfoStruct tinfo;
										[ReturnValue = this.ToString]
										HRESULT dwReturnValue;
									}
							}
						}
*/

					case 43:
						_Struct ImportDiskGroup
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "CchDgid=0x%X", CchDgid )]
									_Struct Request
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													INT32 CchDgid;
													NdrConformant dgidConformant;
													switch
													{
														case cchDgid> 0:
														UUID(1) dgid;
													}
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 44:
						_Struct DiskMergeQuery
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "CchDgid=0x%X NumDisks=0x%X", CchDgid, NumDisks )]
									_Struct Request
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													INT32 CchDgid;
													NdrConformant dgidConformant;
													switch
													{
														case cchDgid > 0:
														UUID(1) Dgid;
													}
													INT32 NumDisks;
													NdrConformant diskListConformant;
													switch
													{
														case numDisks > 0:
														LdmObjectId disk[numDisks];
													}
													UINT32 Flags = DMRPDiskMergeQueryflagsTable( this );
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													hyper MergeConfigTID;
													INT32 NumRids;
													NdrPtr ptr2MergeDMRIDs;
													switch
													{
														case ptr2MergeDMRIDs.ReferentID > 0:
														struct MergeDMRIDs = FormatString("%d Elements", numRids)
														{
															NdrConformant MergeDMRPIDsConformant;
															switch
															{
																case numRids>0:
																_struct rids
																{
																	ALIGN8 align1;
																	hyper MergeDMRID[numRids];
																}
															}
														}
													}
													INT32 NumObjects;
													NdrPtr ptr2mergeObjectInfo;
													switch
													{
														case ptr2mergeObjectInfo.ReferentID > 0:
														struct mergeObjectInfo = FormatString("%d Elements", numObjects)
														{
															NdrConformant mergeObjectInfoConformant;
															switch
															{
																case numObjects>0:
																_struct object
																{
																	ALIGN8 align2;
																	DMRPMergeObjectInfo mergeObject[numObjects];
																}
															}
														}
													}
													UINT32 Flags = DMRPDiskMergeQueryflagsTable( this );                                     
													ALIGN8 ALIGN2;
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 45:
						_Struct DiskMerge
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "CchDgid=0x%X NumDisks=0x%X NumRids=0x%X", CchDgid, NumDisks, NumRids )]
									_Struct Request
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													INT32 CchDgid;
													NdrConformant dgidConformant;
													switch
													{
														case cchDgid > 0:
														UUID(1) Dgid;
													}
													INT32 NumDisks;
													NdrConformant diskListConformant;
													switch
													{
														case numDisks > 0:
														struct DiskList = FormatString("%d Elements", numDisks)
														{
															LdmObjectId disk[numDisks];
														}
													}
													hyper MergeConfigTID;
													INT32 NumRids;
													NdrConformant MergeDMRIDsConformant;
													switch
													{
														case numRids > 0:
														struct MergeDMRIDs = FormatString("%d Elements", numRids)
														{
															hyper MergeDMRID[numRids];
														}
													}
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 46:
						_Struct DetachDisk
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "AffectedVolCount=0x%X", AffectedVolCount )]
									_Struct Request
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId DiskId;
													hyper DiskLastUpdateId;
													UINT32 AffectedVolCount;
													NdrConformant VolLastKnownStateListConformant;
													switch
													{
														case affectedVolCount > 0:
														Struct volLastKnownStateList = FormatString("%d Elements", affectedVolCount)
														{
															ALIGN8 Align;
															hyper volLastKnownState[affectedVolCount];
														}
													}
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 47:
						_Struct ReAttachDisk
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct Request
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId DiskId;
													hyper DiskLastKnownState;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 48:
						_Struct ReplaceDisk
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct Request
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId OldDiskId;
													hyper OldDiskLastKnownState;
													LdmObjectId NewDiskId;
													hyper NewDiskLastKnownState;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

/*
					case 0x0031:
						_Struct ResetDiskCondition
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct Request
									{
										LdmObjectId diskId;
										hyper diskLastKnownState;
										DISKCONDITION conditionMask;
									}

								case 0x02: //RESPONSE
									[IVolumeClientSummary = ""]
									_Struct Response
									{
										DMRTaskInfoStruct tinfo;
										[ReturnValue = this.ToString] 
										HRESULT dwReturnValue;
									}
							}
						}

					case 0x0032:
						_Struct ResetVolumeCondition
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct Request
									{
										LdmObjectId volumeId;
										hyper volumeLastKnownState;
										VolumeStatus statusMask;
									}

								case 0x02: //RESPONSE
									[IVolumeClientSummary = ""]
									_Struct Response
									{
										DMRTaskInfoStruct tinfo;
										[ReturnValue = this.ToString] 
										HRESULT dwReturnValue;
									}
							}
						}
*/

					case 51:
						_Struct ReplaceRaid5Column
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct Request
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId VolumeId;
													hyper VolumeLastKnownState;
													LdmObjectId NewDiskId;
													hyper DiskLastKnownState;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 52:
						_Struct RestartVolume
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct Request
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId VolumeId;
													hyper VolumeLastKnownState;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 53:
						_Struct GetEncapsulateDiskInfo
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "DiskCount=0x%X", DiskCount )]
									_Struct Request
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 DiskCount;  
													NdrConformant diskSpecListConformant;
													switch 
													{ 
														case diskCount>0:
														struct DiskSpecList = FormatString("%d Elements", diskCount)
														{
															[DiskEnter = 0]
															while [DiskEnter < diskCount]
															{
																[DiskEnter = DiskEnter + 1]
																DMRPDiskSpec diskSpec;
															}
														}
													}
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 EncapInfoFlags
													{ 
														UINT32 NotCallEncapsulateDiskMethod:1 = FormatString("          (%s) %s", this.ToBitString,  this ? "Do not call the EncapsulateDisk method"
														: "Call the EncapsulateDisk method" );
														UINT32 NoFreeSpace:1 = FormatString("                           (%s) %s", this.ToBitString,  this ? "Volume manager could not find sufficient free space on the disk for encapsulation"
														: "Volume manager could find sufficient free space on the disk for encapsulation" );
														UINT32 ContainActivePartition:1 = FormatString("                (%s) %s", this.ToBitString,  this ? "Disk contains an active partition from which the current operating system was not booted"
														: "Disk does not contain an active partition from which the current operating system was not booted" );
														UINT32 UnknownPart:1 = FormatString("                           (%s) %s", this.ToBitString,  this ? "Volume manager was unable to determine the type of a partition on the disk"
														: "Volume manager was able to determine the type of a partition on the disk" );
														UINT32 FaultTolerantVolumeUnhealthy:1 = FormatString("          (%s) %s", this.ToBitString,  this ? "Disk contains a fault-tolerant volume that is not functioning properly"
														: "Disk does not contain a fault-tolerant volume that is not functioning properly" );
														UINT32 FaultTolerantVolumeQueryFailed:1 = FormatString("        (%s) %s", this.ToBitString,  this ? "Volume manager was unable to obtain information about a fault-tolerant volume on the disk"
														: "Volume manager was able to obtain information about a fault-tolerant volume on the disk" );
														UINT32 RAID5:1 = FormatString("                                 (%s) %s", this.ToBitString,  this ? "Disk is part of a RAID-5 set, which this interface does not support for encapsulation" 
														: "Disk is not part of a RAID-5 set, which this interface does not support for encapsulation" );                       
														UINT32 FaultTolerantVolumeOnBoot:1 = FormatString("             (%s) %s", this.ToBitString,  this ? "Disk is both part of a fault-tolerant volume and bootable, which this interface does not support for encapsulation"
														: "Disk is neither part of a fault-tolerant volume or bootable, which this interface does not support for encapsulation" );
														UINT32 RequireReboot:1 = FormatString("                         (%s) %s", this.ToBitString,  this ? "Encapsulation of the disk requires a reboot"
														: "Encapsulation of the disk does not require a reboot" );
														UINT32 ContainsFaultTolerantVolume:1 = FormatString("           (%s) %s", this.ToBitString,  this ? "Disk is part of a fault-tolerant volume"
														: "Disk is not part of a fault-tolerant volume" );
														UINT32 VoulumeBusy:1 = FormatString("                           (%s) %s", this.ToBitString,  this ? "Disk is currently in use"
														: "Disk is currently not in use" );
														UINT32 RequiresBootIniModification :1 = FormatString("          (%s) %s", this.ToBitString,  this ? "Encapsulation of the disk requires modification of the boot.ini file"
														: "Encapsulation of the disk does not require modification of the boot.ini file" );
													}
													UINT32 AffectedDiskCount;
													NdrPtr ptr2AffectedDiskList;
													switch
													{
														case ptr2AffectedDiskList.ReferentID > 0:
														struct AffectedDiskList = FormatString("%d Elements", affectedDiskCount)
														{
															NdrConformant affectedDiskListConformant;
															switch
															{
																case affectedDiskCount>0:
																_struct list
																{
																	ALIGN8 ALIGN1; 
																	[DiskInfoEnterCount = 0]
																	while [DiskInfoEnterCount < affectedDiskCount]
																	{
																		[DiskInfoEnterCount = DiskInfoEnterCount + 1]
																		[DMRPDiskInfoDeviceType = ""]
																		DMRPDiskInfo affectedDisk;
																	}
																	[DiskInfoEnterCount = 0]
																	while [DiskInfoEnterCount < affectedDiskCount]
																	{
																		[DiskInfoEnterCount = DiskInfoEnterCount + 1]
																		[DMRPDiskInfoDeviceNameValue = ""]
																		DMRPCommonDiskInfoReference affectedDiskRef;
																	}
																}
															}
			    	    	    	
														}
													}
													NdrPtr ptr2AffectedDiskFlags;
													switch
													{
														case ptr2AffectedDiskFlags.ReferentID > 0:
														struct AffectedDiskFlagsList
														{
															NdrConformant ConformantAffectedDiskFlags;
															switch
															{
																case affectedDiskCount > 0:
																DMRPAffectedDiskFlags AffectedDiskFlags[affectedDiskCount];
															}
														};
													}
													UINT32 AffectedVolCount;
													NdrPtr ptr2AffectedVolList;
													switch
													{
														case ptr2AffectedVolList.ReferentID > 0:
														struct AffectedVolList = FormatString("%d Elements", affectedVolCount)
														{
															NdrConformant affectedVolListConformant;
															[CurrentVolume = 0]
															while [CurrentVolume < affectedVolCount]
															{
																ALIGN8 ALIGN1;
																[CurrentVolume = CurrentVolume + 1]
																DMRPVolumeInfo affectedVol;
															}     
														}
													}
													UINT32 AffectedRegionCount;
													NdrPtr ptr2AffectedRegionList;
													switch
													{
														case ptr2AffectedRegionList.ReferentID > 0:
														struct AffectedRegionList = FormatString("%d Elements", affectedRegionCount)
														{
															NdrConformant affectedRegionListConformant;
															switch
															{
																case affectedRegionCount>0:
																_struct affectRegion
																{
																	Align8 affectRegionAlign;
																	DMRPRegionInfo affectedRegion[affectedRegionCount];
																}        
															}
														}
													}
			    	    	    	
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString]
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 54:
						_Struct EncapsulateDisk
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "AffectedDiskCount=0x%X AffectedVolumeCount=0x%X AffectedRegionCount=0x%X", AffectedDiskCount, AffectedVolumeCount, AffectedRegionCount )]
									_Struct Request
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 AffectedDiskCount;
													NdrConformant affectedDiskListConformant;
													switch
													{
														case affectedDiskCount > 0:
														Struct affectedDiskList = FormatString("%d Elements", affectedDiskCount)
														{
															ALIGN8 alignDiskInfo;  
															[DiskInfoEnterCount = 0] 
															while condition1[ DiskInfoEnterCount < affectedDiskCount ]
															{
																[DiskInfoEnterCount = DiskInfoEnterCount + 1]
																[DMRPDiskInfoDeviceType = ""]
																DMRPDiskInfo diskInfo;
															}
															[DiskInfoEnterCount = 0]
															while condition2[ DiskInfoEnterCount < affectedDiskCount ]
															{
																[DiskInfoEnterCount = DiskInfoEnterCount + 1]
																[DMRPDiskInfoDeviceNameValue = ""]
																DMRPCommonDiskInfoReference diskInfoReference;
															}            
														}
													}
													ALIGN4 AffectedVolumeCountAlign;
													UINT32 AffectedVolumeCount;
													NdrConformant affectedVolumeListConformant;  
													switch
													{
														case affectedVolumeCount > 0:
														Struct affectedVolumeList = FormatString("%d Elements", affectedVolumeCount)
														{
															[VolumeInfoEnterCount = 0]
															while condition3[ VolumeInfoEnterCount < affectedVolumeCount ]
															{
																Align8 align1;
																[VolumeInfoEnterCount = VolumeInfoEnterCount + 1]
																DMRPVolumeInfo affectedVolume;
															}    
														}
													}
													UINT32 AffectedRegionCount;
													NdrConformant affectedRegionListConformant; 
													switch   
													{        
														case affectedRegionCount > 0:
														Struct affectedRegionList = FormatString("%d Elements", affectedRegionCount)
														{
															[RegionInfoEnterCount = 0]
															while condition3[ RegionInfoEnterCount < affectedRegionCount ]
															{
																[RegionInfoEnterCount = RegionInfoEnterCount + 1]
																DMRPRegionInfo affectedRegion;
															}    
														}
													}
												}
										}
									}

								case 0x02: //RESPONSE
								[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 EncapInfoFlags
													{ 
														UINT32 NotCallEncapsulateDiskMethod:1 = FormatString("          (%s) %s", this.ToBitString,  this ? "Do not call the EncapsulateDisk method"
														: "Call the EncapsulateDisk method" );
														UINT32 NoFreeSpace:1 = FormatString("                           (%s) %s", this.ToBitString,  this ? "Volume manager could not find sufficient free space on the disk for encapsulation"
														: "Volume manager could find sufficient free space on the disk for encapsulation" );
														UINT32 ContainActivePartition:1 = FormatString("                (%s) %s", this.ToBitString,  this ? "Disk contains an active partition from which the current operating system was not booted"
														: "Disk does not contain an active partition from which the current operating system was not booted" );
														UINT32 UnknownPart:1 = FormatString("                           (%s) %s", this.ToBitString,  this ? "Volume manager was unable to determine the type of a partition on the disk"
														: "Volume manager was able to determine the type of a partition on the disk" );
														UINT32 FaultTolerantVolumeUnhealthy:1 = FormatString("          (%s) %s", this.ToBitString,  this ? "Disk contains a fault-tolerant volume that is not functioning properly"
														: "Disk does not contain a fault-tolerant volume that is not functioning properly" );
														UINT32 FaultTolerantVolumeQueryFailed:1 = FormatString("        (%s) %s", this.ToBitString,  this ? "Volume manager was unable to obtain information about a fault-tolerant volume on the disk"
														: "Volume manager was able to obtain information about a fault-tolerant volume on the disk" );
														UINT32 RAID5:1 = FormatString("                                 (%s) %s", this.ToBitString,  this ? "Disk is part of a RAID-5 set, which this interface does not support for encapsulation" 
														: "Disk is not part of a RAID-5 set, which this interface does not support for encapsulation" );                       
														UINT32 FaultTolerantVolumeOnBoot:1 = FormatString("             (%s) %s", this.ToBitString,  this ? "Disk is both part of a fault-tolerant volume and bootable, which this interface does not support for encapsulation"
														: "Disk is neither part of a fault-tolerant volume or bootable, which this interface does not support for encapsulation" );
														UINT32 RequireReboot:1 = FormatString("                         (%s) %s", this.ToBitString,  this ? "Encapsulation of the disk requires a reboot"
														: "Encapsulation of the disk does not require a reboot" );
														UINT32 ContainsFaultTolerantVolume:1 = FormatString("           (%s) %s", this.ToBitString,  this ? "Disk is part of a fault-tolerant volume"
														: "Disk is not part of a fault-tolerant volume" );
														UINT32 VoulumeBusy:1 = FormatString("                           (%s) %s", this.ToBitString,  this ? "Disk is currently in use"
														: "Disk is currently not in use" );
														UINT32 RequiresBootIniModification :1 = FormatString("          (%s) %s", this.ToBitString,  this ? "Encapsulation of the disk requires modification of the boot.ini file"
														: "Encapsulation of the disk does not require modification of the boot.ini file" );
													}        
													DMRPTaskInfoStruct TaskInfo;      
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 55:
						_Struct QueryChangePartitionNumbers
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct Request
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 OldPartitionNumber;
													UINT32 NewPartitionNumber;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 56:
						_Struct DeletePartitionNumberInfoFromRegistry
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct Request
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 57:
						_Struct SetDontShow
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "BSetNoShow=0x%X", BSetNoShow )]
									_Struct Request
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 BSetNoShow = DMRPSetDontShowbSetNoShowTable( this );
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 58:
						_Struct GetDontShow
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct Request
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 BGetNoShow = DMRPGetDontShowbGetNoShowTable( this );
													Align4 align1;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 67:
						_Struct EnumTasks
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct Request
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 TaskCount;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 TaskCount;
													NdrPtr ptr2taskList;
													switch
													{
														case ptr2taskList.ReferentID > 0:
														Struct TaskList = FormatString("%d Elements", taskCount)
														{
															NdrConformant taskListConformant;
															[Currenttask = 0]
															while [Currenttask < taskCount]
															{
																ALIGN8 ALIGN1;
																[Currenttask = Currenttask + 1]
																DMRPTaskInfoStruct taskInfo;
															}
														}
													}
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 68:
						_Struct GetTaskDetail
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct Request
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId Id;
													DMRPTaskInfoStruct TaskInfo;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 69:
						_Struct AbortTask
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct Request
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId Id;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}
    	
					case 70:
						_Struct HrGetErrorData
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "Hr=%s Flags=0x%X", Hr.ToString, dwFlags )]
									_Struct Request
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													HRESULT Hr;
													UINT32 dwFlags
													{ 
														UINT32 Reserved:17 = FormatString("            (%s)", this.ToBitString);
														UINT32 NotDeleteErrorInfo:1 = FormatString("  (%s) %s", this.ToBitString,  this ? "Do not delete the error information" 
														: "Delete the error information" );
														UINT32 RetrieveErrorInfo:1 = FormatString("   (%s) %s", this.ToBitString,  this ? "Retrieve the error information even if it was not produced by the client"
														: "Do not retrieve the error information even if it was not produced by the client" );
													};
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue=%s", ReturnValue )]
									_Struct Response
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 PdwStoredFlags;
													INT32 Pcszw;
													NdrPtr ptr2Prgszw;
													switch
													{
														case ptr2Prgszw.ReferentID > 0:
														struct Prgszw = FormatString("%d Elements", Pcszw)
														{
															NdrConformant PrgszwConformant;
															[local.PrgszwEnterCount = 0, local.PrgszwActualCount = 0]
															while condition1[local.PrgszwEnterCount < Pcszw]
															{                                                                    
																[local.PrgszwEnterCount = local.PrgszwEnterCount + 1, local.PrgszwActualCount = local.PrgszwActualCount + (UINT32(FrameData, FrameOffset)) ? 1 : 0]
																NDRPTR prgszw;
															};
															NdrWideString prgszw[local.PrgszwActualCount];
														};
													}
													ALIGN4 Align;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 71:
						_Struct Initialize
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "CRemote=0x%X", CRemote )]
									_Struct Request
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													[Global.DMRPInitializeInterface = 1]
													DCOMMInterfacePointerPtr NotificationInterface;
													ALIGN4 ALIGN;
													UINT32 CRemote = FormatString("%d,%s", this, this ? "The client is on a different machine than the server." 
													: "The client is on the same machine as the server.");
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 UlIDLVersion;
													UINT32 pdwFlags
													{ 
														UINT32 Server:1 = FormatString("               (%s) %s", this.ToBitString,  this ? "Server is running on Windows NT Server."
														: "Server is not running on Windows NT Server." );
														UINT32 Alpha:1 = FormatString("                (%s) %s", this.ToBitString,  this ? "Server is running on an Alpha processor. (Windows Server 2003: No longer used.)"
														: "Server is not running on an Alpha processor. (Windows Server 2003: No longer used.)" );
														UINT32 SystemPartitionSecure:1 = FormatString("(%s) %s", this.ToBitString,  this ? "SYSFLAG_SYSPART_SECURE - System partition for the server is secure. (Windows Server 2003: No longer used.)"
														: "System partition for the server is not secure. (Windows Server 2003: No longer used.)" );                    
														UINT32 NEC98:1 = FormatString("                (%s) %s", this.ToBitString,  this ? "Server is an NEC 98 computer, which supports assignment of drive letters A and B to partitions or volumes. This behavior is supported only on Windows 2000 servers."
														: "Server is not an NEC 98 computer." );
														UINT32 Laptop:1 = FormatString("               (%s) %s", this.ToBitString,  this ? "Server is a laptop and does not support dynamic disks."
														: "Server is not a laptop." );
														UINT32 Wolpack:1 = FormatString("              (%s) %s", this.ToBitString,  this ? "Server is running on a cluster."
														: "Server is not running on a cluster." );
													}
													LdmObjectId ClientId;
													[ReturnValue = this.ToString]
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 72:
						_Struct Uninitialize
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct Request
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 73:
						_Struct Refresh
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct Request
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 74:
						_Struct RescanDisks
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct Request
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 75:
						_Struct RefreshFileSys
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct Request
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 76:
						_Struct SecureSystemPartition
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct Request
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

    	    //# The method has no parameters
					case 77:
						_Struct ShutDownSystem
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct Request
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													[ReturnValue = this.ToString]
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 78:
						_Struct EnumAccessPath
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct Request
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													INT32 LCount;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 LCount;
													NdrPtr ptr2paths;  
													switch
													{
														case ptr2paths.ReferentID > 0:
														Struct PathList = FormatString("%d Elements", lCount)
														{
															NdrConformant pathListConformant;
															switch
															{
																case lCount>0:
																_struct list
																{
																	ALIGN8 ALIGN1;
																	[CurrentPath = 0]
																	while [CurrentPath < lCount]
																	{
																		[CurrentPath = CurrentPath + 1]
																		DMRPCountedString pathInfo;
																	}
																	[CurrentPath = 0]
																	while [CurrentPath < lCount]
																	{
																		[CurrentPath = CurrentPath + 1]
																		DMRPCommonCountedStringReference PathRef;
																	}        
																}
															}
														}
													}
													Align4 dwReturnValueAlign;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 79:
						_Struct EnumAccessPathForVolume
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[IVolumeClientSummary = ""]
									_Struct Request
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId VolumeId;
													INT32 LCount;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 LCount;
													NdrPtr ptr2paths;
													switch
													{
														case ptr2paths.ReferentID > 0:
														_struct pathlist = FormatString("%d Elements", lCount)
														{
															NdrConformant pathListConformant;
															switch
															{
																case lCount>0:
																_struct list
																{
																	ALIGN8 ALIGN1;
																	[CurrentPath = 0]
																	while [CurrentPath < lCount]
																	{
																		[CurrentPath = CurrentPath + 1]
																		DMRPCountedString pathInfo;
																	}
																	[CurrentPath = 0]
																	while [CurrentPath < lCount]
																	{
																		[CurrentPath = CurrentPath + 1]
																		DMRPCommonCountedStringReference PathRef;
																	}        
																}
															}
														}
													}
													Align4 ReturnValueAlign;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 80:
						_Struct AddAccessPath
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "Cch_path=0x%X Path=%s", Cchpath, Path.ToString )]
									_Struct Request
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													INT32 Cchpath;
													NdrConformant pathConformant;
													switch
													{  
														case cchpath > 0:
														UNICODESTRING(cchpath) Path;
													}
													ALIGN8 Align1;
													LdmObjectId TargetId;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 81:
						_Struct DeleteAccessPath
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "Cch_path=0x%X Path=%s", Cchpath, Path.ToString )]
									_Struct Request
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId VolumeId;
													INT32 Cchpath;
													NdrConformant pathConformant;
													switch
													{
														case cchpath > 0:                                                      
														UnicodeString(cchpath) Path;
													}                
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					Default: 
						ReportParserError(ParserErrorProtocolClassWindows, "DMRP", "Unknown IVolumeClient method, Opnum:" + Property.MSRPCOpnum ) UnknownMethod;
				}
			}

        // Windows 2000 and Windows XP Interfaces
		case "{4BDAFC52-FE6A-11D2-93F8-00105A11164A}":
			[Property.DMRPMethodName = "IVolumeClient2:" + DMRPIVolumeClient2MethodTable( Property.MSRPCOpnum )]
			_Struct IVolumeClient2
			{
				switch( Property.MSRPCOpnum )
				{
					case 0x0003:
					_Struct GetMaxAdjustedFreeSpace
					{
						switch( Property.MSRPCPType )
						{
							case 0x00: //REQUEST
							[IVolumeClient2Summary = ""]
							_Struct Request
							{
								switch
								{
									Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
									Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
									default:
										struct
										{
											LdmObjectId DiskId;
										}
								}
							}

							case 0x02: //RESPONSE
							[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
							_Struct Response
							{
								switch
								{
									Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
									Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
									default:
									struct
									{
										INT64 MaxAdjustedFreeSpace;
										[ReturnValue = this.ToString]
										HRESULT ReturnValue;
									}
								}
							}
						}
					}
					Default: ReportParserError(ParserErrorProtocolClassWindows, "Disk Management Remote", "Unknown DMRP " + MSRPCPTypeTable(MSRPCPType) ) ParserError;
				}
			}

		case "{135698D2-3A37-4D26-99DF-E2BB6AE3AC61}":
			[Property.DMRPMethodName = "IVolumeClient3:" + DMRPIVolumeClient3MethodNameTable( Property.MSRPCOpnum )]
			_Struct IVolumeClient3
			{
				switch( Property.MSRPCOpnum )
				{
					case 3:
						_Struct EnumDisksEx
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										}
									}
          	
								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 DiskCount;
													NdrPtr ptr2diskList;
													switch
													{
														case ptr2diskList.ReferentID > 0:
														Struct diskList = FormatString("%d Elements", diskCount)
														{
															NdrConformant diskListConformant;   
															switch
															{
																case diskCount>0:
																_struct list
																{
																	ALIGN8 alignDiskInfo; 
																	[DiskInfoExEnterCount = 0]
																	while condition1[ DiskInfoExEnterCount < diskCount ]
																	{
																		[DiskInfoExEnterCount = DiskInfoExEnterCount + 1]
																		[DMRPDiskInfoExDeviceType = ""]
																		DMRPDiskInfoEx diskInfo;
																	}
																	[DiskInfoExEnterCount = 0]
																	while condition2[ DiskInfoExEnterCount < diskCount ]
																	{
																		[DiskInfoExEnterCount = DiskInfoExEnterCount + 1]
																		[DMRPDiskInfoExDeviceNameValue = ""]
																		DMRPCommonDiskInfoExReference diskInfoReference;
																	}             
																}
															}
														}
													}
													Align4 ReturnValueAlign;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 4:
						_Struct EnumDiskRegionsEx
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId DiskId;
													UINT32 NumRegions;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 NumRegions;
													NdrPtr ptr2RegionEx;
													switch
													{
														case ptr2RegionEx.ReferentID > 0:
														Struct regionList = FormatString("%d Elements", numRegions)
														{
															NdrConformant regionListConformant;
															switch
															{
																case numRegions > 0:
																_struct list
																{
																	ALIGN8 alignRegionInfo;
																	[RegionInfoExEnterCount = 0] 
																	while condition1[ RegionInfoExEnterCount < numRegions ]
																	{
																		[RegionInfoExEnterCount = RegionInfoExEnterCount + 1]
																		DMRPRegionInfoEx regionInfo;
																	}
																	[RegionInfoExEnterCount = 0]
																	while condition2[ RegionInfoExEnterCount < numRegions ]
																	{
																		[RegionInfoExEnterCount = RegionInfoExEnterCount + 1]
																		DMRPCommonRegionInfoExReference regionInfoReference;
																	}
																}
															}
														}
													}
													Align4 ReturnValueAlign;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 5:
						_Struct CreatePartition
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPRegionSpec PartitionSpec;
												}
										}
									}
          	
								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 6:
						_Struct CreatePartitionAssignAndFormat
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "Letter=%s", Letter.ToString )]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPRegionSpec PartitionSpec;
													WCHAR Letter;
													ALIGN8 Align1;
													hyper LetterLastUnknownState;
													DMRPFileSystemInfo FsSpec;
													boolean QuickFormat = DMRPCreatePartitionAssignAndFormatquickFormatTable( this );
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 7:
						_Struct CreatePartitionAssignAndFormatEx
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "Letter=%s CchAccessPath=0x%X AccessPath=%s Flags=0x%X", Letter.ToString, CchAccessPath, Path.ToString, Flags )]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPRegionSpec PartitionSpec;
													WCHAR Letter;
													ALIGN8 Align1;
													hyper LetterLastUnknownState;
			    	    	    	
													INT32 CchAccessPath;
													NdrConformant AccessPathConformant;
													switch
													{  
														case cchAccessPath > 0:
														UnicodeString(cchAccessPath) Path;
													}               
													ALIGN8 ALIGN2;
													DMRPFileSystemInfo FsSpec;
													boolean QuickFormat = DMRPCreatePartitionAssignAndFormatExquickFormatTable( this );
													Align4 Align3;
													UINT32 Flags = DMRPCreatePartitionAssignAndFormatExdwFlagsTable( this );
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 8:
						_Struct DeletePartition
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPRegionSpec PartitionSpec;
													boolean Force = DMRPDeletePartitionforceTable( this );
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 9:
						_Struct InitializeDiskStyle
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId DiskId;
													DMRPPartitionStyle Style ;
													ALIGN8 Align1;
													hyper DiskLastKnownState;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 10:
						_Struct MarkActivePartition
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId RegionId;
													hyper RegionLastKnownState;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 11:
						_Struct Eject
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId regionId;
													hyper regionLastKnownState;
												}
										}
									}

								case 0x02: //RESPONSE
									[ivolumeclient3Summary = ""]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

/*
					case 12:
					_Struct RestoreConfiguration
					{
						switch( Property.MSRPCPType )
						{
							case 0x00: //REQUEST
							[ivolumeclient3Summary = ""]
							_Struct Request
							{
								WCHAR letter;
							}

							case 0x02: //RESPONSE
							[ivolumeclient3Summary = ""]
							_Struct Response
							{
								[ReturnValue = this.ToString] 
								HRESULT dwReturnValue;
							}
						}
					}
*/

					case 13:
						_Struct FTEnumVolumes
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 VolumeCount;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 VolumeCount;
													NdrPtr ptr2VolumeList;
													switch
													{
														case ptr2VolumeList.ReferentID > 0:
														Struct volumeList = FormatString("%d Elements", volumeCount)
														{
															NdrConformant volumeListConformant;
															[volumeEnterCount = 0]
															while condition[volumeEnterCount < volumeCount]
															{
																ALIGN8 align;
																[volumeEnterCount = volumeEnterCount + 1]
																DMRPVolumeInfo volumeInfo;
															}        
														}
													}
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 14:
						_Struct FTEnumLogicalDiskMembers
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId VolumeId;
													UINT32 MemberCount;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 MemberCount;
													NdrPtr ptr2memberList;
													switch
													{
														case ptr2memberList > 0:
														Struct MembersList = FormatString("%d Elements", memberCount)
														{ 
															NdrConformant memberListConformant;  
															switch
															{
																case memberCount>0:
																_struct member
																{
																	ALIGN8 align1;
																	LdmObjectId member[memberCount];
																}
															}
														}
													}
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 15:
						_Struct FTDeleteVolume
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId VolumeId;
													boolean Force = DMRPFTDeleteVolumeforceTable( this );
													ALIGN8 Align1;
													hyper VolumeLastKnownState;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 16:
						_Struct FTBreakMirror
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "BForce=0x%X", BForce )]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId VolumeId;
													hyper VolumeLastKnownState;
													UINT32 BForce = DMRPFTBreakMirrorbForceTable( this );
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}                                            

					case 17:
						_Struct FTResyncMirror
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId VolumeId;
													hyper VolumeLastKnownState;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 18:
						_Struct FTRegenerateParityStripe
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId VolumeId;
													hyper VolumeLastKnownState;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 19:
						_Struct FTReplaceMirrorPartition
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "Flags=0x%X", Flags )]
									_Struct Request
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId VolumeId;
													hyper VolumeLastKnownState;
													LdmObjectId OldMemberId;
													hyper OldMemberLastKnownState;
													LdmObjectId NewRegionId;
													hyper NewRegionLastKnownState;
													UINT32 flags
													{
														UINT32 NotCheckChanges:1 = FormatString("(%s) %s", this.ToBitString,  this ? "Do not check for changes since the last known modification of the partition"
														: "Check for changes since the last known modification of the partition" );
														UINT32 DeleteOnFail:1 = FormatString("   (%s) %s", this.ToBitString,  this ? "Delete the new partition if creation fails"
														: "Do not delete the new partition if creation fails" );
													};
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 20:
						_Struct FTReplaceParityStripePartition
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "Flags=0x%X", Flags )]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId VolumeId;
													hyper VolumeLastKnownState;
													LdmObjectId OldMemberId;
													hyper OldMemberLastKnownState;
													LdmObjectId NewRegionId;
													hyper NewRegionLastKnownState;
													UINT32 flags
													{
														UINT32 NotCheckChanges:1 = FormatString("(%s) %s", this.ToBitString,  this ? "Do not check for changes since the last known modification of the partition"
														: "Check for changes since the last known modification of the partition" );
														UINT32 DeleteOnFail:1 = FormatString("   (%s) %s", this.ToBitString,  this ? "Delete the new partition if creation fails"
														: "Do not delete the new partition if creation fails" );
													};
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 21:
						_Struct EnumDriveLetters
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 DriveLetterCount;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 DriveLetterCount;
													NdrPtr ptr2DriveLetterList;
													switch
													{
														case ptr2DriveLetterList.ReferentID > 0:
														Struct DriveLetterInfoList = FormatString("%d Elements", driveLetterCount)
														{
															NdrConformant DriveLetterListConformant;
															[CurrentLetterInfo = 0]
															while [CurrentLetterInfo < driveLetterCount]
															{
																ALIGN8 align1; 
																[CurrentLetterInfo = CurrentLetterInfo + 1]
																DMRPDriveLetterInfo driveLetterInfo;
															}    
														}
													}
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 22:
						_Struct AssignDriveLetter
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "Letter=%s ForceOption=0x%X", Letter.ToString, ForceOption )]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													WCHAR Letter;
													ALIGN4 Align1;
													UINT32 ForceOption = DMRPAssignDriveLetterforceOptionTable( this );
													ALIGN8 ALIGN2;
													hyper LetterLastKnownState;
													LdmObjectId StorageId;
													hyper StorageLastKnownState;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 23:
						_Struct FreeDriveLetter
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "Letter=%s ForceOption=0x%X", Letter.ToString, ForceOption )]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													WCHAR Letter;
													ALIGN4 Align1;
													UINT32 ForceOption = DMRPFreeDriveLetterforceOptionTable( this );
													hyper LetterLastKnownState;
													LdmObjectId StorageId;
													hyper StorageLastKnownState;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 24:
						_Struct EnumLocalFileSystems
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 FileSystemCount;
													NdrPtr ptr2FileSystemList;
													switch
													{
														case ptr2FileSystemList.ReferentID > 0:
														struct FileSystemList = FormatString("%d Elements", fileSystemCount)
														{
															NdrConformant fileSystemListConformant;
															[CurrentFileSystem = 0]
															while [CurrentFileSystem < fileSystemCount]
															{
																ALIGN8 ALIGN1;
																[CurrentFileSystem = CurrentFileSystem + 1]
																DMRPFileSystemInfo fileSystemInfo;
															}
															[CurrentFileSystem = 0]
															while [CurrentFileSystem < fileSystemCount]
															{
																[CurrentFileSystem = CurrentFileSystem + 1]
																DMRPCommonFileSystemInfoReference fileSystemInfoReference;
															}
														}
													}
													ALIGN4 ALIGN2;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 25:
						_Struct GetInstalledFileSystems
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 FileSystemCount;
													NdrPtr ptr2IFileSystemList;  
													switch
													{
														case ptr2IFileSystemList.ReferentID > 0:
														struct IFileSystemList = FormatString("%d Elements", fileSystemCount)
														{
															NdrConformant IFileSystemListConformant;
															[CurrentFS = 0]
															while [CurrentFS < fileSystemCount]
															{
																[CurrentFS = CurrentFS + 1]
																DMRPIFileSystemInfo IFileSystemInfo;
															}
															[CurrentFS = 0]
															while [CurrentFS < fileSystemCount]
															{
																[CurrentFS = CurrentFS + 1]
																DMRPCommonIFileSystemInfoReference IFileSystemInfoReference;
															}            
														}
													}
													ALIGN4 ALIGN2;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 26:
						_Struct Format
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId StorageId;
													DMRPFileSystemInfo FsSpec;
													boolean QuickFormat = DMRPFormatquickFormatTable( this );
													boolean Force = DMRPFormatforceTable( this );
													ALIGN8 Align1;
													hyper StorageLastKnownState;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue = %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 27:
						_Struct EnumVolumes
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 VolumeCount;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 VolumeCount;
													NdrPtr ptr2VolumeList;
													switch
													{
														case ptr2VolumeList.ReferentID > 0:
														Struct volumeList = FormatString("%d Elements", volumeCount)
														{
															NdrConformant volumeListConformant;
															switch
															{
																case volumeCount>0:
																[volumeEnterCount = 0]
																while condition[volumeEnterCount < volumeCount]
																{
																	ALIGN8 align;
																	[volumeEnterCount = volumeEnterCount + 1]
																	DMRPVolumeInfo volumeInfo;
																}         
															}
														}
													}
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 28:
						_Struct EnumVolumeMembers
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId VolumeId;
													UINT32 MemberCount;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 MemberCount;              
													NdrPtr ptr2memberList;
													switch
													{
														case ptr2memberList.ReferentID > 0:
														struct MemberList = FormatString("%d Elements", memberCount)
														{
															NdrConformant memberListConformant;
															switch
															{
																case memberCount > 0:
																_struct member
																{
																	ALIGN8 ALIGN1;
																	LdmObjectId member[memberCount];
																}
															}            
														}
													}                    
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 29:
						_Struct CreateVolume
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "DiskCount=0x%X", DiskCount )]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPVolumeSpec VolumeSpec;
													UINT32 DiskCount;
													NdrConformant diskListConformant;
													switch
													{
														case diskCount > 0:
														struct diskList = FormatString("%d Elements", diskCount)
														{
															DMRPDiskSpec disk[diskCount]; 
														}
													}
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 30:
						_Struct CreateVolumeAssignAndFormat
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "DiskCount=0x%X Letter=%s", DiskCount, Letter.ToString )]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPVolumeSpec VolumeSpec;
													UINT32 DiskCount;
													NdrConformant diskListConformant;
													switch
													{
														case diskCount > 0:
														struct diskList = FormatString("%d Elements", diskCount)
														{
															[DiskEnter = 0]
															while [DiskEnter < diskCount]
															{
																[DiskEnter = DiskEnter + 1]
																DMRPDiskSpec diskSpec;
															} 
														}
													}
													WCHAR Letter;
													ALIGN8 ALIGN1; 
													hyper LetterLastKnownState;
													DMRPFileSystemInfo FsSpec;
													boolean QuickFormat = DMRPCreateVolumeAssignAndFormatquickFormatTable( this );
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 31:
						_Struct CreateVolumeAssignAndFormatEx
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "DiskCount=0x%X Letter=%s CchAccessPath=0x%X AccessPath=%s Flags=0x%X", DiskCount, Letter.ToString, CchAccessPath, AccessPath.ToString, Flags )]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPVolumeSpec VolumeSpec;
													UINT32 DiskCount;
													NdrConformant diskListConformant;
													switch  
													{
														case diskCount>0:
														Struct diskSpeList = FormatString("%d Elements", diskCount)
														{
															[DiskEnter = 0]
															while [DiskEnter < diskCount]
															{
																[DiskEnter = DiskEnter + 1]
																DMRPDiskSpec diskSpec;
															}
														}
													}                
													WCHAR Letter;
													ALIGN8 ALIGN1;
													hyper LetterLastKnownState;
													INT32 CchAccessPath;
													NdrConformant accesspathConformant; 
													switch
													{
														case cchAccessPath > 0:
														UnicodeString(cchAccessPath) AccessPath;
													}
													ALIGN8 ALIGN2;
													DMRPFileSystemInfo FsSpec;		
    											boolean QuickFormat = DMRPCreateVolumeAssignAndFormatExquickFormatTable( this );
													ALIGN4 ALIGN3;
													UINT32 Flags = DMRPCreateVolumeAssignAndFormatExdwFlagsTable( this );
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 32:
						_Struct GetVolumeMountName
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId VolumeId; 
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "MountName=%s ReturnValue=%s", MountName.Name.ToString, ReturnValue )]
									_Struct Response
									{
										switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 CchMountName;
													NdrPtr ptr2MountName;
													switch
													{
														case ptr2MountName.ReferentID > 0:
														struct MountName = DMRPVolumeMountName3
														{
															NdrConformant MountNameConformant;                         
															switch
															{
																case cchMountName > 0:
																[DMRPVolumeMountName3 = this]
																UnicodeString( cchMountName ) Name;
															}
														}
													}
													ALIGN4 Align;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 33:
						_Struct GrowVolume
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "DiskCount=0x%X", DiskCount )]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId VolumeId;
													DMRPVolumeSpec VolumeSpec;
													UINT32 DiskCount;
													NdrConformant diskListConformant;
													switch  
													{
														case diskCount>0:
														Struct diskList = FormatString("%d Elements", diskCount)
														{
															[DiskEnter = 0]
															while [DiskEnter < diskCount]
															{
																[DiskEnter = DiskEnter + 1]
																DMRPDiskSpec diskSpec;
															} 
														}
													}
													boolean Force = DMRPGrowVolumeforceTable( this );
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 34:
						_Struct DeleteVolume
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId VolumeId;
													boolean Force = DMRPDeleteVolumeforceTable( this );
													ALIGN8 Align1;
													hyper VolumeLastKnownState;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 35:
						_Struct CreatePartitionsForVolume
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId VolumeId;
													Boolean Active = DMRPCreatePartitionsForVolumeactiveTable( this );
													ALIGN8 Align1;
													hyper VolumeLastKnownState;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 36:
						_Struct DeletePartitionsForVolume
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId VolumeId;
													hyper VolumeLastKnownState;
												}
										}
									}

								case 0x02: //RESPONSE
									[ivolumeclient3Summary = ""]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 37:
						_Struct GetMaxAdjustedFreeSpace
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId DiskId;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													INT64 MaxAdjustedFreeSpace;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 38:
						_Struct AddMirror
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId VolumeId;
													hyper VolumeLastKnownState;
													DMRPDiskSpec DiskSpec;
													UINT32 DiskNumber = "Not used by Windows 2000, Windows XP, or Windows Server 2003 servers.";
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 DiskNumber = "Not used by Windows 2000, Windows XP, or Windows Server 2003 servers.";
													UINT32 PartitionNumber = FormatString("%d(0x%X)  %s", this, this, "If volumeId is the boot volume, this parameter is a pointer to the partition number of the newly added plex. This is zero if volumeId is not a system volume.");
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 39:
						_Struct RemoveMirror
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId VolumeId;
													hyper VolumeLastKnownState;
													LdmObjectId DiskId;
													hyper DiskLastKnownState;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 40:
						_Struct SplitMirror
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "Letter=%s", Letter.ToString )]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId VolumeId;
													hyper VolumeLastKnownState;
													LdmObjectId DiskId;
													hyper DiskLastKnownState;
													WCHAR Letter;
													ALIGN8 Align1;
													hyper LetterLastKnownState;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 41:
						_Struct InitializeDiskEx
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId DiskId;
													DMRPPartitionStyle Style ;
													ALIGN8 Align1;
													hyper DiskLastKnownState;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 42:
						_Struct UninitializeDisk
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId DiskId;
													hyper DiskLastKnownState;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 43:
						_Struct ReConnectDisk
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId DiskId;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 44:
						_Struct ImportDiskGroup
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "CchDgid=0x%X", CchDgid )]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													INT32 CchDgid;
													NdrConformant dgidConformant;
													switch
													{
														case cchDgid > 0:
														UINT8 dgid[cchDgid];
													}
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 45:
						_Struct DiskMergeQuery
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "CchDgid=0x%X NumDisks=0x%X", CchDgid, NumDisks )]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													INT32 CchDgid;
													NdrConformant dgidConformant;
													switch
													{
														case cchDgid > 0:
														UUID(1) Dgid;
													}
													INT32 NumDisks;
													NdrConformant diskListConformant;
													switch
													{
														case numDisks > 0:
														LdmObjectId disk[numDisks];
													}
													UINT32 Flags = DMRPDiskMergeQueryflagsTable( this );
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													hyper Mergeconfigtid;
													INT32 NumRids;
													NdrPtr ptr2mergedmrids;
													switch
													{
														case ptr2mergedmrids.ReferentID > 0:
														struct mergedmrids = FormatString("%d Elements", numRids)
														{
															NdrConformant mergedmridsConformant;
															switch
															{
																case NumRids>0:
																_struct rids
																{
																	ALIGN8 Align1;
																	hyper mergedmrid[numRids];
																}
															}
														}
													}
													INT32 NumObjects;
													NdrPtr ptr2mergeObjectInfo;
													switch
													{
														case ptr2mergeObjectInfo.ReferentID > 0:
														struct mergeObjectInfo = FormatString("%d Elements", numObjects)
														{
															NdrConformant mergeObjectInfoConformant;
															switch
															{
																case numObjects>0:
																_struct object
																{
																	ALIGN8 align;
																	DMRPMergeObjectInfo mergeObject[numObjects];
																}
															}
														}
													}
													UINT32 Flags = DMRPDiskMergeQueryflagsTable( this );
													ALIGN8 Align1;
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 46:
						_Struct DiskMerge
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "CchDgid=0x%X NumDisks=0x%X NumRids=0x%X", CchDgid, NumDisks, NumRids )]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													INT32 CchDgid;
													NdrConformant dgidConformant;
													switch
													{
														case cchDgid > 0:
														UUID(1) Dgid;
													}
													INT32 NumDisks;
													NdrConformant diskConformant;
													switch
													{
														case numDisks>0:
														struct DiskList = FormatString("%d Elements", numDisks)
														{
															LdmObjectId disk[numDisks];
														}
													}
													hyper MergeConfigTID;
													INT32 NumRids; 
													NdrConformant RIDConformant;
													switch
													{
														case numRids>0:
														struct RIDList = FormatString("%d Elements", numRids)
														{
															hyper MergeDMRIDs[numRids];
														}
													}
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 47:
						_Struct ReAttachDisk
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId DiskId;
													hyper DiskLastKnownState;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 48:
						_Struct ReplaceRaid5Column
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId VolumeId;
													hyper VolumeLastKnownState;
													LdmObjectId NewDiskId;
													hyper DiskLastKnownState;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 49:
						_Struct RestartVolume
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId VolumeId;
													hyper VolumeLastKnownState;
												}
										}
									}
          	
								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 50:
						_Struct GetEncapsulateDiskInfoEx
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "DiskCount=0x%X", DiskCount )]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 DiskCount;
													NdrConformant diskSpecListConformant;
													switch
													{
														case diskCount>0:
														struct diskSpecList = FormatString("%d Elements", diskCount)
														{
															[DiskEnter = 0]
															while [DiskEnter < diskCount]
															{
																[DiskEnter = DiskEnter + 1]
																DMRPDiskSpec diskSpec;
															}
														}
													}
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 EncapInfoFlags
													{
														UINT32 CantProceed:1 = FormatString("                (%s) %s", this.ToBitString,  this ? "Do not call EncapsulateDiskEx." 
														: "Call EncapsulateDiskEx.");
														UINT32 NoFreeSpace:1 = FormatString("                (%s) %s", this.ToBitString,  this ? "Volume manager could not find sufficient free space on the disk for encapsulation." 
														: "Volume manager could find sufficient free space on the disk for encapsulation.");
														UINT32 BadActive:1 = FormatString("                  (%s) %s", this.ToBitString,  this ? "Disk contains an active partition from which the current operating system was not booted." 
														: "Disk contains an active partition from which the current operating system was booted."  );
														UINT32 UnknownPart:1 = FormatString("                (%s) %s", this.ToBitString,  this ? "Volume manager was unable to determine the type of a partition on the disk." 
														: "Volume manager was able to determine the type of a partition on the disk."  );
														UINT32 FTUnhealthy:1 = FormatString("                (%s) %s", this.ToBitString,  this ? "Disk contains an unhealthy fault-tolerant volume." 
														: "Disk does not contain any unhealthy fault-tolerant volume."  );
														UINT32 FTQueryFailed:1 = FormatString("              (%s) %s", this.ToBitString,  this ? "Volume manager was unable to obtain information about a fault-tolerant volume on the disk." 
														: "Volume manager was able to obtain information about a fault-tolerant volume on the disk."  );
														UINT32 RAID5:1 = FormatString("                      (%s) %s", this.ToBitString,  this ? "Disk is part of a RAID-5 set, which this interface does not support for encapsulation." 
														: "Disk is not part of a RAID-5 set, which this interface does not support for encapsulation." );
														UINT32 FTOnBoot:1 = FormatString("                   (%s) %s", this.ToBitString,  this ? "Disk is both part of a fault-tolerant volume and bootable, which this interface does not support for encapsulation." 
														: "Disk is neither part of a fault-tolerant volume or bootable, which this interface does not support for encapsulation" );
														UINT32 RequireReboot:1 = FormatString("              (%s) %s", this.ToBitString,  this ? "Encapsulation of the disk will require a reboot." 
														: "Encapsulation of the disk will not require a reboot."   );
														UINT32 ContainsFT:1 = FormatString("                 (%s) %s", this.ToBitString,  this ? "Disk is part of a fault-tolerant volume." 
														: "Disk is not part of a fault-tolerant volume."  );
														UINT32 VolumeBusy:1 = FormatString("                 (%s) %s", this.ToBitString,  this ? "Disk is currently in use." 
														: "Disk is not currently in use." );
														UINT32 RequiresBootIniModification:1 = FormatString("(%s) %s", this.ToBitString,  this ? "Encapsulation of the disk requires modification of the boot.ini file." 
														: "Encapsulation of the disk does not require modification of the boot.ini file." );
														UINT32 MixedPartitions:1 = FormatString("            (%s) %s", this.ToBitString,  this ? "Server does not support encapsulating this disk because it contains basic partitions mixed with non-basic partitions." 
														: "Server supports encapsulating this disk." );
														UINT32 OpenFailed:1 = FormatString("                 (%s) %s", this.ToBitString,  this ? "A volume associated with this disk could not be opened." 
														: "A volume associated with this disk could be opened." );
													};
			    	    	    	
													UINT32 AffectedDiskCount;
													struct AffectedDiskList = FormatString("%d Elements", AffectedDiskCount)
													{
														NdrPtr ptr2AffectedDiskList;
														[DiskInfoExEnterCount = 0]    
														switch
														{
															case ptr2AffectedDiskList.ReferentID:
															_struct list
															{
																NdrConformant AffectedDiskListConformant;
																[DiskInfoExEnterCount = 0]
																while condition1[DiskInfoExEnterCount < AffectedDiskCount]
																{
																	ALIGN8 AlignDiskInfoEx;
																	[DiskInfoExEnterCount = DiskInfoExEnterCount + 1]
																	[DMRPDiskInfoExDeviceType = ""]
																	DMRPDiskInfoEx DiskInfoEx;
																}
																[DiskInfoExEnterCount = 0]
																while condition2[DiskInfoExEnterCount < AffectedDiskCount]
																{
																	[DiskInfoExEnterCount = DiskInfoExEnterCount + 1]
																	[DMRPDiskInfoExDeviceNameValue = ""]
																	DMRPCommonDiskInfoExReference DiskInfoExRef;
																}          
															}
														}
													}
			          	    	
													struct AffectedDiskFlagList = FormatString("%d Elements", affectedDiskCount)
													{
														NdrPtr ptr2AffectedDiskFlagsList;
														switch
														{
															case ptr2AffectedDiskFlagsList.ReferentID:
															_struct List
															{
																NdrConformant AffectedDiskListFlagsConformant;
																switch
																{
																	case AffectedDiskCount > 0:
																	DMRPDiskFlags DiskFlag[AffectedDiskCount];
																}
															}         
														}
			    	    	    	
													}
													UINT32 AffectedVolumeCount;

													struct AffectedVolumeList = FormatString("%d Elements", AffectedVolumeCount)
													{
														NdrPtr ptr2AffectedVolumeList;
														switch
														{
															case ptr2AffectedVolumeList.ReferentID:
															_struct List
															{
																NdrConformant VoluemConformant;
																[VolumeInfoEnterCount = 0]
																while condition3[VolumeInfoEnterCount < AffectedVolumeCount]
																{
																	ALIGN8 AlignVolumeInfo;
																	[VolumeInfoEnterCount = VolumeInfoEnterCount + 1]
																	DMRPVolumeInfo VolumeInfo;
																}
															}
														}
													}
													UINT32 AffectedRegionCount;

													struct AffectedRegionList = FormatString("%d Elements", AffectedRegionCount)
													{
														NdrPtr ptr2AffectedRegionList;
			    	    	    	
														switch
														{
															case ptr2AffectedRegionList.ReferentID:
															_struct List
															{
																NdrConformant RegionListConformant;
																[RegionInfoExEnterCount = 0]
																while condition4[RegionInfoExEnterCount < AffectedRegionCount]
																{
																	ALIGN8 AlignRegionInfoEx;
																	[RegionInfoExEnterCount = RegionInfoExEnterCount + 1]
																	DMRPRegionInfoEx RegionInfoEx;
																}
																[RegionInfoExEnterCount = 0]
																while condition5[RegionInfoExEnterCount < AffectedRegionCount]
																{
																	[RegionInfoExEnterCount = RegionInfoExEnterCount + 1]
																	DMRPCommonRegionInfoExReference RegionInfoExRef;
																}
															}
														}      
													}

													ALIGN8 AlignDMRTaskInfoStruct;
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 51:
						_Struct EncapsulateDiskEx
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "AffectedDiskCount=0x%X AffectedVolumeCount=0x%X AffectedRegionCount=0x%X", AffectedDiskCount, AffectedVolumeCount, AffectedRegionCount )]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 AffectedDiskCount;
													NdrConformant affectedDiskListConformant;
													switch
													{
														case affectedDiskCount>0:
														struct DiskInfoList = FormatString("%d Elements", affectedDiskCount)
														{
															ALIGN8 align;
															[DiskInfoExEnterCount = 0]
															while condition1[DiskInfoExEnterCount < affectedDiskCount]
															{
																[DiskInfoExEnterCount = DiskInfoExEnterCount + 1]
																[DMRPDiskInfoExDeviceType = ""]
																DMRPDiskInfoEx diskInfoEx;
															}
															[DiskInfoExEnterCount = 0]
															while condition2[DiskInfoExEnterCount < affectedDiskCount]
															{
																[DiskInfoExEnterCount = DiskInfoExEnterCount + 1]
																[DMRPDiskInfoExDeviceNameValue = ""]
																DMRPCommonDiskInfoExReference diskInfoExRef;
															}
														}
													}
			          	    	
													ALIGN4 Align;                 
													UINT32 AffectedVolumeCount;
													NdrConformant affectedVolumeListConformant;
													switch
													{
														case affectedVolumeCount>0:
														struct VolumeInfoList = FormatString("%d Elements", affectedVolumeCount)
														{
															[VolumeInfoExEnterCount = 0]
															while condition3[VolumeInfoExEnterCount < affectedVolumeCount]
															{
																ALIGN8 align;
																[VolumeInfoExEnterCount = VolumeInfoExEnterCount + 1]
																DMRPVolumeInfo affectedVolume;
															}
														}
													}
			          	    	
													UINT32 AffectedRegionCount;
													NdrConformant affectedRegionListConformant;
													switch
													{
														case affectedRegionCount>0:
														struct RegionInfoList = FormatString("%d Elements", affectedRegionCount)
														{
															ALIGN8 align;   
															[RegionInfoExEnterCount = 0]
															while condition4[RegionInfoExEnterCount < affectedRegionCount]
															{
																[RegionInfoExEnterCount = RegionInfoExEnterCount + 1]
																DMRPRegionInfoEx RegionInfoEx;
															}
															[RegionInfoExEnterCount = 0]
															while condition5[RegionInfoExEnterCount < affectedRegionCount]
															{
																[RegionInfoExEnterCount = RegionInfoExEnterCount + 1]
																DMRPCommonRegionInfoExReference regionInfoExRef;
															}
														}
													}
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 EncapInfoFlags
													{
														UINT32 CantProceed:1 = FormatString("                (%s) %s", this.ToBitString,  this ? "Disk encapsulation will not succeed. Inspect the other encapInfoFlags values to determine the reason. " 
														: "Disk encapsulation will succeed. " );
														UINT32 NoFreeSpace:1 = FormatString("                (%s) %s", this.ToBitString,  this ? "Volume manager could not find sufficient free space on the disk for encapsulation. " 
														: "Volume manager could find sufficient free space on the disk for encapsulation. " );
														UINT32 BadActive:1 = FormatString("                  (%s) %s", this.ToBitString,  this ? "Disk contains an active partition from which the current operating system was not booted. " 
														: "Disk contains an active partition from which the current operating system was booted. " );
														UINT32 UnknownPart:1 = FormatString("                (%s) %s", this.ToBitString,  this ? "Volume manager was unable to determine the type of a partition on the disk. " 
														: "Volume manager was able to determine the type of a partition on the disk. " );
														UINT32 FTUnhealthy:1 = FormatString("                (%s) %s", this.ToBitString,  this ? "Disk contains an unhealthy fault-tolerant volume. " 
														: "Disk does not contain an unhealthy fault-tolerant volume. " );
														UINT32 FTQueryFailed:1 = FormatString("              (%s) %s", this.ToBitString,  this ? "Volume manager was unable to obtain information about a fault-tolerant volume on the disk. " 
														: "Volume manager was able to obtain information about a fault-tolerant volume on the disk. " );
														UINT32 PartOfRAID5:1 = FormatString("                (%s) %s", this.ToBitString,  this ? "Disk is part of a RAID-5 set, which this interface does not support for encapsulation. " 
														: "Disk is not part of a RAID-5 set, which this interface does not support for encapsulation" );
														UINT32 FTOnBoot:1 = FormatString("                   (%s) %s", this.ToBitString,  this ? "Disk is both part of a fault-tolerant volume and bootable, which this interface does not support for encapsulation. " 
														: "Disk is neither part of a fault-tolerant volume or bootable, which this interface does not support for encapsulation" );
														UINT32 RequiresReboot:1 = FormatString("             (%s) %s", this.ToBitString,  this ? "Encapsulation of the disk will require a reboot. " 
														: "Encapsulation of the disk will not require a reboot. " );
														UINT32 ContainsFT:1 = FormatString("                 (%s) %s", this.ToBitString,  this ? "Disk is part of a fault-tolerant volume. " 
														: "Disk is not part of a fault-tolerant volume. " );
														UINT32 VolumeBusy:1 = FormatString("                 (%s) %s", this.ToBitString,  this ? "Disk is currently in use. " 
														: "Disk is not currently in use. " );
														UINT32 RequiresBootIniModification:1 = FormatString("(%s) %s", this.ToBitString,  this ? "Encapsulation of the disk requires modification of the boot.ini file. " 
														: "Encapsulation of the disk does not require modification of the boot.ini file. " );
													}                              
													ALIGN8 Align1;
													DMRPTaskInfoStruct TaskInfo;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 52:
						_Struct QueryChangePartitionNumbers
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													INT32 OldPartitionNumber;
													INT32 NewPartitionNumber;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 53:
						_Struct DeletePartitionNumberInfoFromRegistry
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 54:
						_Struct SetDontShow
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "BSetNoShow=0x%X", BSetNoShow )]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 BSetNoShow = DMRPSetDontShowbSetNoShowTable( this );
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 55:
						_Struct GetDontShow
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 BGetNoShow = DMRPGetDontShowbGetNoShowTable( this );
													ALIGN4 Align;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 64:
						_Struct EnumTasks
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 TaskCount;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 TaskCount;
													NdrPtr ptr2TaskList;
													switch
													{
														case ptr2TaskList.ReferentID > 0:
														struct TaskList = FormatString("%d Elements", taskCount)
														{
															NdrConformant taskListConformant;
															switch
															{
																case taskCount>0:
																[DMRPTaskInfoStructEnterCount = 0]
																while condition[DMRPTaskInfoStructEnterCount < taskCount]
																{
																	ALIGN8 align;
																	[DMRPTaskInfoStructEnterCount = DMRPTaskInfoStructEnterCount + 1]
																	DMRPTaskInfoStruct TaskInfo;
																}
															}
														}
													}
													[ReturnValue = this.ToString]
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 65:
						_Struct GetTaskDetail
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId Id;
													DMRPTaskInfoStruct TaskInfo;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													DMRPTaskInfoStruct TaskInfo;  
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 66:
						_Struct AbortTask
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId Id;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 67:
						_Struct HrGetErrorData
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "Hr=%s Flags=0x%X", Hr.ToString, Flags )]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													HRESULT Hr;
													UINT32 Flags
													{
														UINT32 Reserved:17 = FormatString("           (%s)", this.ToBitString);
														UINT32 NotDeleteErrorInfo:1 = FormatString("  (%s) %s", this.ToBitString,  this ? "Do not delete the error information"
														: "Delete the error information" );
														UINT32 NotRetrieveErrorInfo:1 = FormatString("(%s) %s", this.ToBitString,  this ? "Retrieve the error information even if it was not produced for this client"
														: "Do not retrieve the error information" );
													};
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 PdwStoredFlags = "Pointer to a bitmap of error flags. Windows 2000, Windows XP: No flags are defined.";
													INT32 Pcsw;
													NdrPtr ptr2prgszwArray;
													switch
													{
														case ptr2prgszwArray.ReferentID > 0:
														struct PrgszwList = FormatString("%d Elements", pcsw)
														{
															NdrConformant PrgszwConformant;
															switch
															{
																case pcsw>0:
																_struct list
																{
																	ALIGN8 Align;    
																	[PrgszwEnterCount = 0]
																	while condition1[PrgszwEnterCount < pcsw]
																	{                                                                
																		[PrgszwEnterCount = PrgszwEnterCount + 1]
																		NDRPTR Prgszw;
																	};
																	[PrgszwEnterCount = 0]
																	while condition2[PrgszwEnterCount < pcsw]
																	{                                                                 
																		[PrgszwEnterCount = PrgszwEnterCount + 1]
																		NdrWideString Prgszw;
																	};            
																} 
															}
														}
													}
													ALIGN4 Align;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 68:
						_Struct Initialize
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "CRemote=0x%X", CRemote )]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													[Global.DMRPInitializeInterface = 2]
													// the pointer to IUknownInterface
													DCOMMInterfacePointerPtr NotificationInterface;
													ALIGN4 ALIGN;
													UINT32 CRemote = FormatString("%d,%s", this, this ? "The client is on a different machine than the server." 
													: "The client is on the same machine as the server.");
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 UllDLVersion;
													UINT32 Flags
													{
														UINT32 Server:1 = FormatString("               (%s) %s", this.ToBitString,  this ? "Server is running on Windows NT Server." 
														: "Server is not running on Windows NT Server." );
														UINT32 Alpha:1 = FormatString("                (%s) %s", this.ToBitString,  this ? "Server is running on an Alpha processor." 
														: "Server is not running on an Alpha processor." );
														UINT32 SystemPartitionSecure:1 = FormatString("(%s) %s", this.ToBitString,  this ? "System partition for the server is secure." 
														: "System partition for the server is not secure." );
														UINT32 NEC98:1 = FormatString("                (%s) %s", this.ToBitString,  this ? "Server is a NEC 98 computer, which supports assignment of drive letters A and B to partitions or volumes. This behavior is supported only on Windows 2000 servers." 
														: "Server is not a NEC 98 computer, which supports assignment of drive letters A and B to partitions or volumes. This behavior is supported only on Windows 2000 servers." );
														UINT32 Laptop:1 = FormatString("               (%s) %s", this.ToBitString,  this ? "Server does not support dynamic disks." 
														: "Server supports dynamic disks." );
														UINT32 WolfPack:1 = FormatString("              (%s) %s", this.ToBitString,  this ? "Server is running on a cluster." 
														: "Server is not running on a cluster." );
														UINT32 IA64:1 = FormatString("                 (%s) %s", this.ToBitString,  this ? "Server is running on an IA64 machine." 
														: "Server is not running on an IA64 machine." );
														UINT32 UninstallValid:1 = FormatString("       (%s) %s", this.ToBitString,  this ? "Server has a valid uninstall image to which it can roll back." 
														: "Server has not a valid uninstall image to which it can roll back." );
														UINT32 DynamicIEEE1394Disk:1 = FormatString(" (%s) %s", this.ToBitString,  this ? "Server supports dynamic IEEE 1394 disks." 
														: "Server does not support dynamic IEEE 1394 disks." );
													}
													LdmObjectId ClientId;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 69:
						_Struct Uninitialize
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 70:
						_Struct Refresh
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 71:
						_Struct RescanDisks
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 72:
						_Struct RefreshFileSys
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 73:
						_Struct SecureSystemPartition
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 74:
						_Struct ShutDownSystem
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 75:
						_Struct EnumAccessPath
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													INT32 LCount;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													INT32 LCount;
													NdrPtr ptr2paths;
													switch
													{
														case ptr2paths.ReferentID > 0:
														Struct PathList = FormatString("%d Elements", LCount)
														{
															NdrConformant pathListConformant;
															switch
															{
																case LCount>0:
																_struct list
																{
																	ALIGN8 ALIGN1; 
																	[CurrentPath = 0]
																	while [CurrentPath < LCount]
																	{
																		[CurrentPath = CurrentPath + 1]
																		DMRPCountedString pathInfo;
																	}
																	[CurrentPath = 0]
																	while [CurrentPath < LCount]
																	{
																		[CurrentPath = CurrentPath + 1]
																		DMRPCommonCountedStringReference PathRef;
																	}
																}   
															}            
			    	    	    	
														}                
													}
													ALIGN4 ReturnValueAlign;                        
													[ReturnValue = this.ToString]  
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 76:
						_Struct EnumAccessPathForVolume
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[ivolumeclient3Summary = ""]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectId VolumeId;
													INT32 LCount;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													INT32 Count;
													NdrPtr ptr2paths;
													switch
													{
														case ptr2paths.ReferentID > 0:
														Struct PathList = FormatString("%d Elements", Count)
														{
															NdrConformant pathListConformant;
															switch
															{
																case Count>0:
																_struct list
																{
																	ALIGN8 ALIGN1; 
																	[CurrentPath = 0]
																	while [CurrentPath < Count]
																	{
																		[CurrentPath = CurrentPath + 1]
																		DMRPCountedString pathInfo;
																	}
																	[CurrentPath = 0]
																	while [CurrentPath < Count]
																	{
																		[CurrentPath = CurrentPath + 1]
																		DMRPCommonCountedStringReference PathRef;
																	}
																}
															}
														}
													}
													Align4 ReturnValueAlign;
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 77:
						_Struct AddAccessPath
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "Cch_path=0x%X Path=%s", path, Path.ToString )]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													INT32 path;
													NdrConformant pathConformant;
													switch
													{
														case path > 0:
														UNICODESTRING(path) Path;
													}
													ALIGN8 Align1;
													LdmObjectId TargetId;
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					case 78:
						_Struct DeleteAccessPath
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "Cch_path=0x%X Path=%s", path, Path.ToString )]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													LdmObjectid VolumeId;
													INT32 path;
													NdrConformant pathConformant;
													switch
													{
														case path > 0:                                                      
														UnicodeString(path) Path;
													}
															}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													[ReturnValue = this.ToString] 
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					Default:
						ReportParserError(ParserErrorProtocolClassWindows, "DMRP", "Unknown IVolumeClient3 method, Opnum:" + Property.MSRPCOpnum ) UnknownMethod;
				}
			}

		case "{DEB01010-3A37-4D26-99DF-E2BB6AE3AC61}":
			[Property.DMRPMethodName = "IVolumeClient4:" + DMRPIVolumeClient4MethodNameTable( Property.MSRPCOpnum )]
			_Struct IVolumeClient4
			{
				switch( Property.MSRPCOpnum )
				{
					case 3:
						_Struct RefreshEx
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
								[IVolumeClient4Summary = ""]
								_Struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
									}
								}

								case 0x02: //RESPONSE
								[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
								_Struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												//#[ReturnValue = this[0]] 
												BLOB( property.MSRPCStubDataLen ) encrypted; //#UINT32 dwReturnValue = WinErrorCodeTable( this );
												HRESULT ReturnValue;
											}
									}
								}
							}
						}

					case 4:
						_Struct GetVolumeDeviceName
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
								[IVolumeClient4Summary = ""]
								_Struct Request
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												BLOB( property.MSRPCStubDataLen )   encrypted; //# LdmObjectId VolumeId;
											}
									}
								}

								case 0x02: //RESPONSE
								[IVolumeClient4Summary = ""]
								_Struct Response
								{
									Switch
									{
										Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
										Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
										Default:
											struct
											{
												BLOB( property.MSRPCStubDataLen ) encrypted;
												HRESULT ReturnValue;
											}
									}
								}
							}
						}

					Default: 
						ReportParserError(ParserErrorProtocolClassWindows, "DMRP", "Unknown IVolumeClient4 method, Opnum:" + Property.MSRPCOpnum ) UnknownMethod;
				}
			}

		case "{3A410F21-553F-11D1-8E5E-00A0C92C9D5D}":
			[Property.DMRPMethodName = "IDmRemoteServer:" + DMRPIDmRemoteServerMethodTable( Property.MSRPCOpnum )]
			_Struct IDMRemoteServer
			{
				switch( Property.MSRPCOpnum )
				{
					case 3:
						_Struct CreateRemoteObject
						{
							switch( Property.MSRPCPType )
							{
								case 0x00: //REQUEST
									[Post.DMRPSummary = FormatString( "CMax=0x%X RemoteComputerName=%s", Max, RemoteComputerName.ToString )]
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													UINT32 Max;
													NdrConformant remoteComputerNameConformant;
													switch
													{
														case Max > 0:
														UnicodeString(Max) RemoteComputerName;
													}
												}
										}
									}

								case 0x02: //RESPONSE
									[Post.DMRPSummary = FormatString( "ReturnValue= %s", ReturnValue )]
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
											Default:
												struct
												{
													[ReturnValue = this.ToString]
													HRESULT ReturnValue;
												}
										}
									}
							}
						}

					Default: ReportParserError(ParserErrorProtocolClassWindows, "Disk Management Remote", "Unknown DMRP " + MSRPCPTypeTable(MSRPCPType) ) ParserError;
				}
			}
	}
}

//========= TABLES ==============================================================================================
Table DMRPRegionStatusTable( value )
{
	switch( value )
	{
		case 0: "Region's status is unknown";
		case 1: "Region is intact";
		case 2: "Region failed";
		case 3: "Region is in the process of failing";
		case 4: "Region is regenerating data from the fault-tolerant check information";
		case 5: "The Region needs resynchronization";
		default: FormatString("Unknown region status(0x%08X)", value);
	}
}

Table DMRPPartitionStyleTable( value )
{
	switch( value )
	{
		case 0: "Partition is of an unknown style.";
		case 1: "Partition is of the Master Boot Record (MBR) style.";
		case 2: "Partition is of the globally unique identifier (GUID) Partition Table (GPT) style.";
		Default: FormatString("Unknown partition style(0x%08X)", value);
	}
}

Table DMRPForceOptionTable(option)
{
	switch(option)
	{
		case 0: "Assignment of a drive letter is not forced after freeing it fails";
		case 1: "Assignment of a drive letter is forced after freeing it fails";
		default: "Unknown option";
	}
}

Table DMRPFSTYPETable( value )
{
	switch(value)
	{
		case 0x00000000: "FSTYPE_UNKNOWN: File system type is unknown";
		case 0x00000001: "FSTYPE_NTFS: File system type is NTFS(Windows NT file system)";
		case 0x00000002: "FSTYPE_FAT: File system type is FAT(file allocation table)";
		case 0x00000003: "FSTYPE_FAT32: File system type is FAT32";
		case 0x00000004: "FSTYPE_CDFS: File system type is CDFS(CD-ROM file system)";
		case 0x00000005: "FSTYPE_UDF: File system type is UDF(universal disk format)";
		case 0x80000000: "FSTYPE_OTHER: File system type is not listed";
		default: "Unknown file system type";
	}
}

Table DMRPDMNotifyInfoTypeTable( type )
{
	switch ( type )
	{
		case  0: "Object is of an unknown type";         //DMNOTIFY_UNKNOWN_INFO
		case  1: "Object is a Disk";                     //DMNOTIFY_DISK_INFO
		case  2: "Object is a Volume";                   //DMNOTIFY_VOLUME_INFO
		case  3: "Object is a Region";                   //DMNOTIFY_REGION_INFO
		case  4: "Object is a Task";                     //DMNOTIFY_TASK_INFO
		case  5: "Object is a Drive Letter";             //DMNOTIFY_DL_INFO
		case  6: "Object is a File System";              //DMNOTIFY_FS_INFO
		case  7: "Object is the Disk Management System"; //DMNOTIFY_SYSTEM_INFO
		default: "Unknown Object Type";                  //Invalid value
	}
}

Table DMRPLDMActionTable( action )
{
	switch ( action )
	{
		case  0: "Object Underwent an Unknown type of change"; //LDMACTION_UNKNOWN
		case  1: "Object was Created";                         //LDMACTION_CREATED
		case  2: "Object was Deleted";                         //LDMACTION_DELETED
		case  3: "Object was Modified";                        //LDMACTION_MODIFIED
		case  4: "Object Failed";                              //LDMACTION_FAILED
		default: "Unknown Action Type";                        //Invalid value
	}
}


Table DMRPVolumeTypeTable( type )
{
	switch ( type )
	{
		case  0: "Volume is of an Unknown Type";                             //VOLUMETYPE_UNKNOWN
		case  1: "Volume is a Primary Partition";                           //VOLUMETYPE_PRIMARY_PARTITION
		case  2: "Volume is a Logical Drive";                               //VOLUMETYPE_LOGICAL_DRIVE
		case  3: "Volume is a Windows NT 4.0-style fault-tolerant volume";  //VOLUMETYPE_FT
		case  4: "Volume is controled by the volume manager";               //VOLUMETYPE_VM
		case  5: "Volume resides on a CD-ROM device";                       //VOLUMETYPE_CDROM
		case  6: "Volume resides on a device with removable media";         //VOLUMETYPE_REMOVABLE
		default: "Unknown Volume Type";                                     //Invalid value
	}
}

Table DMRPVolumeLayoutTable( layout )
{
	switch ( layout )
	{
		case  0: "Volume has a Unknown Layout";   //VOLUMELAYOUT_UNKNOWN
		case  1: "Volume is a Partition";         //VOLUMELAYOUT_PARTITION
		case  2: "Volume is a Basic Disk";        //VOLUMELAYOUT_SIMPLE
		case  3: "Volume spans Multiple Disks";   //VOLUMELAYOUT_SPANNED
		case  4: "Volume is a Mirror";            //VOLUMELAYOUT_MIRROR
		case  5: "Volume is a Striped Set";       //VOLUMELAYOUT_STRIPE
		case  6: "Volume is RAID-5 Set";          //VOLUMELAYOUT_RAID5
		default: "Unknown Volume Layout";         //Invalid value
	}
}

Table DMRPVolumeStatusTable( status )
{
	switch ( status )
	{
		case  0: "VOLUME_STATUS_UNKNOWN - Volume has a Unknown Status";                                                          //VOLUME_STATUS_UNKNOWN
		case  1: "VOLUME_STATUS_HEALTHY - Volume is fully functional";                                                           //VOLUME_STATUS_HEALTHY
		case  2: "VOLUME_STATUS_FAILED - Volume is in a failed status";                                                          //VOLUME_STATUS_FAILED
		case  3: "VOLUME_STATUS_FAILED_REDUNDANCY - Volume's redundancy information failed";                                     //VOLUME_STATUS_FAILED_REDUNDANCY
		case  4: "VOLUME_STATUS_FAILING - Volume has encountered I/O errors";                                                    //VOLUME_STATUS_FAILING
		case  5: "VOLUME_STATUS_FAILING_REDUNDANCY - Volume is fault-tolerant, and it encountered I/O errors";                   //VOLUME_STATUS_FAILING_REDUNDANCY
		case  6: "VOLUME_STATUS_FAILED_REDUNDANCY_FAILING - Redundant data in a fault-tolerant volume has failed, and the volume encountered I/O errors in the last remaining copy of the data";   //VOLUME_STATUS_FAILED_REDUNDANCY_FAILING
		case  7: "VOLUME_STATUS_SYNCHING - Volume is resynchronizing fault-tolerant data for a mirrored volume";                                                             //VOLUME_STATUS_CYNCHING
		case  8: "VOLUME_STATUS_REGENERATING - Volume is regenerating fault-tolerant data for a RAID-5 volume";                                   //VOLUME_STATUS_REGENERATING
		case  9: "VOLUME_STATUS_INITIALIZING - Volume is initializing to volume manager control";                                //VOLUME_STATUS_INITIALIZING
		case 10: "VOLUME_STATUS_FORMATTING - Volume is currently being formatted";                                               //VOLUME_STATUS_FORMATTING
		default: "Unknown Volume Status";                                                                                        //Invalid value
	}
}

Table DMRPDMProgressTypeTable( type)
{
	switch ( type )
	{
		case  0: "PROGRESS_UNKNOWN - Unknown type of operation is in progress";  
		case  1: "PROGRESS_FORMAT - Format operation is in progress";            
		case  2: "PROGRESS_SYNCHING - Synchronization operation is in progress";     
		default: "Unknown Progress Type";                                            
	}
}

Table DMRPReqStatusTable( status )
{
	switch ( status )
	{
		case  0: "REQ_UNKNOWN - Request state is unknown";
		case  1: "REQ_STARTED - Request has started";
		case  2: "REQ_IN_PROGRESS - Request is in progress";
		case  3: "REQ_COMPLETED - Request has completed";
		case  4: "REQ_ABORTED - Request has terminated";
		case  5: "REQ_FAILED - Request has failed";
		default: "Unknown Request Status";                                                      
	}
}

//# http://msdn.microsoft.com/library/default.asp?url=/library/en-us/fileio/fs/disk_partition_types.asp
Table DMRPPartitionTypeTable(partition)
{   
	switch(partition)
	{
		case 0x00: "An unused entry partition";
		case 0x05: "An extended partition";
		case 0x01: "A FAT12 file system partition";
		case 0x04: "A FAT16 file system partition";
		case 0x0B: "A FAT32 file system partition";
		case 0x07: "An IFS partition";
		case 0x42: "A logical disk manager (LDM) partition";
		case 0x80: "An NTFT partition";
		case 0xC0: "A valid NTFT petition";
		default: "unknown";
	}
}

TABLE DMRPDeviceTypeTable( type )
{
	switch (type)
	{
		case 0x00000000: "DEVICETYPE_UNKNOWN : Device is of an unknown type.";
		case 0x00000001: "DEVICETYPE_VM : Device is a dynamic disk.";
		case 0x00000002: "DEVICETYPE_REMOVABLE : Device uses removable media.";
		case 0x00000003: "DEVICETYPE_CDROM : Device is a CD-ROM.";
		case 0x00000004: "DEVICETYPE_FDISK : Device is a basic disk.";
		case 0x00000005: "DEVICETYPE_DVD : Device is a DVD.";
	}
}

Table DMRPRegionTypeTable( type )
{
	switch( type )
	{
		case 0: "REGION_UNKNOWN: Region type is unknown.";
		case 1: "REGION_FREE: Region resides in free space.";
		case 2: "REGION_EXTENDED_FREE: Region resides in the free space of an extended partition.";
		case 3: "REGION_PRIMARY: Region resides in a primary partition.";
		case 4: "REGION_LOGICAL: Region resides in a logical partition.";
		case 5: "REGION_EXTENDED: Region resides in an extended partition.";
		case 6: "REGION_SUBDISK: Region resides on a subdisk.";
		case 7: "REGION_CDROM: Region resides on a CD-ROM device.";
		case 8: "REGION_REMOVABLE: Region resides on a device with removable media.";
		default: "Unknown Region Type";
	}
}

Table DMRPInterfaceTable( UUID )
{
	switch( UUID )
	{
		case "{D2D79DF7-3400-11D0-B40B-00AA005FF586}": "IDMNotify";
		case "{3A410F21-553F-11D1-8E5E-00A0C92C9D5D}": "IDMRemoteServer";
		case "{D2D79DF5-3400-11D0-B40B-00AA005FF586}": "IVolumeClient";
		case "{4BDAFC52-FE6A-11D2-93F8-00105A11164A}": "IVolumeClient2";
		case "{135698D2-3A37-4D26-99DF-E2BB6AE3AC61}": "IVolumeClient3";
		case "{DEB01010-3A37-4D26-99DF-E2BB6AE3AC61}": "IVolumeClient4";
		Default: "Unknown DMRP Interface";
	}
}


Table DMRPIVolumeClient2MethodTable( Opnum )
{
	switch( Opnum )
	{
		case 0x0003: "GetMaxAdjustedFreeSpace";
		Default: "Unknown DMRP Method";
	}
}

Table DMRPIDMNotifyMethodTable( Opnum )
{
	switch( Opnum )
	{
		case 3: "ObjectsChanged";
		Default: "unknown";
	}
}

Table DMRPIDmRemoteServerMethodTable( Opnum )
{
	switch( Opnum )
	{
		case 3: "CreateRemoteObject";
		Default: "unknown";
	}
}


Table DMRPIVolumeClientMethodNameTable( Opnum )
{
	Switch( Opnum )
	{
		Case 3: "EnumDisks";
		Case 4: "EnumDiskRegions";
		Case 5: "CreatePartition";
		Case 6: "CreatePartitionAssignAndFormat";
		Case 7: "CreatePartitionAssignAndFormatEx";
		Case 8: "DeletePartition";
		Case 9: "WriteSignature";
		Case 10: "MarkActivePartition";
		Case 11: "Eject";
		Case 13: "FTEnumVolumes";
		Case 14: "FTEnumLogicalDiskMembers";
		Case 15: "FTDeleteVolume";
		Case 16: "FTBreakMirror";
		Case 17: "FTResyncMirror";
		Case 18: "FTRegenerateParityStripe";
		Case 19: "FTReplaceMirrorPartition";
		Case 20: "FTReplaceParityStripePartition";
		Case 21: "EnumDriveLetters";
		Case 22: "AssignDriveLetter";
		Case 23: "FreeDriveLetter";
		Case 24: "EnumLocalFileSystems";
		Case 25: "GetInstalledFileSystems";
		Case 26: "Format";
		Case 28: "EnumVolumes";
		Case 29: "EnumVolumeMembers";
		Case 30: "CreateVolume";
		Case 31: "CreateVolumeAssignAndFormat";
		Case 32: "CreateVolumeAssignAndFormatEx";
		Case 33: "GetVolumeMountName";
		Case 34: "GrowVolume";
		Case 35: "DeleteVolume";
		Case 36: "AddMirror";
		Case 37: "RemoveMirror";
		Case 38: "SplitMirror";
		Case 39: "InitializeDisk";
		Case 40: "UninitializeDisk";
		Case 41: "ReConnectDisk";
		Case 43: "ImportDiskGroup";
		Case 44: "DiskMergeQuery";
		Case 45: "DiskMerge";
		Case 46: "DetachDisk";
		Case 47: "ReAttachDisk";
		Case 48: "ReplaceDisk";
		Case 51: "ReplaceRaid5Column";
		Case 52: "RestartVolume";
		Case 53: "GetEncapsulateDiskInfo";
		Case 54: "EncapsulateDisk";
		Case 55: "QueryChangePartitionNumbers";
		Case 56: "DeletePartitionNumberInfoFromRegistry";
		Case 57: "SetDontShow";
		Case 58: "GetDontShow";
		Case 67: "EnumTasks";
		Case 68: "GetTaskDetail";
		Case 69: "AbortTask";
		Case 70: "HrGetErrorData";
		Case 71: "Initialize";
		Case 72: "Uninitialize";
		Case 73: "Refresh";
		Case 74: "RescanDisks";
		Case 75: "RefreshFileSys";
		Case 76: "SecureSystemPartition";
		Case 77: "ShutDownSystem";
		Case 78: "EnumAccessPath";
		Case 79: "EnumAccessPathForVolume";
		Case 80: "AddAccessPath";
		Case 81: "DeleteAccessPath";
		Default: "unknown";
	}
}     

Table DMRPIVolumeClient3MethodNameTable( Opnum )
{
	switch( Opnum )
	{
		case 3: "EnumDisksEx";
		case 4: "EnumDiskRegionsEx";
		case 5: "CreatePartition";
		case 6: "CreatePartitionAssignAndFormat";
		case 7: "CreatePartitionAssignAndFormatEx";
		case 8: "DeletePartition";
		case 9: "InitializeDiskStyle";
		case 10: "MarkActivePartition";
		case 11: "Eject";
		case 13: "FTEnumVolumes";
		case 14: "FTEnumLogicalDiskMembers";
		case 15: "FTDeleteVolume";
		case 16: "FTBreakMirror";
		case 17: "FTResyncMirror";
		case 18: "FTRegenerateParityStripe";
		case 19: "FTReplaceMirrorPartition";
		case 20: "FTReplaceParityStripePartition";
		case 21: "EnumDriveLetters";
		case 22: "AssignDriveLetter";
		case 23: "FreeDriveLetter";
		case 24: "EnumLocalFileSystems";
		case 25: "GetInstalledFileSystems";
		case 26: "Format";
		case 27: "EnumVolumes";
		case 28: "EnumVolumeMembers";
		case 29: "CreateVolume";
		case 30: "CreateVolumeAssignAndFormat";
		case 31: "CreateVolumeAssignAndFormatEx";
		case 32: "GetVolumeMountName";
		case 33: "GrowVolume";
		case 34: "DeleteVolume";
		case 35: "CreatePartitionsForVolume";
		case 36: "DeletePartitionsForVolume";
		case 37: "GetMaxAdjustedFreeSpace";
		case 38: "AddMirror";
		case 39: "RemoveMirror";
		case 40: "SplitMirror";
		case 41: "InitializeDiskEx";
		case 42: "UninitializeDisk";
		case 43: "ReConnectDisk";
		case 44: "ImportDiskGroup";
		case 45: "DiskMergeQuery";
		case 46: "DiskMerge";
		case 47: "ReAttachDisk";
		case 48: "ReplaceRaid5Column";
		case 49: "RestartVolume";
		case 50: "GetEncapsulateDiskInfoEx";
		case 51: "EncapsulateDiskEx";
		case 52: "QueryChangePartitionNumbers";
		case 53: "DeletePartitionNumberInfoFromRegistry";
		case 54: "SetDontShow";
		case 55: "GetDontShow";
		case 64: "EnumTasks";
		case 65: "GetTaskDetail";
		case 66: "AbortTask";
		case 67: "HrGetErrorData";
		case 68: "Initialize";
		case 69: "Uninitialize";
		case 70: "Refresh";
		case 71: "RescanDisks";
		case 72: "RefreshFileSys";
		case 73: "SecureSystemPartition";
		case 74: "ShutDownSystem";
		case 75: "EnumAccessPath";
		case 76: "EnumAccessPathForVolume";
		case 77: "AddAccessPath";
		case 78: "DeleteAccessPath";
		Default: "unknown";
	}
}

Table DMRPIVolumeClient4MethodNameTable( Opnum )
{
	switch( Opnum )
	{
		case 3: "RefreshEx";
		case 4: "GetVolumeDeviceName";
		Default: "unknown";
	}
}

Table DMRPMethodTable( UUID, Opnum )
{
	switch( UUID )
	{
	  	  //Windows 2000 and Windows XP Interfaces
		case "{D2D79DF7-3400-11d0-B40B-00AA005FF586}": DMRPIDMNotifyMethodTable( Opnum );
		case "{3A410F21-553F-11d1-8E5E-00A0C92C9D5D}": DMRPIDMRemoteServerMethodTable( Opnum );
		case "{D2D79DF5-3400-11D0-B40B-00AA005FF586}": DMRPIVolumeClientMethodNameTable( Opnum );
		case "{4BDAFC52-FE6A-11d2-93F8-00105A11164A}": DMRPIVolumeClient2MethodTable( Opnum );
		case "{135698D2-3A37-4d26-99DF-E2BB6AE3AC61}": DMRPIVolumeClient3MethodNameTable( Opnum );
		case "{DEB01010-3A37-4d26-99DF-E2BB6AE3AC61}": DMRPIVolumeClient4MethodNameTable( Opnum );
	  	  //Windows Server 2003 Interfaces
	  	  //TBD Here
		Default: "";
	}
}

Table DMRPDiskInfodflagsTable( Value )
{
	switch( Value )
	{
		case 0x00000001: "DISK_AUDIO_CD - Disk is an audio CD.";
		case 0x00000002: "DISK_NEC98 - This value is obsolete and MUST NOT be used.";
		Default: "unknown";
	}
}

Table DMRPDiskInfodeviceTypeTable( Value )
{
	switch( Value )
	{
		case 0x00000000: "DEVICETYPE_UNKNOWN - Device is of an unknown type.";
		case 0x00000001: "DEVICETYPE_VM - Device is a dynamic disk.";
		case 0x00000002: "DEVICETYPE_REMOVABLE - Device uses removable media.";
		case 0x00000003: "DEVICETYPE_CDROM - Device is a CD-ROM.";
		case 0x00000004: "DEVICETYPE_FDISK - Device is a basic disk.";
		case 0x00000005: "DEVICETYPE_DVD - Device is a DVD.";
		Default: "unknown";
	}
}

Table DMRPDiskInfodeviceStateTable( Value )
{
	switch( Value )
	{
		case 0x00000000: "DEVICESTATE_UNKNOWN - Disk is in an unknown state.";
		case 0x00000001: "DEVICESTATE_HEALTHY - Disk is fully functional.";
		case 0x00000002: "DEVICESTATE_NO_MEDIA - Disk has no media.";
		case 0x00000004: "DEVICESTATE_NOSIG - Disk has an invalid signature.";
		case 0x00000008: "DEVICESTATE_BAD - Disk was deleted or experienced an install or hardware problem.";
		case 0x00000010: "DEVICESTATE_NOT_READY - Disk is not ready yet.";
		case 0x00000020: "DEVICESTATE_MISSING - Disk is no longer available.";
		case 0x00000040: "DEVICESTATE_OFFLINE - Disk is offline.";
		case 0x00000080: "DEVICESTATE_FAILING - Disk experienced a physical input/output (I/O) error.";
		case 0x00000100: "DEVICESTATE_IMPORT_FAILED - Disk belongs to a group whose import failed.";
		case 0x00000200: "DEVICESTATE_UNCLAIMED - Disk belongs to a foreign disk group.";
		Default: "unknown";
	}
}

Table DMRPDiskInfobusTypeTable( Value )
{
	switch( Value )
	{
		case 0x00000000: "BUSTYPE_UNKNOWN - Bus type is unknown.";
		case 0x00000001: "BUSTYPE_IDE - Disk resides on an integrated drive electronics (IDE) bus.";
		case 0x00000002: "BUSTYPE_SCSI - Disk resides on a small computer system interface (SCSI) bus.";
		case 0x00000003: "BUSTYPE_FIBRE - Disk resides on a Fibre Channel bus.";
		case 0x00000004: "BUSTYPE_USB - Disk resides on a universal serial bus (USB).";
		case 0x00000005: "BUSTYPE_SSA - Disk resides on a Serial Storage Architecture (SSA) bus.";
		case 0x00000006: "BUSTYPE_1394 - Disk resides on an Institute of Electronics and Electrical Engineers (IEEE) 1394 bus.";
		Default: "unknown";
	}
}

Table DMRPDiskInfoattributesTable( Value )
{
	switch( Value )
	{
		case 0x00000000: "DEVICEATTR_NONE - Disk has no attributes.";
		case 0x00000001: "DEVICEATTR_RDONLY - Disk is read-only.";
		case 0x00000002: "DEVICEATTR_NTMS - This value is obsolete.";
		Default: "unknown";
	}
}

Table DMRPDiskInfoisUpgradeableTable( Value )
{
	switch( Value )
	{
		case 0: "FALSE - Disk cannot be converted to a dynamic disk.";
		case 1: "TRUE - Disk can be encapsulated or converted to a dynamic disk.";
		Default: "unknown";
	}
}

Table DMRPRegionInfoisActiveTable( Value )
{
	switch( Value )
	{
		case 0: "FALSE - Region is an inactive partition.";
		case 1: "TRUE - Region is an active partition.";
		Default: "unknown";
	}
}

Table DMRPFileSystemInfofsflagsTable( Value )
{
	switch( Value )
	{
		case 0x00000001: "ENABLE_VOLUME_COMPRESSION - File system supports  File System (NTFS) compression.";
		Default: "unknown";
	}
}

Table DMRPFileSystemInfofsTypeTable( Value )
{
	switch( Value )
	{
		case 0x00000000: "FSTYPE_UNKNOWN - File system type is unknown.";
		case 0x00000001: "FSTYPE_NTFS - File system type is NTFS.";
		case 0x00000002: "FSTYPE_FAT - File system type is FAT (file allocation table).";
		case 0x00000003: "FSTYPE_FAT32 - File system type is FAT32.";
		case 0x00000004: "FSTYPE_CDFS - File system type is CDFS (CD-ROM file system).";
		case 0x00000005: "FSTYPE_UDF - File system type is Universal Disk Format (UDF).";
		case 0x80000000: "FSTYPE_OTHER - File system type is not listed.";
		Default: "unknown";
	}
}

Table DMRPCreatePartitionAssignAndFormatquickFormatTable( Value )
{
	switch( Value )
	{
		case 0: "FALSE - File system will be fully formatted. Full format requires verifying the accessibility of all sectors on the volume.";
		case 1: "TRUE - File system will be quickly formatted.";
		Default: "unknown";
	}
}

Table DMRPCreatePartitionAssignAndFormatExquickFormatTable( Value )
{
	switch( Value )
	{
		case 0: "FALSE - File system will be fully formatted. Full format requires verifying the accessibility of all sectors on the volume.";
		case 1: "TRUE - File system will be quickly formatted.";
		Default: "unknown";
	}
}

Table DMRPCreatePartitionAssignAndFormatExdwFlagsTable( Value )
{
	switch( Value )
	{
		case 0x00000001: "CREATE_ASSIGN_ACCESS_PATH - Assign the mount point AccessPath to the new partition.";
		Default: "unknown";
	}
}

Table DMRPDeletePartitionforceTable( Value )
{
	switch( Value )
	{
		case 0: "FALSE - Deletion will not be forced if the partition is in use.";
		case 1: "TRUE - Deletion will be forced.";
		Default: "unknown";
	}
}

Table DMRPVolumeInfovflagsTable( Value )
{
	switch( Value )
	{
		case 0x00000001: "VOLUME_FORMAT_IN_PROGRESS - Volume is currently being formatted.";
		case 0x00000004: "VOLUME_HAS_PAGEFILE - Volume contains the paging file.";
		case 0x00000100: "VOLUME_IS_BOOT_VOLUME - Volume contains the boot partition.";
		case 0x00000400: "VOLUME_IS_RESTARTABLE - The RestartVolume method can be successfully called on this volume.";
		case 0x00000800: "VOLUME_IS_SYSTEM_VOLUME - Volume contains the system directory.";
		case 0x00001000: "VOLUME_HAS_RETAIN_PARTITION - Volume has an underlying partition.";
		case 0x00002000: "VOLUME_HAD_BOOT_INI - Volume contained the Boot.ini file used when the operating system was last started.";
		case 0x00004000: "VOLUME_CORRUPT - Volume is corrupt.";
		case 0x00008000: "VOLUME_HAS_CRASHDUMP - Volume contains a crash dump file.";
		case 0x00010000: "VOLUME_IS_CURR_BOOT_VOLUME - Volume is the current boot volume.";
		case 0x00020000: "VOLUME_HAS_HIBERNATION - Volume contains a hibernation image.";
		Default: "unknown";
	}
}

Table DMRPFTDeleteVolumeforceTable( Value )
{
	switch( Value )
	{
		case 0: "FALSE - Deletion will not be forced if the partition is in use.";
		case 1: "TRUE - Deletion of the partition will be forced.";
		Default: "unknown";
	}
}

Table DMRPFTBreakMirrorbForceTable( Value )
{
	switch( Value )
	{
		case 0: "FALSE - The method fails if an error occurs while the drive letter is being removed from the FT mirror set.";
		case 1: "TRUE - Removal of the drive letter from the FT mirror set is forced.";
		Default: "unknown";
	}
}

Table DMRPFTReplaceMirrorPartitionflagsTable( Value )
{
	switch( Value )
	{
		case 0x00000001: "FTREPLACE_FORCE - Do not fail the operation if the replacement partition has been changed since newRegionLastKnownState.";
		case 0x00000002: "FTREPLACE_DELETE_ON_FAIL - Delete the replacement partition if operation fails.";
		Default: "unknown";
	}
}

Table DMRPFTReplaceParityStripePartitionflagsTable( Value )
{
	switch( Value )
	{
		case 0x00000001: "FTREPLACE_FORCE - Do not fail the operation if the replacement partition has been changed since newRegionLastKnownState.";
		case 0x00000002: "FTREPLACE_DELETE_ON_FAIL - Delete the replacement partition if operation fails.";
		Default: "unknown";
	}
}

Table DMRPDriveLetterInfoisUsedTable( Value )
{
	switch( Value )
	{
		case 0: "FALSE - Drive letter is free.";
		case 1: "TRUE - Drive letter is in use.";
		Default: "unknown";
	}
}

Table DMRPDriveLetterInfodlflagsTable( Value )
{
	switch( Value )
	{
		case 0x00000001: "DL_PENDING_REMOVAL - Drive letter has a removal operation pending.";
		Default: "unknown";
	}
}

Table DMRPAssignDriveLetterforceOptionTable( Value )
{
	switch( Value )
	{
		case 0: "NO_FORCE_OPERATION - If the volume, partition, or logical drive specified by storageId already has a drive letter assigned, and freeing it fails because the object is in use, assignment fails and the old drive letter is retained.";
		case 1: "FORCE_OPERATION - If the volume, partition, or logical drive specified by storageId already has a drive letter assigned, and freeing it fails because the volume is in use, its removal is forced and assignment of the new drive letter succeeds."; 
		Default: "unknown";
	}
}

Table DMRPFreeDriveLetterforceOptionTable( Value )
{
	switch( Value )
	{
		case 0: "NO_FORCE_OPERATION - If the specified drive letter is assigned to a volume, partition, or logical disk that is in use, contains the paging file, or contains the system directory, the operation fails and returns an error.";
		case 1: "FORCE_OPERATION - The specified drive letter is always freed.";
		Default: "unknown";
	}
}

Table DMRPIfileSystemInfofsTypeTable( Value )
{
	switch( Value )
	{
		case 0x00000000: "FSTYPE_UNKNOWN - File system type is unknown.";
		case 0x00000001: "FSTYPE_NTFS - File system type is NTFS.";
		case 0x00000002: "FSTYPE_FAT - File system type is FAT.";
		case 0x00000003: "FSTYPE_FAT32 - File system type is FAT32.";
		case 0x00000004: "FSTYPE_CDFS - File system type is CDFS.";
		case 0x00000005: "FSTYPE_UDF - File system type is UDF.";
		case 0x80000000: "FSTYPE_OTHER - File system type is not listed.";
		Default: "unknown";
	}
}

Table DMRPIfileSystemInfofsflagsTable( Value )
{
	switch( Value )
	{
		case 0x00000001: "FSF_FMT_OPTION_COMPRESS - File system supports compression.";
		case 0x00000002: "FSF_FMT_OPTION_LABEL - File system supports label specification.";
		case 0x00000004: "FSF_MNT_POINT_SUPPORT - File system supports creation of mount points.";
		case 0x00000008: "FSF_REMOVABLE_MEDIA_SUPPORT - File system supports creation of removable media.";
		case 0x00000010: "FSF_FS_GROW_SUPPORT - File system supports the extend operation.";
		case 0x00000020: "FSF_FS_QUICK_FORMAT_ENABLE - File system supports quick formatting.";
		case 0x00000040: "FSF_FS_ALLOC_SZ_512 - File system supports an allocation unit size of 512 bytes.";
		case 0x00000080: "FSF_FS_ALLOC_SZ_1K - File system supports an allocation unit size of 1 kilobyte (KB).";
		case 0x00000100: "FSF_FS_ALLOC_SZ_2K - File system supports an allocation unit size of 2 KB.";
		case 0x00000200: "FSF_FS_ALLOC_SZ_4K - File system supports an allocation unit size of 4 KB.";
		case 0x00000400: "FSF_FS_ALLOC_SZ_8K - File system supports an allocation unit size of 8 KB.";
		case 0x00000800: "FSF_FS_ALLOC_SZ_16K - File system supports an allocation unit size of 16 KB.";
		case 0x00001000: "FSF_FS_ALLOC_SZ_32K - File system supports an allocation unit size of 32 KB.";
		case 0x00002000: "FSF_FS_ALLOC_SZ_64K - File system supports an allocation unit size of 64 KB.";
		case 0x00004000: "FSF_FS_ALLOC_SZ_128K - File system supports an allocation unit size of 128 KB.";
		case 0x00008000: "FSF_FS_ALLOC_SZ_256K - File system supports an allocation unit size of 256 KB.";
		case 0x00010000: "FSF_FS_ALLOC_SZ_OTHER - File system supports any allocation unit size that the user provides.";
		case 0x00020000: "FSF_FS_FORMAT_SUPPORTED - File system supports formatting.";
		case 0x0003FFFF: "FSF_FS_VALID_BITS - All other bits in the bitmap MUST be ignored. The server does a bitwise AND operation with this value to clear an upper-level bits that may be present but are not supported.";
		Default: "unknown";
	}
}

Table DMRPIfileSystemInfofsCompressionFlagsTable( Value )
{
	switch( Value )
	{
		case 0x00000080: "FSF_FS_ALLOC_SZ_1K - File system supports an allocation unit size of 1 KB.";
		case 0x00000100: "FSF_FS_ALLOC_SZ_2K - File system supports an allocation unit size of 2 KB.";
		case 0x00000200: "FSF_FS_ALLOC_SZ_4K - File system supports an allocation unit size of 4 KB.";
		case 0x00000400: "FSF_FS_ALLOC_SZ_8K - File system supports an allocation unit size of 8 KB.";
		case 0x00000800: "FSF_FS_ALLOC_SZ_16K - File system supports an allocation unit size of 16 KB.";
		case 0x00001000: "FSF_FS_ALLOC_SZ_32K - File system supports an allocation unit size of 32 KB.";
		case 0x00002000: "FSF_FS_ALLOC_SZ_64K - File system supports an allocation unit size of 64 KB.";
		case 0x00004000: "FSF_FS_ALLOC_SZ_128K - File system supports an allocation unit size of 128 KB.";
		case 0x00008000: "FSF_FS_ALLOC_SZ_256K - File system supports an allocation unit size of 256 KB.";
		case 0x00010000: "FSF_FS_ALLOC_SZ_OTHER - File system supports any allocation unit size that the user provides.";
		Default: "unknown";
	}
}

Table DMRPFormatquickFormatTable( Value )
{
	switch( Value )
	{
		case 0: "FALSE - File system will be fully formatted.  Full format requires verifying the accessibility of all sectors on the volume.";
		case 1: "TRUE - File system will be quickly formatted.";
		Default: "unknown";
	}
}

Table DMRPFormatforceTable( Value )
{
	switch( Value )
	{
		case 0: "FALSE - File system will not be formatted unless its underlying storage can be locked.";
		case 1: "TRUE - File system will be formatted regardless of whether the underlying volume, partition, or logical drive can be locked or not.";
		Default: "unknown";
	}
}

Table DMRPDiskSpecneedContiguousTable( Value )
{
	switch( Value )
	{
		case 0: "FALSE - Contiguous space is not needed on the disk.";
		case 1: "TRUE - Contiguous space is needed on the disk.";
		Default: "unknown";
	}
}

Table DMRPCreateVolumeAssignAndFormatquickFormatTable( Value )
{
	switch( Value )
	{
		case 0: "FALSE - File system will be fully formatted.  Full format requires verifying the accessibility of all sectors on the volume.";
		case 1: "TRUE - File system will be quickly formatted.";
		Default: "unknown";
	}
}

Table DMRPCreateVolumeAssignAndFormatExquickFormatTable( Value )
{
	switch( Value )
	{
		case 0: "FALSE - File system will be fully formatted.  Full format requires verifying the accessibility of all sectors on the volume.";
		case 1: "TRUE - File system will be quickly formatted.";
		Default: "unknown";
	}
}

Table DMRPCreateVolumeAssignAndFormatExdwFlagsTable( Value )
{
	switch( Value )
	{
		case 0x00000001: "CREATE_ASSIGN_ACCESS_PATH - Assign the mount point AccessPath to the new volume.  If the flag is not set, the parameter AccessPath is ignored.";
		Default: "unknown";
	}
}

Table DMRPGrowVolumeforceTable( Value )
{
	switch( Value )
	{
		case 0: "FALSE - Volume is not extended unless it is locked.";
		case 1: "TRUE - Volume is extended whether it is locked or unlocked.";
		Default: "unknown";
	}
}

Table DMRPDeleteVolumeforceTable( Value )
{
	switch( Value )
	{
		case 0: "FALSE - Deletion will not be forced if the volume is in use.";
		case 1: "TRUE - Deletion will be forced.";
		Default: "unknown";
	}
}

Table DMRPMergeObjectInfotypeTable( Value )
{
	switch( Value )
	{
		case 0x00000001: "This parameter is always set to 0x00000001.";
		Default: "unknown";
	}
}

Table DMRPMergeObjectInfoflagsTable( Value )
{
	switch( Value )
	{
		case 0x00000001: "DSKMERGE_DELETE - Volume will be deleted.";
		case 0x00000002: "DSKMERGE_DELETE_REDUNDANCY - Redundant data in a fault-tolerant volume will be deleted.";
		case 0x00000004: "DSKMERGE_STALE_DATA - Volume contents will be stale.";
		case 0x00000008: "DSKMERGE_RELATED - Volume has subdisks on merged disks.";
		Default: "unknown";
	}
}

Table DMRPDiskMergeQueryflagsTable( Value )
{
	switch( Value )
	{
		case 0x00000001: "DSKMERGE_IN_NO_UNRELATED - Do not retrieve merge information for volumes of the foreign disk group that do not have extents on diskList.  This is an input-only flag.";
		case 0x00000002: "DSKMERGE_OUT_NO_PRIMARY_DG - The machine does not have a primary disk group.  This is an output-only flag.";
		Default: "unknown";
	}
}

Table DMRPGetEncapsulateDiskInfoencapInfoFlagsTable( Value )
{
	switch( Value )
	{
		case 0x00000001: "ENCAP_INFO_CANT_PROCEED - Encapsulation for disk will not succeed.  The other flags specify the reason.";
		case 0x00000002: "ENCAP_INFO_NO_FREE_SPACE - Volume manager could not find sufficient free space on the disk for encapsulation.";
		case 0x00000004: "ENCAP_INFO_BAD_ACTIVE - Disk contains an active partition from which the current operating system was started.";
		case 0x00000008: "ENCAP_INFO_UNKNOWN_PART - Volume manager was unable to determine the type of a partition on the disk.";
		case 0x00000010: "ENCAP_INFO_FT_UNHEALTHY - Disk contains an FT set volume that is not functioning properly.";
		case 0x00000020: "ENCAP_INFO_FT_QUERY_FAILED - Volume manager was unable to obtain information about an FT set volume on the disk.";
		case 0x00000040: "ENCAP_INFO_FT_HAS_RAID5 - Disk is part of an FT RAID-5 set, which this interface does not support for encapsulation.";
		case 0x00000080: "ENCAP_INFO_FT_ON_BOOT - Disk is both part of an FT set volume and bootable, which this interface does not support for encapsulation.";
		case 0x00000100: "ENCAP_INFO_REBOOT_REQD - Encapsulation of the disk requires a restart of the computer.";
		case 0x00000200: "ENCAP_INFO_CONTAINS_FT - Disk is part of an FT set volume.";
		case 0x00000400: "ENCAP_INFO_VOLUME_BUSY - Disk is currently in use.";
		case 0x00000800: "ENCAP_INFO_PART_NR_CHANGE - Encapsulation of the disk requires modification of the boot configuration.";
		Default: "unknown";
	}
}

Table DMRPGetEncapsulateDiskInfoaffectedDMRPDiskFlagsTable( Value )
{
	switch( Value )
	{
		case 0x00000001: "CONTAINS_FT - Disk contains an FT set volume.";
		case 0x00000002: "CONTAINS_RAID5 - Disk contains part of an FT RAID-5 set.";
		case 0x00000004: "CONTAINS_REDISTRIBUTION - Disk contains an unknown volume type.";
		case 0x00000008: "CONTAINS_BOOTABLE_PARTITION - Disk contains a bootable partition.";
		case 0x00000010: "CONTAINS_LOCKED_PARTITION - Disk contains a locked partition.";
		case 0x00000020: "CONTAINS_NO_FREE_SPACE - Disk is full.";
		case 0x00000040: "CONTAINS_EXTENDED_PARTITION - Disk contains an empty partition.";
		case 0x00000080: "PARTITION_NUMBER_CHANGE - A partition number on the disk has changed.";
		case 0x00000100: "CONTAINS_BOOTINDICATOR - Disk contains the active partition.";
		case 0x00000200: "CONTAINS_BOOTLOADER - Disk contains the boot loader.";
		case 0x00000400: "CONTAINS_SYSTEMDIR - Partition contains the system directory.";
		case 0x00000800: "CONTAINS_MIXED_PARTITIONS - Partition contains different types of partitions.";
		Default: "unknown";
	}
}

Table DMRPEncapsulateDiskencapInfoFlagsTable( Value )
{
	switch( Value )
	{
		case 0x00000001: "ENCAP_INFO_CANT_PROCEED - Encapsulation for disk did not succeed.  The other flags specify the reason.";
		case 0x00000002: "ENCAP_INFO_NO_FREE_SPACE - The volume manager could not find sufficient free space on the disk for encapsulation.";
		case 0x00000004: "ENCAP_INFO_BAD_ACTIVE - The disk contains an active partition from which the current operating system was not started.";
		case 0x00000008: "ENCAP_INFO_UNKNOWN_PART - The volume manager was unable to determine the type of a partition on the disk.";
		case 0x00000010: "ENCAP_INFO_FT_UNHEALTHY - The disk contains an unhealthy FT set volume.";
		case 0x00000020: "ENCAP_INFO_FT_QUERY_FAILED - The volume manager was unable to obtain information about an FT set volume on the disk.";
		case 0x00000040: "ENCAP_INFO_FT_HAS_RAID5 - The disk is part of an FT RAID-5 set, which this interface does not support for encapsulation.";
		case 0x00000080: "ENCAP_INFO_FT_ON_BOOT - The disk is part of an FT set volume and bootable, which this interface does not support for encapsulation.";
		case 0x00000100: "ENCAP_INFO_REBOOT_REQD - Encapsulation of the disk will require a restart of the computer.";
		case 0x00000200: "ENCAP_INFO_CONTAINS_FT - The disk is part of an FT set volume.";
		case 0x00000400: "ENCAP_INFO_VOLUME_BUSY - The disk is currently in use.";
		case 0x00000800: "ENCAP_INFO_PART_NR_CHANGE - Encapsulation of the disk requires modification of the boot configuration.";
		Default: "unknown";
	}
}

Table DMRPSetDontShowbSetNoShowTable( Value )
{
	switch( Value )
	{
		case 0: "FALSE - Enable new Disk Wizard. This is the default value. This value indicates that the user has not selected the check box in the New Disk Wizard to request the wizard not to be displayed in the future.";
		case 1: "TRUE - Disable new Disk Wizard. This value indicates that the user has selected the check box in the New Disk Wizard to request the wizard not to be displayed in the future.";
		Default: "unknown";
	}
}

Table DMRPGetDontShowbGetNoShowTable( Value )
{
	switch( Value )
	{
		case 0: "FALSE - New Disk Wizard is enabled. This is the default value. This value indicates that the user has not selected the check box in the New Disk Wizard to request the wizard not to be displayed in the future.";
		case 1: "TRUE - New Disk Wizard is disabled. Indicates that the user has selected the check box in the New Disk Wizard to request that the wizard not to be displayed in the future.";
		Default: "unknown";
	}
}

Table DMRPHrGetErrorDatadwFlagsTable( Value )
{
	switch( Value )
	{
		case 0x00020000: "ERRFLAG_NOREMOVE - Do not delete the error information from the list maintained by the server.";
		case 0x00040000: "ERRFLAG_IGNORETAG - Retrieve the error information even if it was not produced for this client.";
		Default: "unknown";
	}
}

Table DMRPInitializepdwFlagsTable( Value )
{
	switch( Value )
	{
		case 0x00000001: "SYSFLAG_SERVER - Server is running on Windows NT Server.";
		case 0x00000002: "SYSFLAG_ALPHA - Server is running on an Alpha processor.This flag is never set by , , or .";
		case 0x00000004: "SYSFLAG_SYSPART_SECURE - System partition for the server is secure.This flag is never set by , , or .";
		case 0x00000008: "SYSFLAG_NEC_98 - Server is an NEC 98 computer, which supports assignment of drive letters A and B to partitions or volumes.This flag is only set by .";
		case 0x00000010: "SYSFLAG_NO_DYNAMIC - Server is a laptop and does not support dynamic disks.";
		case 0x00000020: "SYSFLAG_WOLFPACK - Server is running on an MSCS cluster.";
		case 0x00000040: "SYSFLAG_IA64 - Server is running on an Intel IA64 processor.";
		case 0x00000080: "SYSFLAG_UNINSTALL_VALID - Server has an available and valid backup for uninstall.";
		case 0x00000100: "SYSFLAG_DYNAMIC_1394 - Server supports converting IEEE 1394 attached disks to dynamic disks.";
		Default: "unknown";
	}
}

Table DMRPDiskInfoExdflagsTable( Value )
{
	switch( Value )
	{
		case 0x00000001: "DISK_AUDIO_CD - Disk is an audio CD.";
		case 0x00000002: "DISK_NEC98 - This value is obsolete and MUST NOT be returned.";
		case 0x00000004: "DISK_FORMATTABLE_DVD - Disk is a formattable DVD.";
		case 0x00000008: "DISK_MEMORY_STICK - Disk is a memory stick.";
		case 0x000000010: "DISK_NTFS_NOT_SUPPORTED - Disk does not support being formatted as NTFS.";
		Default: "unknown";
	}
}

Table DMRPDiskInfoExdeviceTypeTable( Value )
{
	switch( Value )
	{
		case 0x00000000: "DEVICETYPE_UNKNOWN - Device is of an unknown type.";
		case 0x00000001: "DEVICETYPE_VM - Device is a dynamic disk.";
		case 0x00000002: "DEVICETYPE_REMOVABLE - Device uses removable media.";
		case 0x00000003: "DEVICETYPE_CDROM - Device is a CD-ROM.";
		case 0x00000004: "DEVICETYPE_FDISK - Device is a basic disk.";
		case 0x00000005: "DEVICETYPE_DVD - Device is a DVD.";
		Default: "unknown";
	}
}

Table DMRPDiskInfoExdeviceStateTable( Value )
{
	switch( Value )
	{
		case 0x00000000: "DEVICESTATE_UNKNOWN - Disk is in an unknown state.";
		case 0x00000001: "DEVICESTATE_HEALTHY - Disk is fully functional.";
		case 0x00000002: "DEVICESTATE_NO_MEDIA - Disk has no media.";
		case 0x00000004: "DEVICESTATE_NOSIG - Disk has an invalid signature.";
		case 0x00000008: "DEVICESTATE_BAD - Disk experienced a geometry failure.";
		case 0x00000010: "DEVICESTATE_NOT_READY - Disk is not ready yet.";
		case 0x00000020: "DEVICESTATE_MISSING - Disk is no longer available.";
		case 0x00000040: "DEVICESTATE_OFFLINE - Disk is offline.";
		case 0x00000080: "DEVICESTATE_FAILING - Disk experienced a physical I/O error.";
		case 0x00000100: "DEVICESTATE_IMPORT_FAILED - Disk belongs to a group whose import failed. See Disk Group Import.";
		case 0x00000200: "DEVICESTATE_UNCLAIMED - Disk belongs to a foreign disk group.";
		Default: "unknown";
	}
}

Table DMRPDiskInfoExbusTypeTable( Value )
{
	switch( Value )
	{
		case 0x00000000: "BUSTYPE_UNKNOWN - Bus type is unknown.";
		case 0x00000001: "BUSTYPE_IDE - Disk resides on an integrated drive electronics (IDE) bus.";
		case 0x00000002: "BUSTYPE_SCSI - Disk resides on a small computer system interface (SCSI) bus.";
		case 0x00000003: "BUSTYPE_FIBRE - Disk resides on a Fibre Channel bus.";
		case 0x00000004: "BUSTYPE_USB - Disk resides on a universal serial bus (USB).";
		case 0x00000005: "BUSTYPE_SSA - Disk resides on a Serial Storage Architecture (SSA) bus.";
		case 0x00000006: "BUSTYPE_1394 - Disk resides on an Institute of Electronics and Electrical Engineers (IEEE) 1394 bus.";
		Default: "unknown";
	}
}

Table DMRPDiskInfoExattributesTable( Value )
{
	switch( Value )
	{
		case 0x00000000: "DEVICEATTR_NONE - Disk has no attributes.";
		case 0x00000001: "DEVICEATTR_RDONLY - Disk is read-only.";
		case 0x00000002: "DEVICEATTR_NTMS - This value is obsolete.";
		Default: "unknown";
	}
}

Table DMRPDiskInfoExisUpgradeableTable( Value )
{
	switch( Value )
	{
		case 0: "FALSE - Disk cannot be encapsulated or converted to a dynamic disk.";
		case 1: "TRUE - Disk can be encapsulated or converted to a dynamic disk.";
		Default: "unknown";
	}
}

Table DMRPDiskInfoExmayswitchStyleTable( Value )
{
	switch( Value )
	{
		case 0: "FALSE - Partition style of the disk cannot be changed.";
		case 1: "TRUE - Partition style of the disk can be changed between Master Boot Record (MBR) and (GUID) Partition Table (GPT).";
		Default: "unknown";
	}
}

Table DMRPRegionInfoExrflagsTable( Value )
{
	switch( Value )
	{
		case 0x00000001: "REGION_FORMAT_IN_PROGRESS - Region is currently being formatted.";
		case 0x00000002: "REGION_IS_SYSTEM_PARTITION - Region contains the system directory.  The system directory has the operating system installed on it.  This is not necessarily the active partition that contains the boot loader file.";
		case 0x00000004: "REGION_HAS_PAGEFILE - Region contains the paging file.";
		case 0x00000040: "REGION_HAD_BOOT_INI - Boot.ini file was located in this region when the operating system was last started.  This is the active partition that contains the boot loader file.";
		case 0x00040000: "REGION_HIDDEN - This region is part of a volume that is not accessible through any user-available path names.Hidden volumes are not accessible by opening a handle to the file system on the volume using the Win32 API.  The volume may only be accessed by opening a handle to the volume device.";
		Default: "unknown";
	}
}

Table DMRPCreatePartitionsForVolumeactiveTable( Value )
{
	switch( Value )
	{
		case 0: "FALSE - New partition is not set to active.";
		case 1: "TRUE - New partition is set to active.";
		Default: "unknown";
	}
}

Table DMRPGetEncapsulateDiskInfoExencapInfoFlagsTable( Value )
{
	switch( Value )
	{
		case 0x00000001: "ENCAP_INFO_CANT_PROCEED - Encapsulation for the disk will not succeed.  The other flags specify the reason.";
		case 0x00000002: "ENCAP_INFO_NO_FREE_SPACE - Volume manager could not find sufficient free space on the disk for encapsulation.";
		case 0x00000004: "ENCAP_INFO_BAD_ACTIVE - Disk contains an active partition from which the current operating system was not started.";
		case 0x00000008: "ENCAP_INFO_UNKNOWN_PART - Volume manager was unable to determine the type of a partition on the disk because of corruption or other errors reading the disk. For example, any error preventing the partition information from being read, the partition is neither GPT or MBR, an OEM partition is found that is not at the beginning of the disk, etc.";
		case 0x00000010: "ENCAP_INFO_FT_UNHEALTHY - Disk contains an FT set volume that is not functioning properly.";
		case 0x00000020: "ENCAP_INFO_FT_QUERY_FAILED - Volume manager was unable to obtain information about an FT set volume on the disk.";
		case 0x00000100: "ENCAP_INFO_REBOOT_REQD - Encapsulation of the disk requires a restart of the computer.";
		case 0x00000200: "ENCAP_INFO_CONTAINS_FT - Disk is part of an FT set volume.";
		case 0x00000400: "ENCAP_INFO_VOLUME_BUSY - Disk is currently in use.";
		case 0x00000800: "ENCAP_INFO_PART_NR_CHANGE - Encapsulation of the disk requires modification of the boot configuration.";
		case 0x00001000: "ENCAP_INFO_MIXED_PARTITIONS - Encapsulation of a GPT disk containing basic partitions mixed with non-basic partitions is not supported.";
		case 0x00002000: "ENCAP_INFO_OPEN_FAILED - Could not open a volume residing on a disk in the set of disks specified for encapsulation.";
		Default: "unknown";
	}
}

Table DMRPGetEncapsulateDiskInfoExaffectedDMRPDiskFlagsTable( Value )
{
	switch( Value )
	{
		case 0x00000001: "CONTAINS_FT - Disk contains an FT set volume.";
		case 0x00000002: "CONTAINS_RAID5 - Disk contains part of an FT RAID-5 set.";
		case 0x00000004: "CONTAINS_REDISTRIBUTION - Not used.";
		case 0x00000008: "CONTAINS_BOOTABLE_PARTITION - Disk contains a bootable partition.";
		case 0x00000010: "CONTAINS_LOCKED_PARTITION - Disk contains a locked partition.";
		case 0x00000020: "CONTAINS_NO_FREE_SPACE - Disk is full.";
		case 0x00000040: "CONTAINS_EXTENDED_PARTITION - Disk contains an extended partition.";
		case 0x00000080: "PARTITION_NUMBER_CHANGE - A partition number on the disk has changed.";
		case 0x00000100: "CONTAINS_BOOTINDICATOR - Disk contains the active partition.";
		case 0x00000200: "CONTAINS_BOOTLOADER - Disk contains the boot loader.";
		case 0x00000400: "CONTAINS_SYSTEMDIR - Partition contains the system directory.";
		case 0x00000800: "CONTAINS_MIXED_PARTITIONS - Partition contains partitions that will not be converted to dynamic.";
		Default: "unknown";
	}
}

Table DMRPEncapsulateDiskExencapInfoFlagsTable( Value )
{
	switch( Value )
	{
		case 0x00000001: "ENCAP_INFO_CANT_PROCEED - Encapsulation for disk did not succeed.  Inspect the other values of encapInfoFlags to determine the reason.";
		case 0x00000002: "ENCAP_INFO_NO_FREE_SPACE - The volume manager could not find sufficient free space on the disk for encapsulation.";
		case 0x00000004: "ENCAP_INFO_BAD_ACTIVE - The disk contains an active partition from which the current operating system was not started.";
		case 0x00000008: "ENCAP_INFO_UNKNOWN_PART - The volume manager was unable to determine the type of a partition on the disk.";
		case 0x00000010: "ENCAP_INFO_FT_UNHEALTHY - The disk contains an unhealthy FT set volume.";
		case 0x00000020: "ENCAP_INFO_FT_QUERY_FAILED - The volume manager was unable to obtain information about an FT set volume on the disk.";
		case 0x00000100: "ENCAP_INFO_REBOOT_REQD - Encapsulation of the disk will require a restart of the computer.";
		case 0x00000200: "ENCAP_INFO_CONTAINS_FT - The disk is part of an FT set volume.";
		case 0x00000400: "ENCAP_INFO_VOLUME_BUSY - The disk is currently in use.";
		case 0x00000800: "ENCAP_INFO_PART_NR_CHANGE - Encapsulation of the disk requires modification of the boot configuration.";
		case 0x00001000: "ENCAP_INFO_MIXED_PARTITIONS - Encapsulation of a GPT disk containing basic partitions mixed with non-basic partitions is not supported.";
		case 0x00002000: "ENCAP_INFO_OPEN_FAILED - Could not open a volume residing on a disk in the set of disks specified for encapsulation.";
		Default: "unknown";
	}
}


Struct DMRPDiskInfo = DMRPDiskInfoDeviceType
{
	[DMRPStructStartOffset = FrameOffset]          
	LdmObjectId id;   
	INT64 length;     
	INT64 freeBytes;  
	UINT32 bytesPerTrack;
	UINT32 bytesPerCylinder;
	UINT32 bytesPerSector;
	UINT32 regionCount;
	UINT32 dflags     
	{        
		UINT32 AudioCD:1 = FormatString(" (%s) %s", this.ToBitString, this ? "Disk is an audio CD"
		: "Disk is not an audio CD" ); 
		UINT32 Obsolete:1 = FormatString("(%s) %s", this.ToBitString, this ? "This value is obsolete"
		: "This value is not obsolete" );                                                              
	};
	[DMRPDiskInfoDeviceType = this.ToString]
	UINT32 deviceType = DMRPDeviceTypeTable(this);
	switch(UINT32(FrameData, FrameOffset))
	{
		case 0x00000000:
		_struct DeviceUnknownState
		{  
			UINT32 deviceState = FormatString("%s","Disk is in an unknown state");
		}
		default:
		UINT32 deviceState
		{ 
			UINT32 Healthy:1 = FormatString("     (%s) %s", this.ToBitString, this ? "Disk is fully functional"
			: "Disk is not fully functional" );
			UINT32 NoMedia:1 = FormatString("     (%s) %s", this.ToBitString, this ? "Disk has no media"
			: "Disk has media" );
			UINT32 NoSig:1 = FormatString("       (%s) %s", this.ToBitString, this ? "Disk has an invalid signature"
			: "Disk has a valid signature" );
			UINT32 Bad:1 = FormatString("         (%s) %s", this.ToBitString, this ? "Disk experienced a geometry failure"
			: "Disk didn't experience a geometry failure" );
			UINT32 NoReady:1 = FormatString("     (%s) %s", this.ToBitString, this ? "Disk is not ready yet"
			: "Disk is ready" );
			UINT32 Missing:1 = FormatString("     (%s) %s", this.ToBitString, this ? "Disk is no longer available"
			: "Disk is still available" );
			UINT32 Offline:1 = FormatString("     (%s) %s", this.ToBitString, this ? "Disk is offline"
			: "Disk is online" );
			UINT32 Failing:1 = FormatString("     (%s) %s", this.ToBitString, this ? "Disk experienced a physical input/output (I/O) error"
			: "Disk didn't experience a physical input/output (I/O) error" );
			UINT32 ImportFailed:1 = FormatString("(%s) %s", this.ToBitString, this ? "Disk belongs to a group whose import failed"
			: "Disk does not belong to a group whose import failed." ); 
			UINT32 Unclaimed:1 = FormatString("   (%s) %s", this.ToBitString, this ? "Disk belongs to a foreign disk group"
			: "Disk does not belong to a foreign disk group" );
		}
	}
	UINT32 busType = DMRPDiskInfoBusTypeTable( this );
	switch(UINT32(FrameData, FrameOffset))
	{
		case 0x00000000: 
		_struct DiskNoAttr
		{
			UINT32 attributes = FormatString("%s", "Disk has no attributes");
		}
		default:   
		UINT32 attributes 
		{ 
			UINT32 RDONLY:1 = FormatString("(%s) %s", this.ToBitString,  this ? "Disk is read-only."
			: "Disk is not read-only." );
			UINT32 NTMS:1 = FormatString("  (%s) %s", this.ToBitString,  this ? "This value is not used."
			: "This value is used." );                    
		}
	}
	BOOLEAN isUpgradeable = FormatString("%s", this ? "TRUE : Disk can be upgraded to control by the volume manager" 
	: "FALSE : Disk cannot be upgraded to control by the volume manager");
	switch( DMRPINBYTESTREAM )
	{
		case 1: DMRPCommonMemoryAlign(4) MemoryPortNumberAlign;
		default: ALIGN4 NDRPortNumberAlign;
	}
	INT32 portNumber;
	INT32 targetNumber;
	INT32 lunNumber;
	switch( DMRPINBYTESTREAM )
	{
		case 1: DMRPCommonMemoryAlign(8) MemoryLastKnownStateAlign;
		default: ALIGN8 NDRLastKnownStateAlign;
	}
	INT64 lastKnownState;
	LdmObjectId taskId;
	INT32 cchName;
	INT32 cchVendor;
	INT32 cchDgid;
	INT32 cchAdapterName;
	INT32 cchDgName;
	switch
	{
		case Property.MSRPCNdr64: Align8 Pad;
	}
	switch( DMRPINBYTESTREAM )
	{
		case 1:
		_struct InByteStream
		{
			UnicodeString(cchName) name;
			UnicodeString(cchVendor) vendor;
			BLOB(cchDgid) dgid;
			UnicodeString(cchAdapterName) adapterName;
			UnicodeString(cchDgName) dgName;
		};
		default:
		_struct NotInByteStream
		{
			[DMRPDiskInfoName$[DiskInfoEnterCount] = cchName]
			NdrPtr ptr2name;

			[DMRPDiskInfoVendor$[DiskInfoEnterCount] = cchVendor]
			NdrPtr ptr2vendor;

			[DMRPDiskInfoDgid$[DiskInfoEnterCount] = cchDgid]
			NdrPtr ptr2dgid;

			[DMRPDiskInfoAdapterName$[DiskInfoEnterCount] = cchAdapterName]
			NdrPtr ptr2adapterName;

			[DMRPDiskInfoDgName$[DiskInfoEnterCount] = cchDgName]
			NdrPtr ptr2dgName;
		}
	}
}

Struct DMRPRegionInfo = "ReginType = "+ DMRPRegionTypeTable(DMRPRegionType)
{
	[DMRPStructStartOffset = FrameOffset]
	LdmObjectId id;
	LdmObjectId diskId;
	LdmObjectId volId;
	LdmObjectId fsId;
	INT64 start;
	INT64 length;
	[DMRPRegionType = this]
	DMRPRegionType RegionType;
	switch( DMRPINBYTESTREAM )
	{
		case 1: DMRPCommonMemoryAlign(4) MemoryPartitionTypeAlign;
		default: ALIGN4 NDRPartitionTypeAlign;
	}
	UINT32 partitionType = DMRPPartitionTypeTable(this);    // P536 where to find partitiontype??
	BOOLEAN isActive = FormatString("%s", this ? "TRUE : Region resides in an active partition." 
	: "FALSE : Region resides in an inactive partition.");
	switch( DMRPINBYTESTREAM )
	{
		case 1: DMRPCommonMemoryAlign(4) MemoryRegionStatusAlign;
		default: ALIGN2 NDRRegionStatusAlign;
	}
	DMRPRegionStatus regionStatus;
	switch (DMRPINBYTESTREAM)
	{
		case 1: DMRPCommonMemoryAlign(8) MemoryLastKnownStateAlign;
		default: ALIGN8 NDRLastKnownStateAlign;
	}

	hyper lastKnownState;
	LdmObjectId taskId;
	UINT32 rflags
	{
		UINT32 FormatInProgress:1 = FormatString(" (%s) %s", this.ToBitString, this ? "Region is currently being formatted"  
		: "Region is not being formatted currently" );                                          
		UINT32 IsSystemPartition:1 = FormatString("(%s) %s", this.ToBitString, this ? "Region contains the system directory"
		: "Region does not contain the system directory" );
		UINT32 HasPageFile:1 = FormatString("      (%s) %s", this.ToBitString, this ? "Region contains the paging file"
		: "Region does not contain the paging file" );
		UINT32 Reserved1:3 = FormatString("        (%s)", this.ToBitString);
		UINT32 HadBootIni:1 = FormatString("       (%s) %s", this.ToBitString, this ? "Boot.ini file was located in this region when the operating system was last booted"
		: "Boot.ini file was not located in this region when the operating system was last booted" );
	};
	UINT32 currentPartitionNumber;
	switch
	{
		case Property.MSRPCNdr64: Align8 Pad;
	}
}

Struct DMRPRegionSpec
{
	LdmObjectId regionId;
	DMRPRegionType regionType;
	BLOB(6) align1;
	LdmObjectId diskId;
	INT64 start;
	INT64 length;
	INT64 lastKnownState;
	switch
	{
		case Property.MSRPCNdr64: Align8 Pad;
	}
}

Struct DMRPTaskInfoStruct = "RequestStatus = " + DMRPReqStatusTable( DMRPTaskStatus )
+ ", Progress = " + DMRPDMProgressTypeTable( DMRPTaskType )
{
	LdmObjectId id;
	LdmObjectId storageId;
	INT64 createTime = FormatString("Unused in Win2000 and WinXP");
	LdmObjectId clientId;
	UINT32 percentComplete;
	[DMRPTaskStatus = this]
	DMRPReqStatus status;
	[DMRPTaskType = this]
	DMRPDMProgressType type;    
	HResult error;
	UINT32 tflag = FormatString("Unused in Win2000 and WinXP");
	switch
	{
		case Property.MSRPCNdr64: Align8 Pad;
	}
}


Struct DMRPFileSystemInfo = FormatString("%s, lable length: %d", fsType.ToString,cchLabel)
{
	LdmObjectId id;
	LdmObjectId storageid;
	INT64 totalAllocationUnits;
	INT64 availableAllocationUnits;
	UINT32 allocationUnitSize;
	UINT32 fsflags
	{ 
		UINT32 SupportNTFSComperssion:1 = FormatString("(%s) %s", this.ToBitString, this ? "File system supports Windows NT file system (NTFS) comperssion"
		: "File system does not support Windows NT file system (NTFS) comperssion" );
	}
	hyper lastKnownState;
	LdmObjectId taskId;
	INT32 fsType = DMRPFSTYPETable( this );
	INT32 cchLabel;

	switch( DMRPINBYTESTREAM )
	{
		case 1:
		_struct InByteStream
		{
			UnicodeString(cchLabel) Label;
		};
		default:
		_struct NotInByteStream
		{
			[DMRPFileSystemInfoLabel$[CurrentFileSystem] = cchLabel]
			NdrPtr ptr2label;
		};
	}	
}

Struct DMRPVolumeInfo = "VolumeType = " + DMRPVolumeTypeTable(DMRPVolumeType) +
", VolumeLayout = " + DMRPVolumeLayoutTable(DMRPVolumeLayout) +
", VolumeStatus = " + DMRPVolumeStatusTable(DMRPVolumeStatus)
{
	[DMRPStructStartOffset = FrameOffset]
	LdmObjectId id;
	[DMRPVolumeType = this]
	DMRPVolumeType type;
	[DMRPVolumeLayout = this]
	DMRPVolumeLayout Layout;
	switch( DMRPINBYTESTREAM )
	{
		case 1: DMRPCommonMemoryAlign(8) MemoryLengthAlign;
		default: ALIGN8 NDRLengthAlign;
	}
	INT64 length;
	LdmObjectId fsId;
	UINT32 memberCount;
	[DMRPVolumeStatus]
	DMRPVolumeStatus Status;
	switch( DMRPINBYTESTREAM )
	{
		case 1: DMRPCommonMemoryAlign(8) MemoryLastKnownStateAlign;
		default: ALIGN8 NDRLastKnownStateAlign;
	}        
	INT64 lastKnownState;
	LdmObjectId taskId;
	UINT32 vflags
	{ 
		UINT32 FormatInProgress:1 = FormatString("  (%s) %s", this.ToBitString, this ? "Volume is currently being formatted."
		: "Volume is not being formatted currently." );
		UINT32 Reserved1:1 = FormatString("         (%s)", this.ToBitString);
		UINT32 HasPageFile:1 = FormatString("       (%s) %s", this.ToBitString, this ? "Volume contains the paging file."
		: "Volume does not contain the paging file." );
		UINT32 Reserved2:5 = FormatString("         (%s)", this.ToBitString);
		UINT32 IsBootVolume:1 = FormatString("      (%s) %s", this.ToBitString, this ? "Volume contains the boot partition."
		: "Volume does not contain the boot partition." );
		UINT32 Reserved3:1 = FormatString("         (%s)", this.ToBitString);
		UINT32 IsRestartable:1 = FormatString("     (%s) %s", this.ToBitString, this ? "The RestartVolume method can be successfully called on this volume."
		: "The RestartVolume method cann't be successfully called on this volume." );
		UINT32 IsSystemVolume:1 = FormatString("    (%s) %s", this.ToBitString, this ? "Volume contains the system directory."
		: "Volume does not contain the system directory." );
		UINT32 HasRetainPartition:1 = FormatString("(%s) %s", this.ToBitString, this ? "Volume has an underlying partition."
		: "Volume does not have any underlying partitions." );
		UINT32 HadBootIni:1 = FormatString("        (%s) %s", this.ToBitString, this ? "Volume contained the boot.ini file used when the operating system was last booted."
		: "Volume did not containe the boot.ini file used when the operating system was last booted." );
		UINT32 Corrupt:1 = FormatString("           (%s) %s", this.ToBitString, this ? "Volume is corrupt."
		: "Volume is not corrupt." ); 
		UINT32 HasCrashDump:1 = FormatString("      (%s) %s", this.ToBitString, this ? "Volume contains a crash dump file."
		: "Volume does not contain a crash dump file." );
		UINT32 IsCurrBootVolume:1 = FormatString("  (%s) %s", this.ToBitString, this ? "Volume is the current boot volume."
		: "Volume is not the current boot volume." ); 
		UINT32 HasHibernation:1 = FormatString("    (%s) %s", this.ToBitString, this ? "Volume contains a hibernation image."
		: "Volume does not contain a hibernation image." );
	};
	switch
	{
		case Property.MSRPCNdr64: Align8 Pad;
	}
}

Struct DMRPDriveLetterInfo = "DriveLetter = " + Letter.ToString
{
	[DMRPStructStartOffset = FrameOffset]
	WCHAR letter;
	switch( DMRPINBYTESTREAM )
	{
		case 1: DMRPCommonMemoryAlign(8) MemoryStorageIDAlign;
		default: ALIGN8 NDRStorageIDAlign;
	}
	LdmObjectId storageId;
	BOOLEAN isUsed = FormatString("%s", this ? "TRUE : Drive letter is in use." 
	: "FALSE : Drive letter is free.");
	switch( DMRPINBYTESTREAM )
	{
		case 1: DMRPCommonMemoryAlign(8) MemoryLastKnownStateAlign;
		default: ALIGN8 NDRLastKnownStateAlign;
	}
	hyper lastKnownState;
	LdmObjectId taskId;
	UINT32 dlflags
	{
		UINT32 RemovalOperationPending:1 = FormatString("(%s) %s", this.ToBitString, this ? "Drive letter has a removal operation pending"
		: "Drive letter does not have removal operation pending" );
	}
	switch
	{
		case Property.MSRPCNdr64: Align8 Pad;
	}
}

Struct DMRPIFileSystemInfo = DMRPIFileSystemInfoType
{
	[DMRPIFileSystemInfoType = this.ToString]
	INT32 fsType = DMRPFSTYPETable (this);
	UnicodeString(8) fsName;
	UINT32 fsflags
	{ 
		UINT32 Compress:1 = FormatString("                  (%s) %s", this.ToBitString,  this ? "File system supports compression"         
		: "File system does not support compression" );
		UINT32 LabelSpecification:1 = FormatString("        (%s) %s", this.ToBitString,  this ? "File system supports label specification"         
		: "File system does not support label specification" );
		UINT32 MountPoints:1 = FormatString("               (%s) %s", this.ToBitString,  this ? "File system supports creation of mount points"         
		: "File system does not support creation of mount points" );
		UINT32 RemovableMedia:1 = FormatString("            (%s) %s", this.ToBitString,  this ? "File system supports creation of removable media"         
		: "File system does not support creation of removable media" );
		UINT32 ExtendOperation:1 = FormatString("           (%s) %s", this.ToBitString,  this ? "File system supports the extend operation"         
		: "File system does not support the extend operation" );
		UINT32 QuickFormatting:1 = FormatString("           (%s) %s", this.ToBitString,  this ? "File system supports quick formatting"         
		: "File system does not support quick formatting" );
		UINT32 AllocationUnit512K:1 = FormatString("        (%s) %s", this.ToBitString,  this ? "File system supports an allocation unit size of 512 bytes"         
		: "File system does not support an allocation unit size of 512 bytes" );
		UINT32 AllocationUnit1K:1 = FormatString("          (%s) %s", this.ToBitString,  this ? "File system supports an allocation unit size of 1 kilobyte (KB)"         
		: "File system does not support an allocation unit size of 1 kilobyte (KB)" );
		UINT32 AllocationUnit2K:1 = FormatString("          (%s) %s", this.ToBitString,  this ? "File system supports an allocation unit size of 2 KB"
		: "File system does not support an allocation unit size of 2 KB" );
		UINT32 AllocationUnit4K:1 = FormatString("          (%s) %s", this.ToBitString,  this ? "File system supports an allocation unit size of 4 KB"
		: "File system does not support an allocation unit size of 4 KB" );
		UINT32 AllocationUnit8K:1 = FormatString("          (%s) %s", this.ToBitString,  this ? "File system supports an allocation unit size of 8 KB"
		: "File system does not support an allocation unit size of 8 KB" );
		UINT32 AllocationUnit16K:1 = FormatString("         (%s) %s", this.ToBitString,  this ? "File system supports an allocation unit size of 16 KB"
		: "File system does not support an allocation unit size of 16 KB" );
		UINT32 AllocationUnit32K:1 = FormatString("         (%s) %s", this.ToBitString,  this ? "File system supports an allocation unit size of 32 KB"
		: "File system does not support an allocation unit size of 32 KB" );
		UINT32 AllocationUnit64K:1 = FormatString("         (%s) %s", this.ToBitString,  this ? "File system supports an allocation unit size of 64 KB"
		: "File system does not support an allocation unit size of 64 KB" );
		UINT32 AllocationUnit128K:1 = FormatString("        (%s) %s", this.ToBitString,  this ? "File system supports an allocation unit size of 128 KB"
		: "File system does not support an allocation unit size of 128 KB" );
		UINT32 AllocationUnit256K:1 = FormatString("        (%s) %s", this.ToBitString,  this ? "File system supports an allocation unit size of 256 KB"
		: "File system does not support an allocation unit size of 256 KB" );
		UINT32 AllocationUnitUserProvided:1 = FormatString("(%s) %s", this.ToBitString,  this ? "File system supports any allocation unit size that the user provides"
		: "File system does not support any allocation unit size that the user provides" );
		UINT32 Formatting:1 = FormatString("                (%s) %s", this.ToBitString,  this ? "File system supports formatting"
		: "File system does not support formatting" );
	}
	UINT32 fsCompressionFlags
	{ 
		UINT32 Reserved1:6 = FormatString("                 (%s)", this.ToBitString);                  
		UINT32 AllocationUnit512K:1 = FormatString("        (%s) %s", this.ToBitString,  this ? "File system supports an allocation unit size of 512 bytes"          
		: "File system does not support an allocation unit size of 512 bytes" );  
		UINT32 AllocationUnit1K:1 = FormatString("          (%s) %s", this.ToBitString,  this ? "File system supports an allocation unit size of 1 KB" 
		: "File system does not support an allocation unit size of 1 KB" );
		UINT32 AllocationUnit2K:1 = FormatString("          (%s) %s", this.ToBitString,  this ? "File system supports an allocation unit size of 2 KB"
		: "File system does not support an allocation unit size of 2 KB" );
		UINT32 AllocationUnit4K:1 = FormatString("          (%s) %s", this.ToBitString,  this ? "File system supports an allocation unit size of 4 KB"
		: "File system does not support an allocation unit size of 4 KB" );                   
		UINT32 AllocationUnit8K:1 = FormatString("          (%s) %s", this.ToBitString,  this ? "File system supports an allocation unit size of 8 KB"
		: "File system does not support an allocation unit size of 8 KB" );                   
		UINT32 AllocationUnit16K:1 = FormatString("         (%s) %s", this.ToBitString,  this ? "File system supports an allocation unit size of 16 KB"
		: "File system does not support an allocation unit size of 16 KB" );                   
		UINT32 AllocationUnit32K:1 = FormatString("         (%s) %s", this.ToBitString,  this ? "File system supports an allocation unit size of 32 KB"
		: "File system does not support an allocation unit size of 32 KB" );                   
		UINT32 AllocationUnit64K:1 = FormatString("         (%s) %s", this.ToBitString,  this ? "File system supports an allocation unit size of 64 KB"
		: "File system does not support an allocation unit size of 64 KB" );
		UINT32 AllocationUnit128K:1 = FormatString("        (%s) %s", this.ToBitString,  this ? "File system supports an allocation unit size of 128 KB"
		: "File system does not support an allocation unit size of 128 KB" );
		UINT32 AllocationUnit256K:1 = FormatString("        (%s) %s", this.ToBitString,  this ? "File system supports an allocation unit size of 256 KB"
		: "File system does not support an allocation unit size of 256 KB" );
		UINT32 AllocationUnitUserProvided:1 = FormatString("(%s) %s", this.ToBitString,  this ? "File system supports any allocation unit size that the user provides"
		: "File system does not support any allocation unit size that the user provides" );                   
	}
	INT32 cchLabelLimit;
	INT32 cchLabel;

	[DMRPIFileSystemInfoLabelChSet$[CurrentFS] = cchLabel]                                    
	NdrPtr ptr2iLabelChSet;
}

Struct DMRPVolumeSpec = "VolumeType = " + DMRPVolumeTypeTable(DMRPVolumeType) +
", VolumeLayout = " + DMRPVolumeLayoutTable(DMRPVolumeLayout) +
", RegionType = " + DMRPRegionTypeTable(DMRPRegionType)
{
	[DMRPVolumeType]
	DMRPVolumeType type;
	[DMRPVolumeLayout]
	DMRPVolumeLayout layout;
	[DMRPRegionType]
	DMRPRegionType regiontype;
	BLOB(2) ALIGN;
	INT64 length;
	INT64 laskKnownState; // hyper or INT64 ??
	switch
	{
		case Property.MSRPCNdr64: Align8 Pad;
	}
}

Struct DMRPDiskSpec = FormatString("DiskID = %s ", diskId)
{
	LdmObjectId diskId;
	INT64 length;
	BOOLEAN needContiguous = FormatString("%s", this ? "TRUE : Contiguous space is needed on the desk." 
	: "FALSE : Contiguous space is not needed on the desk.");
	ALIGN8 ALIGN;
	INT64 lastKnownState;
	switch
	{
		case Property.MSRPCNdr64: Align8 Pad;
	}
}

Struct DMRPMergeObjectInfo
{
	UINT32 type = FormatString("0x%X This parameter is always set to 0x00000001.", this);
	UINT32 flags
	{    
		UINT32 DeleteVolume:1 = FormatString("    (%s) %s", this.ToBitString,  this ? "Volume will be deleted"    
		: "Volume will not be deleted" );
		UINT32 DeleteRedundancy:1 = FormatString("(%s) %s", this.ToBitString,  this ? "Redundancy information will be deleted"
		: "Redundancy information will not be deleted" ); 
		UINT32 StaleContent:1 = FormatString("    (%s) %s", this.ToBitString,  this ? "Volume contents will be stale"
		: "Volume contents will not be stale" );                                         
		UINT32 Subdisks:1 = FormatString("        (%s) %s", this.ToBitString,  this ? "Volume has subdisks on merged disks"
		: "Volume has not subdisks on merged disks" );
	}
	DMRPVolumeLayout layout;
	ALIGN8 ALIGN1;
	INT64 length;
	switch
	{
		case Property.MSRPCNdr64: Align8 Pad;
	}
}

Struct DMRPCountedString = FormatString("cchString:%d", cchString)
{
	LdmObjectId sourceId;
	LdmObjectId targetId;
	INT32 cchString;

	[DMRPCountedStringSString$[CurrentPath] = cchString]                                    
	NdrPtr ptr2sstring;
}

Struct DMRPDiskInfoEx = DMRPDiskInfoExDeviceType
{
	[DMRPStructStartOffset = FrameOffset]
	LdmObjectId id;
	INT64 length;
	INT64 freeBytes;
	UINT32 bytesPerTrack;
	UINT32 bytesPerCylinder;
	UINT32 bytesPerSector;
	UINT32 regionCount;
	UINT32 dflags
	{
		UINT32 AudioCD:1 = FormatString("                  (%s) %s", this.ToBitString, this ? "Disk is an audio CD"
		: "Disk is not an audio CD" );
		UINT32 Obsoleted:1 = FormatString("                (%s) %s", this.ToBitString, this ? "This value is obsolete and MUST NOT be used"
		: "This value is not obsolete" );
		UINT32 FormatableDVD:1 = FormatString("            (%s) %s", this.ToBitString, this ? "Disk is a writeable DVD"
		: "Disk is not a writeable DVD" );
		UINT32 MemoryStick:1 = FormatString("              (%s) %s", this.ToBitString, this ? "Disk is a removable memory stick"
		: "Disk is not a removable memory stick" );
		UINT32 NTFSNotSupported:1 = FormatString("         (%s) %s", this.ToBitString, this ? "Disk does not support NT file system(NTFS)"
		: "Disk supports NT file system(NTFS)" );
	};
	[DMRPDiskInfoExDeviceType = this.ToString]
	UINT32 deviceType = DMRPDiskInfoDeviceTypeTable( this );

	switch(UINT32(FrameData, FrameOffset))
	{
		case 0x00000000:
		_struct DeviceUnknownState
		{  
			UINT32 deviceState = FormatString("%s","Disk is in an unknown state");
		}
		default:
		UINT32 deviceState
		{ 
			UINT32 Healthy:1 = FormatString("     (%s) %s", this.ToBitString, this ? "Disk is fully functional"
			: "Disk is not fully functional" );
			UINT32 NoMedia:1 = FormatString("     (%s) %s", this.ToBitString, this ? "Disk has no media"
			: "Disk has media" );
			UINT32 NoSig:1 = FormatString("       (%s) %s", this.ToBitString, this ? "Disk has an invalid signature"
			: "Disk has a valid signature" );
			UINT32 Bad:1 = FormatString("         (%s) %s", this.ToBitString, this ? "Disk experienced a geometry failure"
			: "Disk didn't experience a geometry failure" );
			UINT32 NoReady:1 = FormatString("     (%s) %s", this.ToBitString, this ? "Disk is not ready yet"
			: "Disk is ready" );
			UINT32 Missing:1 = FormatString("     (%s) %s", this.ToBitString, this ? "Disk is no longer available"
			: "Disk is still available" );
			UINT32 Offline:1 = FormatString("     (%s) %s", this.ToBitString, this ? "Disk is offline"
			: "Disk is online" );
			UINT32 Failing:1 = FormatString("     (%s) %s", this.ToBitString, this ? "Disk experienced a physical input/output (I/O) error"
			: "Disk didn't experience a physical input/output (I/O) error" );
			UINT32 ImportFailed:1 = FormatString("(%s) %s", this.ToBitString, this ? "Disk belongs to a group whose import failed"
			: "Disk does not belong to a group whose import failed." ); 
			UINT32 Unclaimed:1 = FormatString("   (%s) %s", this.ToBitString, this ? "Disk belongs to a foreign disk group"
			: "Disk does not belong to a foreign disk group" );
		}
	}
	UINT32 busType = DMRPDiskInfoBusTypeTable( this );
	switch(UINT32(FrameData, FrameOffset))
	{
		case 0x00000000: 
		_struct DiskNoAttr
		{
			UINT32 attributes = FormatString("%s", "Disk has no attributes");
		}
		default:   
		UINT32 attributes 
		{ 
			UINT32 RDONLY:1 = FormatString("(%s) %s", this.ToBitString,  this ? "Disk is read-only."
			: "Disk is not read-only." );
			UINT32 NTMS:1 = FormatString("  (%s) %s", this.ToBitString,  this ? "This value is not used."
			: "This value is used." );                    
		}
	}
	UINT32 maxPartitionCount;
	BOOLEAN isUpgradeable = FormatString("%s", this ? "TRUE : Disk can be upgraded to control by the volume manager." 
	: "FALSE : Disk cannot be upgraded to control by the volume manager.");
	BOOLEAN mayswitchStyle = FormatString("%s", this ? "TRUE : Partition style of the disk can be changed between Master Boot Record (MBR) and globally unique identifier (GUID) Partition Type (GPT)." 
	: "FALSE : Partition style of the disk cannot be changed between Master Boot Record (MBR) and globally unique identifier (GUID) Partition Type (GPT).");
	switch( DMRPINBYTESTREAM )
	{
		case 1: DMRPCommonMemoryAlign(4) MemoryPartitionStyleAlign;
	}
	switch
	{
		case Property.MSRPCNdr64: Align4 Pad;
	}
	DMRPPartitionStyle PartitionStyle;

	switch( DMRPINBYTESTREAM )
	{
		case 1: DMRPCommonMemoryAlign(8) MemoryAlignUnion;
		default: ALIGN8 NDRAlignUnion;
	}
	switch
	{
		case Property.MSRPCNdr64: Align4 Pad;
	}
	switch( partitionStyle.partitionStyle )
	{
		case 1: 
		_struct MBR
		{
			UINT32 signature;
			switch( DMRPINBYTESTREAM )
			{
				case 1: BLOB(12) SignaturePadding;
			}
		}
		case 2: 
		_struct GPT
		{
			GUID(1) diskId;
		}
	}
	INT32 PortNumber;
	INT32 TargetNumber;
	INT32 LunNumber;
	switch( DMRPINBYTESTREAM )
	{
		case 1: DMRPCommonMemoryAlign(8) MemoryAlignLaseKnownState;
		default:ALIGN8 NDRAlignLastKnownState;
	}
	INT64 lastKnownState;
	LdmObjectId taskId;
	INT32 cchName;
	INT32 cchVendor;
	INT32 cchDgid;
	INT32 cchAdapterName;
	INT32 cchDgName;
	INT32 cchDevInstId;
	switch
	{
		case Property.MSRPCNdr64: Align8 Pad;
	}

	switch( DMRPINBYTESTREAM )
	{
		case 1:
		_struct InByteStream
		{
			UnicodeString(cchName) name;
			UnicodeString(cchVendor) vendor;
			BLOB(cchDgid) dgid;
			UnicodeString(cchAdapterName) adapterName;
			UnicodeString(cchDgName) dgName;
			UnicodeString(cchDevInstId) devInstId;
		};
		default:
		_struct NotInByteStream
		{
			[DMRPDiskExInfoName$[DiskInfoExEnterCount] = cchName]
			NdrPtr ptr2name;

			[DMRPDiskExInfoVendor$[DiskInfoExEnterCount] = cchVendor]
			NdrPtr ptr2vendor;

			[DMRPDiskExInfoDgid$[DiskInfoExEnterCount] = cchDgid]
			NdrPtr ptr2dgid;

			[DMRPDiskExInfoAdapterName$[DiskInfoExEnterCount] = cchAdapterName]
			NdrPtr ptr2adapterName;

			[DMRPDiskExInfoDgName$[DiskInfoExEnterCount] = cchDgName]
			NdrPtr ptr2dgName;

			[DMRPDiskExInfoNameDevInstId$[DiskInfoExEnterCount] = cchDevInstId]
			NdrPtr ptr2DevInstId;
		}
	}
}

Struct DMRPRegionInfoEx = DMRPRegionInfoExRegionType
{
	[DMRPStructStartOffset = FrameOffset]
	LdmObjectId id;
	LdmObjectId diskId;
	LdmObjectId volId;
	LdmObjectId fsId;
	INT64 start;
	INT64 length;
	[DMRPRegionInfoExRegionType = this.ToString]
	DMRPRegionType regionType;
	switch
	{
		case Property.MSRPCNdr64: Align8 Pad;
	}
	DMRPPartitionStyle partitionStyle;
	switch( DMRPINBYTESTREAM )
	{
		case 1: DMRPCommonMemoryAlign(8) MemoryUnionAlign;
		default: ALIGN8 NDRUnionAlign;
	}
	switch
	{
		case Property.MSRPCNdr64: Align8 Pad;
	}
	switch( partitionStyle.partitionStyle )
	{
		case 1: _struct PartitionStyleMBR
		{
			UINT32 partitionType = DMRPPartitionTypeTable(this);
			BOOLEAN isActive = FormatString("%s", this ? "TRUE : Partition is active." 
			: "FALSE : Partition is not active.");
			switch( DMRPINBYTESTREAM )
			{
				case 1: BLOB(35) MBRPadding;
			}
		};
		case 2: _struct PartitionStyleGPT
		{
			GUID(1) partitionType;
			GUID(1) partitionId;
			UINT64 attributes;
		};
	}
	DMRPRegionStatus status;
	switch( DMRPINBYTESTREAM )
	{
		case 1: DMRPCommonMemoryAlign(8) MemoryLastKnownStateAlign;
		default: ALIGN8 NDRLastKnownStateAlign;
	}
	hyper lastKnownState;
	LdmObjectId taskId;
	UINT32 rflags
	{
		UINT32 FormatInProgress:1 = FormatString(" (%s) %s", this.ToBitString, this ? "Region is currently being formatted"  
		: "Region is not being formatted currently" );                                          
		UINT32 IsSystemPartition:1 = FormatString("(%s) %s", this.ToBitString, this ? "Region contains the system directory"
		: "Region does not contain the system directory" );
		UINT32 HasPageFile:1 = FormatString("      (%s) %s", this.ToBitString, this ? "Region contains the paging file"
		: "Region does not contain the paging file" );
		UINT32 Reserved1:3 = FormatString("        (%s)", this.ToBitString);
		UINT32 HadBootIni:1 = FormatString("       (%s) %s", this.ToBitString, this ? "Boot.ini file was located in this region when the operating system was last booted"
		: "Boot.ini file was not located in this region when the operating system was last booted" );
		UINT32 Reserved2:11 = FormatString("       (%s)", this.ToBitString);                  
		UINT32 Hidden:1 = FormatString("           (%s) %s", this.ToBitString, this ? "Region is hidden"
		: "Region is not hidden" );
	};
	UINT32 currentPartitionNumber;
	INT32 cchName;
	switch
	{
		case Property.MSRPCNdr64: Align8 Pad;
	}

	switch( DMRPINBYTESTREAM )
	{
		case 1: UnicodeString(cchName) Name;
		default: [DMRPRegionInfoExName$[RegionInfoExEnterCount] = cchName]
		NdrPtr ptr2Name;
	}
}


//========= STRUCTS ==============================================================================================

struct DMRPAffectedDiskFlags
{
	UINT32 AffectedDMRPDiskFlags
	{ 
		UINT32 ContainFaultTolerantVolume:1 = FormatString("   (%s) %s", this.ToBitString,  this ? "Disk contains a fault-tolerant volume"
		: "Disk does not contain a fault-tolerant volume" );
		UINT32 ContainRAID5:1 = FormatString("                 (%s) %s", this.ToBitString,  this ? "Disk contains part of a RAID-5 volume"
		: "Disk does not contain part of a RAID-5 volume" );
		UINT32 ContainUnknownVolumeType:1 = FormatString("     (%s) %s", this.ToBitString,  this ? "Disk contains an unknown volume type"
		: "Disk does not contain an unknown volume type" );
		UINT32 ContainBootablePartition:1 = FormatString("     (%s) %s", this.ToBitString,  this ? "Disk contains a bootable partition"
		: "Disk does not contain a bootable partition" );
		UINT32 LockedPartition:1 = FormatString("              (%s) %s", this.ToBitString,  this ? "Disk contains a locked partition"
		: "Disk does not contain a locked partition" );
		UINT32 DiskIsFull:1 = FormatString("                   (%s) %s", this.ToBitString,  this ? "Disk is full"
		: "Disk is not full" );
		UINT32 ContainEmptyPartition:1 = FormatString("        (%s) %s", this.ToBitString,  this ? "Disk contains an empty partition" 
		: "Disk does not contain an empty partition" );
		UINT32 PartitionNumberChanged:1 = FormatString("       (%s) %s", this.ToBitString,  this ? "A partition number on the disk has changed"
		: "No partition number on the disk has changed" );
		UINT32 ContainActivePartition:1 = FormatString("       (%s) %s", this.ToBitString,  this ? "Disk contains the active partition"
		: "Disk does not contain the active partition" );
		UINT32 ContainBootLoader:1 = FormatString("            (%s) %s", this.ToBitString,  this ? "Disk contains the boot loader"
		: "Disk does not contain the boot loader" );
		UINT32 ContainSystemDirectory:1 = FormatString("       (%s) %s", this.ToBitString,  this ? "Partition contains the system directory"
		: "Partition does not contain the system directory" );
		UINT32 ContainDifferentPartitionType:1 = FormatString("(%s) %s", this.ToBitString,  this ? "Partition contains different types of partitions"
		: "Partition does not contain different types of partitions" ); 
	};
}

Struct DMRPByteStream = DMRPByteStreamNotifyInfoType
{
	[DMRPByteStreamSize = this]
	UINT32 TotalSize;
	[DMRPByteStreamNotifyInfoType = this.ToString]
	UINT32 DMNotifyInfoType = DMRPDMNotifyInfoTypeTable(this);
	UINT32 LDMAction = DMRPLDMActionTable(this);
	switch ( DMNotifyInfoType )
	{
		case 1:
		switch( Global.DMRPInitializeInterface )
		{
			case 1: 
			DMRPDiskInfo diskInfo;
			case 2:
			DMRPDiskInfoEx diskInfoEx;
			default: BLOB(FrameLength - FrameOffset) UnknownInitialize;
		}
		case 2:  
		DMRPVolumeInfo volumeInfo;
		case 3: 
		switch( Global.DMRPInitializeInterface )
		{
			case 1: DMRPRegionInfo regionInfo;
			case 2: DMRPRegionInfoEx regionInfoEx;
			default: BLOB(FrameLength - FrameOffset) UnknownInitialize;
		}
		case 4:  
		DMRPTaskInfoStruct taskInfo;
		case 5:   
		DMRPDriveLetterInfo driveLetterInfo;
		case 6:
		DMRPFileSystemInfo fileSystemInfo;
		case 7:
		UINT32 systeminfo;
		default:
		BLOB(TotalSize - 12) UnknownObject;            

    //#? case  7:  what's following?
	}
	switch
	{
		case FrameOffset < FrameLength: BLOB( FrameLength - FrameOffset ) Padding;
	} 
}            

//define two alignment base offset
//one is according to the NDR align whose beginning offset is protocol offset
//another is according to the Memory align whose beginning offset is the first offset of this parameter.

struct DMRPCommonMemoryAlign(BaseAlign) = FormatString("%d Bytes", AlignBytesCount)
{
    switch
    {
        case  ( (FrameOffset - DMRPStructStartOffset) % BaseAlign ) > 0: 
              [AlignBytesCount = (BaseAlign - ( (FrameOffset - DMRPStructStartOffset) % BaseAlign ))]          
	 	          Blob(BaseAlign - ( (FrameOffset - DMRPStructStartOffset) % BaseAlign )) padding;
	 	}
}

struct DMRPCommonDiskInfoExReference = FormatString("Name=%s, Vendor=%s, AdapterName=%s", NameValue.ToString, VendorValue.ToString, AdapterNameValue.ToString)
{
	switch
	{
		case DMRPDiskExInfoName$[DiskInfoExEnterCount]:
		struct NameValue = FormatString("%s", DMRPDiskExInfoName$[DiskInfoExEnterCount] <= 1 ? "NULL" : name.ToString)
		{
			ALIGN4 alignName;
			NdrConformant length;
			UnicodeString(DMRPDiskExInfoName$[DiskInfoExEnterCount]) name;
		};
	}

	switch
	{
		case DMRPDiskExInfoVendor$[DiskInfoExEnterCount]:
		struct VendorValue = FormatString("%s", DMRPDiskExInfoVendor$[DiskInfoExEnterCount] <= 1 ? "NULL" : vendor.ToString)
		{
			ALIGN4 alignVendor;
			NdrConformant length;
			UnicodeString(length.MaxCount) vendor;
		};
	}
	switch
	{
		case DMRPDiskExInfoDgid$[DiskInfoExEnterCount]:
		struct Dgid
		{
			ALIGN4 alignDgid;
			NdrConformant length;
			BLOB(length.MaxCount) dgid;
		};
	}

	switch
	{
		case DMRPDiskExInfoAdapterName$[DiskInfoExEnterCount]:
		struct AdapterNameValue = FormatString("%s", DMRPDiskExInfoAdapterName$[DiskInfoExEnterCount] <= 1 ? "NULL" : adapterName.ToString)
		{
			ALIGN4 alignAdapterName;
			NdrConformant length;
			UnicodeString(length.MaxCount) adapterName;
		};
	}

	switch
	{
		case DMRPDiskExInfoDgName$[DiskInfoExEnterCount]:
		struct DgNameValue = FormatString("%s", DMRPDiskExInfoDgName$[DiskInfoExEnterCount] <= 1 ? "NULL" : dgName.ToString)
		{
			ALIGN4 alignDgName;
			NdrConformant length;
			UnicodeString(length.MaxCount) dgName;
		};
	}
	switch
	{
		case DMRPDiskExInfoNameDevInstId$[DiskInfoExEnterCount]:
		struct DevInstIdValue = FormatString("%s", DMRPDiskExInfoNameDevInstId$[DiskInfoExEnterCount] <= 1 ? "NULL" : devInstId.ToString)
		{
			ALIGN4 alignDevInstId;
			NdrConformant length;
			UnicodeString(length.MaxCount) devInstId;
		};
	}
}

struct DMRPCommonRegionInfoExReference = FormatString("Name=%s", NameValue.ToString)
{
	switch
	{
		case DMRPRegionInfoExName$[RegionInfoExEnterCount]:
		struct NameValue = FormatString("%s", DMRPRegionInfoExName$[RegionInfoExEnterCount] <= 1 ? "NULL" : Name.ToString)
		{
			NdrConformant Length;
			UnicodeString(DMRPRegionInfoExName$[RegionInfoExEnterCount]) Name;
		};
	}
}

struct DMRPCommonDiskInfoReference = FormatString("Name=%s, Vendor=%s, AdapterName=%s", NameValue.ToString, VendorValue.ToString, AdapterNameValue.ToString)
{
	switch
	{
		case DMRPDiskInfoName$[DiskInfoEnterCount]:
		struct NameValue = FormatString("%s", DMRPDiskInfoName$[DiskInfoEnterCount] <= 1 ? "NULL" : Name.ToString)
		{
			NdrConformant Length;
			UnicodeString(DMRPDiskInfoName$[DiskInfoEnterCount]) Name;
		};
	}

	switch
	{
		case DMRPDiskInfoVendor$[DiskInfoEnterCount]:
		struct VendorValue = FormatString("%s", DMRPDiskInfoVendor$[DiskInfoEnterCount] <= 1 ? "NULL" : Vendor.ToString)
		{
			NdrConformant Length;
			UnicodeString(length.MaxCount) Vendor;
		};
	}
	switch
	{
		case DMRPDiskInfoDgid$[DiskInfoEnterCount]:
		struct Dgid
		{
			NdrConformant Length;
			BLOB(DMRPDiskInfoDgid$[DiskInfoEnterCount]) Dgid;
		};
	}

	switch
	{
		case DMRPDiskInfoAdapterName$[DiskInfoEnterCount]:
		struct AdapterNameValue = FormatString("%s", DMRPDiskInfoAdapterName$[DiskInfoEnterCount] <= 1 ? "NULL" : AdapterName.ToString)
		{
			NdrConformant Length;
			UnicodeString(DMRPDiskInfoAdapterName$[DiskInfoEnterCount]) AdapterName;
		};
	}

	switch
	{
		case DMRPDiskInfoDgName$[DiskInfoEnterCount]:
		struct DgNameValue = FormatString("%s", DMRPDiskInfoDgName$[DiskInfoEnterCount] <= 1 ? "NULL" : DgName.ToString)
		{
			NdrConformant Length;
			UnicodeString(DMRPDiskInfoDgName$[DiskInfoEnterCount]) DgName;
		};
	}
}

//yolanda bitorder
struct DMRPDiskFlags
{
	UINT32 FaultTolerantVolume:1 = FormatString("      (%s) %s", this.ToBitString, this ? "Disk contains a fault-tolerant volume. " 
	: "Disk does not contain a fault-tolerant volume. " );
	UINT32 RAID5Volume:1 = FormatString("              (%s) %s", this.ToBitString, this ? "Disk contains part of a RAID-5 volume. " 
	: "Disk does not contain part of a RAID-5 volume. " );
	UINT32 UnknownVolumeType:1 = FormatString("        (%s) %s", this.ToBitString, this ? "Disk contains an unknown volume type. " 
	: "Disk does not contain any unknown volume type. " );
	UINT32 BootablePartition:1 = FormatString("        (%s) %s", this.ToBitString, this ? "Disk contains a bootable partition. " 
	: "Disk does not contain a bootable partition. " );
	UINT32 LockedPartition:1 = FormatString("          (%s) %s", this.ToBitString, this ? "Disk contains a locked partition. " 
	: "Disk does not contain a locked partition. " );
	UINT32 Full:1 = FormatString("                     (%s) %s", this.ToBitString, this ? "Disk is full. " 
	: "Disk is not full. " );
	UINT32 ExtendedPartition:1 = FormatString("        (%s) %s", this.ToBitString, this ? "Disk contains an empty partition. " 
	: "Disk does not contain an empty partition. " );
	UINT32 PartitionNumberChanged:1 = FormatString("   (%s) %s", this.ToBitString, this ? "A partition number on the disk changed. " 
	: "Any partition number on the disk didn't change. " );
	UINT32 ActivePartition:1 = FormatString("          (%s) %s", this.ToBitString, this ? "Disk contains the active partition. " 
	: "Disk does not contain the active partition. " );
	UINT32 BootLoader:1 = FormatString("               (%s) %s", this.ToBitString, this ? "Disk contains the boot loader. " 
	: "Disk does not contain the boot loader. " );
	UINT32 SystemDirectory:1 = FormatString("          (%s) %s", this.ToBitString, this ? "Partition contains the system directory. " 
	: "Partition does not contain the system directory. " );
	UINT32 MixedPartitions:1 = FormatString("          (%s) %s", this.ToBitString, this ? "Partition contains different types of partitions. " 
	: "Partition does not contain different types of partitions. " );
}

struct DMRPCommonFileSystemInfoReference = FormatString("Label = %s", DMRPFileSystemInfoLabel$[CurrentFileSystem] <= 1 ? "NULL" : Label.Label)
{
	switch
	{
		case DMRPFileSystemInfoLabel$[CurrentFileSystem]:
		Struct Label = Label.ToString
		{
			ALIGN4 ALIGN;
			NdrConformant Length;
			UnicodeString(DMRPFileSystemInfoLabel$[CurrentFileSystem]) Label;
		}
	}
}

struct DMRPCommonIFileSystemInfoReference = FormatString("ILabelChSeT=%s", DMRPIFileSystemInfoLabelChSet$[CurrentFS] <= 1 ? "NULL" : iLabelChSet.iLabelChSetValue)      
{                                        
	switch                               
	{                                    
		case DMRPIFileSystemInfoLabelChSet$[CurrentFS] :
		_Struct iLabelChSet 
		{                                
			ALIGN4 ALIGN;                
			NdrConformant length;   
			UnicodeString(DMRPIFileSystemInfoLabelChSet$[CurrentFS]) iLabelChSetValue;
		}                                
	}
}

struct DMRPCommonCountedStringReference = FormatString("%s", DMRPCountedStringSString$[CurrentPath] <= 1 ? "NULL" : string.stringvalue)
{
	switch
	{
		case DMRPCountedStringSString$[CurrentPath]:
		_struct string
		{
			ALIGN4 ALIGN1;
			NdrConformant length;
			UnicodeString(DMRPCountedStringSString$[CurrentPath]) stringvalue;
		}
	}
}


//========= DataTypes for DMRP ==============================================================================================
Struct DMRPPartitionStyle = partitionStyle.ToString
{
	BLOB( DMRPINBYTESTREAM == 1 ? 4 : 2 ) partitionStyle = FormatString( "0x%X : %s", this, DMRPPartitionStyleTable(this) );
}

Number LdmObjectId
{
	Size = 8;
	DisplayFormat = FormatString( "%I64d (0x%I64X)", this, this );
}

Number hyper
{
	Size = 8;
	DisplayFormat = FormatString( "%I64d (0x%I64X)", this, this );
}

struct DMRPRegionStatus = regionStatus.ToString
{
	BLOB( DMRPINBYTESTREAM == 1 ? 4 : 2 ) regionStatus = FormatString( "0x%X : %s", this, DMRPRegionStatusTable(this) );
}
struct DMRPVolumeStatus = volumeStatus.ToString
{
	BLOB( DMRPINBYTESTREAM == 1 ? 4 : 2 ) volumeStatus = FormatString( "0x%X : %s", this, DMRPVolumeStatusTable(this) );
}

struct DMRPRegionType = regionType.ToString
{
	BLOB( DMRPINBYTESTREAM == 1 ? 4 : 2 ) regionType = FormatString( "0x%X : %s", this, DMRPRegionTypeTable(this) );
}

struct DMRPVolumeType = this.ToString
{
	BLOB( DMRPINBYTESTREAM == 1 ? 4 : 2 ) volumeType = FormatString( "0x%X : %s", this, DMRPVolumeTypeTable(this) );
}

struct DMRPVolumeLayout = volumeLayout.ToString
{
	BLOB( DMRPINBYTESTREAM == 1 ? 4 : 2 ) volumeLayout = FormatString( "0x%X : %s", this, DMRPVolumeLayoutTable(this) );
}

struct DMRPReqStatus = reqStatus.ToString
{
	BLOB( DMRPINBYTESTREAM == 1 ? 4 : 2 ) reqStatus = FormatString( "0x%X : %s", this, DMRPReqStatusTable(this) );
}

struct DMRPDMProgressType = progressType.ToString
{
	BLOB( DMRPINBYTESTREAM == 1 ? 4 : 2 ) progressType = FormatString( "0x%X : %s", this, DMRPDMProgressTypeTable(this) );
}


