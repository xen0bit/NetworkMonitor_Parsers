//#  (c) 2009 CodePlex Foundation
//#
//#  Title:                  Group Policy: Preferences Extension Data Structure
//#
//#  Details:                
//#
//#  Microsoft References:   [MS-GPPREF]: Group Policy: Preferences Extension Data Structure
//#
//#  Comments:               
//#
//#  Revision Class and Date:Major, 12/08/2009
//#                          Minor, 3/11/2010
//#
//####

[
  RegisterBefore( FileTypeContent.FileData, GPPREF, Contains(Property.SmbFileName, "Data Sources\\DataSources.xml")
												||Contains(Property.SmbFileName, "Devices\\Devices.xml")
												||Contains(Property.SmbFileName, "Drives\\Drives.xml")
												||Contains(Property.SmbFileName, "EnvironmentVariables\\EnvironmentVariables.xml")
												||Contains(Property.SmbFileName, "Files\\Files.xml")
												||Contains(Property.SmbFileName, "FolderOptions\\FolderOptions.xml")
												||Contains(Property.SmbFileName, "Folders\\Folders.xml")
												||Contains(Property.SmbFileName, "IniFiles\\IniFiles.xml")
												||Contains(Property.SmbFileName, "InternetSettings\\InternetSettings.xml")
												||Contains(Property.SmbFileName, "Groups\\Groups.xml")
												||Contains(Property.SmbFileName, "NetworkOptions\\NetworkOptions.xml")
												||Contains(Property.SmbFileName, "NetworkShares\\NetworkShares.xml")
												||Contains(Property.SmbFileName, "PowerOptions\\PowerOptions.xml")
												||Contains(Property.SmbFileName, "Printers\\Printers.xml")
												||Contains(Property.SmbFileName, "RegionalOptions\\RegionalOptions.xml")
												||Contains(Property.SmbFileName, "Registry\\Registry.xml")
												||Contains(Property.SmbFileName, "ScheduledTasks\\ScheduledTasks.xml")
												||Contains(Property.SmbFileName, "Services\\Services.xml")
												||Contains(Property.SmbFileName, "Shortcuts\\Shortcuts.xml")
												||Contains(Property.SmbFileName, "StartMenuTaskbar\\StartMenuTaskbar.xml"))
]
Protocol GPPREF = formatstring("Preference type: %s", Property.GPPREFPreferenceType)
{
	XmlTag("xml") Header;
	Switch
	{
		Case Contains(Property.SmbFileName, "Data Sources\\DataSources.xml"):
			[ Property.GPPREFPreferenceType = "DataSources" ]
			GPPREFgppDataSourcesElement DataSources;
		Case Contains(Property.SmbFileName, "Devices\\Devices.xml"):
			[ Property.GPPREFPreferenceType = "Devices" ]
			GPPREFgppDevicesElement Devices;
		Case Contains(Property.SmbFileName, "Drives\\Drives.xml"):
			[ Property.GPPREFPreferenceType = "Drives" ]
			GPPREFgppDrivesElement Drives;
		Case Contains(Property.SmbFileName, "EnvironmentVariables\\EnvironmentVariables.xml"):
			[ Property.GPPREFPreferenceType = "EnvironmentVariables" ]
			GPPREFgppEnvironmentVariablesElement EnvironmentVariables;
		Case Contains(Property.SmbFileName, "Files\\Files.xml"):
			[ Property.GPPREFPreferenceType = "Files" ]
			GPPREFgppFilesElement Files;
		Case Contains(Property.SmbFileName, "FolderOptions\\FolderOptions.xml"):
			[ Property.GPPREFPreferenceType = "FolderOptions" ]
			GPPREFgppFolderOptionsElement FolderOptions;
		Case Contains(Property.SmbFileName, "Folders\\Folders.xml"):
			[ Property.GPPREFPreferenceType = "Folders" ]
			GPPREFgppFoldersElement Folders;
		Case Contains(Property.SmbFileName, "IniFiles\\IniFiles.xml"):
			[ Property.GPPREFPreferenceType = "IniFiles" ]
			GPPREFgppIniFilesElement IniFiles;
		Case Contains(Property.SmbFileName, "InternetSettings\\InternetSettings.xml"):
			[ Property.GPPREFPreferenceType = "InternetSettings" ]
			GPPREFgppInternetSettingsElement InternetSettings;
		Case Contains(Property.SmbFileName, "Groups\\Groups.xml"):
			[ Property.GPPREFPreferenceType = "Groups" ]
			GPPREFgppGroupsElement Groups;
		Case Contains(Property.SmbFileName, "NetworkOptions\\NetworkOptions.xml"):
			[ Property.GPPREFPreferenceType = "NetworkOptions" ]
			GPPREFgppNetworkOptionsElement NetworkOptions;
		Case Contains(Property.SmbFileName, "NetworkShares\\NetworkShares.xml"):
			[ Property.GPPREFPreferenceType = "NetworkShares" ]
			GPPREFgppNetworkShareSettingsElement NetworkShares;
		Case Contains(Property.SmbFileName, "PowerOptions\\PowerOptions.xml"):
			[ Property.GPPREFPreferenceType = "PowerOptions" ]
			GPPREFgppPowerOptionsElement PowerOptions;
		Case Contains(Property.SmbFileName, "Printers\\Printers.xml"):
			[ Property.GPPREFPreferenceType = "Printers" ]
			GPPREFgppPrintersElement Printers;
		Case Contains(Property.SmbFileName, "RegionalOptions\\RegionalOptions.xml"):
			[ Property.GPPREFPreferenceType = "RegionalOptions" ]
			GPPREFgppRegionalElement RegionalOptions;
		Case Contains(Property.SmbFileName, "Registry\\Registry.xml"):
			[ Property.GPPREFPreferenceType = "Registry" ]
			GPPREFgppRegistrySettingsElement Registry;
		Case Contains(Property.SmbFileName, "ScheduledTasks\\ScheduledTasks.xml"):
			[ Property.GPPREFPreferenceType = "ScheduledTasks" ]
			GPPREFgppScheduledTasksElement ScheduledTasks;
		Case Contains(Property.SmbFileName, "Services\\Services.xml"):
			[ Property.GPPREFPreferenceType = "Services" ]
			GPPREFgppNTServicesElement Services;
		Case Contains(Property.SmbFileName, "Shortcuts\\Shortcuts.xml"):
			[ Property.GPPREFPreferenceType = "Shortcuts" ]
			GPPREFgppShortcutsElement Shortcuts;
		Case Contains(Property.SmbFileName, "StartMenuTaskbar\\StartMenuTaskbar.xml"):
			[ Property.GPPREFPreferenceType = "StartMenuTaskbar" ]
			GPPREFgppStartMenuTaskbarElement StartMenuTaskbar;
	}
}

//
// Element DataSources
// Embedded ComplexType 
//
Struct GPPREFgppDataSourcesElement = this.STag.ToString
{
	[Post.Local.GPPREFgppDataSourcesElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("DataSources") STag;
	Switch
	{
		Case !Local.GPPREFgppDataSourcesElement_IsEmpty:
			Struct
			{
				While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "DataSource") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
				{
					//
					// Embedded ComplexType 
					//
					Struct DataSource = this.STag.ToString
					{
						[Post.Local.DataSource_IsEmpty = Property.IsXmlEmptyElement]
						XmlTag("DataSource") STag;
						Switch
						{
							Case !Local.DataSource_IsEmpty:
								Struct
								{
									While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
									{
										Switch
										{
											Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Filters"):
												GPPREFgppFiltersElement Filters;
											Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Properties"):
												//
												// Embedded ComplexType 
												//
												Struct Properties = this.STag.ToString
												{
													[Post.Local.Properties_IsEmpty = Property.IsXmlEmptyElement]
													XmlTag("Properties") STag;
													Switch
													{
														Case !Local.Properties_IsEmpty:
															Struct
															{
																Switch
																{
																	Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Attributes") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
																		//
																		// Embedded ComplexType 
																		//
																		Struct Attributes = this.STag.ToString
																		{
																			[Post.Local.Attributes_IsEmpty = Property.IsXmlEmptyElement]
																			XmlTag("Attributes") STag;
																			Switch
																			{
																				Case !Local.Attributes_IsEmpty:
																					Struct
																					{
																						While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Attribute") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
																						{
																							//
																							// Embedded ComplexType 
																							//
																							Struct Attribute = this.STag.ToString
																							{
																								[Post.Local.Attribute_IsEmpty = Property.IsXmlEmptyElement]
																								XmlTag("Attribute") STag;
																								Switch
																								{
																									Case !Local.Attribute_IsEmpty:
																										Struct
																										{
																											XmlTag("Attribute") ETag;
																										}
																								}
																							}
																							
																						}
																						XmlTag("Attributes") ETag;
																					}
																			}
																		}
																		
																}
																
																XmlTag("Properties") ETag;
															}
													}
												}
												
										}
										
									}
									XmlTag("DataSource") ETag;
								}
						}
					}
					
				}
				XmlTag("DataSources") ETag;
			}
	}
}

//
// Element Devices
// Embedded ComplexType 
//
Struct GPPREFgppDevicesElement = this.STag.ToString
{
	[Post.Local.GPPREFgppDevicesElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Devices") STag;
	Switch
	{
		Case !Local.GPPREFgppDevicesElement_IsEmpty:
			Struct
			{
				While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Device") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
				{
					//
					// Embedded ComplexType 
					//
					Struct Device = this.STag.ToString
					{
						[Post.Local.Device_IsEmpty = Property.IsXmlEmptyElement]
						XmlTag("Device") STag;
						Switch
						{
							Case !Local.Device_IsEmpty:
								Struct
								{
									While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
									{
										Switch
										{
											Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Filters"):
												GPPREFgppFiltersElement Filters;
											Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Properties"):
												//
												// Embedded ComplexType 
												//
												Struct Properties = this.STag.ToString
												{
													[Post.Local.Properties_IsEmpty = Property.IsXmlEmptyElement]
													XmlTag("Properties") STag;
													Switch
													{
														Case !Local.Properties_IsEmpty:
															Struct
															{
																XmlTag("Properties") ETag;
															}
													}
												}
												
										}
										
									}
									XmlTag("Device") ETag;
								}
						}
					}
					
				}
				XmlTag("Devices") ETag;
			}
	}
}

//
// Element Drives
// Embedded ComplexType 
//
Struct GPPREFgppDrivesElement = this.STag.ToString
{
	[Post.Local.GPPREFgppDrivesElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Drives") STag;
	Switch
	{
		Case !Local.GPPREFgppDrivesElement_IsEmpty:
			Struct
			{
				While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Drive") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
				{
					//
					// Embedded ComplexType 
					//
					Struct Drive = this.STag.ToString
					{
						[Post.Local.Drive_IsEmpty = Property.IsXmlEmptyElement]
						XmlTag("Drive") STag;
						Switch
						{
							Case !Local.Drive_IsEmpty:
								Struct
								{
									While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
									{
										Switch
										{
											Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Filters"):
												GPPREFgppFiltersElement Filters;
											Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Properties"):
												//
												// Embedded ComplexType 
												//
												Struct Properties = this.STag.ToString
												{
													[Post.Local.Properties_IsEmpty = Property.IsXmlEmptyElement]
													XmlTag("Properties") STag;
													Switch
													{
														Case !Local.Properties_IsEmpty:
															Struct
															{
																XmlTag("Properties") ETag;
															}
													}
												}
												
										}
										
									}
									XmlTag("Drive") ETag;
								}
						}
					}
					
				}
				XmlTag("Drives") ETag;
			}
	}
}

//
// Element EnvironmentVariables
// Embedded ComplexType 
//
Struct GPPREFgppEnvironmentVariablesElement = this.STag.ToString
{
	[Post.Local.GPPREFgppEnvironmentVariablesElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("EnvironmentVariables") STag;
	Switch
	{
		Case !Local.GPPREFgppEnvironmentVariablesElement_IsEmpty:
			Struct
			{
				While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EnvironmentVariable") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
				{
					//
					// Embedded ComplexType 
					//
					Struct EnvironmentVariable = this.STag.ToString
					{
						[Post.Local.EnvironmentVariable_IsEmpty = Property.IsXmlEmptyElement]
						XmlTag("EnvironmentVariable") STag;
						Switch
						{
							Case !Local.EnvironmentVariable_IsEmpty:
								Struct
								{
									While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
									{
										Switch
										{
											Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Filters"):
												GPPREFgppFiltersElement Filters;
											Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Properties"):
												//
												// Embedded ComplexType 
												//
												Struct Properties = this.STag.ToString
												{
													[Post.Local.Properties_IsEmpty = Property.IsXmlEmptyElement]
													XmlTag("Properties") STag;
													Switch
													{
														Case !Local.Properties_IsEmpty:
															Struct
															{
																XmlTag("Properties") ETag;
															}
													}
												}
												
										}
										
									}
									XmlTag("EnvironmentVariable") ETag;
								}
						}
					}
					
				}
				XmlTag("EnvironmentVariables") ETag;
			}
	}
}

//
// Element Files
// Embedded ComplexType 
//
Struct GPPREFgppFilesElement = this.STag.ToString
{
	[Post.Local.GPPREFgppFilesElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Files") STag;
	Switch
	{
		Case !Local.GPPREFgppFilesElement_IsEmpty:
			Struct
			{
				While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "File") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
				{
					//
					// Embedded ComplexType 
					//
					Struct File = this.STag.ToString
					{
						[Post.Local.File_IsEmpty = Property.IsXmlEmptyElement]
						XmlTag("File") STag;
						Switch
						{
							Case !Local.File_IsEmpty:
								Struct
								{
									While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
									{
										Switch
										{
											Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Filters"):
												GPPREFgppFiltersElement Filters;
											Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Properties"):
												//
												// Embedded ComplexType 
												//
												Struct Properties = this.STag.ToString
												{
													[Post.Local.Properties_IsEmpty = Property.IsXmlEmptyElement]
													XmlTag("Properties") STag;
													Switch
													{
														Case !Local.Properties_IsEmpty:
															Struct
															{
																XmlTag("Properties") ETag;
															}
													}
												}
												
										}
										
									}
									XmlTag("File") ETag;
								}
						}
					}
					
				}
				XmlTag("Files") ETag;
			}
	}
}

//
// Element FolderOptions
// Embedded ComplexType 
//
Struct GPPREFgppFolderOptionsElement = this.STag.ToString
{
	[Post.Local.GPPREFgppFolderOptionsElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("FolderOptions") STag;
	Switch
	{
		Case !Local.GPPREFgppFolderOptionsElement_IsEmpty:
			Struct
			{
				While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
				{
					Switch
					{
						Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GlobalFolderOptions"):
							//
							// Embedded ComplexType 
							//
							Struct GlobalFolderOptions = this.STag.ToString
							{
								[Post.Local.GlobalFolderOptions_IsEmpty = Property.IsXmlEmptyElement]
								XmlTag("GlobalFolderOptions") STag;
								Switch
								{
									Case !Local.GlobalFolderOptions_IsEmpty:
										Struct
										{
											While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
											{
												Switch
												{
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Filters"):
														GPPREFgppFiltersElement Filters;
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Properties"):
														//
														// Embedded ComplexType 
														//
														Struct Properties = this.STag.ToString
														{
															[Post.Local.Properties_IsEmpty = Property.IsXmlEmptyElement]
															XmlTag("Properties") STag;
															Switch
															{
																Case !Local.Properties_IsEmpty:
																	Struct
																	{
																		XmlTag("Properties") ETag;
																	}
															}
														}
														
												}
												
											}
											XmlTag("GlobalFolderOptions") ETag;
										}
								}
							}
							
						Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GlobalFolderOptionsVista"):
							//
							// Embedded ComplexType 
							//
							Struct GlobalFolderOptionsVista = this.STag.ToString
							{
								[Post.Local.GlobalFolderOptionsVista_IsEmpty = Property.IsXmlEmptyElement]
								XmlTag("GlobalFolderOptionsVista") STag;
								Switch
								{
									Case !Local.GlobalFolderOptionsVista_IsEmpty:
										Struct
										{
											While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
											{
												Switch
												{
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Filters"):
														GPPREFgppFiltersElement Filters;
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Properties"):
														//
														// Embedded ComplexType 
														//
														Struct Properties = this.STag.ToString
														{
															[Post.Local.Properties_IsEmpty = Property.IsXmlEmptyElement]
															XmlTag("Properties") STag;
															Switch
															{
																Case !Local.Properties_IsEmpty:
																	Struct
																	{
																		XmlTag("Properties") ETag;
																	}
															}
														}
														
												}
												
											}
											XmlTag("GlobalFolderOptionsVista") ETag;
										}
								}
							}
							
						Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "OpenWith"):
							//
							// Embedded ComplexType 
							//
							Struct OpenWith = this.STag.ToString
							{
								[Post.Local.OpenWith_IsEmpty = Property.IsXmlEmptyElement]
								XmlTag("OpenWith") STag;
								Switch
								{
									Case !Local.OpenWith_IsEmpty:
										Struct
										{
											While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
											{
												Switch
												{
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Filters"):
														GPPREFgppFiltersElement Filters;
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Properties"):
														//
														// Embedded ComplexType 
														//
														Struct Properties = this.STag.ToString
														{
															[Post.Local.Properties_IsEmpty = Property.IsXmlEmptyElement]
															XmlTag("Properties") STag;
															Switch
															{
																Case !Local.Properties_IsEmpty:
																	Struct
																	{
																		XmlTag("Properties") ETag;
																	}
															}
														}
														
												}
												
											}
											XmlTag("OpenWith") ETag;
										}
								}
							}
							
						Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FileType"):
							//
							// Embedded ComplexType 
							//
							Struct FileType = this.STag.ToString
							{
								[Post.Local.FileType_IsEmpty = Property.IsXmlEmptyElement]
								XmlTag("FileType") STag;
								Switch
								{
									Case !Local.FileType_IsEmpty:
										Struct
										{
											While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
											{
												Switch
												{
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Filters"):
														GPPREFgppFiltersElement Filters;
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Properties"):
														//
														// Embedded ComplexType 
														//
														Struct Properties = this.STag.ToString
														{
															[Post.Local.Properties_IsEmpty = Property.IsXmlEmptyElement]
															XmlTag("Properties") STag;
															Switch
															{
																Case !Local.Properties_IsEmpty:
																	Struct
																	{
																		XmlTag("Properties") ETag;
																	}
															}
														}
														
												}
												
											}
											XmlTag("FileType") ETag;
										}
								}
							}
							
					}
					
				}
				XmlTag("FolderOptions") ETag;
			}
	}
}

//
// Element Folders
// Embedded ComplexType 
//
Struct GPPREFgppFoldersElement = this.STag.ToString
{
	[Post.Local.GPPREFgppFoldersElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Folders") STag;
	Switch
	{
		Case !Local.GPPREFgppFoldersElement_IsEmpty:
			Struct
			{
				While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Folder") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
				{
					//
					// Embedded ComplexType 
					//
					Struct Folder = this.STag.ToString
					{
						[Post.Local.Folder_IsEmpty = Property.IsXmlEmptyElement]
						XmlTag("Folder") STag;
						Switch
						{
							Case !Local.Folder_IsEmpty:
								Struct
								{
									While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
									{
										Switch
										{
											Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Filters"):
												GPPREFgppFiltersElement Filters;
											Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Properties"):
												//
												// Embedded ComplexType 
												//
												Struct Properties = this.STag.ToString
												{
													[Post.Local.Properties_IsEmpty = Property.IsXmlEmptyElement]
													XmlTag("Properties") STag;
													Switch
													{
														Case !Local.Properties_IsEmpty:
															Struct
															{
																XmlTag("Properties") ETag;
															}
													}
												}
												
										}
										
									}
									XmlTag("Folder") ETag;
								}
						}
					}
					
				}
				XmlTag("Folders") ETag;
			}
	}
}

//
// Element IniFiles
// Embedded ComplexType 
//
Struct GPPREFgppIniFilesElement = this.STag.ToString
{
	[Post.Local.GPPREFgppIniFilesElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("IniFiles") STag;
	Switch
	{
		Case !Local.GPPREFgppIniFilesElement_IsEmpty:
			Struct
			{
				While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Ini") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
				{
					//
					// Embedded ComplexType 
					//
					Struct Ini = this.STag.ToString
					{
						[Post.Local.Ini_IsEmpty = Property.IsXmlEmptyElement]
						XmlTag("Ini") STag;
						Switch
						{
							Case !Local.Ini_IsEmpty:
								Struct
								{
									While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
									{
										Switch
										{
											Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Filters"):
												GPPREFgppFiltersElement Filters;
											Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Properties"):
												//
												// Embedded ComplexType 
												//
												Struct Properties = this.STag.ToString
												{
													[Post.Local.Properties_IsEmpty = Property.IsXmlEmptyElement]
													XmlTag("Properties") STag;
													Switch
													{
														Case !Local.Properties_IsEmpty:
															Struct
															{
																XmlTag("Properties") ETag;
															}
													}
												}
												
										}
										
									}
									XmlTag("Ini") ETag;
								}
						}
					}
					
				}
				XmlTag("IniFiles") ETag;
			}
	}
}

//
// Element InternetSettings
// Embedded ComplexType 
//
Struct GPPREFgppInternetSettingsElement = this.STag.ToString
{
	[Post.Local.GPPREFgppInternetSettingsElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("InternetSettings") STag;
	Switch
	{
		Case !Local.GPPREFgppInternetSettingsElement_IsEmpty:
			Struct
			{
				While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
				{
					Switch
					{
						Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Internet"):
							//
							// Embedded ComplexType 
							//
							Struct Internet = this.STag.ToString
							{
								[Post.Local.Internet_IsEmpty = Property.IsXmlEmptyElement]
								XmlTag("Internet") STag;
								Switch
								{
									Case !Local.Internet_IsEmpty:
										Struct
										{
											While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
											{
												Switch
												{
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Filters"):
														GPPREFgppFiltersElement Filters;
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Properties"):
														//
														// Embedded ComplexType 
														//
														Struct Properties = this.STag.ToString
														{
															[Post.Local.Properties_IsEmpty = Property.IsXmlEmptyElement]
															XmlTag("Properties") STag;
															Switch
															{
																Case !Local.Properties_IsEmpty:
																	Struct
																	{
																		While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Reg") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
																		{
																			//
																			// Embedded ComplexType 
																			//
																			Struct Reg = this.STag.ToString
																			{
																				[Post.Local.Reg_IsEmpty = Property.IsXmlEmptyElement]
																				XmlTag("Reg") STag;
																				Switch
																				{
																					Case !Local.Reg_IsEmpty:
																						Struct
																						{
																							While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
																							{
																								While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "SubProp") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
																								{
																									//
																									// Embedded ComplexType 
																									//
																									Struct SubProp = this.STag.ToString
																									{
																										[Post.Local.SubProp_IsEmpty = Property.IsXmlEmptyElement]
																										XmlTag("SubProp") STag;
																										Switch
																										{
																											Case !Local.SubProp_IsEmpty:
																												Struct
																												{
																													XmlTag("SubProp") ETag;
																												}
																										}
																									}
																									
																								}
																							}
																							XmlTag("Reg") ETag;
																						}
																				}
																			}
																			
																		}
																		XmlTag("Properties") ETag;
																	}
															}
														}
														
												}
												
											}
											XmlTag("Internet") ETag;
										}
								}
							}
							
						Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "IE7"):
							//
							// Embedded ComplexType 
							//
							Struct IE7 = this.STag.ToString
							{
								[Post.Local.IE7_IsEmpty = Property.IsXmlEmptyElement]
								XmlTag("IE7") STag;
								Switch
								{
									Case !Local.IE7_IsEmpty:
										Struct
										{
											While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
											{
												Switch
												{
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Filters"):
														GPPREFgppFiltersElement Filters;
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Properties"):
														//
														// Embedded ComplexType 
														//
														Struct Properties = this.STag.ToString
														{
															[Post.Local.Properties_IsEmpty = Property.IsXmlEmptyElement]
															XmlTag("Properties") STag;
															Switch
															{
																Case !Local.Properties_IsEmpty:
																	Struct
																	{
																		While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Reg") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
																		{
																			//
																			// Embedded ComplexType 
																			//
																			Struct Reg = this.STag.ToString
																			{
																				[Post.Local.Reg_IsEmpty = Property.IsXmlEmptyElement]
																				XmlTag("Reg") STag;
																				Switch
																				{
																					Case !Local.Reg_IsEmpty:
																						Struct
																						{
																							While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
																							{
																								While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "SubProp") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
																								{
																									//
																									// Embedded ComplexType 
																									//
																									Struct SubProp = this.STag.ToString
																									{
																										[Post.Local.SubProp_IsEmpty = Property.IsXmlEmptyElement]
																										XmlTag("SubProp") STag;
																										Switch
																										{
																											Case !Local.SubProp_IsEmpty:
																												Struct
																												{
																													XmlTag("SubProp") ETag;
																												}
																										}
																									}
																									
																								}
																							}
																							XmlTag("Reg") ETag;
																						}
																				}
																			}
																			
																		}
																		XmlTag("Properties") ETag;
																	}
															}
														}
														
												}
												
											}
											XmlTag("IE7") ETag;
										}
								}
							}
							
						Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "IE8"):
							//
							// Embedded ComplexType 
							//
							Struct IE8 = this.STag.ToString
							{
								[Post.Local.IE8_IsEmpty = Property.IsXmlEmptyElement]
								XmlTag("IE8") STag;
								Switch
								{
									Case !Local.IE8_IsEmpty:
										Struct
										{
											While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
											{
												Switch
												{
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Filters"):
														GPPREFgppFiltersElement Filters;
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Properties"):
														//
														// Embedded ComplexType 
														//
														Struct Properties = this.STag.ToString
														{
															[Post.Local.Properties_IsEmpty = Property.IsXmlEmptyElement]
															XmlTag("Properties") STag;
															Switch
															{
																Case !Local.Properties_IsEmpty:
																	Struct
																	{
																		While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Reg") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
																		{
																			//
																			// Embedded ComplexType 
																			//
																			Struct Reg = this.STag.ToString
																			{
																				[Post.Local.Reg_IsEmpty = Property.IsXmlEmptyElement]
																				XmlTag("Reg") STag;
																				Switch
																				{
																					Case !Local.Reg_IsEmpty:
																						Struct
																						{
																							While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
																							{
																								While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "SubProp") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
																								{
																									//
																									// Embedded ComplexType 
																									//
																									Struct SubProp = this.STag.ToString
																									{
																										[Post.Local.SubProp_IsEmpty = Property.IsXmlEmptyElement]
																										XmlTag("SubProp") STag;
																										Switch
																										{
																											Case !Local.SubProp_IsEmpty:
																												Struct
																												{
																													XmlTag("SubProp") ETag;
																												}
																										}
																									}
																									
																								}
																							}
																							XmlTag("Reg") ETag;
																						}
																				}
																			}
																			
																		}
																		XmlTag("Properties") ETag;
																	}
															}
														}
														
												}
												
											}
											XmlTag("IE8") ETag;
										}
								}
							}
							
					}
					
				}
				XmlTag("InternetSettings") ETag;
			}
	}
}

//
// Element Groups
// Embedded ComplexType 
//
Struct GPPREFgppGroupsElement = this.STag.ToString
{
	[Post.Local.GPPREFgppGroupsElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Groups") STag;
	Switch
	{
		Case !Local.GPPREFgppGroupsElement_IsEmpty:
			Struct
			{
				While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
				{
					Switch
					{
						Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "User"):
							//
							// Embedded ComplexType 
							//
							Struct User = this.STag.ToString
							{
								[Post.Local.User_IsEmpty = Property.IsXmlEmptyElement]
								XmlTag("User") STag;
								Switch
								{
									Case !Local.User_IsEmpty:
										Struct
										{
											While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
											{
												Switch
												{
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Filters"):
														GPPREFgppFiltersElement Filters;
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Properties"):
														//
														// Embedded ComplexType 
														//
														Struct Properties = this.STag.ToString
														{
															[Post.Local.Properties_IsEmpty = Property.IsXmlEmptyElement]
															XmlTag("Properties") STag;
															Switch
															{
																Case !Local.Properties_IsEmpty:
																	Struct
																	{
																		XmlTag("Properties") ETag;
																	}
															}
														}
														
												}
												
											}
											XmlTag("User") ETag;
										}
								}
							}
							
						Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Group"):
							//
							// Embedded ComplexType 
							//
							Struct Group = this.STag.ToString
							{
								[Post.Local.Group_IsEmpty = Property.IsXmlEmptyElement]
								XmlTag("Group") STag;
								Switch
								{
									Case !Local.Group_IsEmpty:
										Struct
										{
											While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
											{
												Switch
												{
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Filters"):
														GPPREFgppFiltersElement Filters;
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Properties"):
														//
														// Embedded ComplexType 
														//
														Struct Properties = this.STag.ToString
														{
															[Post.Local.Properties_IsEmpty = Property.IsXmlEmptyElement]
															XmlTag("Properties") STag;
															Switch
															{
																Case !Local.Properties_IsEmpty:
																	Struct
																	{
																		Switch
																		{
																			Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Members") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
																				//
																				// Embedded ComplexType 
																				//
																				Struct Members = this.STag.ToString
																				{
																					[Post.Local.Members_IsEmpty = Property.IsXmlEmptyElement]
																					XmlTag("Members") STag;
																					Switch
																					{
																						Case !Local.Members_IsEmpty:
																							Struct
																							{
																								While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Member") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
																								{
																									//
																									// Embedded ComplexType 
																									//
																									Struct Member = this.STag.ToString
																									{
																										[Post.Local.Member_IsEmpty = Property.IsXmlEmptyElement]
																										XmlTag("Member") STag;
																										Switch
																										{
																											Case !Local.Member_IsEmpty:
																												Struct
																												{
																													XmlTag("Member") ETag;
																												}
																										}
																									}
																									
																								}
																								XmlTag("Members") ETag;
																							}
																					}
																				}
																				
																		}
																		
																		XmlTag("Properties") ETag;
																	}
															}
														}
														
												}
												
											}
											XmlTag("Group") ETag;
										}
								}
							}
							
					}
					
				}
				XmlTag("Groups") ETag;
			}
	}
}

//
// Element NetworkOptions
// Embedded ComplexType 
//
Struct GPPREFgppNetworkOptionsElement = this.STag.ToString
{
	[Post.Local.GPPREFgppNetworkOptionsElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("NetworkOptions") STag;
	Switch
	{
		Case !Local.GPPREFgppNetworkOptionsElement_IsEmpty:
			Struct
			{
				While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
				{
					Switch
					{
						Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "VPN"):
							//
							// Embedded ComplexType 
							//
							Struct VPN = this.STag.ToString
							{
								[Post.Local.VPN_IsEmpty = Property.IsXmlEmptyElement]
								XmlTag("VPN") STag;
								Switch
								{
									Case !Local.VPN_IsEmpty:
										Struct
										{
											While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
											{
												Switch
												{
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Filters"):
														GPPREFgppFiltersElement Filters;
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Properties"):
														//
														// Embedded ComplexType 
														//
														Struct Properties = this.STag.ToString
														{
															[Post.Local.Properties_IsEmpty = Property.IsXmlEmptyElement]
															XmlTag("Properties") STag;
															Switch
															{
																Case !Local.Properties_IsEmpty:
																	Struct
																	{
																		XmlTag("Properties") ETag;
																	}
															}
														}
														
												}
												
											}
											XmlTag("VPN") ETag;
										}
								}
							}
							
						Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "DUN"):
							//
							// Embedded ComplexType 
							//
							Struct DUN = this.STag.ToString
							{
								[Post.Local.DUN_IsEmpty = Property.IsXmlEmptyElement]
								XmlTag("DUN") STag;
								Switch
								{
									Case !Local.DUN_IsEmpty:
										Struct
										{
											While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
											{
												Switch
												{
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Filters"):
														GPPREFgppFiltersElement Filters;
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Properties"):
														//
														// Embedded ComplexType 
														//
														Struct Properties = this.STag.ToString
														{
															[Post.Local.Properties_IsEmpty = Property.IsXmlEmptyElement]
															XmlTag("Properties") STag;
															Switch
															{
																Case !Local.Properties_IsEmpty:
																	Struct
																	{
																		XmlTag("Properties") ETag;
																	}
															}
														}
														
												}
												
											}
											XmlTag("DUN") ETag;
										}
								}
							}
							
					}
					
				}
				XmlTag("NetworkOptions") ETag;
			}
	}
}

//
// Element NetworkShareSettings
// Embedded ComplexType 
//
Struct GPPREFgppNetworkShareSettingsElement = this.STag.ToString
{
	[Post.Local.GPPREFgppNetworkShareSettingsElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("NetworkShareSettings") STag;
	Switch
	{
		Case !Local.GPPREFgppNetworkShareSettingsElement_IsEmpty:
			Struct
			{
				While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "NetShare") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
				{
					//
					// Embedded ComplexType 
					//
					Struct NetShare = this.STag.ToString
					{
						[Post.Local.NetShare_IsEmpty = Property.IsXmlEmptyElement]
						XmlTag("NetShare") STag;
						Switch
						{
							Case !Local.NetShare_IsEmpty:
								Struct
								{
									While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
									{
										Switch
										{
											Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Filters"):
												GPPREFgppFiltersElement Filters;
											Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Properties"):
												//
												// Embedded ComplexType 
												//
												Struct Properties = this.STag.ToString
												{
													[Post.Local.Properties_IsEmpty = Property.IsXmlEmptyElement]
													XmlTag("Properties") STag;
													Switch
													{
														Case !Local.Properties_IsEmpty:
															Struct
															{
																XmlTag("Properties") ETag;
															}
													}
												}
												
										}
										
									}
									XmlTag("NetShare") ETag;
								}
						}
					}
					
				}
				XmlTag("NetworkShareSettings") ETag;
			}
	}
}

//
// Element PowerOptions
// Embedded ComplexType 
//
Struct GPPREFgppPowerOptionsElement = this.STag.ToString
{
	[Post.Local.GPPREFgppPowerOptionsElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("PowerOptions") STag;
	Switch
	{
		Case !Local.GPPREFgppPowerOptionsElement_IsEmpty:
			Struct
			{
				While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
				{
					Switch
					{
						Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GlobalPowerOptions"):
							//
							// Embedded ComplexType 
							//
							Struct GlobalPowerOptions = this.STag.ToString
							{
								[Post.Local.GlobalPowerOptions_IsEmpty = Property.IsXmlEmptyElement]
								XmlTag("GlobalPowerOptions") STag;
								Switch
								{
									Case !Local.GlobalPowerOptions_IsEmpty:
										Struct
										{
											While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
											{
												Switch
												{
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Filters"):
														GPPREFgppFiltersElement Filters;
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Properties"):
														//
														// Embedded ComplexType 
														//
														Struct Properties = this.STag.ToString
														{
															[Post.Local.Properties_IsEmpty = Property.IsXmlEmptyElement]
															XmlTag("Properties") STag;
															Switch
															{
																Case !Local.Properties_IsEmpty:
																	Struct
																	{
																		XmlTag("Properties") ETag;
																	}
															}
														}
														
												}
												
											}
											XmlTag("GlobalPowerOptions") ETag;
										}
								}
							}
							
						Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "PowerScheme"):
							//
							// Embedded ComplexType 
							//
							Struct PowerScheme = this.STag.ToString
							{
								[Post.Local.PowerScheme_IsEmpty = Property.IsXmlEmptyElement]
								XmlTag("PowerScheme") STag;
								Switch
								{
									Case !Local.PowerScheme_IsEmpty:
										Struct
										{
											While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
											{
												Switch
												{
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Filters"):
														GPPREFgppFiltersElement Filters;
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Properties"):
														//
														// Embedded ComplexType 
														//
														Struct Properties = this.STag.ToString
														{
															[Post.Local.Properties_IsEmpty = Property.IsXmlEmptyElement]
															XmlTag("Properties") STag;
															Switch
															{
																Case !Local.Properties_IsEmpty:
																	Struct
																	{
																		XmlTag("Properties") ETag;
																	}
															}
														}
														
												}
												
											}
											XmlTag("PowerScheme") ETag;
										}
								}
							}
							
						Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GlobalPowerOptionsV2"):
							//
							// Embedded ComplexType 
							//
							Struct GlobalPowerOptionsV2 = this.STag.ToString
							{
								[Post.Local.GlobalPowerOptionsV2_IsEmpty = Property.IsXmlEmptyElement]
								XmlTag("GlobalPowerOptionsV2") STag;
								Switch
								{
									Case !Local.GlobalPowerOptionsV2_IsEmpty:
										Struct
										{
											While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
											{
												Switch
												{
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Filters"):
														GPPREFgppFiltersElement Filters;
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Properties"):
														//
														// Embedded ComplexType 
														//
														Struct Properties = this.STag.ToString
														{
															[Post.Local.Properties_IsEmpty = Property.IsXmlEmptyElement]
															XmlTag("Properties") STag;
															Switch
															{
																Case !Local.Properties_IsEmpty:
																	Struct
																	{
																		XmlTag("Properties") ETag;
																	}
															}
														}
														
												}
												
											}
											XmlTag("GlobalPowerOptionsV2") ETag;
										}
								}
							}
							
					}
					
				}
				XmlTag("PowerOptions") ETag;
			}
	}
}

//
// Element Printers
// Embedded ComplexType 
//
Struct GPPREFgppPrintersElement = this.STag.ToString
{
	[Post.Local.GPPREFgppPrintersElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Printers") STag;
	Switch
	{
		Case !Local.GPPREFgppPrintersElement_IsEmpty:
			Struct
			{
				While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
				{
					Switch
					{
						Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "SharedPrinter"):
							//
							// Embedded ComplexType 
							//
							Struct SharedPrinter = this.STag.ToString
							{
								[Post.Local.SharedPrinter_IsEmpty = Property.IsXmlEmptyElement]
								XmlTag("SharedPrinter") STag;
								Switch
								{
									Case !Local.SharedPrinter_IsEmpty:
										Struct
										{
											While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
											{
												Switch
												{
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Filters"):
														GPPREFgppFiltersElement Filters;
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Properties"):
														//
														// Embedded ComplexType 
														//
														Struct Properties = this.STag.ToString
														{
															[Post.Local.Properties_IsEmpty = Property.IsXmlEmptyElement]
															XmlTag("Properties") STag;
															Switch
															{
																Case !Local.Properties_IsEmpty:
																	Struct
																	{
																		XmlTag("Properties") ETag;
																	}
															}
														}
														
												}
												
											}
											XmlTag("SharedPrinter") ETag;
										}
								}
							}
							
						Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "PortPrinter"):
							//
							// Embedded ComplexType 
							//
							Struct PortPrinter = this.STag.ToString
							{
								[Post.Local.PortPrinter_IsEmpty = Property.IsXmlEmptyElement]
								XmlTag("PortPrinter") STag;
								Switch
								{
									Case !Local.PortPrinter_IsEmpty:
										Struct
										{
											While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
											{
												Switch
												{
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Filters"):
														GPPREFgppFiltersElement Filters;
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Properties"):
														//
														// Embedded ComplexType 
														//
														Struct Properties = this.STag.ToString
														{
															[Post.Local.Properties_IsEmpty = Property.IsXmlEmptyElement]
															XmlTag("Properties") STag;
															Switch
															{
																Case !Local.Properties_IsEmpty:
																	Struct
																	{
																		XmlTag("Properties") ETag;
																	}
															}
														}
														
												}
												
											}
											XmlTag("PortPrinter") ETag;
										}
								}
							}
							
						Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "LocalPrinter"):
							//
							// Embedded ComplexType 
							//
							Struct LocalPrinter = this.STag.ToString
							{
								[Post.Local.LocalPrinter_IsEmpty = Property.IsXmlEmptyElement]
								XmlTag("LocalPrinter") STag;
								Switch
								{
									Case !Local.LocalPrinter_IsEmpty:
										Struct
										{
											While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
											{
												Switch
												{
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Filters"):
														GPPREFgppFiltersElement Filters;
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Properties"):
														//
														// Embedded ComplexType 
														//
														Struct Properties = this.STag.ToString
														{
															[Post.Local.Properties_IsEmpty = Property.IsXmlEmptyElement]
															XmlTag("Properties") STag;
															Switch
															{
																Case !Local.Properties_IsEmpty:
																	Struct
																	{
																		XmlTag("Properties") ETag;
																	}
															}
														}
														
												}
												
											}
											XmlTag("LocalPrinter") ETag;
										}
								}
							}
							
					}
					
				}
				XmlTag("Printers") ETag;
			}
	}
}

//
// Element Regional
// Embedded ComplexType 
//
Struct GPPREFgppRegionalElement = this.STag.ToString
{
	[Post.Local.GPPREFgppRegionalElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Regional") STag;
	Switch
	{
		Case !Local.GPPREFgppRegionalElement_IsEmpty:
			Struct
			{
				While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RegionalOptions") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
				{
					//
					// Embedded ComplexType 
					//
					Struct RegionalOptions = this.STag.ToString
					{
						[Post.Local.RegionalOptions_IsEmpty = Property.IsXmlEmptyElement]
						XmlTag("RegionalOptions") STag;
						Switch
						{
							Case !Local.RegionalOptions_IsEmpty:
								Struct
								{
									While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
									{
										Switch
										{
											Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Filters"):
												GPPREFgppFiltersElement Filters;
											Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Properties"):
												//
												// Embedded ComplexType 
												//
												Struct Properties = this.STag.ToString
												{
													[Post.Local.Properties_IsEmpty = Property.IsXmlEmptyElement]
													XmlTag("Properties") STag;
													Switch
													{
														Case !Local.Properties_IsEmpty:
															Struct
															{
																XmlTag("Properties") ETag;
															}
													}
												}
												
										}
										
									}
									XmlTag("RegionalOptions") ETag;
								}
						}
					}
					
				}
				XmlTag("Regional") ETag;
			}
	}
}

//
// ComplexType gRegistryGroup
//
Struct GPPREFgppGRegistryGroup
{
	Switch
	{
		Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Registry"):
			//
			// Embedded ComplexType 
			//
			Struct Registry = this.STag.ToString
			{
				[Post.Local.Registry_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Registry") STag;
				Switch
				{
					Case !Local.Registry_IsEmpty:
						Struct
						{
							While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
							{
								Switch
								{
									Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Filters"):
										GPPREFgppFiltersElement Filters;
									Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Properties"):
										//
										// Embedded ComplexType 
										//
										Struct Properties = this.STag.ToString
										{
											[Post.Local.Properties_IsEmpty = Property.IsXmlEmptyElement]
											XmlTag("Properties") STag;
											Switch
											{
												Case !Local.Properties_IsEmpty:
													Struct
													{
														Switch
														{
															Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Values") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
																//
																// Embedded ComplexType 
																//
																Struct Values = this.STag.ToString
																{
																	[Post.Local.Values_IsEmpty = Property.IsXmlEmptyElement]
																	XmlTag("Values") STag;
																	Switch
																	{
																		Case !Local.Values_IsEmpty:
																			Struct
																			{
																				XmlTag("Values") ETag;
																			}
																	}
																}
																
														}
														
														XmlTag("Properties") ETag;
													}
											}
										}
										
								}
								
							}
							XmlTag("Registry") ETag;
						}
				}
			}
			
		Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Collection"):
			//
			// Embedded ComplexType 
			//
			Struct Collection = this.STag.ToString
			{
				[Post.Local.Collection_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Collection") STag;
				Switch
				{
					Case !Local.Collection_IsEmpty:
						Struct
						{
							While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
							{
								GPPREFgppGRegistryGroup GRegistryGroup;					
							}
							XmlTag("Collection") ETag;
						}
				}
			}
			
		Default:
			ReportParserError("ParserErrorProtocolClassWindows", "GPPREF", "There is no such choice") ChoiceError;
	}
	
}

//
// Element RegistrySettings
// Embedded ComplexType 
//
Struct GPPREFgppRegistrySettingsElement = this.STag.ToString
{
	[Post.Local.GPPREFgppRegistrySettingsElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("RegistrySettings") STag;
	Switch
	{
		Case !Local.GPPREFgppRegistrySettingsElement_IsEmpty:
			Struct
			{
				While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
				{
					GPPREFgppGRegistryGroup GRegistryGroup;					
				}
				XmlTag("RegistrySettings") ETag;
			}
	}
}

//
// Element ScheduledTasks
// Embedded ComplexType 
//
Struct GPPREFgppScheduledTasksElement = this.STag.ToString
{
	[Post.Local.GPPREFgppScheduledTasksElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("ScheduledTasks") STag;
	Switch
	{
		Case !Local.GPPREFgppScheduledTasksElement_IsEmpty:
			Struct
			{
				While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
				{
					Switch
					{
						Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ImmediateTaskV2"):
							//
							// Embedded ComplexType 
							//
							struct ImmediateTaskV2 = this.STag.ToString
							{
								[Post.Local.ImmediateTaskV2_IsEmpty = Property.IsXmlEmptyElement]
								XmlTag("ImmediateTaskV2") STag;
								switch
								{
									Case !Local.ImmediateTaskV2_IsEmpty:
										struct
										{
											While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
											{
												Switch
												{
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Filters"):
														GPPREFgppFiltersElement Filters;
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Properties"):
														//
														// Embedded ComplexType 
														//
														struct Properties = this.STag.ToString
														{
															[Post.Local.Properties_IsEmpty = Property.IsXmlEmptyElement]
															XmlTag("Properties") STag;
															switch
															{
																Case !Local.Properties_IsEmpty:
																	struct
																	{
																		GPPREFgppTaskType Task;
																		XmlTag("Properties") ETag;
																	}
															}
														}
														
												}
												
											}
											XmlTag("ImmediateTaskV2") ETag;
										}
								}
							}
						
						Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "TaskV2"):
							//
							// Embedded ComplexType 
							//
							Struct TaskV2 = this.STag.ToString
							{
								[Post.Local.TaskV2_IsEmpty = Property.IsXmlEmptyElement]
								XmlTag("TaskV2") STag;
								Switch
								{
									Case !Local.TaskV2_IsEmpty:
										Struct
										{
											While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
											{
												Switch
												{
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Filters"):
														GPPREFgppFiltersElement Filters;
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Properties"):
														//
														// Embedded ComplexType 
														//
														Struct Properties = this.STag.ToString
														{
															[Post.Local.Properties_IsEmpty = Property.IsXmlEmptyElement]
															XmlTag("Properties") STag;
															Switch
															{
																Case !Local.Properties_IsEmpty:
																	Struct
																	{
																		GPPREFgppTaskType Task;
																		XmlTag("Properties") ETag;
																	}
															}
														}
														
												}
												
											}
											XmlTag("TaskV2") ETag;
										}
								}
							}
							
						Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ImmediateTask"):
							//
							// Embedded ComplexType 
							//
							Struct ImmediateTask = this.STag.ToString
							{
								[Post.Local.ImmediateTask_IsEmpty = Property.IsXmlEmptyElement]
								XmlTag("ImmediateTask") STag;
								Switch
								{
									Case !Local.ImmediateTask_IsEmpty:
										Struct
										{
											While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
											{
												Switch
												{
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Filters"):
														GPPREFgppFiltersElement Filters;
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Properties"):
														//
														// Embedded ComplexType 
														//
														Struct Properties = this.STag.ToString
														{
															[Post.Local.Properties_IsEmpty = Property.IsXmlEmptyElement]
															XmlTag("Properties") STag;
															Switch
															{
																Case !Local.Properties_IsEmpty:
																	Struct
																	{
																		XmlTag("Properties") ETag;
																	}
															}
														}
														
												}
												
											}
											XmlTag("ImmediateTask") ETag;
										}
								}
							}
						
						Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Task"):
							GPPREFgppTaskType Task;
					}
				}
				XmlTag("ScheduledTasks") ETag;
			}
	}
}

//
// Element NTServices
// Embedded ComplexType 
//
Struct GPPREFgppNTServicesElement = this.STag.ToString
{
	[Post.Local.GPPREFgppNTServicesElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("NTServices") STag;
	Switch
	{
		Case !Local.GPPREFgppNTServicesElement_IsEmpty:
			Struct
			{
				While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "NTService") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
				{
					//
					// Embedded ComplexType 
					//
					Struct NTService = this.STag.ToString
					{
						[Post.Local.NTService_IsEmpty = Property.IsXmlEmptyElement]
						XmlTag("NTService") STag;
						Switch
						{
							Case !Local.NTService_IsEmpty:
								Struct
								{
									While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
									{
										Switch
										{
											Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Filters"):
												GPPREFgppFiltersElement Filters;
											Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Properties"):
												//
												// Embedded ComplexType 
												//
												Struct Properties = this.STag.ToString
												{
													[Post.Local.Properties_IsEmpty = Property.IsXmlEmptyElement]
													XmlTag("Properties") STag;
													Switch
													{
														Case !Local.Properties_IsEmpty:
															Struct
															{
																XmlTag("Properties") ETag;
															}
													}
												}
												
										}
										
									}
									XmlTag("NTService") ETag;
								}
						}
					}
					
				}
				XmlTag("NTServices") ETag;
			}
	}
}

//
// Element Shortcuts
// Embedded ComplexType 
//
Struct GPPREFgppShortcutsElement = this.STag.ToString
{
	[Post.Local.GPPREFgppShortcutsElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Shortcuts") STag;
	Switch
	{
		Case !Local.GPPREFgppShortcutsElement_IsEmpty:
			Struct
			{
				While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Shortcut") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
				{
					//
					// Embedded ComplexType 
					//
					Struct Shortcut = this.STag.ToString
					{
						[Post.Local.Shortcut_IsEmpty = Property.IsXmlEmptyElement]
						XmlTag("Shortcut") STag;
						Switch
						{
							Case !Local.Shortcut_IsEmpty:
								Struct
								{
									While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
									{
										Switch
										{
											Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Filters"):
												GPPREFgppFiltersElement Filters;
											Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Properties"):
												//
												// Embedded ComplexType 
												//
												Struct Properties = this.STag.ToString
												{
													[Post.Local.Properties_IsEmpty = Property.IsXmlEmptyElement]
													XmlTag("Properties") STag;
													Switch
													{
														Case !Local.Properties_IsEmpty:
															Struct
															{
																XmlTag("Properties") ETag;
															}
													}
												}
												
										}
										
									}
									XmlTag("Shortcut") ETag;
								}
						}
					}
					
				}
				XmlTag("Shortcuts") ETag;
			}
	}
}

//
// Element StartMenuTaskbar
// Embedded ComplexType 
//
Struct GPPREFgppStartMenuTaskbarElement = this.STag.ToString
{
	[Post.Local.GPPREFgppStartMenuTaskbarElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("StartMenuTaskbar") STag;
	Switch
	{
		Case !Local.GPPREFgppStartMenuTaskbarElement_IsEmpty:
			Struct
			{
				While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
				{
					Switch
					{
						Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "StartMenu"):
							//
							// Embedded ComplexType 
							//
							Struct StartMenu = this.STag.ToString
							{
								[Post.Local.StartMenu_IsEmpty = Property.IsXmlEmptyElement]
								XmlTag("StartMenu") STag;
								Switch
								{
									Case !Local.StartMenu_IsEmpty:
										Struct
										{
											While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
											{
												Switch
												{
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Filters"):
														GPPREFgppFiltersElement Filters;
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Properties"):
														//
														// Embedded ComplexType 
														//
														Struct Properties = this.STag.ToString
														{
															[Post.Local.Properties_IsEmpty = Property.IsXmlEmptyElement]
															XmlTag("Properties") STag;
															Switch
															{
																Case !Local.Properties_IsEmpty:
																	Struct
																	{
																		XmlTag("Properties") ETag;
																	}
															}
														}
														
												}
												
											}
											XmlTag("StartMenu") ETag;
										}
								}
							}
							
						Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "StartMenuVista"):
							//
							// Embedded ComplexType 
							//
							Struct StartMenuVista = this.STag.ToString
							{
								[Post.Local.StartMenuVista_IsEmpty = Property.IsXmlEmptyElement]
								XmlTag("StartMenuVista") STag;
								Switch
								{
									Case !Local.StartMenuVista_IsEmpty:
										Struct
										{
											While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
											{
												Switch
												{
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Filters"):
														GPPREFgppFiltersElement Filters;
													Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Properties"):
														//
														// Embedded ComplexType 
														//
														Struct Properties = this.STag.ToString
														{
															[Post.Local.Properties_IsEmpty = Property.IsXmlEmptyElement]
															XmlTag("Properties") STag;
															Switch
															{
																Case !Local.Properties_IsEmpty:
																	Struct
																	{
																		XmlTag("Properties") ETag;
																	}
															}
														}
														
												}
												
											}
											XmlTag("StartMenuVista") ETag;
										}
								}
							}
							
					}
					
				}
				XmlTag("StartMenuTaskbar") ETag;
			}
	}
}

//
// ComplexType gFilterTypes
//
Struct GPPREFgppGFilterTypes
{
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		Switch
		{
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FilterSite"):
				//
				// Embedded ComplexType 
				//
				Struct FilterSite = this.STag.ToString
				{
					[Post.Local.FilterSite_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("FilterSite") STag;
					Switch
					{
						Case !Local.FilterSite_IsEmpty:
							Struct
							{
								XmlTag("FilterSite") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FilterGroup"):
				//
				// Embedded ComplexType 
				//
				Struct FilterGroup = this.STag.ToString
				{
					[Post.Local.FilterGroup_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("FilterGroup") STag;
					Switch
					{
						Case !Local.FilterGroup_IsEmpty:
							Struct
							{
								XmlTag("FilterGroup") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FilterRunOnce"):
				//
				// Embedded ComplexType 
				//
				Struct FilterRunOnce = this.STag.ToString
				{
					[Post.Local.FilterRunOnce_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("FilterRunOnce") STag;
					Switch
					{
						Case !Local.FilterRunOnce_IsEmpty:
							Struct
							{
								XmlTag("FilterRunOnce") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FilterLdap"):
				//
				// Embedded ComplexType 
				//
				Struct FilterLdap = this.STag.ToString
				{
					[Post.Local.FilterLdap_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("FilterLdap") STag;
					Switch
					{
						Case !Local.FilterLdap_IsEmpty:
							Struct
							{
								XmlTag("FilterLdap") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FilterBattery"):
				//
				// Embedded ComplexType 
				//
				Struct FilterBattery = this.STag.ToString
				{
					[Post.Local.FilterBattery_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("FilterBattery") STag;
					Switch
					{
						Case !Local.FilterBattery_IsEmpty:
							Struct
							{
								XmlTag("FilterBattery") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FilterComputer"):
				//
				// Embedded ComplexType 
				//
				Struct FilterComputer = this.STag.ToString
				{
					[Post.Local.FilterComputer_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("FilterComputer") STag;
					Switch
					{
						Case !Local.FilterComputer_IsEmpty:
							Struct
							{
								XmlTag("FilterComputer") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FilterCpu"):
				//
				// Embedded ComplexType 
				//
				Struct FilterCpu = this.STag.ToString
				{
					[Post.Local.FilterCpu_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("FilterCpu") STag;
					Switch
					{
						Case !Local.FilterCpu_IsEmpty:
							Struct
							{
								XmlTag("FilterCpu") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FilterDate"):
				//
				// Embedded ComplexType 
				//
				Struct FilterDate = this.STag.ToString
				{
					[Post.Local.FilterDate_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("FilterDate") STag;
					Switch
					{
						Case !Local.FilterDate_IsEmpty:
							Struct
							{
								XmlTag("FilterDate") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FilterDun"):
				//
				// Embedded ComplexType 
				//
				Struct FilterDun = this.STag.ToString
				{
					[Post.Local.FilterDun_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("FilterDun") STag;
					Switch
					{
						Case !Local.FilterDun_IsEmpty:
							Struct
							{
								XmlTag("FilterDun") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FilterDisk"):
				//
				// Embedded ComplexType 
				//
				Struct FilterDisk = this.STag.ToString
				{
					[Post.Local.FilterDisk_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("FilterDisk") STag;
					Switch
					{
						Case !Local.FilterDisk_IsEmpty:
							Struct
							{
								XmlTag("FilterDisk") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FilterDomain"):
				//
				// Embedded ComplexType 
				//
				Struct FilterDomain = this.STag.ToString
				{
					[Post.Local.FilterDomain_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("FilterDomain") STag;
					Switch
					{
						Case !Local.FilterDomain_IsEmpty:
							Struct
							{
								XmlTag("FilterDomain") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FilterVariable"):
				//
				// Embedded ComplexType 
				//
				Struct FilterVariable = this.STag.ToString
				{
					[Post.Local.FilterVariable_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("FilterVariable") STag;
					Switch
					{
						Case !Local.FilterVariable_IsEmpty:
							Struct
							{
								XmlTag("FilterVariable") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FilterFile"):
				//
				// Embedded ComplexType 
				//
				Struct FilterFile = this.STag.ToString
				{
					[Post.Local.FilterFile_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("FilterFile") STag;
					Switch
					{
						Case !Local.FilterFile_IsEmpty:
							Struct
							{
								XmlTag("FilterFile") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FilterIpRange"):
				//
				// Embedded ComplexType 
				//
				Struct FilterIpRange = this.STag.ToString
				{
					[Post.Local.FilterIpRange_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("FilterIpRange") STag;
					Switch
					{
						Case !Local.FilterIpRange_IsEmpty:
							Struct
							{
								XmlTag("FilterIpRange") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FilterLanguage"):
				//
				// Embedded ComplexType 
				//
				Struct FilterLanguage = this.STag.ToString
				{
					[Post.Local.FilterLanguage_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("FilterLanguage") STag;
					Switch
					{
						Case !Local.FilterLanguage_IsEmpty:
							Struct
							{
								XmlTag("FilterLanguage") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FilterMacRange"):
				//
				// Embedded ComplexType 
				//
				Struct FilterMacRange = this.STag.ToString
				{
					[Post.Local.FilterMacRange_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("FilterMacRange") STag;
					Switch
					{
						Case !Local.FilterMacRange_IsEmpty:
							Struct
							{
								XmlTag("FilterMacRange") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FilterMsi"):
				//
				// Embedded ComplexType 
				//
				Struct FilterMsi = this.STag.ToString
				{
					[Post.Local.FilterMsi_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("FilterMsi") STag;
					Switch
					{
						Case !Local.FilterMsi_IsEmpty:
							Struct
							{
								XmlTag("FilterMsi") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FilterOs"):
				//
				// Embedded ComplexType 
				//
				Struct FilterOs = this.STag.ToString
				{
					[Post.Local.FilterOs_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("FilterOs") STag;
					Switch
					{
						Case !Local.FilterOs_IsEmpty:
							Struct
							{
								XmlTag("FilterOs") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FilterOrgUnit"):
				//
				// Embedded ComplexType 
				//
				Struct FilterOrgUnit = this.STag.ToString
				{
					[Post.Local.FilterOrgUnit_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("FilterOrgUnit") STag;
					Switch
					{
						Case !Local.FilterOrgUnit_IsEmpty:
							Struct
							{
								XmlTag("FilterOrgUnit") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FilterPcmcia"):
				//
				// Embedded ComplexType 
				//
				Struct FilterPcmcia = this.STag.ToString
				{
					[Post.Local.FilterPcmcia_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("FilterPcmcia") STag;
					Switch
					{
						Case !Local.FilterPcmcia_IsEmpty:
							Struct
							{
								XmlTag("FilterPcmcia") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FilterPortable"):
				//
				// Embedded ComplexType 
				//
				Struct FilterPortable = this.STag.ToString
				{
					[Post.Local.FilterPortable_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("FilterPortable") STag;
					Switch
					{
						Case !Local.FilterPortable_IsEmpty:
							Struct
							{
								XmlTag("FilterPortable") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FilterProcMode"):
				//
				// Embedded ComplexType 
				//
				Struct FilterProcMode = this.STag.ToString
				{
					[Post.Local.FilterProcMode_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("FilterProcMode") STag;
					Switch
					{
						Case !Local.FilterProcMode_IsEmpty:
							Struct
							{
								XmlTag("FilterProcMode") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FilterRam"):
				//
				// Embedded ComplexType 
				//
				Struct FilterRam = this.STag.ToString
				{
					[Post.Local.FilterRam_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("FilterRam") STag;
					Switch
					{
						Case !Local.FilterRam_IsEmpty:
							Struct
							{
								XmlTag("FilterRam") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FilterRegistry"):
				//
				// Embedded ComplexType 
				//
				Struct FilterRegistry = this.STag.ToString
				{
					[Post.Local.FilterRegistry_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("FilterRegistry") STag;
					Switch
					{
						Case !Local.FilterRegistry_IsEmpty:
							Struct
							{
								XmlTag("FilterRegistry") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FilterTerminal"):
				//
				// Embedded ComplexType 
				//
				Struct FilterTerminal = this.STag.ToString
				{
					[Post.Local.FilterTerminal_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("FilterTerminal") STag;
					Switch
					{
						Case !Local.FilterTerminal_IsEmpty:
							Struct
							{
								XmlTag("FilterTerminal") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FilterTime"):
				//
				// Embedded ComplexType 
				//
				Struct FilterTime = this.STag.ToString
				{
					[Post.Local.FilterTime_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("FilterTime") STag;
					Switch
					{
						Case !Local.FilterTime_IsEmpty:
							Struct
							{
								XmlTag("FilterTime") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FilterUser"):
				//
				// Embedded ComplexType 
				//
				Struct FilterUser = this.STag.ToString
				{
					[Post.Local.FilterUser_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("FilterUser") STag;
					Switch
					{
						Case !Local.FilterUser_IsEmpty:
							Struct
							{
								XmlTag("FilterUser") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FilterWmi"):
				//
				// Embedded ComplexType 
				//
				Struct FilterWmi = this.STag.ToString
				{
					[Post.Local.FilterWmi_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("FilterWmi") STag;
					Switch
					{
						Case !Local.FilterWmi_IsEmpty:
							Struct
							{
								XmlTag("FilterWmi") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FilterCollection"):
				//
				// Embedded ComplexType 
				//
				Struct FilterCollection = this.STag.ToString
				{
					[Post.Local.FilterCollection_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("FilterCollection") STag;
					Switch
					{
						Case !Local.FilterCollection_IsEmpty:
							Struct
							{
								GPPREFgppGFilterTypes GFilterTypes;
								XmlTag("FilterCollection") ETag;
							}
					}
				}
				
		}
		
	}
}

//
// ComplexType gFilters
//
Struct GPPREFgppGFilters
{
	GPPREFgppGFilterTypes GFilterTypes;
}

//
// Element Filters
// Embedded ComplexType 
//
Struct GPPREFgppFiltersElement = this.STag.ToString
{
	[Post.Local.GPPREFgppFiltersElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Filters") STag;
	Switch
	{
		Case !Local.GPPREFgppFiltersElement_IsEmpty:
			Struct
			{
				GPPREFgppGFilters GFilters;
				XmlTag("Filters") ETag;
			}
	}
}

//
// ComplexType taskType
//
Struct GPPREFgppTaskType
{
	[Post.Local.Task_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Task") STag;
	Switch
	{
		Case !Local.Task_IsEmpty:
			Struct
			{
				While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
				{
					Switch
					{
						Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RegistrationInfo"):
							struct RegistrationInfo = this.STag.ToString
							{
								[Post.Local.RegistrationInfo_IsEmpty = Property.IsXmlEmptyElement]
								XmlTag("RegistrationInfo") STag;
								switch
								{
									Case !Local.RegistrationInfo_IsEmpty:
										struct
										{
											GPPREFgppRegistrationInfoType RegistrationInfo;
											XmlTag("RegistrationInfo") ETag;
										}
								}
							}
							
						Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Triggers"):
							struct Triggers = this.STag.ToString
							{
								[Post.Local.Triggers_IsEmpty = Property.IsXmlEmptyElement]
								XmlTag("Triggers") STag;
								switch
								{
									Case !Local.Triggers_IsEmpty:
										struct
										{
											GPPREFgppTriggerGroup Triggers;
											XmlTag("Triggers") ETag;
										}
								}
							}
							
						Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Settings"):
							struct Settings = this.STag.ToString
							{
								[Post.Local.Settings_IsEmpty = Property.IsXmlEmptyElement]
								XmlTag("Settings") STag;
								switch
								{
									Case !Local.Settings_IsEmpty:
										struct
										{
											GPPREFgppSettingsType Settings;
											XmlTag("Settings") ETag;
										}
								}
							}
							
						Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Data"):
							struct Data = this.STag.ToString
							{
								[Post.Local.Data_IsEmpty = Property.IsXmlEmptyElement]
								XmlTag("Data") STag;
								switch
								{
									Case !Local.Data_IsEmpty:
										struct
										{
											GPPREFgppDataType Data;
											XmlTag("Data") ETag;
										}
								}
							}
							
						Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Principals"):
							struct Principals = this.STag.ToString
							{
								[Post.Local.Principals_IsEmpty = Property.IsXmlEmptyElement]
								XmlTag("Principals") STag;
								switch
								{
									Case !Local.Principals_IsEmpty:
										struct
										{
											GPPREFgppPrincipalsType Principals;
											XmlTag("Principals") ETag;
										}
								}
							}
							
						Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Actions"):
							struct Actions = this.STag.ToString
							{
								[Post.Local.Actions_IsEmpty = Property.IsXmlEmptyElement]
								XmlTag("Actions") STag;
								switch
								{
									Case !Local.Actions_IsEmpty:
										struct
										{
											GPPREFgppActionsType Actions;
											XmlTag("Actions") ETag;
										}
								}
							}
							
					}
					
				}
				XmlTag("Task") ETag;
			}
	}
}

//
// ComplexType registrationInfoType
//
Struct GPPREFgppRegistrationInfoType
{
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		Switch
		{
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "URI"):
				struct URI = this.URI
				{
					[Post.Local.URI_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("URI") STag;
					switch
					{
						Case !Local.URI_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) URI;
								XmlTag("URI") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "SecurityDescriptor"):
				struct SecurityDescriptor = this.SecurityDescriptor
				{
					[Post.Local.SecurityDescriptor_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("SecurityDescriptor") STag;
					switch
					{
						Case !Local.SecurityDescriptor_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) SecurityDescriptor;
								XmlTag("SecurityDescriptor") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Source"):
				struct Source = this.Source
				{
					[Post.Local.Source_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("Source") STag;
					switch
					{
						Case !Local.Source_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) Source;
								XmlTag("Source") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Date"):
				struct Date = this.Date
				{
					[Post.Local.Date_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("Date") STag;
					switch
					{
						Case !Local.Date_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) Date;
								XmlTag("Date") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Author"):
				struct Author = this.Author
				{
					[Post.Local.Author_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("Author") STag;
					switch
					{
						Case !Local.Author_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) Author;
								XmlTag("Author") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Version"):
				struct Version = this.Version
				{
					[Post.Local.Version_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("Version") STag;
					switch
					{
						Case !Local.Version_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) Version;
								XmlTag("Version") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Description"):
				struct Description = this.Description
				{
					[Post.Local.Description_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("Description") STag;
					switch
					{
						Case !Local.Description_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) Description;
								XmlTag("Description") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Documentation"):
				struct Documentation = this.Documentation
				{
					[Post.Local.Documentation_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("Documentation") STag;
					switch
					{
						Case !Local.Documentation_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) Documentation;
								XmlTag("Documentation") ETag;
							}
					}
				}
				
		}
		
	}
}

//
// ComplexType triggerGroup
//
Struct GPPREFgppTriggerGroup
{
	Switch
	{
		Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "BootTrigger"):
			struct BootTrigger = this.STag.ToString
			{
				[Post.Local.BootTrigger_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("BootTrigger") STag;
				switch
				{
					Case !Local.BootTrigger_IsEmpty:
						struct
						{
							GPPREFgppBootTriggerType BootTrigger;
							XmlTag("BootTrigger") ETag;
						}
				}
			}
			
		Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RegistrationTrigger"):
			struct RegistrationTrigger = this.STag.ToString
			{
				[Post.Local.RegistrationTrigger_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("RegistrationTrigger") STag;
				switch
				{
					Case !Local.RegistrationTrigger_IsEmpty:
						struct
						{
							GPPREFgppRegistrationTriggerType RegistrationTrigger;
							XmlTag("RegistrationTrigger") ETag;
						}
				}
			}
			
		Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "IdleTrigger"):
			struct IdleTrigger = this.STag.ToString
			{
				[Post.Local.IdleTrigger_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("IdleTrigger") STag;
				switch
				{
					Case !Local.IdleTrigger_IsEmpty:
						struct
						{
							GPPREFgppIdleTriggerType IdleTrigger;
							XmlTag("IdleTrigger") ETag;
						}
				}
			}
			
		Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "TimeTrigger"):
			struct TimeTrigger = this.STag.ToString
			{
				[Post.Local.TimeTrigger_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("TimeTrigger") STag;
				switch
				{
					Case !Local.TimeTrigger_IsEmpty:
						struct
						{
							GPPREFgppTimeTriggerType TimeTrigger;
							XmlTag("TimeTrigger") ETag;
						}
				}
			}
			
		Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EventTrigger"):
			struct EventTrigger = this.STag.ToString
			{
				[Post.Local.EventTrigger_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("EventTrigger") STag;
				switch
				{
					Case !Local.EventTrigger_IsEmpty:
						struct
						{
							GPPREFgppEventTriggerType EventTrigger;
							XmlTag("EventTrigger") ETag;
						}
				}
			}
			
		Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "LogonTrigger"):
			struct LogonTrigger = this.STag.ToString
			{
				[Post.Local.LogonTrigger_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("LogonTrigger") STag;
				switch
				{
					Case !Local.LogonTrigger_IsEmpty:
						struct
						{
							GPPREFgppLogonTriggerType LogonTrigger;
							XmlTag("LogonTrigger") ETag;
						}
				}
			}
			
		Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "SessionStateChangeTrigger"):
			struct SessionStateChangeTrigger = this.STag.ToString
			{
				[Post.Local.SessionStateChangeTrigger_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("SessionStateChangeTrigger") STag;
				switch
				{
					Case !Local.SessionStateChangeTrigger_IsEmpty:
						struct
						{
							GPPREFgppSessionStateChangeTriggerType SessionStateChangeTrigger;
							XmlTag("SessionStateChangeTrigger") ETag;
						}
				}
			}
			
		Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "CalendarTrigger"):
			struct CalendarTrigger = this.STag.ToString
			{
				[Post.Local.CalendarTrigger_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("CalendarTrigger") STag;
				switch
				{
					Case !Local.CalendarTrigger_IsEmpty:
						struct
						{
							GPPREFgppCalendarTriggerType CalendarTrigger;
							XmlTag("CalendarTrigger") ETag;
						}
				}
			}
			
	}
	
}

//
// ComplexType triggerBaseType
//
[Property.ChildType = Property.XmlElemAttrValues$["type"]]
Struct GPPREFgppTriggerBaseType
{
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Enabled") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Enabled = this.Enabled
			{
				[Post.Local.Enabled_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Enabled") STag;
				switch
				{
					Case !Local.Enabled_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) Enabled;
							XmlTag("Enabled") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "StartBoundary") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct StartBoundary = this.StartBoundary
			{
				[Post.Local.StartBoundary_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("StartBoundary") STag;
				switch
				{
					Case !Local.StartBoundary_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) StartBoundary;
							XmlTag("StartBoundary") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EndBoundary") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct EndBoundary = this.EndBoundary
			{
				[Post.Local.EndBoundary_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("EndBoundary") STag;
				switch
				{
					Case !Local.EndBoundary_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) EndBoundary;
							XmlTag("EndBoundary") ETag;
						}
				}
			}
			
	}
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Repetition") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Repetition = this.STag.ToString
			{
				[Post.Local.Repetition_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Repetition") STag;
				switch
				{
					Case !Local.Repetition_IsEmpty:
						struct
						{
							GPPREFgppRepetitionType Repetition;
							XmlTag("Repetition") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ExecutionTimeLimit") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct ExecutionTimeLimit = this.ExecutionTimeLimit
			{
				[Post.Local.ExecutionTimeLimit_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("ExecutionTimeLimit") STag;
				switch
				{
					Case !Local.ExecutionTimeLimit_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) ExecutionTimeLimit;
							XmlTag("ExecutionTimeLimit") ETag;
						}
				}
			}
			
	}
	
}

//
// ComplexType repetitionType
//
Struct GPPREFgppRepetitionType
{
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		Switch
		{
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Interval"):
				//
				// Embedded ComplexType 
				//
				struct Interval = this.STag.ToString
				{
					[Post.Local.Interval_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("Interval") STag;
					switch
					{
						Case !Local.Interval_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "</", true, false, false) Value;
								XmlTag("Interval") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Duration"):
				//
				// Embedded ComplexType 
				//
				struct Duration = this.STag.ToString
				{
					[Post.Local.Duration_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("Duration") STag;
					switch
					{
						Case !Local.Duration_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "</", true, false, false) Value;
								XmlTag("Duration") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "StopAtDurationEnd"):
				struct StopAtDurationEnd = this.StopAtDurationEnd
				{
					[Post.Local.StopAtDurationEnd_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("StopAtDurationEnd") STag;
					switch
					{
						Case !Local.StopAtDurationEnd_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) StopAtDurationEnd;
								XmlTag("StopAtDurationEnd") ETag;
							}
					}
				}
				
		}
		
	}
}

//
// ComplexType bootTriggerType
//
Struct GPPREFgppBootTriggerType
{
	GPPREFgppTriggerBaseType TriggerBase;
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Delay") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Delay = this.Delay
			{
				[Post.Local.Delay_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Delay") STag;
				switch
				{
					Case !Local.Delay_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) Delay;
							XmlTag("Delay") ETag;
						}
				}
			}
			
	}
	
}

//
// ComplexType registrationTriggerType
//
Struct GPPREFgppRegistrationTriggerType
{
	GPPREFgppTriggerBaseType TriggerBase;
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Delay") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Delay = this.Delay
			{
				[Post.Local.Delay_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Delay") STag;
				switch
				{
					Case !Local.Delay_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) Delay;
							XmlTag("Delay") ETag;
						}
				}
			}
			
	}
	
}

//
// ComplexType idleTriggerType
//
Struct GPPREFgppIdleTriggerType
{
	GPPREFgppTriggerBaseType TriggerBase;
}

//
// ComplexType timeTriggerType
//
Struct GPPREFgppTimeTriggerType
{
	GPPREFgppTriggerBaseType TriggerBase;
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RandomDelay") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct RandomDelay = this.RandomDelay
			{
				[Post.Local.RandomDelay_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("RandomDelay") STag;
				switch
				{
					Case !Local.RandomDelay_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) RandomDelay;
							XmlTag("RandomDelay") ETag;
						}
				}
			}
			
	}
	
}

//
// ComplexType namedValues
//
Struct GPPREFgppNamedValues
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Value") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct Value = this.STag.ToString
		{
			[Post.Local.Value_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("Value") STag;
			switch
			{
				Case !Local.Value_IsEmpty:
					struct
					{
						GPPREFgppNamedValue Value;
						XmlTag("Value") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType namedValue
//
Struct GPPREFgppNamedValue
{
	StringTerm(Property.XMLEncoding, "<", true, false, false) BaseType;
}

//
// ComplexType eventTriggerType
//
Struct GPPREFgppEventTriggerType
{
	GPPREFgppTriggerBaseType TriggerBase;
	struct Subscription = this.STag.ToString
	{
		[Post.Local.Subscription_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("Subscription") STag;
		switch
		{
			Case !Local.Subscription_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) Subscription;
					XmlTag("Subscription") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Delay") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Delay = this.Delay
			{
				[Post.Local.Delay_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Delay") STag;
				switch
				{
					Case !Local.Delay_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) Delay;
							XmlTag("Delay") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "PeriodOfOccurrence") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct PeriodOfOccurrence = this.PeriodOfOccurrence
			{
				[Post.Local.PeriodOfOccurrence_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("PeriodOfOccurrence") STag;
				switch
				{
					Case !Local.PeriodOfOccurrence_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) PeriodOfOccurrence;
							XmlTag("PeriodOfOccurrence") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "NumberOfOccurrences") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			//
			// Embedded ComplexType 
			//
			struct NumberOfOccurrences = this.STag.ToString
			{
				[Post.Local.NumberOfOccurrences_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("NumberOfOccurrences") STag;
				switch
				{
					Case !Local.NumberOfOccurrences_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "</", true, false, false) Value;
							XmlTag("NumberOfOccurrences") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "MatchingElement") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct MatchingElement = this.STag.ToString
			{
				[Post.Local.MatchingElement_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("MatchingElement") STag;
				switch
				{
					Case !Local.MatchingElement_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) MatchingElement;
							XmlTag("MatchingElement") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ValueQueries") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct ValueQueries = this.STag.ToString
			{
				[Post.Local.ValueQueries_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("ValueQueries") STag;
				switch
				{
					Case !Local.ValueQueries_IsEmpty:
						struct
						{
							GPPREFgppNamedValues ValueQueries;
							XmlTag("ValueQueries") ETag;
						}
				}
			}
			
	}
	
}

//
// ComplexType logonTriggerType
//
Struct GPPREFgppLogonTriggerType
{
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "UserId") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct UserId = this.STag.ToString
			{
				[Post.Local.UserId_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("UserId") STag;
				switch
				{
					Case !Local.UserId_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) UserId;
							XmlTag("UserId") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Delay") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Delay = this.Delay
			{
				[Post.Local.Delay_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Delay") STag;
				switch
				{
					Case !Local.Delay_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) Delay;
							XmlTag("Delay") ETag;
						}
				}
			}
			
	}
	
}

//
// ComplexType sessionStateChangeTriggerType
//
Struct GPPREFgppSessionStateChangeTriggerType
{
	GPPREFgppTriggerBaseType TriggerBase;
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "UserId") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct UserId = this.STag.ToString
			{
				[Post.Local.UserId_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("UserId") STag;
				switch
				{
					Case !Local.UserId_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) UserId;
							XmlTag("UserId") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Delay") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Delay = this.Delay
			{
				[Post.Local.Delay_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Delay") STag;
				switch
				{
					Case !Local.Delay_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) Delay;
							XmlTag("Delay") ETag;
						}
				}
			}
			
	}
	
	struct StateChange = this.STag.ToString
	{
		[Post.Local.StateChange_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("StateChange") STag;
		switch
		{
			Case !Local.StateChange_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) StateChange;
					XmlTag("StateChange") ETag;
				}
		}
	}
	
}

//
// ComplexType calendarTriggerType
//
Struct GPPREFgppCalendarTriggerType
{
	GPPREFgppTriggerBaseType TriggerBase;
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RandomDelay") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct RandomDelay = this.RandomDelay
			{
				[Post.Local.RandomDelay_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("RandomDelay") STag;
				switch
				{
					Case !Local.RandomDelay_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) RandomDelay;
							XmlTag("RandomDelay") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ScheduleByDay"):
			struct ScheduleByDay = this.STag.ToString
			{
				[Post.Local.ScheduleByDay_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("ScheduleByDay") STag;
				switch
				{
					Case !Local.ScheduleByDay_IsEmpty:
						struct
						{
							GPPREFgppDailyScheduleType ScheduleByDay;
							XmlTag("ScheduleByDay") ETag;
						}
				}
			}
			
		Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ScheduleByWeek"):
			struct ScheduleByWeek = this.STag.ToString
			{
				[Post.Local.ScheduleByWeek_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("ScheduleByWeek") STag;
				switch
				{
					Case !Local.ScheduleByWeek_IsEmpty:
						struct
						{
							GPPREFgppWeeklyScheduleType ScheduleByWeek;
							XmlTag("ScheduleByWeek") ETag;
						}
				}
			}
			
		Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ScheduleByMonth"):
			struct ScheduleByMonth = this.STag.ToString
			{
				[Post.Local.ScheduleByMonth_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("ScheduleByMonth") STag;
				switch
				{
					Case !Local.ScheduleByMonth_IsEmpty:
						struct
						{
							GPPREFgppMonthlyScheduleType ScheduleByMonth;
							XmlTag("ScheduleByMonth") ETag;
						}
				}
			}
			
		Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ScheduleByMonthDayOfWeek"):
			struct ScheduleByMonthDayOfWeek = this.STag.ToString
			{
				[Post.Local.ScheduleByMonthDayOfWeek_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("ScheduleByMonthDayOfWeek") STag;
				switch
				{
					Case !Local.ScheduleByMonthDayOfWeek_IsEmpty:
						struct
						{
							GPPREFgppMonthlyDayOfWeekScheduleType ScheduleByMonthDayOfWeek;
							XmlTag("ScheduleByMonthDayOfWeek") ETag;
						}
				}
			}
			
		Default:
			ReportParserError("ParserErrorProtocolClassWindows", "GPPREF", "There is no such choice") ChoiceError;
	}
	
}

//
// ComplexType dailyScheduleType
//
Struct GPPREFgppDailyScheduleType
{
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		Switch
		{
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "DaysInterval"):
				//
				// Embedded ComplexType 
				//
				struct DaysInterval = this.STag.ToString
				{
					[Post.Local.DaysInterval_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("DaysInterval") STag;
					switch
					{
						Case !Local.DaysInterval_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "</", true, false, false) Value;
								XmlTag("DaysInterval") ETag;
							}
					}
				}
				
		}
		
	}
}

//
// ComplexType weeklyScheduleType
//
Struct GPPREFgppWeeklyScheduleType
{
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		Switch
		{
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "WeeksInterval"):
				//
				// Embedded ComplexType 
				//
				struct WeeksInterval = this.STag.ToString
				{
					[Post.Local.WeeksInterval_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("WeeksInterval") STag;
					switch
					{
						Case !Local.WeeksInterval_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "</", true, false, false) Value;
								XmlTag("WeeksInterval") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "DaysOfWeek"):
				struct DaysOfWeek = this.STag.ToString
				{
					[Post.Local.DaysOfWeek_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("DaysOfWeek") STag;
					switch
					{
						Case !Local.DaysOfWeek_IsEmpty:
							struct
							{
								GPPREFgppDaysOfWeekType DaysOfWeek;
								XmlTag("DaysOfWeek") ETag;
							}
					}
				}
				
		}
		
	}
}

//
// ComplexType monthlyScheduleType
//
Struct GPPREFgppMonthlyScheduleType
{
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		Switch
		{
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "DaysOfMonth"):
				struct DaysOfMonth = this.STag.ToString
				{
					[Post.Local.DaysOfMonth_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("DaysOfMonth") STag;
					switch
					{
						Case !Local.DaysOfMonth_IsEmpty:
							struct
							{
								GPPREFgppDaysOfMonthType DaysOfMonth;
								XmlTag("DaysOfMonth") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Months"):
				struct Months = this.STag.ToString
				{
					[Post.Local.Months_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("Months") STag;
					switch
					{
						Case !Local.Months_IsEmpty:
							struct
							{
								GPPREFgppMonthsType Months;
								XmlTag("Months") ETag;
							}
					}
				}
				
		}
		
	}
}

//
// ComplexType monthlyDayOfWeekScheduleType
//
Struct GPPREFgppMonthlyDayOfWeekScheduleType
{
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		Switch
		{
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Weeks"):
				struct Weeks = this.STag.ToString
				{
					[Post.Local.Weeks_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("Weeks") STag;
					switch
					{
						Case !Local.Weeks_IsEmpty:
							struct
							{
								GPPREFgppWeeksType Weeks;
								XmlTag("Weeks") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "DaysOfWeek"):
				struct DaysOfWeek = this.STag.ToString
				{
					[Post.Local.DaysOfWeek_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("DaysOfWeek") STag;
					switch
					{
						Case !Local.DaysOfWeek_IsEmpty:
							struct
							{
								GPPREFgppDaysOfWeekType DaysOfWeek;
								XmlTag("DaysOfWeek") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Months"):
				struct Months = this.STag.ToString
				{
					[Post.Local.Months_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("Months") STag;
					switch
					{
						Case !Local.Months_IsEmpty:
							struct
							{
								GPPREFgppMonthsType Months;
								XmlTag("Months") ETag;
							}
					}
				}
				
		}
		
	}
}

//
// ComplexType daysOfWeekType
//
Struct GPPREFgppDaysOfWeekType
{
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		Switch
		{
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Monday"):
				struct Monday = this.STag.ToString
				{
					[Post.Local.Monday_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("Monday") STag;
					switch
					{
						Case !Local.Monday_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) Monday;
								XmlTag("Monday") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Tuesday"):
				struct Tuesday = this.STag.ToString
				{
					[Post.Local.Tuesday_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("Tuesday") STag;
					switch
					{
						Case !Local.Tuesday_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) Tuesday;
								XmlTag("Tuesday") ETag;
							}
					}
				}
			
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Wednesday"):
				struct Wednesday = this.STag.ToString
				{
					[Post.Local.Wednesday_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("Wednesday") STag;
					switch
					{
						Case !Local.Wednesday_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) Wednesday;
								XmlTag("Wednesday") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Thursday"):
				struct Thursday = this.STag.ToString
				{
					[Post.Local.Thursday_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("Thursday") STag;
					switch
					{
						Case !Local.Thursday_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) Thursday;
								XmlTag("Thursday") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Friday"):
				struct Friday = this.STag.ToString
				{
					[Post.Local.Friday_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("Friday") STag;
					switch
					{
						Case !Local.Friday_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) Friday;
								XmlTag("Friday") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Saturday"):
				struct Saturday = this.STag.ToString
				{
					[Post.Local.Saturday_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("Saturday") STag;
					switch
					{
						Case !Local.Saturday_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) Saturday;
								XmlTag("Saturday") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Sunday"):
				struct Sunday = this.STag.ToString
				{
					[Post.Local.Sunday_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("Sunday") STag;
					switch
					{
						Case !Local.Sunday_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) Sunday;
								XmlTag("Sunday") ETag;
							}
					}
				}
		}
		
	}
}

//
// ComplexType monthsType
//
Struct GPPREFgppMonthsType
{
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		Switch
		{
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "January"):
				struct January = this.STag.ToString
				{
					[Post.Local.January_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("January") STag;
					switch
					{
						Case !Local.January_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) January;
								XmlTag("January") ETag;
							}
					}
				}
			
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "February"):
				struct February = this.STag.ToString
				{
					[Post.Local.February_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("February") STag;
					switch
					{
						Case !Local.February_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) February;
								XmlTag("February") ETag;
							}
					}
				}
			
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "March"):
				struct March = this.STag.ToString
				{
					[Post.Local.March_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("March") STag;
					switch
					{
						Case !Local.March_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) March;
								XmlTag("March") ETag;
							}
					}
				}
			
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "April"):
				struct April = this.STag.ToString
				{
					[Post.Local.April_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("April") STag;
					switch
					{
						Case !Local.April_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) April;
								XmlTag("April") ETag;
							}
					}
				}
			
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "May"):
				struct May = this.STag.ToString
				{
					[Post.Local.May_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("May") STag;
					switch
					{
						Case !Local.May_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) May;
								XmlTag("May") ETag;
							}
					}
				}
			
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "June"):
				struct June = this.STag.ToString
				{
					[Post.Local.June_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("June") STag;
					switch
					{
						Case !Local.June_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) June;
								XmlTag("June") ETag;
							}
					}
				}
			
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "July"):
				struct July = this.STag.ToString
				{
					[Post.Local.July_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("July") STag;
					switch
					{
						Case !Local.July_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) July;
								XmlTag("July") ETag;
							}
					}
				}
			
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "August"):
				struct August = this.STag.ToString
				{
					[Post.Local.August_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("August") STag;
					switch
					{
						Case !Local.August_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) August;
								XmlTag("August") ETag;
							}
					}
				}
			
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "September"):
				struct September = this.STag.ToString
				{
					[Post.Local.September_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("September") STag;
					switch
					{
						Case !Local.September_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) September;
								XmlTag("September") ETag;
							}
					}
				}
			
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "October"):
				struct October = this.STag.ToString
				{
					[Post.Local.October_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("October") STag;
					switch
					{
						Case !Local.October_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) October;
								XmlTag("October") ETag;
							}
					}
				}
			
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "November"):
				struct November = this.STag.ToString
				{
					[Post.Local.November_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("November") STag;
					switch
					{
						Case !Local.November_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) November;
								XmlTag("November") ETag;
							}
					}
				}
			
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "December"):
				struct December = this.STag.ToString
				{
					[Post.Local.December_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("December") STag;
					switch
					{
						Case !Local.December_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) December;
								XmlTag("December") ETag;
							}
					}
				}
			
		}
		
	}
}

//
// ComplexType daysOfMonthType
//
Struct GPPREFgppDaysOfMonthType
{
	struct Day = this.STag.ToString
	{
		[Post.Local.Day_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("Day") STag;
		switch
		{
			Case !Local.Day_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) Day;
					XmlTag("Day") ETag;
				}
		}
	}
	
}

//
// ComplexType weeksType
//
Struct GPPREFgppWeeksType
{
	struct Week = this.STag.ToString
	{
		[Post.Local.Week_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("Week") STag;
		switch
		{
			Case !Local.Week_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) Week;
					XmlTag("Week") ETag;
				}
		}
	}
	
}

//
// ComplexType settingsType
//
Struct GPPREFgppSettingsType
{
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		Switch
		{
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "AllowStartOnDemand"):
				struct AllowStartOnDemand = this.AllowStartOnDemand
				{
					[Post.Local.AllowStartOnDemand_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("AllowStartOnDemand") STag;
					switch
					{
						Case !Local.AllowStartOnDemand_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) AllowStartOnDemand;
								XmlTag("AllowStartOnDemand") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RestartOnFailure"):
				struct RestartOnFailure = this.STag.ToString
				{
					[Post.Local.RestartOnFailure_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("RestartOnFailure") STag;
					switch
					{
						Case !Local.RestartOnFailure_IsEmpty:
							struct
							{
								GPPREFgppRestartType RestartOnFailure;
								XmlTag("RestartOnFailure") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "MultipleInstancesPolicy"):
				struct MultipleInstancesPolicy = this.STag.ToString
				{
					[Post.Local.MultipleInstancesPolicy_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("MultipleInstancesPolicy") STag;
					switch
					{
						Case !Local.MultipleInstancesPolicy_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) MultipleInstancesPolicy;
								XmlTag("MultipleInstancesPolicy") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "DisallowStartIfOnBatteries"):
				struct DisallowStartIfOnBatteries = this.DisallowStartIfOnBatteries
				{
					[Post.Local.DisallowStartIfOnBatteries_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("DisallowStartIfOnBatteries") STag;
					switch
					{
						Case !Local.DisallowStartIfOnBatteries_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) DisallowStartIfOnBatteries;
								XmlTag("DisallowStartIfOnBatteries") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "StopIfGoingOnBatteries"):
				struct StopIfGoingOnBatteries = this.StopIfGoingOnBatteries
				{
					[Post.Local.StopIfGoingOnBatteries_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("StopIfGoingOnBatteries") STag;
					switch
					{
						Case !Local.StopIfGoingOnBatteries_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) StopIfGoingOnBatteries;
								XmlTag("StopIfGoingOnBatteries") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "AllowHardTerminate"):
				struct AllowHardTerminate = this.AllowHardTerminate
				{
					[Post.Local.AllowHardTerminate_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("AllowHardTerminate") STag;
					switch
					{
						Case !Local.AllowHardTerminate_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) AllowHardTerminate;
								XmlTag("AllowHardTerminate") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "StartWhenAvailable"):
				struct StartWhenAvailable = this.StartWhenAvailable
				{
					[Post.Local.StartWhenAvailable_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("StartWhenAvailable") STag;
					switch
					{
						Case !Local.StartWhenAvailable_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) StartWhenAvailable;
								XmlTag("StartWhenAvailable") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "NetworkProfileName"):
				struct NetworkProfileName = this.NetworkProfileName
				{
					[Post.Local.NetworkProfileName_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("NetworkProfileName") STag;
					switch
					{
						Case !Local.NetworkProfileName_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) NetworkProfileName;
								XmlTag("NetworkProfileName") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RunOnlyIfNetworkAvailable"):
				struct RunOnlyIfNetworkAvailable = this.RunOnlyIfNetworkAvailable
				{
					[Post.Local.RunOnlyIfNetworkAvailable_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("RunOnlyIfNetworkAvailable") STag;
					switch
					{
						Case !Local.RunOnlyIfNetworkAvailable_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) RunOnlyIfNetworkAvailable;
								XmlTag("RunOnlyIfNetworkAvailable") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "WakeToRun"):
				struct WakeToRun = this.WakeToRun
				{
					[Post.Local.WakeToRun_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("WakeToRun") STag;
					switch
					{
						Case !Local.WakeToRun_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) WakeToRun;
								XmlTag("WakeToRun") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Enabled"):
				struct Enabled = this.Enabled
				{
					[Post.Local.Enabled_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("Enabled") STag;
					switch
					{
						Case !Local.Enabled_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) Enabled;
								XmlTag("Enabled") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Hidden"):
				struct Hidden = this.Hidden
				{
					[Post.Local.Hidden_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("Hidden") STag;
					switch
					{
						Case !Local.Hidden_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) Hidden;
								XmlTag("Hidden") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "DeleteExpiredTaskAfter"):
				struct DeleteExpiredTaskAfter = this.DeleteExpiredTaskAfter
				{
					[Post.Local.DeleteExpiredTaskAfter_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("DeleteExpiredTaskAfter") STag;
					switch
					{
						Case !Local.DeleteExpiredTaskAfter_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) DeleteExpiredTaskAfter;
								XmlTag("DeleteExpiredTaskAfter") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "IdleSettings"):
				struct IdleSettings = this.STag.ToString
				{
					[Post.Local.IdleSettings_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("IdleSettings") STag;
					switch
					{
						Case !Local.IdleSettings_IsEmpty:
							struct
							{
								GPPREFgppIdleSettingsType IdleSettings;
								XmlTag("IdleSettings") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "NetworkSettings"):
				struct NetworkSettings = this.STag.ToString
				{
					[Post.Local.NetworkSettings_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("NetworkSettings") STag;
					switch
					{
						Case !Local.NetworkSettings_IsEmpty:
							struct
							{
								GPPREFgppNetworkSettingsType NetworkSettings;
								XmlTag("NetworkSettings") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ExecutionTimeLimit"):
				struct ExecutionTimeLimit = this.ExecutionTimeLimit
				{
					[Post.Local.ExecutionTimeLimit_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("ExecutionTimeLimit") STag;
					switch
					{
						Case !Local.ExecutionTimeLimit_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) ExecutionTimeLimit;
								XmlTag("ExecutionTimeLimit") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Priority"):
				struct Priority = this.STag.ToString
				{
					[Post.Local.Priority_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("Priority") STag;
					switch
					{
						Case !Local.Priority_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) Priority;
								XmlTag("Priority") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RunOnlyIfIdle"):
				struct RunOnlyIfIdle = this.RunOnlyIfIdle
				{
					[Post.Local.RunOnlyIfIdle_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("RunOnlyIfIdle") STag;
					switch
					{
						Case !Local.RunOnlyIfIdle_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) RunOnlyIfIdle;
								XmlTag("RunOnlyIfIdle") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "UseUnifiedSchedulingEngine"):
				struct UseUnifiedSchedulingEngine = this.UseUnifiedSchedulingEngine
				{
					[Post.Local.UseUnifiedSchedulingEngine_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("UseUnifiedSchedulingEngine") STag;
					switch
					{
						Case !Local.UseUnifiedSchedulingEngine_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) UseUnifiedSchedulingEngine;
								XmlTag("UseUnifiedSchedulingEngine") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "DisallowStartOnRemoteAppSession"):
				struct DisallowStartOnRemoteAppSession = this.DisallowStartOnRemoteAppSession
				{
					[Post.Local.DisallowStartOnRemoteAppSession_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("DisallowStartOnRemoteAppSession") STag;
					switch
					{
						Case !Local.DisallowStartOnRemoteAppSession_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) DisallowStartOnRemoteAppSession;
								XmlTag("DisallowStartOnRemoteAppSession") ETag;
							}
					}
				}
				
		}
		
	}
}

//
// ComplexType idleSettingsType
//
Struct GPPREFgppIdleSettingsType
{
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		Switch
		{
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Duration"):
				//
				// Embedded ComplexType 
				//
				struct Duration = this.STag.ToString
				{
					[Post.Local.Duration_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("Duration") STag;
					switch
					{
						Case !Local.Duration_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "</", true, false, false) Value;
								XmlTag("Duration") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "WaitTimeout"):
				//
				// Embedded ComplexType 
				//
				struct WaitTimeout = this.STag.ToString
				{
					[Post.Local.WaitTimeout_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("WaitTimeout") STag;
					switch
					{
						Case !Local.WaitTimeout_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "</", true, false, false) Value;
								XmlTag("WaitTimeout") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "StopOnIdleEnd"):
				struct StopOnIdleEnd = this.StopOnIdleEnd
				{
					[Post.Local.StopOnIdleEnd_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("StopOnIdleEnd") STag;
					switch
					{
						Case !Local.StopOnIdleEnd_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) StopOnIdleEnd;
								XmlTag("StopOnIdleEnd") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RestartOnIdle"):
				struct RestartOnIdle = this.RestartOnIdle
				{
					[Post.Local.RestartOnIdle_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("RestartOnIdle") STag;
					switch
					{
						Case !Local.RestartOnIdle_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) RestartOnIdle;
								XmlTag("RestartOnIdle") ETag;
							}
					}
				}
				
		}
		
	}
}

//
// ComplexType networkSettingsType
//
Struct GPPREFgppNetworkSettingsType
{
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		Switch
		{
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Name"):
				struct Name = this.STag.ToString
				{
					[Post.Local.Name_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("Name") STag;
					switch
					{
						Case !Local.Name_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) Name;
								XmlTag("Name") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Id"):
				struct Id = this.STag.ToString
				{
					[Post.Local.Id_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("Id") STag;
					switch
					{
						Case !Local.Id_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) Id;
								XmlTag("Id") ETag;
							}
					}
				}
				
		}
		
	}
}

//
// ComplexType restartType
//
Struct GPPREFgppRestartType
{
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		Switch
		{
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Interval"):
				//
				// Embedded ComplexType 
				//
				struct Interval = this.STag.ToString
				{
					[Post.Local.Interval_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("Interval") STag;
					switch
					{
						Case !Local.Interval_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "</", true, false, false) Value;
								XmlTag("Interval") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Count"):
				//
				// Embedded ComplexType 
				//
				struct Count = this.STag.ToString
				{
					[Post.Local.Count_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("Count") STag;
					switch
					{
						Case !Local.Count_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "</", true, false, false) Value;
								XmlTag("Count") ETag;
							}
					}
				}
				
		}
		
	}
}

//
// ComplexType dataType
//
Struct GPPREFgppDataType
{
	XmlElement(true) OtherElement;
}

//
// ComplexType principalsType
//
Struct GPPREFgppPrincipalsType
{
	struct Principal = this.STag.ToString
	{
		[Post.Local.Principal_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("Principal") STag;
		switch
		{
			Case !Local.Principal_IsEmpty:
				struct
				{
					GPPREFgppPrincipalType Principal;
					XmlTag("Principal") ETag;
				}
		}
	}
	
}

//
// ComplexType principalType
//
Struct GPPREFgppPrincipalType
{
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		Switch
		{
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "UserId"):
				struct UserId = this.STag.ToString
				{
					[Post.Local.UserId_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("UserId") STag;
					switch
					{
						Case !Local.UserId_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) UserId;
								XmlTag("UserId") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "LogonType"):
				struct LogonType = this.STag.ToString
				{
					[Post.Local.LogonType_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("LogonType") STag;
					switch
					{
						Case !Local.LogonType_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) LogonType;
								XmlTag("LogonType") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GroupId"):
				struct GroupId = this.STag.ToString
				{
					[Post.Local.GroupId_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("GroupId") STag;
					switch
					{
						Case !Local.GroupId_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) GroupId;
								XmlTag("GroupId") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "DisplayName"):
				struct DisplayName = this.DisplayName
				{
					[Post.Local.DisplayName_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("DisplayName") STag;
					switch
					{
						Case !Local.DisplayName_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) DisplayName;
								XmlTag("DisplayName") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RunLevel"):
				struct RunLevel = this.STag.ToString
				{
					[Post.Local.RunLevel_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("RunLevel") STag;
					switch
					{
						Case !Local.RunLevel_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) RunLevel;
								XmlTag("RunLevel") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ProcessTokenSidType"):
				struct ProcessTokenSidType = this.STag.ToString
				{
					[Post.Local.ProcessTokenSidType_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("ProcessTokenSidType") STag;
					switch
					{
						Case !Local.ProcessTokenSidType_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) ProcessTokenSidType;
								XmlTag("ProcessTokenSidType") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RequiredPrivileges"):
				struct RequiredPrivileges = this.STag.ToString
				{
					[Post.Local.RequiredPrivileges_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("RequiredPrivileges") STag;
					switch
					{
						Case !Local.RequiredPrivileges_IsEmpty:
							struct
							{
								GPPREFgppRequiredPrivilegesType RequiredPrivileges;
								XmlTag("RequiredPrivileges") ETag;
							}
					}
				}
				
		}
		
	}
}

//
// ComplexType requiredPrivilegesType
//
Struct GPPREFgppRequiredPrivilegesType
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Privilege") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct Privilege = this.STag.ToString
		{
			[Post.Local.Privilege_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("Privilege") STag;
			switch
			{
				Case !Local.Privilege_IsEmpty:
					struct
					{
						StringTerm(Property.XMLEncoding, "<", true, false, false) Privilege;
						XmlTag("Privilege") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType actionsType
//
Struct GPPREFgppActionsType
{
	GPPREFgppActionGroup ActionGroup;
}

//
// ComplexType actionGroup
//
Struct GPPREFgppActionGroup
{
	Switch
	{
		Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Exec"):
			struct Exec = this.STag.ToString
			{
				[Post.Local.Exec_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Exec") STag;
				switch
				{
					Case !Local.Exec_IsEmpty:
						struct
						{
							GPPREFgppExecType Exec;
							XmlTag("Exec") ETag;
						}
				}
			}
			
		Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ComHandler"):
			struct ComHandler = this.STag.ToString
			{
				[Post.Local.ComHandler_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("ComHandler") STag;
				switch
				{
					Case !Local.ComHandler_IsEmpty:
						struct
						{
							GPPREFgppComHandlerType ComHandler;
							XmlTag("ComHandler") ETag;
						}
				}
			}
			
		Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "SendEmail"):
			struct SendEmail = this.STag.ToString
			{
				[Post.Local.SendEmail_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("SendEmail") STag;
				switch
				{
					Case !Local.SendEmail_IsEmpty:
						struct
						{
							GPPREFgppSendEmailType SendEmail;
							XmlTag("SendEmail") ETag;
						}
				}
			}
			
		Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ShowMessage"):
			struct ShowMessage = this.STag.ToString
			{
				[Post.Local.ShowMessage_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("ShowMessage") STag;
				switch
				{
					Case !Local.ShowMessage_IsEmpty:
						struct
						{
							GPPREFgppShowMessageType ShowMessage;
							XmlTag("ShowMessage") ETag;
						}
				}
			}
			
		Default:
			ReportParserError("ParserErrorProtocolClassWindows", "GPPREF", "There is no such choice") ChoiceError;
	}
	
}

//
// ComplexType execType
//
Struct GPPREFgppExecType
{
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		Switch
		{
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Command"):
				struct Command = this.STag.ToString
				{
					[Post.Local.Command_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("Command") STag;
					switch
					{
						Case !Local.Command_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) Command;
								XmlTag("Command") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Arguments"):
				struct Arguments = this.Arguments
				{
					[Post.Local.Arguments_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("Arguments") STag;
					switch
					{
						Case !Local.Arguments_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) Arguments;
								XmlTag("Arguments") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "WorkingDirectory"):
				struct WorkingDirectory = this.STag.ToString
				{
					[Post.Local.WorkingDirectory_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("WorkingDirectory") STag;
					switch
					{
						Case !Local.WorkingDirectory_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) WorkingDirectory;
								XmlTag("WorkingDirectory") ETag;
							}
					}
				}
				
		}
		
	}
}

//
// ComplexType comHandlerType
//
Struct GPPREFgppComHandlerType
{
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		Switch
		{
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ClassId"):
				struct ClassId = this.STag.ToString
				{
					[Post.Local.ClassId_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("ClassId") STag;
					switch
					{
						Case !Local.ClassId_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) ClassId;
								XmlTag("ClassId") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Data"):
				struct Data = this.STag.ToString
				{
					[Post.Local.Data_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("Data") STag;
					switch
					{
						Case !Local.Data_IsEmpty:
							struct
							{
								GPPREFgppDataType Data;
								XmlTag("Data") ETag;
							}
					}
				}
				
		}
		
	}
}

//
// ComplexType sendEmailType
//
Struct GPPREFgppSendEmailType
{
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		Switch
		{
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Server"):
				struct Server = this.STag.ToString
				{
					[Post.Local.Server_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("Server") STag;
					switch
					{
						Case !Local.Server_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) Server;
								XmlTag("Server") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Subject"):
				struct Subject = this.Subject
				{
					[Post.Local.Subject_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("Subject") STag;
					switch
					{
						Case !Local.Subject_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) Subject;
								XmlTag("Subject") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "To"):
				struct To = this.To
				{
					[Post.Local.To_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("To") STag;
					switch
					{
						Case !Local.To_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) To;
								XmlTag("To") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Cc"):
				struct Cc = this.Cc
				{
					[Post.Local.Cc_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("Cc") STag;
					switch
					{
						Case !Local.Cc_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) Cc;
								XmlTag("Cc") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Bcc"):
				struct Bcc = this.Bcc
				{
					[Post.Local.Bcc_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("Bcc") STag;
					switch
					{
						Case !Local.Bcc_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) Bcc;
								XmlTag("Bcc") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ReplyTo"):
				struct ReplyTo = this.ReplyTo
				{
					[Post.Local.ReplyTo_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("ReplyTo") STag;
					switch
					{
						Case !Local.ReplyTo_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) ReplyTo;
								XmlTag("ReplyTo") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "From"):
				struct From = this.From
				{
					[Post.Local.From_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("From") STag;
					switch
					{
						Case !Local.From_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) From;
								XmlTag("From") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "HeaderFields"):
				struct HeaderFields = this.STag.ToString
				{
					[Post.Local.HeaderFields_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("HeaderFields") STag;
					switch
					{
						Case !Local.HeaderFields_IsEmpty:
							struct
							{
								GPPREFgppHeaderFieldsType HeaderFields;
								XmlTag("HeaderFields") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Body"):
				struct Body = this.Body
				{
					[Post.Local.Body_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("Body") STag;
					switch
					{
						Case !Local.Body_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) Body;
								XmlTag("Body") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Attachments"):
				struct Attachments = this.STag.ToString
				{
					[Post.Local.Attachments_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("Attachments") STag;
					switch
					{
						Case !Local.Attachments_IsEmpty:
							struct
							{
								GPPREFgppAttachmentsType Attachments;
								XmlTag("Attachments") ETag;
							}
					}
				}
				
		}
		
	}
}

//
// ComplexType headerFieldsType
//
Struct GPPREFgppHeaderFieldsType
{
	struct HeaderField = this.STag.ToString
	{
		[Post.Local.HeaderField_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("HeaderField") STag;
		switch
		{
			Case !Local.HeaderField_IsEmpty:
				struct
				{
					GPPREFgppHeaderFieldType HeaderField;
					XmlTag("HeaderField") ETag;
				}
		}
	}
	
}

//
// ComplexType headerFieldType
//
Struct GPPREFgppHeaderFieldType
{
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		Switch
		{
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Name"):
				struct Name = this.STag.ToString
				{
					[Post.Local.Name_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("Name") STag;
					switch
					{
						Case !Local.Name_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) Name;
								XmlTag("Name") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Value"):
				struct Value = this.Value
				{
					[Post.Local.Value_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("Value") STag;
					switch
					{
						Case !Local.Value_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) Value;
								XmlTag("Value") ETag;
							}
					}
				}
				
		}
		
	}
}

//
// ComplexType attachmentsType
//
Struct GPPREFgppAttachmentsType
{
	struct File = this.STag.ToString
	{
		[Post.Local.File_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("File") STag;
		switch
		{
			Case !Local.File_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) File;
					XmlTag("File") ETag;
				}
		}
	}
	
}

//
// ComplexType showMessageType
//
Struct GPPREFgppShowMessageType
{
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		Switch
		{
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Title"):
				struct Title = this.STag.ToString
				{
					[Post.Local.Title_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("Title") STag;
					switch
					{
						Case !Local.Title_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) Title;
								XmlTag("Title") ETag;
							}
					}
				}
				
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Body"):
				struct Body = this.STag.ToString
				{
					[Post.Local.Body_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("Body") STag;
					switch
					{
						Case !Local.Body_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) Body;
								XmlTag("Body") ETag;
							}
					}
				}
				
		}
		
	}
}