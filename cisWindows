//#  (c) 2009 CodePlex Foundation
//#
//#  Title:                  Content Indexing Services Protocol
//#
//#  Details:                
//#
//#  Microsoft References:   [MS-MCIS]: Content Indexing Services Protocol Specification
//#
//#  Comments:               
//#
//#  Revision Class and Date:Major, 4/20/2009
//#                          Minor, 11/17/2009
//#
//####

const VTEMPTY = 0;
const VTVARIANT = 12;
const VTI1 = 16;
const VTUI1 = 17;
const VTI2 = 2;
const VTUI2 = 18;
const VTBOOL = 11;
const VTI4 = 3;
const VTUI4 = 19;
const VTR4 = 4;
const VTINT = 22;
const VTUINT = 23;
const VTERROR = 10;
const VTI8 = 20;
const VTUI8 = 21;
const VTR8 = 5;
const VTCY = 6;
const VTDATE = 7;
const VTFILETIME= 64;
const VTDECIMAL = 14;
const VTCLSID = 72;
const CISVTBlob = 65;
const VTBlobObject = 70;
const VTCF = 71;
const VTBSTR = 8;
const VTLPSTR = 30;
const VTLPWSTR = 31;
const CISVTVector = 0x1000;
const CISVTArray = 0x2000;
const VectorORI1 = 0x1010;
const VectorORUI1= 0x1011;
const VectorORI2 = 0x1002;
const VectorORUI2 = 0x1012;
const VectorORBOOL = 0x100B;
const VectorORI4 = 0x1003;
const VectorORUI4 = 0x1013;
const VectorORR4 = 0x1004;
const VectorORERROR = 0x100A;
const VectorORI8 = 0x1014;
const VectorORUI8 = 0x1015;
const VectorORR8 = 0x1005;
const VectorORCY = 0x1006;
const VectorORDATE = 0x1007;
const VectorORFILETIME = 0x1040;
const VectorORCF = 0x1047;
const CISVectorORCLSID = 0x1048;
const VectorORBSTR = 0x1008;
const VectorORLPSTR = 0x101E;
const VectorORLPWSTR = 0x101F;
const VectorORVARIANT = 0x100C;


const ArrayORI1 = 0x2010;
const ArrayORUI1 = 0x2011;
const ArrayORI2 = 0x2002;
const ArrayORUI2 = 0x2012;
const ArrayORBOOL = 0x200B;
const ArrayORI4 = 0x2003;
const ArrayORUI4 = 0x2013;
const ArrayORR4 = 0x2004;
const ArrayORERROR = 0x200A;
const ArrayORR8 = 0x2005;
const ArrayORCY = 0x2006;
const ArrayORDATE = 0x2007;
const ArrayORBSTR = 0x2008;
const ArrayORVARIANT = 0x200C;
const ArrayORINT = 0x2016;
const ArrayORUINT = 0x2017;
const ArrayORDECIMAL = 0x200E;

[EmbeddedProtocol,DataTypeByteOrder = LittleEndian]
Protocol CISSerializedPropertyValue
{
	UINT32 type = CISVarTypeValues(this);
	CISCBaseStorageVariantData(type) CBaseStorageVariantData;
	Blob(FrameOffset - ProtocolOffset < property.ReassembledPayloadLength ?property.ReassembledPayloadLength - (FrameOffset - ProtocolOffset):0) Pad;
}

[DataTypeByteOrder = LittleEndian, BuildConversationWithParent]
Protocol CIS = FormatString( "%s  %s",Property.SMBResponse ? CISSummary + " Response" : CISSummary + " Request", CISMessageSummary)
{
	[CISSummary = CISMessageTypeTable(Property.SMBResponse, MessageType)]
	
	UINT32 MessageType = FormatString("%s, %d(0x%X)", CISMessageTypeTable(Property.SMBResponse, This), this, this);
	[
		Conversation.RowOffset$[FrameNumber] = Conversation.RowsOffset,
		Conversation.CISNumColumn$[FrameNumber] = Conversation.CISNumColumns,
		Conversation.CISRowSizeTable$[FrameNumber] = Conversation.CISRowSize,
		Conversation.CISRowscount$[FrameNumber] = conversation.Rowscount,
		Conversation.CISClientOSVersion$[framenumber]= Conversation.ClientOSVersion,
		Conversation.CISServerVersion$[framenumber]=Conversation.CISServerVersion,
		Conversation.CISClientBases$[FrameNumber]=Conversation.CISClientBase
	]
	switch( Property.SMBResponse )
	{
		case FALSE: //CIS REQUEST
		switch( MessageType )
		{
			case 0x000000C8: CISCPMConnectIn CPMConnectInRequest;//200
			case 0x000000C9: CISCPMDisconnect CPMDisconnectRequest;//201
			case 0x000000CA: CISCPMCreateQueryIn CPMCreateQueryInRequest;//202
			case 0x000000CB: CISCPMFreeCursorIn CPMFreeCursorInRequest;//203
			case 0x000000CC: CISCPMGetRowsIn CPMGetRowsInRequest;//204
			case 0x000000CD: CISCPMRatioFinishedIn CPMRatioFinishedInRequest;//205
			case 0x000000CE: CISCPMCompareBmkIn CPMCompareBmkInRequest;//206
			case 0x000000CF: CISCPMGetApproximatePositionIn	CPMGetApproximatePositionInRequest;//207
			case 0x000000D0: CISCPMSetBindingsIn CPMSetBindingsInRequest;//208 
			case 0x000000D1: CISCPMGetNotify CPMGetNotifyRequest;//209
			case 0x000000D7: CISCPMGetQueryStatusIn	CPMGetQueryStatusInRequest;//215
			case 0x000000D9: CISCPMCiStateInOut CPMCiStateInOutRequest;//217
			case 0x000000E1: CISCPMForceMergeIn CPMForceMergeInRequest;//225
			case 0x000000E4: CISCPMFetchValueIn CPMFetchValueInRequest;//228
			case 0x000000E6: CISCPMUpdateDocumentsIn	CPMUpdateDocumentsInRequest;//230
			case 0x000000E7: CISCPMGetQueryStatusExIn	CPMGetQueryStatusExInRequest;//231
			case 0x000000E8: CISCPMRestartPositionIn	CPMRestartPositionInRequest;//232
			case 0x000000E9: CISCPMStopAsynchIn CPMStopAsynchInRequest;//233
			case 0x000000EC: CISCPMSetCatStateIn CPMSetCatStateInRequest;//236
			Default:         ReportParserError ( 2, "CIS", "Undefined Message" ) ProtocolError;
		}

		case TRUE: //CIS RESPONSE
		switch( MessageType )
		{
			case 0x000000C8: CISCPMConnectOut CPMConnectOutResponse;//200
			case 0x000000CA: CISCPMCreateQueryOut CPMCreateQueryOutResponse;//202
			case 0x000000CB: CISCPMFreeCursorOut CPMFreeCursorOutResponse;//203
			case 0x000000CC: CISCPMGetRowsOut CPMGetRowsOutResponse;//204
			case 0x000000CD: CISCPMRatioFinishedOut	CPMRatioFinishedOutResponse;//205
			case 0x000000CE: CISCPMCompareBmkOut CPMCompareBmkOutResponse;//206
			case 0x000000CF: CISCPMGetApproximatePositionOut	CPMGetApproximatePositionOutResponse;//207
			case 0x000000D0: CISCPMSetBindingsOut CISCPMSetBindingsOutResponse;//208
			case 0x000000D1: CISCPMGetNotify CPMGetNotifyResponse;//209
			case 0x000000D2: CISCPMSendNotifyOut CPMSendNotifyOutResponse;//210
			case 0x000000D7: CISCPMGetQueryStatusOut	CPMGetQueryStatusOutResponse;//215
			case 0x000000D9: CISCPMCiStateInOut CPMCiStateInOutResponse;//217
			case 0x000000E1: CISCPMForceMergeIn CPMForceMergeInResponse;//225
			case 0x000000E4: CISCPMFetchValueOut CPMFetchValueInRespone;//228
			case 0x000000E6: CISCPMUpdateDocumentsIn	CPMUpdateDocumentsInResponse;//230
			case 0x000000E7: CISCPMGetQueryStatusExOut	CPMGetQueryStatusExOutResponse;//231
			case 0x000000E8: CISCPMRestartPositionIn	CPMRestartPositionInReponse;//232
			case 0x000000EC: CISCPMSetCatStateOut CPMSetCatStateOutResponse;//236
			Default:         ReportParserError ( 2, "CIS", "Undefined Message" ) ProtocolError;
		}
	}
}
//protocol

Table CISRestrictionTypeTable( RTType,Description )
{
	switch( RTType )
	{

		case 0x00000000:FormatString("RTNone (0x%08X) %s",RTType,Description?"The node represents a noise word in a vector query":"");
		case 0x00000001:FormatString("RTAnd (0x%08X) %s",RTType,Description?"The node contains a CISCNodeRestriction upon which a logical AND operation should be performed":"");
		case 0x00000002:FormatString("RTOr (0x%08X) %s",RTType,Description?"The node contains a CISCNodeRestriction upon which a logical OR operation should be performed":"");
		case 0x00000003:FormatString("RTNot (0x%08X) %s",RTType,Description?"The node contains a CISCNotRestriction":"");
		case 0x00000004:FormatString("RTContent (0x%08X) %s",RTType,Description?"The node contains a CISCContentRestriction":"");
		case 0x00000005:FormatString("RTProperty (0x%08X) %s",RTType,Description?"The node contains a CISCPropertyRestriction":"");
		case 0x00000006:FormatString("RTProximity (0x%08X) %s",RTType,Description?"The node contains a CISCNodeRestriction upon which a proximity ranking should be performed":"");
		case 0x00000007:FormatString("RTVector (0x%08X) %s",RTType,Description?"The node contains a VectorRestriction":"");
		case 0x00000008:FormatString("RTNatLanguage (0x%08X) %s",RTType,Description?"The node contains a CISCNatLanguageRestriction":"");
		case 0x00000009:FormatString("RTScope (0x%08X) %s",RTType,Description?"The node contains a CISCScopeRestriction":"");
		case 0xFFFFFFFD:FormatString("RTPhrase (0x%08X) %s",RTType,Description?"The node contains a CISCNodeRestriction upon which a phrase match should be performed":"");
		default:		FormatString("(0x%08X) %s",RTType,Description?"Undefined Value":"");
	}
}
		

Table CISRelationToPerformTable ( value )
{
	switch( value )
	{
		case 0x00000000: FormatString("PRLT -- A less then comparision and Value = 0x%08X" , value);
		case 0x00000001: FormatString("PRLE -- A less then or equal comparision and Value = 0x%08X" , value);
		case 0x00000002: FormatString("PRGT -- A greater then comparision and Value = 0x%08X" , value);
		case 0x00000003: FormatString("PRGE -- A greater then comparision and Value = 0x%08X" , value);
		case 0x00000004: FormatString("PREQ -- An equality comparision and Value = 0x%08X" , value);
		case 0x00000005: FormatString("PRNE -- A not equal comparision and Value = 0x%08X" , value);
		case 0x00000006: FormatString("PRRE -- A egular expression comparision and Value = 0x%08X" , value);
		case 0x00000007: FormatString("PRAllBits -- A bitwise AND that returns the right operand and Value = 0x%08X" , value);
		case 0x00000008: FormatString("PRSomeBits -- A bitwise AND that returns a nonzero value = 0x%08X" , value);
		case 0x00000100: FormatString("PRAll -- Operation should be performed on a clumn of a rowset -- only true when opertaion is true for all rows and Value = 0x%08X" , value);
		case 0x00000200: FormatString("PRAny -- Operation should be performed on a clumn of a rowset -- only true when opertaion is true for any row and Value = 0x%08X" , value);
		default:		FormatString("Unknown PR type and Value = 0x%08X" , value);
	}
}		


Table CISupdateFlagTable ( value )
{
	switch( value )
	{
		case 0x00000000: FormatString("UPD_INCREM = 0x%08X" , value);
		case 0x00000001: FormatString("UPD_FULL = 0x%08X" , value);
		case 0x00000002: FormatString("UPD_INIT = 0x%08X" , value);
		default:		FormatString("Unknown update type and Value = 0x%08X" , value);
	}
}


Table CISDbPropOptionsTable( value,Description )
{
	switch( value )
	{
		case 0x0000: FormatString("DBPROPOPTIONS_REQUIRED (0x%02X) %s", value,Description?"The specified property value is required":"");
		case 0x0001: FormatString("DBPROPOPTIONS_OPTIONAL (0x%02X) %s", value,Description?"The specified property value is optional":"");
		Default:  FormatString("(0x%02X) %s", value,Description?"Undefined value":"");
	}
}


Table CISDbPropStatusTable( value,Description )
{
	switch( value )
	{
		case 0x0000:FormatString("DBPROPSTATUS_OK (0x%02X) %s", value,Description?"The property's value was successfully set":"");
		case 0x0001:FormatString("DBPROPSTATUS_BADCOLUMN (0x%02X) %s", value,Description?"The colid element of the CISDBProp structure was invalid":"");
		case 0x0002:FormatString("DBPROPSTATUS_BADOPTION (0x%02X) %s", value,Description?"The value of dwOptions was invalid":"");
		case 0x0003:FormatString("DBPROPSTATUS_BADVALUE (0x%02X) %s", value,Description?"The data type in vValue was not the data type of the property or was not VT_EMPTY":"");
		case 0x0004:FormatString("DBPROPSTATUS_CONFLICTING (0x%02X) %s", value,Description?"The property's value was not set because doing so would have conflicted with an existing property":"");
		case 0x0005:FormatString("DBPROPSTATUS_NOTALLSETTABLE (0x%02X) %s", value,Description?"A property was specified to be applied to all columns but could not be applied to one or more of them":"");
		case 0x0006:FormatString("DBPROPSTATUS_NOTAVAILABLE (0x%02X) %s", value,Description?"Reserved":"");
		case 0x0007:FormatString("DBPROPSTATUS_NOTSET (0x%02X) %s", value,Description?"The property's value was not set to the specified value because dwOptions was DBPROPOPTIONS_OPTIONAL and setting the property to the specified value was not possible":"");
		case 0x0008:FormatString("DBPROPSTATUS_NOTSETTABLE (0x%02X) %s", value,Description?"The property was read-only, or the consumer attempted to set values of properties in the Initialization property group after the data source object was initialized":"");
		case 0x0009:FormatString("DBPROPSTATUS_NOTSUPPORTED (0x%02X) %s", value,Description?"The property's value was not set":"");
		default:	FormatString("(0x%02X) %s", value,Description?"Undefined Value":"");
	}
}


Table	CISQuereyTypeTable( value )
{
	switch( value )
	{
		case 0x00000001:  FormatString("ESequentialand = 0x%08X, cursor can only move forward", value);
		case 0x00000002:  FormatString("ELocatable = 0x%08X, cursor can move to any location", value);
		case 0x00000004:  FormatString("EScrollable = 0x%08X, cursor can move and fetch in any direction", value);
		case 0x00000008:  FormatString("EAsynchrous = 0x%08X, caller will not wait for execution completion", value);
		case 0x00000020:  FormatString("EWatchable = 0x%08X, Obsolete", value);
		case 0x00000040:  FormatString("EGenericOptionsString = 0x%08X, Unused", value);
		case 0x00000080:  FormatString("EFirstRows = 0x%08X, Reurns first row encountred not the best match", value);
		case 0x00000100:  FormatString("EDistributed = 0x%08X, Querey is distributed over multiple catalogs or servers", value);
		case 0x00000200:  FormatString("EHoldRows = 0x%08X, Client can hold rows while asking for more" , value);
		case 0x00000800:  FormatString("EChaptered  = 0x%08X, Rowser supports chapters", value);
		case 0x00001000:  FormatString("EUseCI = 0x%08X, Only answer the querey from the index, not the file system", value);
		case 0x00002000:  FormatString("EDeferTrimming = 0x%08X, For queries sorted by rank, do security trimming last", value);
		case 0x00004000:  FormatString("EExtendedTypes = 0x%08X, Client supports non-automation datatypes in rowset", value);
		default:    FormatString("Unknown Query type and Value = 0x%08X" , value);
	}
}

Table	CISQueryPermissionTable( value )
{
	switch( value )
	{
		case 0x00000000: FormatString("Query recursivly examines all subdirectories of the path 0x%08", value);
		case 0x00000001: FormatString("Query should not examines any subdirectories 0x%08X", value);
		default:         FormatString("Unknown Query type and Value = 0x%08X" , value);
	}
}
		

Table	CISPathTypeTable( value )
{
	switch( value )
	{
		case 0x00000000:  FormatString("Lowerpath is the file system path 0x%08X", value);
		case 0x00000001:  FormatString("Lowerpath is an IIS path 0x%08X", value);
		default:   FormatString("Unknown lowerpath type and Value = 0x%08X" , value);
	}
}


Table	CISColumnOrderTable( value,Description )
{
	switch( value )
	{
		case 0x00000000:  FormatString("QUERY_SORTASCEND (0x%08X) %s",Value,Description?"Column should be sorted in ascending order":"");
		case 0x00000001:  FormatString("QUERY_DESCEND (0x%08X) %s",Value,Description?"Column should be sorted in descending order":"");
		default:   FormatString("(0x%08X) %s",Value,Description?"Undefined Value":"");
	}
}


Table CISIsRangeTable( value )
{
	switch( value )
	{
		case 0x00000000:  FormatString("Keys are prefixes 0x%02X", value);
		case 0x00000001:  FormatString("Keys are not prefixes 0x%02X", value);
		default:   FormatString("Unknown Keys type and Value = 0x%02X" , value);
	}
}


Table CISNewRowsTable( value )
{
	switch( value )
	{
		case 0x00000000:  FormatString("Rowset does not contain any new rows (%u)", value); 
		case 0x00000001:  FormatString("New rows are available in the Rowset(%u)", value);
		default:   FormatString("Undefined value (%u)" , value);
	}
}


Table CISBwdFetchTable( value )
{
	switch( value )
	{
		case 0x00000000:  FormatString("Rows should be fetch in forward order (%u)", value);
		case 0x00000001:  FormatString("Rows should be fetch in reverse order (%u)", value);
		default:   FormatString("Undefined Value" , value);
	}
}


Table CISServerVersionTable( value,Description )
{
	switch( value )
	{
	case 0x00000007:  FormatString("Windows XP, Windows 2000 or Windows Server 2003 (0x%08X) %s",Value,Description?"Server is running on a 32-bit operating system":"");//???? Tahir changed from 8 to 7
	case 0x00010000:  FormatString("Windows 2000 or Windows Server 2003 (0x%08X) %s",Value,Description?"Server is running on a 64-bit operating system":"");
	default:   FormatString("(0x%08X) %s",Value,Description?"Undefined Value":"");
	}
}


Table CISClientVersionTable( value )
{
	switch( value )
	{
		case 0x00000005:  FormatString("Windows 2000 (0x%08X)", value);
		case 0x00000008:  FormatString("Windows Server 2003 or Windows XP (0x%08X)", value);//???? tahir case 08 from 07	
		case 0x00010000:  FormatString("64-bit machine (0x%08X)", value);
		default:   FormatString("Undefined (0x%08X)" , value);
	}
}

Table CISUpdateTable( value,Description )
{
	switch( value )
	{
	case 0x00000000:  FormatString("UPD_INCREM (0x%08X) %s",Value,Description?"An increment update should be performed":"");
	case 0x00000001:  FormatString("UPD_FULL (0x%08X) %s",Value,Description?"A full update should be performed":"");
	case 0x00000002:  FormatString("UPD_INIT (0x%08X) %s",Value,Description?"A new initialization should be performed":"");
	default:   FormatString("(0x%08X) %s",Value,Description?"Undefined Value":"");
	}
}

Table CISStateTable( value,Description )
{
	switch( value )
	{
	case 0x00000001:  FormatString("CICAT_STOPPED (0x%08X) %s",Value,Description?"The catalog is stopped":"");// change accroding to #2404(Protodoc)
	case 0x00000002:  FormatString("CICAT_READONLY (0x%08X) %s",Value,Description?"The catalog is read only":"");
	case 0x00000004:  FormatString("CICAT_WRITABLE (0x%08X) %s",Value,Description?"The catalog is writable ":"");
	case 0x00000008:  FormatString("CICAT_NO_QUERY (0x%08X) %s",Value,Description?"The catalog is not available for query":"");
	default:   FormatString("(0x%08X) %s",Value,Description?"Undefined value":"");
	}
}

Table CISSequentialTable( value )
{
	switch( value )
	{
		case 0x00:  FormatString("Query can use the index", value);
		case 0x01:  FormatString("Query will require a sequential scan" , value);
		default:   FormatString("Undefined Value" , value);
	}
}

Table CISWorkIdUniqueTable( value )
{
	switch( value )
	{
		case 0x00:  FormatString("The identifiers are unique only throughout the rowset", value);
		case 0x01:  FormatString("The identifiers are unique throughout the catalog", value);
		default:   FormatString("Undefined Value" , value);
	}
}


Table CISComparisionTable( value,Description )
{
	switch( value )
	{
		case 0x0000000:  FormatString("DBCOMPARE_LT (0x%08X) %s",Value,Description?"First bookmark is positioned before second":"");
		case 0x0000001:  FormatString("DBCOMPARE_EQ (0x%08X) %s",Value,Description?"First bookmark has same position as second":"");
		case 0x0000002:  FormatString("DBCOMPARE_GT (0x%08X) %s",Value,Description?"First bookmark is positioned after second":"");
		case 0x0000003:  FormatString("DBCOMPARE_NE (0x%08X) %s",Value,Description?"First bookmark does not have same position as second":"");
		case 0x0000004:  FormatString("DBCOMPARE_NOTCOMPARABLE (0x%08X) %s",Value,Description?":first bookmark not comparable to second":"");
		default:   FormatString("(0x%08X) %s",Value,Description?"Undefined value":"");
	}
}

Table	CISThisValueTable( value )
{
	switch( value )
	{
		case 0x0000000:  FormatString("CiNormal -- a regular querey = 0x%08X", value);
		case 0x0000001:  FormatString("CiVirtualRoots -- querey for list of virtual roots in Catalog, Requires administrative priviliges = 0x%08X", value);
		case 0x0000002:  FormatString("CiPhysicalRoots -- Obsolete = 0x%08X", value);
		case 0x0000003:  FormatString("CiPrperties -- List of all server supported properties = 0x%08X", value);
		case 0x0000004:  FormatString("CiAdminOP -- this query is an administrative operation = 0x%08X", value);
		default:   FormatString("Unknown Ci type and Value = 0x%08X" , value);
	}
}

Table CISCategTypeTable( value )
{
	switch( value )
	{
		case 0x00000000:  FormatString("Columns should be grouped based on a unique value = 0x%08X" , value);
		default:   FormatString("Columns should be grouped based this value = 0x%08X" , value);
	}
}

Table CISHResultSeverityCodeValues(value)
{
	switch(value)
	{
		case "..............................00":FormatString( "Success");
		case "..............................01":FormatString( "Informational");
		case "..............................10":FormatString( "Warning");
		case "..............................11":FormatString( "Error");
		Default:"Undefined";
	}
}

//Table CISBookmarkValues(Value)
//{
//	switch(value)
//	{
//		case 0xFFFFFFFB:FormatString("0x%08X - Indicates a position before the first row",value);
//		case 0xFFFFFFFC:FormatString("0x%08X - Indicates a position on the first row",value);
//		case 0xFFFFFFFD:FormatString("0x%08X - Indicates a position on the last row",value);
//		case 0xFFFFFFFE:FormatString("0x%08X - Indicates a position after the last row",value);
//		default:FormatString("0x%08X - Undefined Value",Value);
//	}
//}

Table CISVarTypeValues(Value)
{
	switch(value)
	{
		case 0:FormatString("VT_EMPTY (%u)",Value);
		case 1:FormatString("VT_NULL (%u)",Value);
		case 2:FormatString("VT_I2 (%u)",Value);
		case 3:FormatString("VT_I4 (%u)",Value);
		case 4:FormatString("VT_R4 (%u)",Value);
		case 5:FormatString("VT_R8 (%u)",Value);
		case 6:FormatString("VT_CY (%u)",Value);
		case 7:FormatString("VT_DATE (%u)",Value);
		case 8:FormatString("VT_BSTR (%u)",Value);
		case 9:FormatString("VT_DISPATCH (%u)",Value);
		case 10:FormatString("VT_ERROR (%u)",Value);
		case 11:FormatString("VT_BOOL (%u)",Value);
		case 12:FormatString("VT_VARIANT (%u)",Value);
		case 14:FormatString("VT_DECIMAL (%u)",Value);
		case 16:FormatString("VT_I1 (%u)",Value);
		case 17:FormatString("VT_UI1 (%u)",Value);
		case 18:FormatString("VT_UI2 (%u)",Value);
		case 19:FormatString("VT_UI4 (%u)",Value);
		case 20:FormatString("VT_I8 (%u)",Value);
		case 21:FormatString("VT_UI8 (%u)",Value);
		case 22:FormatString("VT_INT (%u)",Value);
		case 23:FormatString("VT_UINT (%u)",Value);
		case 24:FormatString("VT_VOID (%u)",Value);
		case 25:FormatString("VT_HRESULT (%u)",Value);
		case 26:FormatString("VT_PTR (%u)",Value);
		case 27:FormatString("VT_SAFEARRAY (%u)",Value);
		case 28:FormatString("VT_CARRAY (%u)",Value);
		case 29:FormatString("VT_USERDEFINED (%u)",Value);
		case 30:FormatString("VT_LPSTR (%u)",Value);
		case 31:FormatString("VT_LPWSTR (%u)",Value);
		case 64:FormatString("VT_FILETIME (%u)",Value);
		case 65:FormatString("VT_BLOB (%u)",Value);
		case 66:FormatString("VT_STREAM (%u)",Value);
		case 67:FormatString("VT_STORAGE (%u)",Value);
		case 68:FormatString("VT_STREAMED_OBJECT (%u)",Value);
		case 69:FormatString("VT_STORED_OBJECT (%u)",Value);
		case 70:FormatString("VT_BLOB_OBJECT (%u)",Value);
		case 71:FormatString("VT_CF (%u)",Value);
		case 72:FormatString("VT_CLSID (%u)",Value);
		case 0x1000:FormatString("VT_VECTOR (%u)",Value);
		case 0x2000:FormatString("VT_ARRAY (%u)",Value);
		case 0x4000:FormatString("VT_BYREF (%u)",Value);
		case 0x8000:FormatString("VT_RESERVED (%u)",Value);
		case 0xFFFF:FormatString("VT_ILLEGAL (%u)",Value);
		case 0xFFF: FormatString("VT_ILLEGALMASKED or VT_TYPEMASK (%u)",Value);
		case 0x1010:FormatString("VectorORI1 (%u)",Value);
		case 0x1011:FormatString("VectorORUI1 (%u)",Value);
		case 0x1002:FormatString("VectorORI2 (%u)",Value); 
		case 0x1012:FormatString("VectorORUI2 (%u)",Value); 
		case 0x100B:FormatString("VectorORBOOL (%u)",Value);
		case 0x1003:FormatString("VectorORI4 (%u)",Value); 
		case 0x1013:FormatString("VectorORUI4 (%u)",Value);
		case 0x1004:FormatString("VectorORR4 (%u)",Value); 
		case 0x100A:FormatString("VectorORERROR (%u)",Value);
		case 0x1014:FormatString("VectorORI8 (%u)",Value);
		case 0x1015:FormatString("VectorORUI8 (%u)",Value);
		case 0x1005:FormatString("VectorORR8 (%u)",Value); 
		case 0x1006:FormatString("VectorORCY (%u)",Value); 
		case 0x1007:FormatString("VectorORDATE (%u)",Value); 
		case 0x1040:FormatString("VectorORFILETIME (%u)",Value);
		case 0x1047:FormatString("VectorORCF (%u)",Value);
		case 0x1048:FormatString("CISVectorORCLSID (%u)",Value);
		case 0x1008:FormatString("VectorORBSTR (%u)",Value);
		case 0x101E:FormatString("VectorORLPSTR (%u)",Value);
		case 0x101F:FormatString("VectorORLPWSTR (%u)",Value);
		case 0x100C:FormatString("VectorORVARIANT (%u)",Value);
		case 0x2010:FormatString("ArrayORI1 (%u)",Value);
		case 0x2011:FormatString("ArrayORUI1 (%u)",Value);
		case 0x2002:FormatString("ArrayORI2 (%u)",Value);
		case 0x2012:FormatString("ArrayORUI2 (%u)",Value);
		case 0x200B:FormatString("ArrayORBOOL (%u)",Value);
		case 0x2003:FormatString("ArrayORI4 (%u)",Value);
		case 0x2013:FormatString("ArrayORUI4 (%u)",Value);
		case 0x2004:FormatString("ArrayORR4 (%u)",Value);
		case 0x200A:FormatString("ArrayORERROR (%u)",Value);
		case 0x2005:FormatString("ArrayORR8 (%u)",Value);
		case 0x2006:FormatString("ArrayORCY (%u)",Value);
		case 0x2007:FormatString("ArrayORDATE (%u)",Value);
		case 0x2008:FormatString("ArrayORBSTR (%u)",Value);
		case 0x200C:FormatString("ArrayORVARIANT (%u)",Value);
		case 0x2016:FormatString("ArrayORINT (%u)",Value);
		case 0x2017:FormatString("ArrayORUINT (%u)",Value);
		case 0x200E:FormatString("ArrayORDECIMAL (%u)",Value);
	}
}

Table CISStoreStatusValues(Value)
{
	switch(Value)
	{
		case 0:FormatString("StoreStatusOK (%u)",value);
		case 1:FormatString("StoreStatusDeferred (%u)",value);
		case 2:FormatString("StoreStatusNull (%u)",value);
	}
}

struct CISVTUINT8
{
	UINT8 VByte;
}

struct CISVTUINT16
{
	UINT16 VWord;
}


struct CISVTUINT32
{
	UINT32 VWord;
}

struct CISVTUINT64
{
	UINT64 VDWord;
}

struct CISDecimal =  FormatString("%s%uE%u",Sign.bit7.toString,Integerpart,Exponent)		
{
	
	INT8 Sign
	{
		INT8 bit7:1 = bit7==0?"+":"-";
		INT8 bits0_6:1 = this.ToBitString + "Unused";
	}
	UINT8 Exponent;
	UINT16 Unused;
	Integer ( 12 ) Integerpart;
}

struct CISCurrency = FormatString("%u.%u",High,Low)
{
	INT32 High;
	INT32 Low;
}

struct CISVTBlob
{
	UINT32 VBlobLength;
	BLOB(VBlobLength)	VBlobValue; 
}

struct CISVTClipData									
{
	UINT32 CbLength;
	UINT8 UlClipFmt[4];
	BLOB(CbLength)	VClipValue; 
}

struct CISVTString
{
	UINT32 VStrLength;
	BLOB(VStrLength)	VStrValue;
}

struct CISVTAString
{
	UINT32 VStrLength;
	AsciiString(VStrLength)	VStrValue;
}

struct CISVTWString
{
	UINT32 VWStringLength;
	UnicodeString	VWStrvalue;
}

struct CISVTVector(vType)
{
	UINT32 VVectorElements;
	switch 
	{
		case vType & 0xFF:
			CISCBaseStorageVariantData(vType& 0xFF) VVectorArray[VVectorElements];
		default:
			BLOB(VVectorElements) VVectorArray1;
	}
}

struct CISVTArray(vType)
{
	UINT16 CDims;
	UINT16 FFeatures;
	UINT32 CbElements = FormatString("%u, ignored by server",this);
	[CISSafeArrayElementCount = 1] 
	CISSafeArrayBound Rgsabound[CDims];
	switch 
	{
		case vType & 0xFF:
			CISCBaseStorageVariantData(vType& 0xFF) Data[CISSafeArrayElementCount];
	}
}

struct CISSafeArrayBound
{
	[CISSafeArrayElementCount = CISSafeArrayElementCount * CElements]
	UINT32 CElements;
	UINT32 ILbound;
}

struct CISCBaseStorageVariant 
{
	[conversation.CBaseStorageVariantvType$[CISColumncount]]
	UINT16 vType = CISVarTypeValues(this);
	UINT8 vData1;
	UINT8 vData2;
	CISCBaseStorageVariantData(vType) Data;
}

struct CISCBaseStorageVariantData(vType)
{
	switch( vType )
	{
		case VTI1:         CISVTUINT8 VTypeI1;
		case VTUI1:        CISVTUINT8 VTypeUI1;
		case VTI2:         CISVTUINT16 VTypeI2;
		case VTUI2:        CISVTUINT16 VTypeUI2;
		case VTBOOL:       CISVTUINT16 VTypeBOOL;
		case VTI4:         CISVTUINT32 VTypeI4;
		case VTUI4:        CISVTUINT32 VTypeUI4;
		case VTR4:         CISVTUINT32 VTypeR4;
		case VTINT:        CISVTUINT32 VTypeINT;
		case VTUINT:       CISVTUINT32 VTypeUINT;
		case VTERROR:      CISVTUINT32 VTypeERROR;
		case VTI8:         CISVTUINT64 VTypeI8;
		case VTUI8:        CISVTUINT64 VTypeUI8;
		case VTR8:         CISVTUINT64 VTypeR8;
		case VTCY:         CISVTUINT64 VTypeCY;
		case VTDATE:       CISVTUINT64 VTypeDate;
		case VTFILETIME:   CISVTUINT64 VTypeFiletime;
		case VTDECIMAL:    CISDECIMAL vDecimal;
		case VTCLSID:      UINT8 vClSid[16];
		case CISVTBlob:
		case VTBlobObject: CISVTBlob vBlob;
		case VTCF:         CISVTClipData VtCF;
		case VTVARIANT:CISCBaseStorageVariant VTVariant; 
		case VTBSTR:			 CISVTString vString;
		case VTLPSTR:      CISVTAString vAString;
		case VTLPWSTR:     CISVTWString vWstring;
		case VTEMPTY:      _struct Empty{};
		default:       
		switch
		{
			case (vType & 0xFF00) == 0x2000:   CISVTArray(vType) vArray;
			case (vType & 0xFF00) == 0x1000:  CISVTVector(vType) VVector;
			default:	ReportParserError(2, "Vtype", "Invalid vType") Error;
		}
	}
}

struct CISCCategorizationSet = FormatString("Count: %u",Count)
{
	UINT32 Count;
	CISCCategorizationSpec	Categories[count];
}

struct CISCCategorizationSpec 
{
	CISCColumnSet	CsColumns;
	UINT32 CCategSpec;
}

struct CISCColumnSet = FormatString("Count: %u",Count)
{
	UINT32 Count;
	UINT32 Indexes[Count];
}

struct CISCContentRestriction  
{
	CISCFullPropSpec Property;
	UINT32 Length;
	UnicodeString(Length)	PwcsPhrase;
	ALIGN4 		Pad;
	UINT32 Lcid;
	UINT32 GenerateMethod;
}

Struct CISUnicodeString = FormatString("String: %s",StringValue.toString) {
	UINT32 Length;
	[CISStringValue = StringValue.toString]
	UnicodeString StringValue;
}

struct CISCPropSpec = FormatString("%s",Kind?"PropID: "+PropID:CISStringValue)
{
	UINT32 Kind;
	switch( Kind )
	{
		case 0:	CISUnicodeString StringValue;
		case 1: UINT32 PropID;
	}
}

struct CISCFullPropSpec = FormatString("GUID: %s, %s",GuidPropSet.toString,PsPropSpec.toString)
{
	ALIGN8 paddingPropSet;
	GUID(TRUE) GuidPropSet; 
	CISCPropSpec PsPropSpec; 
}

struct CISCDBColId
{
	UINT32 EKind;
	Align8 Pad;
	switch( EKind )
	{
		case 0://DBKIND_GUID_NAME
		case 1://DBKIND_GUID_PROPID
		case 3://DBKIND_PGUID_NAME
		case 4://DBKIND_PGUID_PROPID
		case 5: GUID(true) Guid;//DBKIND_PROPID
	}

	UINT32 ulId;
	switch ( EKind ) 
	{
		case 0:
			UnicodeString(ulId) vString;
	}
}

struct CISDBProp = FormatString("PropID: %u, PropOptions: %s, PropStatus: %s",DBPropID,CISDbPropOptionsTable( DBPropOptions,FALSE),CISDbPropStatusTable( DBPropStatus,FALSE )  )
{
	UINT32 DBPropID;
	UINT32	DBPropOptions = CISDbPropOptionsTable( this,TRUE );
	UINT32	DBPropStatus = CISDbPropStatusTable( this,TRUE );
	CISCDBColId	ColId;
	Align4 Pad;
	CISCBaseStorageVariant VValue;
}


struct CISCDBPropSet = FormatString("GUID: %s, PropCount: %u",GUID.toString,CProperties)
{
	GUID(TRUE) GUID;
	Align4 Pad;
	UINT32 CProperties;
	[MaxLoopCount=CProperties]
	while [true]
	{
		Align4 Pad;
		CISDBProp AProps; 
	}
}

struct CISCNatLanguageRestriction
{
	CISCFullPropSpec Property;
	Align4 PadCc;
	UINT32 PhraseLength;
	UnicodeString(PhraseLength)	Phrase;
	ALIGN4 PadLcid;
	UINT32 Lcid;
}

struct CISCNodeRestriction
{
	UINT32 CNode;
	CISCRestriction	PaNode[CNode];
}

struct CISCNotRestriction
{
	CISCRestriction Pres;
}

struct CISCPropertyRestriction
{
	UINT32 Relop = CISRelationToPerformTable( this );
	CISCFullPropSpec Property;
	CISCBaseStorageVariant	PrVal;
}

struct CISCVectorRestriction
{
	CISCNodeRestriction	Pres;
	UINT32 	UlRankMethod;
}

struct CISCRestriction  = FormatString("RestrictionType: %s, Weight: %u",CISRestrictionTypeTable(RestrictionType,FALSE ),weight) {
	UINT32 RestrictionType = CISRestrictionTypeTable( this,TRUE );
	INT32	weight;
	switch( RestrictionType )
	{
		case	0x00000001: CISCNodeRestriction     NodeRestrictionAND;
		case	0x00000002: CISCNodeRestriction     NodeRestrictionOR;
		case	0x00000003: CISCNotRestriction      NotRestriction;
		case	0x00000004: CISCContentRestriction  ContentRestriction;
		case	0x00000005: CISCPropertyRestriction PropertyRestriction;
		case	0x00000006: CISCNodeRestriction     ProximityRestriction;
		case	0x00000007: CISCVectorRestriction   VectorRestriction;
		case	0x00000008: CISCNatLanguageRestriction NatLanguageRestriction;
		case	0x00000009: CISCScopeRestriction    ScopeRestriction;
		case	0xFFFFFFFD: CISCNodeRestriction     NodeRestrictionPhrase;
	}
}

table CISBookmarkTable(value)
{
	switch(value)
	{
		case 0x00000000: "DB_NULL_HCHAPTER";
		case 0x00000001: "DBBMK_FIRST";
		case 0x00000002: "DBBMK_LAST";
		default:
			FormatString("Bookmark Handle: 0x%08X", value);
	}
}

struct CISCRowSeekAt = FormatString("Rows to skip: %u, Bookmark: %u",Skip,Bookmark)
{
//	UINT32 Bookmark = CISBookmarkValues( this );
	UINT32 Bookmark = CISBookmarkTable(this);
	UINT32 Skip;
//	UINT32 WatchRegion = FormatString("%s (%u)",this?"Valid watch region":"Invalid watch region",WatchRegion);
	UINT32 Region = FormatString("0x%08X (Must set to 0x00000000)", this);
}

struct CISCRowSeekAtRatio = FormatString("Numerator: %u, Denominator: %u",Numerator,Denominator)
{
//	UINT32 Chapter;
//	UINT32 WatchRegion = FormatString("%s (%u)",this?"Valid watch region":"Invalid watch region",WatchRegion);
	UINT32 Numerator;
	UINT32 Denominator;
	UINT32 Region = FormatString("0x%08X (Must set to 0x00000000)", this);
}


struct CISCRowSeekByBookmark = FormatString("Bookmarks: %u, MaxRetrieval: %u, ValidRetrieval: %u",cBookmarks,MaxRetrieval,ValidRetrieval)
{
	UINT32 cBookmarks;                  //change accroding to #2386(protoDoc)
	UINT32 aBookmarks[cBookmarks];
	UINT32 MaxRetrieval;
	HResult ValidRetrieval[MaxRetrieval];
}

struct CISCRowSeekNext = FormatString("Rows to skip: %u",Skip)
{
	//UINT32 Chapter;
	//UINT32 WatchRegion = FormatString("%s (%u)",this?"Valid watch region":"Invalid watch region",WatchRegion);
	UINT32 Skip;
}

struct CISCRowsetProperties = FormatString("BooleanOptions: %s, CmdTimeOut: %s",BooleanOptions.toString,CmdTimeOut.toString)
{
	UINT32 BooleanOptions = FormatString( "0x%08X", UINT32( FrameData, FrameOffset ) )
	{
		UINT32 Sequential:1 = FormatString("         (%s) %s", this.ToBitString,"The cursor can only be moved forwards");
		UINT32 Locatable:1 = FormatString("          (%s) %s", this.ToBitString,"The cursor can be moved to any position");
		UINT32 Scrollable:1 = FormatString("         (%s) %s", this.ToBitString,"The cursor can be moved to any position and fetch in any direction");
		UINT32 Asynchronous:1 = FormatString("       (%s) %s", this.ToBitString,"The caller will not wait for execution completion");
		UINT32 Reserved1:1 = FormatString("          (%s)", this.ToBitString);
		UINT32 Watchable:1 = FormatString("          (%s) %s", this.ToBitString,"Obsolete and should not used");
		UINT32 GenericOptionString:1 = FormatString("(%s) %s", this.ToBitString,"Unused and should be ignored");
		UINT32 FirstRows:1 = FormatString("          (%s) %s", this.ToBitString,"Return the first rows encountered, not the best matches");
		UINT32 Distributed:1 = FormatString("        (%s) %s", this.ToBitString,"The query is distributed over multiple catalogs or servers");
		UINT32 HoldRows:1 = FormatString("           (%s) %s", this.ToBitString,"The client can hold rows while asking for more");
		UINT32 Reserved2:1 = FormatString("          (%s)", this.ToBitString);
		UINT32 Chaptered:1 = FormatString("          (%s) %s", this.ToBitString,"The rowset supports chapters");
		UINT32 UseCI:1 = FormatString("              (%s) %s", this.ToBitString,"Only answer the query from the index, not the file system");
		UINT32 DeferTrimming:1 = FormatString("      (%s) %s", this.ToBitString,"For queries sorted by rank,do security trimming last");
		UINT32 ExtendedTypes:1 = FormatString("      (%s) %s", this.ToBitString,"The client supports non-automation datatypes in rowsets");
		UINT32 Reserved:17 = FormatString("           (%s)", this.ToBitString);
	}

	UINT32 MaxOpenRows = "Not Used";
	UINT32 MemoryUsage = "Not Used";
	UINT32 MaxResults;
	UINT32 CmdTimeout = FormatString("%u seconds",CmdTimeOut);
}

struct CISCScopeRestriction
{
	UnicodeString LowerPath; 
	ALIGN4   Pad;
	UINT32 Length;
	UINT32 FRecursive = CISQueryPermissionTable( this );
	UINT32 FVirtual = CISPathTypeTable( this ); 
}

struct CISCSort = FormatString("PidColumn: %u, Order: %s, Locate: %u",PidColumn,CISColumnOrderTable( Order,FALSE), Locate)
{
	UINT32 PidColumn;
	UINT32 Order = CISColumnOrderTable( this,TRUE);
	UINT32 Locate;
}

struct CISCSortSet = FormatString("Count: %u",Count)
{
	UINT32 Count;
	CISCSort SortArray[Count];
}

struct CISCTableColumn = FormatString("%s, VarType: %s",FullPropSpec.toString,CISVarTypeValues(VarType))
{
	[CISColumnCountLoop=CISColumnCountLoop+1]
	CISCFullPropSpec FullPropSpec;
	[Conversation.CISTableVarTypeArray$[CISColumnCountLoop]]
	UINT32 VarType = CISVarTypeValues(this);
	UINT8 ValueUsedFlag;
	switch( ValueUsedFlag )
	{
		case 0x01:
		struct
		{
			Align2 Pad1;
			[Conversation.CISValueOffsetArray$[CISColumnCountLoop]]
			UINT16 ValueOffset;
			UINT16 ValueSize;
		}
	}
	UINT8 	StatusUsedFlag;
	switch( StatusUsedFlag )
	{
		case 0x01:
		struct
			{
				Align2 Pad2;
				[Conversation.CISStatusOffsetArray$[CISColumnCountLoop]]
				UINT16 StatusOffset;
			}
	}
	UINT8 LengthUsedFlag;
	switch( LengthUsedFlag )
	{
		case 0x01:
		struct
			{
				Align2 Pad3;
				[Conversation.CISLengthOffsetArray$[CISColumnCountLoop]]
				UINT16 LengthOffset;
			}
	}
}

struct CISCI_State = FormatString("WordList: %u, Queries: %u, State: %s",WordList,Queries,State.toString)
{
	UINT32 StructSize;
	UINT32 WordList;
	UINT32 PersistentIndex;
	UINT32 Queries;
	UINT32 Documents;
	UINT32 FreshTest;
	UINT32 MergeProgress;
	UINT32 State = FormatString( "0x%08X", UINT32( FrameData, FrameOffset ) )
	{
		UINT32 ShadowMerge:1 = FormatString("        (%s) %s", this.ToBitString,this?"A shadow merge is in process":"A shadow merge is NOT in process");
		UINT32 MasterMerge:1 = FormatString("        (%s) %s", this.ToBitString,this?"A master merge is in process":"A master merge is NOT in process");         
		UINT32 ContentScanRequired:1 = FormatString("(%s) %s", this.ToBitString,this?"Indexing Service needs to determine which documents have been added, changed, or deleted":"Indexing Service does NOT require scanning of documents");
		UINT32 AnnealingMerge:1 = FormatString("     (%s) %s", this.ToBitString,this?"An annealing merge is in process":"An annealing merge is NOT in process");      
		UINT32 Scanning:1 = FormatString("           (%s) %s", this.ToBitString,this?"A scan is in process":"A scan is NOT in process");
		UINT32 Recovering:1 = FormatString("         (%s) %s", this.ToBitString,this?"The service is starting from the last saved state and is in the process of recovering":"The service is NOT in the process of recovering");
		UINT32 IndexMigrationMerge:1 = FormatString("(%s) %s", this.ToBitString,this?"The catalog is in the process of being merged for the purpose of migrating the catalog":"The catalog is NOT in the process of merging");
		UINT32 LowMemory:1 = FormatString("          (%s) %s", this.ToBitString,this?"Most of the virtual memory of the computer running Indexing Service is in use":"Virtual memory of the computer running Indexing Service is NOT highly used");
		UINT32 HighIO:1 = FormatString("             (%s) %s", this.ToBitString,this?"The level of input/output (I/O) activity on the computer running Indexing Service is relatively high":"The level of input/output (I/O) activity on the computer running Indexing Service is relatively low"); 
		UINT32 MasterMergePaused:1 = FormatString("  (%s) %s", this.ToBitString,this?"The master merge that was in progress has been paused":"The master merge is in progress");
		UINT32 ReadOnly:1 = FormatString("           (%s) %s", this.ToBitString,this?"The service has been manually paused":"The service has NOT been manually paused");
		UINT32 BatteryPower:1 = FormatString("       (%s) %s", this.ToBitString,this?"The service is paused to conserve battery lifetime":"The service is NOT paused");
		UINT32 UserActive:1 = FormatString("         (%s) %s", this.ToBitString,this?"The service is paused due to high activity by the user (keyboard or mouse)":"The service is NOT paused");
		UINT32 Starting:1 = FormatString("           (%s) %s", this.ToBitString,this?"The service is starting":"The service is stopped");
		UINT32 ReadingUSNS:1 = FormatString("        (%s) %s", this.ToBitString,this?"The service has NOT read the USN journal from one or more volumes being indexed":"The service has read the USN journal from one or more volumes being indexed");
		UINT32 Reserved:17  = FormatString("           (%s)", this.ToBitString);
	}
	UINT32 FilteredDocuments;
	UINT32 TotalDocuments;
	UINT32 PendingScans;
	UINT32 IndexSize;
	UINT32 UniqueKeys;
	UINT32 SecQDocuments;
	UINT32 PropCacheSize;
}

[CISMessageSummary = FormatString("%s, Status: %s",State.toString,Status.toString)]
struct CISCPMCiStateInOut = FormatString("%s, Status: %s",State.toString,Status.toString)
{
	HResult Status;
	UINT32 UlReserved1; 
	UINT32 UlReserved2;
	CISCI_State State;
}

[CISMessageSummary = FormatString("Cursor: %u, Status: %s",Cursor,Status.toString)]
struct CISCPMCompareBmkIn = FormatString("Cursor: %u, Status: %s",Cursor,Status.toString)
{
	HResult Status;
	UINT32 Reserved1;
	UINT32 Reserved2;
	UINT32 Cursor;
	UINT32 Chapter;
	UINT32 BookmarkFirst;
	UINT32 BookmarkSecond;
}

[CISMessageSummary = FormatString("Comparision: %s, Status: %s",CISComparisionTable( Comparision,FALSE),Status.toString)]
struct CISCPMCompareBmkOut = FormatString("Comparision: %s, Status: %s",CISComparisionTable( Comparision,FALSE),Status.toString)
{
	HResult Status;
	UINT32 Reserved1;
	UINT32 Reserved2;
	UINT32 Comparision = CISComparisionTable( this,TRUE ); 
}

[CISMessageSummary = FormatString("ClientOS: %s, MachineName: %s, UserName: %s, Status: %s",CISClientVersionTable( ClientOSVersion ),MachineName.toString,UserName.toString,Status.toString)]
struct CISCPMConnectIn	= FormatString("ClientOS: %s, MachineName: %s, UserName: %s, Status: %s",CISClientVersionTable( ClientOSVersion ),MachineName.toString,UserName.toString,Status.toString)	//Under construction ????
{
	HResult Status;
	UINT32 Checksum;
	UINT32 Reserved2;
	[Conversation.ClientOSVersion]
	UINT32 ClientOSVersion = CISClientVersionTable( this );
	BOOL ClientIsRemote = FormatString("%s",this?"Client is running on a separate machine":"Client is running on the same machine as the server");
	UINT32 CbBlob1;// size of propset1+propset2
	ALIGN8 PadCbBlob2;
	UINT32 CbBlob2;
	BLOB(12) Pad; 
	UnicodeString	MachineName; 
	UnicodeString	UserName;
	ALIGN8 PadCPropSets;
	UINT32 CPropSets;// value is 2 always.
	CISCDBPropSet PropertySet1; 
	CISCDBPropSet PropertySet2; 
	ALIGN8 PadExtPropset;
	UINT32 cExtPropSet;
	CISCDBPropSet aPropertySets[cExtPropSet];
}

[CISMessageSummary = FormatString("ServerVersion: %s, Status: %s",CISServerVersionTable( ServerVersion,FALSE ),Status.toString)]
struct CISCPMConnectOut = FormatString("ServerVersion: %s, Status: %s",CISServerVersionTable( ServerVersion,FALSE ),Status.toString)
{
	HResult Status;
	UINT32 Reserved1;
	UINT32 Reserved2;
	[Conversation.CISServerVersion]
	UINT32 ServerVersion = CISServerVersionTable( this,TRUE ); 
	blob(framelength-frameoffset)		Reserved;
}

struct CISCPidMapper = FormatString("Count: %u",Count)
{
	UINT32 Count;
	Align4 Pad;
	CISCFullPropSpec PropSpec[Count];
}

[CISMessageSummary = FormatString("RowSetProperties: %s, PidMapper: %s, Status: %s",RowSetProperties.toString,PidMapper.toString,Status.toString)]
struct CISCPMCreateQueryIn = FormatString("RowSetProperties: %s, PidMapper: %s, Status: %s",RowSetProperties.toString,PidMapper.toString,Status.toString)
{
	HResult Status;
	UINT32 Checksum;
	UINT32 Reserved2;
	UINT32 Size;
	
	UINT8 CColumnSetPresent;
	switch( CColumnSetPresent )
	{
		case 1:
			struct
			{
				Align4 Pad1;
				CISCColumnSet	ColumnSet;
			}
	}
	
	UINT8 CRestrictionPresent;
	switch
	{
		case CRestrictionPresent > 0: 
			struct
			{
				Align4 Pad2;
				CISCRestriction	CISCRestriction;
			}
	}
	
	UINT8 CSortSetPresent;
	switch
	{
		case CSortSetPresent > 0: 
			struct 
			{
				Align4 Pad3;
				CISCSortSet	SortSet;
			}
	}

	UINT8 CCategorizationSetPresent;
	Align4 Pad4;
	switch
	{
		case CCategorizationSetPresent > 0: 
			CISCCategorizationSet	CategorizationSet;
	}
	
	CISCRowsetProperties RowSetProperties;
	CISCPidMapper PidMapper;
}
	
	
[CISMessageSummary = FormatString("Sequential: %s, WorkIDUnique: %s, Cursors: %u, Status: %s",CISSequential,CISWorkIDUnique,Cursors,Status.toString)]
struct CISCPMCreateQueryOut = FormatString("Sequential: %s, WorkIDUnique: %s, Cursors: %u, Status: %s",CISSequential,CISWorkIDUnique,Cursors,Status.toString)
{
	HResult Status;
	UINT32 Reserved1;
	UINT32 Reserved2;
	[Post.CISSequential = this?"TRUE":"FALSE"]
	BOOL TrueSequential = FormatString("%s - %s",this?"TRUE":"FALSE",CISSequentialTable( this ));
	[Post.CISWorkIDUnique = this?"TRUE":"FALSE"]
	BOOL WorkIDUnique = FormatString("%s - %s",this?"TRUE":"FALSE",CISWorkIdUniqueTable( this ));
	UINT32 Cursors;
}

[CISMessageSummary = FormatString("Status",Status.toString)]
struct CISCPMDisconnect = FormatString("Status",Status.toString)
{
	HResult Status;
	UINT32 Reserved1;
	UINT32 Reserved2;
}

[CISMessageSummary = FormatString("WorkID: %s, %s, Status: %s",WorkID,PropSpec.toString,Status.toString)]
struct CISCPMFetchValueIn = FormatString("WorkID: %s, %s, Status: %s",WorkID,PropSpec.toString,Status.toString)
{
	HResult Status;
	UINT32 Checksum;
	UINT32 Reserved2;
	UINT32 WorkID;
	[Conversation.CISFetchValueInSoFar]
	UINT32 SoFar = FormatString("%u bytes previously transferred",SoFar);
	UINT32 PropSpecSize;
	UINT32 Chunk;
	CISCFullPropSpec PropSpec;
	Align4 padding;
}

[CISMessageSummary = FormatString("MessageSize: %u, MoreExists: %s, ValueExists: %s, Status: %s",Value,CISMoreExists,CISValueExists,Status.toString)]
struct CISCPMFetchValueOut = FormatString("MessageSize: %u, MoreExists: %s, ValueExists: %s, Status: %s",Value,CISMoreExists,CISValueExists,Status.toString)
{
	[Conversation.CISFetchValueInSoFar$[FrameNumber] = Conversation.CISFetchValueInSoFar]
	HResult Status;
	UINT32 Reserved1;
	UINT32 Reserved2;
	UINT32 Value;
	[Post.CISMoreExists = FormatString("%s",this?"TRUE":"FALSE")]
	BOOL MoreExists = FormatString("%s",this?"TRUE - CISCPMFetchValueOut messages are available containing more data":"FALSE - CISCPMFetchValueOut messages are not available");
	[Post.CISValueExists = FormatString("%s",this?"TRUE":"FALSE")]
	BOOL ValueExists = FormatString("%s",this?"TRUE - Value for the property exists":"FALSE - a value for the property does NOT exist");
	switch
	{
		case ValueExists == 1: 
			[
				PayloadStart(
						Property.NetworkDirection, /*direction */
						0, /* id */
						0, /* sequence token */
						0, /* next sequence token */
						0, /* total payload length */
						Conversation.CISFetchValueInSoFar$[FrameNumber] == 0, /* is first */
						!MoreExists, /* is last */
						RssmblyIndStartBit+RssmblyIndEndBit  // Has start, end indication 
						);
			]
			switch
			{
				case Conversation.CISFetchValueInSoFar$[FrameNumber]==0:
					CISSerializedPropertyValue SerializedPropertyValue;
				default:
					Blob(FrameLength - FrameOffset ) SerializedPropertyValueContinuationData;
			}
	}
}


[CISMessageSummary = Property.SMBResponse? FormatString("Status: %s",Status.toString): FormatString("PartitionID: %u, Status: %s",PartitionID,Status.toString)]
struct CISCPMForceMergeIn = Property.SMBResponse? FormatString("Status: %s",Status.toString): FormatString("PartitionID: %u, Status: %s",PartitionID,Status.toString)
{
	HResult Status;
	UINT32 Checksum;
	UINT32 Reserved2;
	switch(Property.SMBResponse )
	{
		case false: UINT32 PartitionID;
	}
}

[CISMessageSummary = FormatString("Cursor: %u, Status: %s",Cursor,Status.toString)]
struct CISCPMFreeCursorIn = FormatString("Cursor: %u, Status: %s",Cursor,Status.toString)
{
	HResult Status;
	UINT32 Reserved1;
	UINT32 Reserved2;
	UINT32 Cursor;
}

[CISMessageSummary = FormatString("CursorsRemaining: %u, Status: %s",CursorsRemaining,Status.toString)]
struct CISCPMFreeCursorOut = FormatString("CursorsRemaining: %u, Status: %s",CursorsRemaining,Status.toString)
{
	HResult Status;
	UINT32 Reserved1;
	UINT32 Reserved2;
	UINT32 CursorsRemaining;
}

[CISMessageSummary = FormatString("Cursor: %u, Status: %s",Cursor,Status.toString)]
struct CISCPMGetApproximatePositionIn = FormatString("Cursor: %u, Status: %s",Cursor,Status.toString)
{
	HResult Status;
	UINT32 Reserved1;
	UINT32 Reserved2;
	UINT32 Cursor;
	UINT32 Chapter;
	UINT32 Bookmark = CISBookmarkTable( this );
}

[CISMessageSummary = FormatString("Numerator: %u, Denominator: %u, Status: %s", Numerator,Denominator,Status.toString)]
struct CISCPMGetApproximatePositionOut = FormatString("Numerator: %u, Denominator: %u, Status: %s", Numerator,Denominator,Status.toString)
{
	HResult Status;
	UINT32 Reserved1;
	UINT32 Reserved2;
	UINT32 Numerator;
	UINT32 Denominator;
}

[CISMessageSummary = FormatString("Status: %s",Status.toString)]
struct CISCPMGetNotify = FormatString("Status: %s",Status.toString)
{
	HResult Status;
	UINT32 Reserved1;
	UINT32 Reserved2;
}

[CISMessageSummary = FormatString("RowsToTransfer: %u, RowsWidth: %u, Type: %u, Status: %s",RowsToTransfer,RowsWidth,Type,Status.toString)]
struct CISCPMGetRowsIn = FormatString("RowsToTransfer: %u, RowsWidth: %u, Type: %u, Status: %s",RowsToTransfer,RowsWidth,Type,Status.toString)
{
	HResult Status;
	UINT32 Checksum;
	UINT32 Reserved2;
	UINT32 Cursor;
	UINT32 RowsToTransfer;
	UINT32 RowsWidth;
	[Conversation.CISSeek$[FrameNumber] = Seek]
	UINT32 Seek;
	[Conversation.RowsOffset]
	UINT32 Reserved;
	UINT32 ReadBuffer;
	[Conversation.CISClientBase]
	UINT32 ClientBase;
	UINT32 Fetch = CISBwdFetchTable( this );
	UINT32 Type = CISCPMGetRowsIntable( this ) ;
	UINT32 Chapter;
	switch( Type )
	{
		case 0x00000001:CISCRowSeekNext 		RowSeekNext;
		case 0x00000002:CISCRowSeekAt			RowSeekAt;
		case 0x00000003:CISCRowSeekAtRatio		RowSeekAtRatio;
		case 0x00000004:CISCRowSeekByBookmark	RowSeekByBookmark;
	}
}

Table CISCPMGetRowsIntable(value)
{
	switch(value)
	{
		case 0x00000001: FormatString( "eRowSeekNext");
		case 0x00000002: FormatString( "eRowSeekAt");
		case 0x00000003: FormatString( "eRowSeekAtRatio");
		case 0x00000004: FormatString( "eRowSeekByBookmark");
	}
}

Table CISCPMGetRowsOuttable(value)
{
	switch(value)
	{
		case 0x00000000: FormatString( "eRowsSeekNone");
		case 0x00000001: FormatString( "eRowSeekNext");
		case 0x00000002: FormatString( "eRowSeekAt");
		case 0x00000003: FormatString( "eRowSeekAtRatio");
		case 0x00000004: FormatString( "eRowSeekByBookmark");
	}
}

[CISMessageSummary = FormatString("RowsReturned: %u, Status: %s",RowsReturned,Status.toString)]
struct CISCPMGetRowsOut = FormatString("RowsReturned: %u, Status: %s",RowsReturned,Status.toString)
{ 
	HResult Status;
	UINT32 Reserved1;
	[Property.Reserved2]
	UINT32 Reserved2;
	[conversation.Rowscount]
	UINT32 RowsReturned;
	UINT32 Type = CISCPMGetRowsOuttable(this);
	UINT32 Chapter;
	switch(Type)
	{
		case 0x00000000:_struct NoSeekDescription{};
		case 0x00000001:CISCRowSeekNext		RowSeekNext;
		case 0x00000002:CISCRowSeekAt		RowSeekAt;
		case 0x00000003:CISCRowSeekAtRatio		RowSeekAtRatio;
		case 0x00000004:CISCRowSeekByBookmark		RowSeekByBookmark; 
	}
	BLOB(Conversation.RowOffset$[FrameNumber]- CurrentProtocolOffset) Padding;
	CISColumnArray Row[RowsReturned] = FormatString("%u, Columns: %u",CISRowCount,Conversation.CISNumColumn$[FrameNumber]);
	while cond[FrameOffset<FrameLength]
	{
		[local.CBaseStorageVarianOffset=FrameOffset]
		switch(Conversation.CISVarTypeArray$[CISColumncount])
		{
		case 0x000C:
		[
			local.tmpRowOffset = Conversation.CISRowVariantOffset32$[CISRowCount],
			local.tmpClientBase = Conversation.CISClientBases$[framenumber],
			local.tmpProtocolOffset = CurrentProtocolOffset,
			local.tmp = local.tmpRowOffset - local.tmpClientBase - local.tmpProtocolOffset
		]
		_struct
		{
			Blob(ProtocolOffset+local.tmp-local.CBaseStorageVarianOffset) Pad1;
			CISCBaseStorageVariant CBaseStorageVariant;
		}
		default:Blob(FrameLength-FrameOffset) ColumnVariantData;
		}
	}
}

struct CISCRowVariant=Formatstring("VariantData:%s",VariantData)
{
	[Conversation.CISVarTypeArray$[CISColumncount]]
	UINT16 vType=CISVarTypeValues(this);
	UINT16 reserved1;
	UINT32 reserved2;
	switch(vType)
	{
		case 0x001F:
		switch
		{
			case Conversation.CISClientOSVersion$[framenumber]<=0x00000008:
			case Conversation.CISClientOSVersion$[framenumber]>=0x00000008 && Conversation.CISServerVersion$[framenumber]==0x00000007:
			[
			local.tmpRowOffset = UINT32(FrameData, FrameOffset),
			local.tmpClientBase = Conversation.CISClientBases$[framenumber],
			local.tmpProtocolOffset = CurrentProtocolOffset,
			local.tmp = local.tmpRowOffset - local.tmpClientBase - local.tmpProtocolOffset,
			Conversation.CISRowVariantOffset32$[framenumber]= RowVariantOffset32,
			OffSet32=1,
			VariantData=UnicodeString(Framedata,FrameOffset+local.tmp)
			]
			UINT32 RowVariantOffset32;
			case Conversation.CISClientOSVersion$[framenumber]>=0x00000008 && Conversation.CISServerVersion$[framenumber]==0x00010007:
			[
			local.tmpRowOffset64 = UINT64(FrameData, FrameOffset),
			local.tmpClientBase64 = Conversation.CISClientBases$[framenumber],
			local.tmpProtocolOffset64 = CurrentProtocolOffset,
			local.tmp64 = local.tmpRowOffset64 - local.tmpClientBase64 - local.tmpProtocolOffset64,
			Conversation.CISRowVariantOffset64$[framenumber]= RowVariantOffset64,
			OffSet32=0,
			VariantData=UnicodeString(Framedata,FrameOffset+local.tmp64)
			]
			UINT64 RowVariantOffset64;
		}
		case 0x001E: 
		switch
		{
			case Conversation.CISClientOSVersion$[framenumber]<=0x00000008: 
			case Conversation.CISClientOSVersion$[framenumber]>=0x00000008 && Conversation.CISServerVersion$[framenumber]==0x00000007:
			[
			local.tmpRowOffset = UINT32(FrameData, FrameOffset),
			local.tmpClientBase = Conversation.CISClientBases$[framenumber],
			local.tmpProtocolOffset = CurrentProtocolOffset,
			local.tmp = local.tmpRowOffset - local.tmpClientBase - local.tmpProtocolOffset,
			Conversation.CISRowVariantOffset32$[framenumber]= RowVariantOffset32,
			OffSet32=1,
			VariantData=AsciiString(Framedata,FrameOffset+local.tmp)
			]
			UINT32 RowVariantOffset32;
			case Conversation.CISClientOSVersion$[framenumber]>=0x00000008 && Conversation.CISServerVersion$[framenumber]==0x00010007:
			[
			local.tmpRowOffset64 = UINT64(FrameData, FrameOffset),
			local.tmpClientBase64 = Conversation.CISClientBases$[framenumber],
			local.tmpProtocolOffset64 = CurrentProtocolOffset,
			local.tmp64 = local.tmpRowOffset64 - local.tmpClientBase64 - local.tmpProtocolOffset64,
			Conversation.CISRowVariantOffset64$[framenumber]= RowVariantOffset64,
			OffSet32=0,
			VariantData=AsciiString(Framedata,FrameOffset+local.tmp64)
			]
			UINT64 RowVariantOffset64;
		}
		case 0x000C:
		switch
		{
			case Conversation.CISClientOSVersion$[framenumber]<=0x00000008: 
			case Conversation.CISClientOSVersion$[framenumber]>=0x00000008 && Conversation.CISServerVersion$[framenumber]==0x00000007:
			[
			OffSet32=1,
			VariantData="CBaseStorageVariantstruct",Conversation.CISRowVariantOffset32$[CISRowCount]
			]
			UINT32 RowVariantOffset32;
			case Conversation.CISClientOSVersion$[framenumber]>=0x00000008 && Conversation.CISServerVersion$[framenumber]==0x00010007:
			[
			OffSet32=0,
			VariantData="CBaseStorageVariantstruct",Conversation.CISRowVariantOffset64$[CISRowCount]
			]
			UINT64 RowVariantOffset64;
		}
	}
}

Table CISStatusarraytable(value)
{
	switch(value)
	{
	case 0x00: FormatString( "StatusOK");
	case 0x01: FormatString( "StatusDeferred");
	case 0x02: FormatString( "StatusNull");
	}
}

struct CISColumnArray 
{
	[Post.CISValueOffsetCount=0, Post.CISLengthOffsetCount=0,Post.CISVarTypeCount=0, 
	CISRowCount = CISRowCount + 1,local.rowcount=CISRowCount,
	CISStringRowCount = CISStringRowCount + 1]
	[local.RowstartOffset=FrameOffset]
	[Rowendoffset=CurrentProtocolOffset+Conversation.CISRowSizeTable$[FrameNumber]]
	[MaxLoopCount = Rowendoffset - CurrentProtocolOffset]
	while row[CurrentProtocolOffset<Rowendoffset]
	{
		[local.dataConsumed = false, local.startOffset=FrameOffset-local.RowstartOffset,CISColumncount =0]
		[MaxLoopCount = Conversation.CISNumColumn$[FrameNumber]]
		while col[CISColumncount<Conversation.CISNumColumn$[FrameNumber]]
		{
			[CISColumncount = CISColumncount+1]
			switch
			{
			case local.startOffset == Conversation.CISValueOffsetArray$[CISColumncount]: 
			[local.dataConsumed = true]
			struct Columnvalue =FormatString("Row:%d,Col:%d,ValueType:%s,Columnvalue:%s",CISRowCount,CISColumncount,CISVarTypeValues(Conversation.CISTableVarTypeArray$[CISColumncount]),CISColumnValueSummary)
			{
				switch(Conversation.CISTableVarTypeArray$[CISColumncount])
				{
					case 0x00: [CISColumnValueSummary]_struct VTEmpty{};
					case 0x01: [CISColumnValueSummary]_struct VTNull{};
					case 0x02: [CISColumnValueSummary]INT16 I2Value;
					case 0x03: [CISColumnValueSummary]INT32 I4Value;
					case 0x04: [CISColumnValueSummary]Float R4Value;
					case 0x05: [CISColumnValueSummary]Double R8Value;
					case 0x06: [CISColumnValueSummary]CISCurrency Currency;
					case 0x07: [CISColumnValueSummary]Double Date;
					case 0x08: [CISColumnValueSummary]UINT32 BSTR;
					case 0x10: [CISColumnValueSummary]INT8 I1Value;
					case 0x11: [CISColumnValueSummary]UINT8 UI1Value;
					case 0x12: [CISColumnValueSummary]UINT16 UI2Value;
					case 0x13: [CISColumnValueSummary][CISVTUI4 = UI4Value]UINT32 UI4Value;
					case 0x14: [CISColumnValueSummary]INT64 I8Value;
					case 0x15: [CISColumnValueSummary]UINT64 UI8Value;
					case 0x16: [CISColumnValueSummary]INT32 INTValue;
					case 0x17: [CISColumnValueSummary]UINT32 UINTValue;
					case 0x0A: [CISColumnValueSummary]HRESULT ERROR;
					case 0x0B: [CISColumnValueSummary]VARIANTBOOL BOOLValue;
					case 0x0E: [CISColumnValueSummary]CISDecimal DecimalValue;
					case 0x40: [CISColumnValueSummary]FILETIME Time;
					case 0x41: [CISColumnValueSummary]UINT32 BLOB;
					case 0x48: [CISColumnValueSummary]GUID(true) CLSID;
					case 0x1E:
					case 0x1F:
					case 0x0C:
										[Post.CISColumnValueSummary=VariantData]CISCRowVariant CRowVariant;
				}
			}
			case local.startOffset == Conversation.CISStatusOffsetArray$[CISColumncount]:
				[local.dataConsumed = true] 
				struct Columnstatus =FormatString("Row: %d,Col:%d,Status:%s",CISRowCount,CISColumncount,CISStatusarraytable(CISStatus))
				{
					UINT8 CISStatus;
				}
			case local.startOffset == Conversation.CISLengthOffsetArray$[CISColumncount] && !IsValueNone(Conversation.CISLengthOffsetArray$[CISColumncount]):  
				[local.dataConsumed = true]
				struct Columnlength =FormatString("Row: %d,Col:%d,Length:%d",CISRowCount,CISColumncount,CISLength)
				{
					UINT32 CISLength;
				}
			}
		}
		switch
		{
			case !local.dataConsumed:
				UINT8 Pad;
		}
	}
}
	
[CISMessageSummary = FormatString("Cursor: %u, Status: %s",Cursor,Status.toString)]
struct CISCPMGetQueryStatusExIn = FormatString("Cursor: %u, Status: %s",Cursor,Status.toString)
{
	HResult Status;
	UINT32 Reserved1;
	UINT32 Reserved2;
	UINT32 Cursor;
	UINT32 Bookmark;
}

[CISMessageSummary = FormatString("TotalRows: %u, QueryStatus: %s, Status: %s",RowsTotal,QueryStatus.toString,Status.toString)]
struct CISCPMGetQueryStatusExOut = FormatString("TotalRows: %u, QueryStatus: %s, Status: %s",RowsTotal,QueryStatus.toString,Status.toString)
{
	HResult Status;
	UINT32 Reserved1;
	UINT32 Reserved2;
	CISQueryStatus	QueryStatus;
	UINT32 FilterdDocumnets;
	UINT32 DocumentsToFilter;
	UINT32 RatioFinishedDenominator;
	UINT32 RatioFinishedNumerator;
	UINT32 RowBookmark;
	UINT32 RowsTotal;
}

[CISMessageSummary = FormatString("Cursor: %u, Status: %s",Cursor,Status.toString)]
struct CISCPMGetQueryStatusIn = FormatString("Cursor: %u, Status: %s",Cursor,Status.toString)
{
	HResult Status;
	UINT32 Reserved1; 
	UINT32 Reserved2;
	UINT32 Cursor;
}

[CISMessageSummary = FormatString("QueryStatus: %s, Status: %s",QueryStatus.toString,Status.toString)]
struct CISCPMGetQueryStatusOut	= FormatString("QueryStatus: %s, Status: %s",QueryStatus.toString,Status.toString)
{
	HResult Status;
	UINT32 Reserved1;
	UINT32 Reserved2;
	CISQueryStatus QueryStatus;
}

[CISMessageSummary = FormatString("Cursor: %u, Status: %s",Cursor,Status.toString)]
struct CISCPMRatioFinishedIn = FormatString("Cursor: %u, Status: %s",Cursor,Status.toString)
{
	HResult Status;
	UINT32 Reserved1;
	UINT32 Reserved2;
	UINT32 Cursor;
	UINT32 Quick; 
}

[CISMessageSummary = FormatString("Numerator: %u, Denominator: %u, Rows: %u, Status: %s",Numerator,Denominator,Rows,Status.toString)]
struct CISCPMRatioFinishedOut = FormatString("Numerator: %u, Denominator: %u, Rows: %u, Status: %s",Numerator,Denominator,Rows,Status.toString)
{
	HResult Status;
	UINT32 Reserved1;
	UINT32 Reserved2;
	UINT32 Numerator;
	UINT32 Denominator;
	UINT32 Rows;
	BOOL NewRows = CISNewRowsTable( this );
}

[CISMessageSummary = FormatString("Cursor: %u, Status: %s",Cursor,Status.toString)]
struct CISCPMRestartPositionIn = FormatString("Cursor: %u, Status: %s",Cursor,Status.toString)
{
	HResult Status;
	UINT32 Reserved1;
	UINT32 Reserved2;
	UINT32 Cursor;
	UINT32 Chapter;
}

[CISMessageSummary = FormatString("RowSize: %u, Columns: %u, Status: %s",RowSize,Columns,Status.toString)]
struct CISCPMSetBindingsIn = FormatString("RowSize: %u, Columns: %u, Status: %s",RowSize,Columns,Status.toString)//Same struct used for Request and Response
{
	HResult Status;
	UINT32 Checksum;
	UINT32 Reserved2;
	switch(Property.SMBResponse)
	{
		case false:
			_Struct
			{
				UINT32 Cursor;
				[Conversation.CISRowSize]
				UINT32 RowSize;
				UINT32 BindingDesc;
				UINT32 Dummy;
				[Conversation.CISNumColumns]
				UINT32 Columns;
				[CISColumnCountLoop=0]
				CISCTableColumn TableColumn[Columns];				
			}
	}
}

[CISMessageSummary = FormatString("Status: %s",Status.toString)]
struct CISCPMSetBindingsOut = FormatString("Status: %s",Status.toString){
	HResult Status;
	UINT32 Reserved1;
	UINT32 Reserved2;
}

[CISMessageSummary = FormatString("Cursor: %u, Status: %s",Cursor,Status.toString)]
struct CISCPMStopAsynchIn = FormatString("Cursor: %u, Status: %s",Cursor,Status.toString)
{
	HResult Status;
	UINT32 Reserved1;
	UINT32 Reserved2;
	UINT32 Cursor;
}

[CISMessageSummary = FormatString("CatalogName: %s, PartitionID: %u, NewState: %s, Status: %s",CatalogName.toString, PartitionID,CISStateTable( NewState,FALSE ), Status.toString)]
struct CISCPMSetCatStateIn = FormatString("CatalogName: %s, PartitionID: %u, NewState: %s, Status: %s",CatalogName.toString, PartitionID, CISStateTable( NewState,FALSE),Status.toString)
{
	HResult Status; 
	UINT32 Reserved1;
	UINT32 Reserved2;
	UINT32 PartitionID;
	UINT32 NewState = CISStateTable( this,TRUE );
	UnicodeString CatalogName;
}

[CISMessageSummary = FormatString("OldState: %s, Status: %s",CISStateTable( OldState,FALSE),Status.toString)]
struct CISCPMSetCatStateOut = FormatString("OldState: %s, Status: %s",CISStateTable( OldState,FALSE),Status.toString)
{
	HResult Status;
	UINT32 Reserved1;
	UINT32 Reserved2;
	UINT32 OldState = CISStateTable( this,TRUE );
}

[CISMessageSummary = FormatString("Flag: %s, Status: %s",CISUpdateTable( Flag,FALSE ),Status.toString)]
struct CISCPMUpdateDocumentsIn = FormatString("Flag: %s, Status: %s",CISUpdateTable( Flag,FALSE ),Status.toString)
{
	HResult Status;
	UINT32 Reserved1;
	UINT32 Reserved2;
	switch(Property.SMBResponse)
	{
		case false:
			_struct
			{
				UINT32 Flag = CISUpdateTable( this,TRUE );
				BOOL RootPath;
				switch
				{
					case RootPath != 0 && Property.SMBResponse == false: UnicodeString	RootPathString;
				}
			}
	}
}

[CISMessageSummary = FormatString("Status: %s",Status.toString)]
struct CISCPMSendNotifyOut = FormatString("Status: %s",Status.toString)
{
	HResult Status;
	UINT32 Reserved1;
	UINT32 Reserved2;
	UINT32 WatchNotify=CISWatchNotifyTable(this);
}

Table CISWatchNotifyTable(value)
{
	switch( value )
	{
		case 1:"DBWATCHNOTIFY_ROWSCHANGED";
		case 2:"DBWATCHNOTIFY_QUERYDONE";
		case 3:"DBWATCHNOTIFY_QUERYREEXECUTED";
		default:FormatString("Unknown Value %s",value);
	}
}

Struct CISQueryStatus = FormatString( "0x%08X", UINT32( FrameData, FrameOffset ) )
{
	UINT32 QueryStatus = FormatString( "0x%08X", UINT32( FrameData, FrameOffset ) )
	{
		UINT32 StatStatus:3  = FormatString("                (%s) %s", this.ToBitString,CISStatusTable(this));
		UINT32 Reserved1:1  = FormatString("                 (%s)", this.ToBitString);
		UINT32 StatNoiseWords:1  = FormatString("            (%s) %s", this.ToBitString,"Noise words were replaced by wildcard characters in the content query");
		UINT32 StatContentOutOfDate:1  = FormatString("      (%s) %s", this.ToBitString,"The results of the query might be incorrect because the query involved modified, but unindexed, files");
		UINT32 StatRefreshIncomplete:1  = FormatString("     (%s) %s", this.ToBitString,"The results of the query might be incorrect because the query involved modified and re-indexed files whose content wasn't included");
		UINT32 StatContentQueryIncomplete:1  = FormatString("(%s) %s", this.ToBitString,"The content query was too complex to complete or required enumeration instead of use of the content index");
		UINT32 StatTimeLimitExceeded:1  = FormatString("     (%s) %s", this.ToBitString,"The results of the query might be incorrect because the query execution time reached the maximum allowable time");
		UINT32 Reserved2:23 = FormatString("                 (%s)", this.ToBitString);
	}
}

table CISStatusTable(value)
{
	switch(value)
	{
		case 0x00000000: FormatString("The asynchronous query is still running 0x%02X", value);
		case 0x00000001: FormatString("The query is in an error state 0x%02X", value);
		case 0x00000002: FormatString("The query is complete 0x%02X", value);
		case 0x00000003: FormatString("The query is complete, but updates are resulting in additional query computation 0x%02X", value);
		default:	FormatString("Unknown Status = 0x%02X" , value);
	}
}

/*Struct CISHResult = FormatString( "%s (0x%08X)",Status?WinErrorCodeNameTable( UINT16(FrameData,FrameOffset) ):"S_OK",UINT32(FrameData,FrameOffset)) {
	UINT32 Status = FormatString("0x%08X",UINT32(FrameData,FrameOffset))
	{
		UINT32 SeverityCode:2 = FormatString("(%s) %s",this.ToBitString, CISHResultSeverityCodeValues(this.ToBitstring));
		UINT32 CustomerCode:1 = FormatString("(%s)", this.ToBitString);
		UINT32 Reserved:1 = FormatString("    (%s)", this.ToBitString);
		UINT32 FacilityCode:12 = FormatString("(%s)", this.ToBitString);
		UINT32 Code:16 = FormatString("        (%s)", this.ToBitString);
	}
}*/

table CISMessageTypeInTable(MessageType)
{
	switch( MessageType )
	{
		case 0x000000C8: "CPMConnectIn";//200
		case 0x000000C9: "CPMDisconnect";//201
		case 0x000000CA: "CPMCreateQueryIn";//202
		case 0x000000CB: "CPMFreeCursorIn";//203
		case 0x000000CC: "CPMGetRowsIn";//204
		case 0x000000CD: "CPMRatioFinishedIn";//205
		case 0x000000CE: "CPMCompareBmkIn";//206
		case 0x000000CF: "CPMGetApproximatePositionIn";//207
		case 0x000000D0: "CPMSetBindingsIn";//208 
		case 0x000000D1: "CPMGetNotify";//209
		case 0x000000D7: "CPMGetQueryStatusIn";//215
		case 0x000000D9: "CPMCiStateInOut";//217
		case 0x000000E1: "CPMForceMergeIn";//225
		case 0x000000E4: "CPMFetchValueIn";//228
		case 0x000000E6: "CPMUpdateDocumentsIn";//230
		case 0x000000E7: "CPMGetQueryStatusExIn";//231
		case 0x000000E8: "CPMRestartPositionIn";//232
		case 0x000000E9: "CPMStopAsynchIn";//233
		case 0x000000EC: "CPMSetCatStateIn";//236
		Default:         "Undefined Message";
	}
}
table CISMessageTypeOutTable(MessageType)
{
	switch( MessageType )
	{
		case 0x000000C8: "CPMConnectOut";//200
		case 0x000000CA: "CPMCreateQueryOut";//202
		case 0x000000CB: "CPMFreeCursorOut";//203
		case 0x000000CC: "CPMGetRowsOut";//204
		case 0x000000CD: "CPMRatioFinishedOut";//205
		case 0x000000CE: "CPMCompareBmkOut";//206
		case 0x000000CF: "CPMGetApproximatePositionOut";//207
		case 0x000000D0: "CPMSetBindingsIn";//208
		case 0x000000D1: "CPMGetNotify";//209
		case 0x000000D2: "CPMSendNotifyOut";//210
		case 0x000000D7: "CPMGetQueryStatusOut";//215
		case 0x000000D9: "CPMCiStateInOut";//217
		case 0x000000E1: "CPMForceMergeIn";//225
		case 0x000000E4: "CPMFetchValueOut";//228
		case 0x000000E6: "CPMUpdateDocumentsIn";//230
		case 0x000000E7: "CPMGetQueryStatusExOut";//231
		case 0x000000E8: "CPMRestartPositionIn";//232
		case 0x000000EC: "CPMSetCatStateOut";//236
		Default:         "Undefined Message";
	}
}

Table CISMessageTypeTable(Response, MessageType)
{
	switch(Response)
	{
		case  true: CISMessageTypeOutTable(MessageType);
		case false: CISMessageTypeInTable(MessageType);
	}
}

