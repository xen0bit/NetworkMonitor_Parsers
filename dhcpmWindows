//#  (c) 2009 CodePlex Foundation
//#
//#  Title:                  Microsoft Dynamic Host Configuration Protocol (DHCP) Server Management Protocol
//#
//#  Details:                
//#
//#  Microsoft References:   [MS-DHCPM]: Microsoft Dynamic Host Configuration Protocol (DHCP) Server Management Protocol Specification (9.0)
//#
//#  Comments:               Parser Framework: PAC v2.1.1577.0
//#                          Microsoft implementation is encrypted
//#
//#  Revision Class and Date:Major, 7/29/2009
//#                          Minor, 3/2/2010
//#
//####

Protocol DHCPM = FormatString( "%s %s%s%s%s%s", 
	Property.DHCPMMethodName,
	Property.MSRPCPType ? "Response" : "Request",
	Property.MSRPCPfcFlags & 0x03 == 0x01 ? ", RPC first fragment" : "",
	Property.MSRPCCompleteFrag == 0 ? ", partial" : "",
	Property.MSRPCEncrypted == ConstEncTypeEncrypted ? ", *Encrypted*" : Property.MSRPCEncrypted == ConstEncTypeUnknown ? "*Un-Interpreted*" : "",
	Property.DHCPMSummary && Property.MSRPCEncrypted == ConstEncTypeClearData ? ", " + Property.DHCPMSummary : "" )
{
	[Property.DHCPMSummary = ""]
	Switch( Property.MSRPCIfUuid )
	{
		Case "{6BFFD098-A112-3610-9833-46C3F874532D}":
			[Property.DHCPMMethodName = "dhcpsrv:" + DHCPMdhcpsrvMethodNameTable( Property.MSRPCOpnum )]
			_Struct dhcpsrv
			{
				Switch( Property.MSRPCOpnum )
				{
					Case 0:
						_Struct RDhcpCreateSubnet
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s SubnetAddress=%u", ServerIpAddress.ToString, SubnetAddress )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad1;
													IPv4Address SubnetAddress;
													NDRAlign Pad2;
													DHCPMDhcpSubnetInfo SubnetInfo;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%d: %s", ReturnValue, WinErrorCodeTable(ReturnValue ) )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 1:
						_Struct RDhcpSetSubnetInfo
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s SubnetAddress=%u", ServerIpAddress.ToString, SubnetAddress )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad1;
													IPv4Address SubnetAddress;
													NDRAlign Pad2;
													DHCPMDhcpSubnetInfo SubnetInfo;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%d: %s", ReturnValue, WinErrorCodeTable(ReturnValue ) )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 2:
						_Struct RDhcpGetSubnetInfo
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s SubnetAddress=%u", ServerIpAddress.ToString, SubnetAddress )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad;
													IPv4Address SubnetAddress;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%d: %s", ReturnValue, WinErrorCodeTable(ReturnValue ) )]
												Struct
												{
													NdrPtr SubnetInfoPtr;
													Switch 
													{
														Case SubnetInfoPtr.ReferentID > 0:
															DHCPMDhcpSubnetInfo SubnetInfo;
													}
													Align4 Pad;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 3:
						_Struct RDhcpEnumSubnets
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s ResumeHandle=%u PreferredMaximum=%u", ServerIpAddress.ToString, ResumeHandle, PreferredMaximum )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad;
													UINT32 ResumeHandle;
													UINT32 PreferredMaximum;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ResumeHandle=%u ElementsRead=%u ElementsTotal=%u ReturnValue=%u", ResumeHandle, ElementsRead, ElementsTotal, ReturnValue )]
												Struct
												{
													UINT32 ResumeHandle;
													NdrPtr DhcpIpArrayPtr;
													Switch 
													{
														Case DhcpIpArrayPtr.ReferentID > 0:
															DHCPMDhcpIpArray DhcpIpArray;
													}
													UINT32 ElementsRead;
													UINT32 ElementsTotal;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 4:
						_Struct RDhcpAddSubnetElement
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s SubnetAddress=%u", ServerIpAddress.ToString, SubnetAddress )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad1;
													UINT32 SubnetAddress;
													NdrAlign Pad2;
													DHCPMDhcpSubnetElementData AddElementInfo;
													DHCPMDhcpSubnetElementDataRef AddElementInfoRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%d: %s", ReturnValue, WinErrorCodeTable(ReturnValue ) )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 5:
						_Struct RDhcpEnumSubnetElements
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s SubnetAddress=%u ResumeHandle=%u PreferredMaximum=%u", ServerIpAddress.ToString, SubnetAddress, ResumeHandle, PreferredMaximum )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad1;
													IPv4Address SubnetAddress;
													NdrEnum EnumElementType = DHCPMDhcpSubnetElementTypeTable(this.value);
													Align4 Pad2;
													UINT32 ResumeHandle;
													UINT32 PreferredMaximum;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ResumeHandle=%u ElementsRead=%u ElementsTotal=%u ReturnValue=%u", ResumeHandle, ElementsRead, ElementsTotal, ReturnValue )]
												Struct
												{
													UINT32 ResumeHandle;
													NdrPtr DhcpSubnetElementInfoArrayPtr;
													Switch {
														Case DhcpSubnetElementInfoArrayPtr.ReferentID > 0:
															DHCPMDhcpSubnetElementInfoArray DhcpSubnetElementInfoArray;
													}
													Align4 Pad;
													UINT32 ElementsRead;
													UINT32 ElementsTotal;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 6:
						_Struct RDhcpRemoveSubnetElement
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s SubnetAddress=%u", ServerIpAddress.ToString, SubnetAddress )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad1;
													IPv4Address SubnetAddress;
													NdrAlign Pad2;
													DHCPMDhcpSubnetElementData RemoveElementInfo;
													DHCPMDhcpSubnetElementDataRef RemoveElementInfoRef;
													NdrEnum ForceFlag = DHCPMDhcpForceFlagTable(this.value);
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%d: %s", ReturnValue, WinErrorCodeTable(ReturnValue ) )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 7:
						_Struct RDhcpDeleteSubnet
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s SubnetAddress=%u", ServerIpAddress.ToString, SubnetAddress )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad;
													IPv4Address SubnetAddress;
													NdrEnum ForceFlag = DHCPMDhcpForceFlagTable(this.value);
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%d: %s", ReturnValue, WinErrorCodeTable(ReturnValue ) )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 8:
						_Struct RDhcpCreateOption
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s OptionID=%u", ServerIpAddress.ToString, OptionID )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad1;
													UINT32 OptionID;
													NdrAlign Pad2;
													DHCPMDhcpOption OptionInfo;
													DHCPMDhcpOptionRef OptionInfoRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%d: %s", ReturnValue, WinErrorCodeTable(ReturnValue ) )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 9:
						_Struct RDhcpSetOptionInfo
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s OptionID=%u", ServerIpAddress.ToString, OptionID )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad1;
													UINT32 OptionID;
													NdrAlign Pad2;
													DHCPMDhcpOption OptionInfo;
													DHCPMDhcpOptionRef OptionInfoRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%d: %s", ReturnValue, WinErrorCodeTable(ReturnValue ) )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 10:
						_Struct RDhcpGetOptionInfo
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s OptionID=%u", ServerIpAddress.ToString, OptionID )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad;
													UINT32 OptionID;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%d: %s", ReturnValue, WinErrorCodeTable(ReturnValue ) )]
												Struct
												{
													NdrPtr OptionInfoPtr;
													Switch {
														Case OptionInfoPtr.ReferentID > 0:
															Struct
															{
																DHCPMDhcpOption OptionInfo;
																DHCPMDhcpOptionRef OptionInfoRef;
															}
													}
													Align4 Pad;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 11:
						_Struct RDhcpRemoveOption
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s OptionID=%u", ServerIpAddress.ToString, OptionID )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad;
													UINT32 OptionID;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%d: %s", ReturnValue, WinErrorCodeTable(ReturnValue ) )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 12:
						_Struct RDhcpSetOptionValue
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s OptionID=%u", ServerIpAddress.ToString, OptionID )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad1;
													UINT32 OptionID;
													NdrAlign Pad2;
													DHCPMDhcpOptionScopeInfo ScopeInfo;
													DHCPMDhcpOptionScopeInfoRef ScopeInfoRef;
													NdrAlign Pad3;
													DHCPMDhcpOptionData OptionValue;
													DHCPMDhcpOptionDataRef OptionValueRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%d: %s", ReturnValue, WinErrorCodeTable(ReturnValue ) )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 13:
						_Struct RDhcpGetOptionValue
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s OptionID=%u", ServerIpAddress.ToString, OptionID )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad1;
													UINT32 OptionID;
													NdrAlign Pad2;
													DHCPMDhcpOptionScopeInfo ScopeInfo;
													DHCPMDhcpOptionScopeInfoRef ScopeInfoRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%d: %s", ReturnValue, WinErrorCodeTable(ReturnValue ) )]
												Struct
												{
													NdrPtr OptionValuePtr;
													Switch
													{
														Case OptionValuePtr.ReferentID > 0:
															Struct
															{
																DHCPMDhcpOptionValue OptionValue;
																DHCPMDhcpOptionValueRef OptionValueRef;
															}
													}
													Align4 Pad;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 14:
						_Struct RDhcpEnumOptionValues
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s ResumeHandle=%u PreferredMaximum=%u", ServerIpAddress.ToString, ResumeHandle, PreferredMaximum )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													NdrAlign Pad1;
													DHCPMDhcpOptionScopeInfo ScopeInfo;
													DHCPMDhcpOptionScopeInfoRef ScopeInfoRef;
													Align4 Pad2;
													UINT32 ResumeHandle;
													UINT32 PreferredMaximum;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ResumeHandle=%u OptionsRead=%u OptionsTotal=%u ReturnValue=%u", ResumeHandle, OptionsRead, OptionsTotal, ReturnValue )]
												Struct
												{
													UINT32 ResumeHandle;
													NdrPtr OptionValuesPtr;
													Switch
													{
														Case OptionValuesPtr.ReferentID > 0:
															DHCPMDhcpOptionValueArray OptionValues;
													}
													Align4 Pad;
													UINT32 OptionsRead;
													UINT32 OptionsTotal;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 15:
						_Struct RDhcpRemoveOptionValue
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s OptionID=%u", ServerIpAddress.ToString, OptionID )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad1;
													UINT32 OptionID;
													NdrAlign Pad2;
													DHCPMDhcpOptionScopeInfo ScopeInfo;
													DHCPMDhcpOptionScopeInfoRef ScopeInfoRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%d: %s", ReturnValue, WinErrorCodeTable(ReturnValue ) )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 16:
						_Struct RDhcpCreateClientInfo
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s", ServerIpAddress.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													NdrAlign Pad;
													DHCPMDhcpClientInfo ClientInfo;
													DHCPMDhcpClientInfoRef ClientInfoRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%d: %s", ReturnValue, WinErrorCodeTable(ReturnValue ) )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 17:
						_Struct RDhcpSetClientInfo
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s", ServerIpAddress.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													NdrAlign Pad;
													DHCPMDhcpClientInfo ClientInfo;
													DHCPMDhcpClientInfoRef ClientInfoRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%d: %s", ReturnValue, WinErrorCodeTable(ReturnValue ) )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 18:
						_Struct RDhcpGetClientInfo
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s", ServerIpAddress.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													NdrAlign pad;
													DHCPMDhcpClientSearchInfo SearchInfo;
													DHCPMDhcpClientSearchInfoRef SearchInfoRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%d: %s", ReturnValue, WinErrorCodeTable(ReturnValue ) )]
												Struct
												{
													NdrPtr ClientInfoPtr;
													Switch
													{
														Case ClientInfoPtr.ReferentID > 0:
															Struct
															{
																DHCPMDhcpClientInfo ClientInfo;
																DHCPMDhcpClientInfoRef ClientInfoRef;
															}
													}
													Align4 Pad;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 19:
						_Struct RDhcpDeleteClientInfo
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s", ServerIpAddress.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													NdrAlign Pad;
													DHCPMDhcpClientSearchInfo SearchInfo;
													DHCPMDhcpClientSearchInfoRef SearchInfoRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%d: %s", ReturnValue, WinErrorCodeTable(ReturnValue ) )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 20:
						_Struct RDhcpEnumSubnetClients
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s SubnetAddress=%u ResumeHandle=%u PreferredMaximum=%u", ServerIpAddress.ToString, SubnetAddress, ResumeHandle, PreferredMaximum )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad;
													IPv4Address SubnetAddress;
													UINT32 ResumeHandle;
													UINT32 PreferredMaximum;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ResumeHandle=%u ClientsRead=%u ClientsTotal=%u ReturnValue=%u", ResumeHandle, ClientsRead, ClientsTotal, ReturnValue )]
												Struct
												{
													UINT32 ResumeHandle;
													NdrPtr ClientInfoPtr;
													Switch
													{
														Case ClientInfoPtr.ReferentID > 0:
															DHCPMDhcpClientInfoArray ClientInfo;
													}
													Align4 Pad;
													UINT32 ClientsRead;
													UINT32 ClientsTotal;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 21:
						_Struct RDhcpGetClientOptions
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s ClientIpAddress=%u ClientSubnetMask=%u", ServerIpAddress.ToString, ClientIpAddress, ClientSubnetMask )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad;
													IPv4Address ClientIpAddress;
													IPv4Address ClientSubnetMask;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%d: %s", ReturnValue, WinErrorCodeTable(ReturnValue ) )]
												Struct
												{
													NdrPtr ClientOptionsPtr;
													Switch
													{
														Case ClientOptionsPtr.ReferentID > 0:
															DHCPMDhcpOptionList ClientOptions;
													}
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 22:
						_Struct RDhcpGetMibInfo
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s", ServerIpAddress.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%d: %s", ReturnValue, WinErrorCodeTable(ReturnValue ) )]
												Struct
												{
													NdrPtr MibInfoPtr;
													Switch
													{
														Case MibInfoPtr.ReferentID > 0:
															DhcpMibInfo MibInfo;
													}
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 23:
						_Struct RDhcpEnumOptions
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s ResumeHandle=%u PreferredMaximum=%u", ServerIpAddress.ToString, ResumeHandle, PreferredMaximum )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad;
													UINT32 ResumeHandle;
													UINT32 PreferredMaximum;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ResumeHandle=%u OptionsRead=%u OptionsTotal=%u ReturnValue=%u", ResumeHandle, OptionsRead, OptionsTotal, ReturnValue )]
												Struct
												{
													UINT32 ResumeHandle;
													NdrPtr OptionsPtr;
													Switch
													{
														Case OptionsPtr.ReferentID > 0:
															DHCPMDhcpOptionArray Options;
													}
													Align4 Pad;
													UINT32 OptionsRead;
													UINT32 OptionsTotal;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 24:
						_Struct RDhcpSetOptionValues
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s", ServerIpAddress.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													NdrAlign Pad1;
													DHCPMDhcpOptionScopeInfo ScopeInfo;
													DHCPMDhcpOptionScopeInfoRef ScopeInfoRef;
													NdrAlign Pad2;
													DHCPMDhcpOptionValueArray OptionValues;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%d: %s", ReturnValue, WinErrorCodeTable(ReturnValue ) )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 25:
						_Struct RDhcpServerSetConfig
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s FieldsToSet=%u", ServerIpAddress.ToString, FieldsToSet )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad;
													DHCPMFieldsToSet FieldsToSet;
													DHCPMDhcpServerConfigInfo ConfigInfo;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%d: %s", ReturnValue, WinErrorCodeTable(ReturnValue ) )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 26:
						_Struct RDhcpServerGetConfig
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s", ServerIpAddress.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%d: %s", ReturnValue, WinErrorCodeTable(ReturnValue ) )]
												Struct
												{
													NdrPtr ConfigInfoPtr;
													Switch
													{
														Case ConfigInfoPtr.ReferentID > 0:
															DHCPMDhcpServerConfigInfo ConfigInfo;
													}
													Align4 Pad;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 27:
						_Struct RDhcpScanDatabase
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s SubnetAddress=%u FixFlag=%u", ServerIpAddress.ToString, SubnetAddress, FixFlag )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad;
													UINT32 SubnetAddress;
													UINT32 FixFlag;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%d: %s", ReturnValue, WinErrorCodeTable(ReturnValue ) )]
												Struct
												{
													NdrPtr ScanListPtr;
													Switch
													{
														Case ScanListPtr.ReferentID > 0:
															DHCPMDhcpScanList ScanList;
													}
													Align4 Pad;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 28:
						_Struct RDhcpGetVersion
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s", ServerIpAddress.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "MajorVersion=%u MinorVersion=%u ReturnValue=%u", MajorVersion, MinorVersion, ReturnValue )]
												Struct
												{
													UINT32 MajorVersion;
													UINT32 MinorVersion;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 29:
						_Struct RDhcpAddSubnetElementV4
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s SubnetAddress=%u", ServerIpAddress.ToString, SubnetAddress )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad1;
													IPv4Address SubnetAddress;
													NdrAlign Pad2;
													DHCPMDhcpSubnetElementDataV4 AddElementInfo;
													DHCPMDhcpSubnetElementDataV4Ref AddElementInfoRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%d: %s", ReturnValue, WinErrorCodeTable(ReturnValue ) )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 30:
						_Struct RDhcpEnumSubnetElementsV4
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s SubnetAddress=%u ResumeHandle=%u PreferredMaximum=%u", ServerIpAddress.ToString, SubnetAddress, ResumeHandle, PreferredMaximum )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad1;
													IPv4Address SubnetAddress;
													NdrEnum EnumElementType = DHCPMDhcpSubnetElementTypeTable(this.value);
													Align4 Pad2;
													UINT32 ResumeHandle;
													UINT32 PreferredMaximum;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ResumeHandle=%u ElementsRead=%u ElementsTotal=%u ReturnValue=%u", ResumeHandle, ElementsRead, ElementsTotal, ReturnValue )]
												Struct
												{
													UINT32 ResumeHandle;
													NdrPtr EnumElementInfoPtr;
													Switch {
														Case EnumElementInfoPtr.ReferentID > 0:
															DHCPMDhcpSubnetElementInfoArrayV4 EnumElementInfo;
													}
													Align4 Pad;
													UINT32 ElementsRead;
													UINT32 ElementsTotal;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 31:
						_Struct RDhcpRemoveSubnetElementV4
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s SubnetAddress=%u", ServerIpAddress.ToString, SubnetAddress )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad1;
													IPv4Address SubnetAddress;
													NdrAlign Pad2;
													DHCPMDhcpSubnetElementDataV4 RemoveElementInfo;
													DHCPMDhcpSubnetElementDataV4Ref RemoveElementInfoRef;
													NdrEnum ForceFlag = DHCPMDhcpForceFlagTable(this.value);
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%d: %s", ReturnValue, WinErrorCodeTable(ReturnValue ) )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 32:
						_Struct RDhcpCreateClientInfoV4
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s", ServerIpAddress.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													NdrAlign Pad;
													DHCPMDhcpClientInfoV4 ClientInfo;
													DHCPMDhcpClientInfoV4Ref ClientInfoRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%d: %s", ReturnValue, WinErrorCodeTable(ReturnValue ) )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 33:
						_Struct RDhcpSetClientInfoV4
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s", ServerIpAddress.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													NdrAlign Pad;
													DHCPMDhcpClientInfoV4 ClientInfo;
													DHCPMDhcpClientInfoV4Ref ClientInfoRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%d: %s", ReturnValue, WinErrorCodeTable(ReturnValue ) )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 34:
						_Struct RDhcpGetClientInfoV4
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s", ServerIpAddress.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													NdrAlign Pad;
													DHCPMDhcpClientSearchInfo SearchInfo;
													DHCPMDhcpClientSearchInfoRef SearchInfoRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%d: %s", ReturnValue, WinErrorCodeTable(ReturnValue ) )]
												Struct
												{
													NdrPtr ClientInfoPtr;
													Switch
													{
														case ClientInfoPtr.ReferentID > 0:
															Struct
															{
																DHCPMDhcpClientInfoV4 ClientInfo;
																DHCPMDhcpClientInfoV4Ref ClientInfoRef;
															}
													}
													Align4 Pad;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 35:
						_Struct RDhcpEnumSubnetClientsV4
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s SubnetAddress=%u ResumeHandle=%u PreferredMaximum=%u", ServerIpAddress.ToString, SubnetAddress, ResumeHandle, PreferredMaximum )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad;
													IPv4Address SubnetAddress;
													UINT32 ResumeHandle;
													UINT32 PreferredMaximum;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ResumeHandle=%u ClientsRead=%u ClientsTotal=%u ReturnValue=%u", ResumeHandle, ClientsRead, ClientsTotal, ReturnValue )]
												Struct
												{
													UINT32 ResumeHandle;
													NdrPtr ClientInfoPtr;
													Switch
													{
														Case ClientInfoPtr.ReferentID > 0:
															DHCPMDhcpClientInfoArrayV4 ClientInfo;
													}
													Align4 Pad;
													UINT32 ClientsRead;
													UINT32 ClientsTotal;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 36:
						_Struct RDhcpSetSuperScopeV4
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s SubnetAddress=%u SuperScopeName=%s ChangeExisting=%d", ServerIpAddress.ToString, SubnetAddress, SuperScopeName.ToString, ChangeExisting )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad1;
													IPv4Address SubnetAddress;
													NdrWideStringPtr SuperScopeName;
													Align4 Pad2;
													BOOL ChangeExisting;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%d: %s", ReturnValue, WinErrorCodeTable(ReturnValue ) )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 37:
						_Struct RDhcpGetSuperScopeInfoV4
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s", ServerIpAddress.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%d: %s", ReturnValue, WinErrorCodeTable(ReturnValue ) )]
												Struct
												{
													NdrPtr SuperScopeTablePtr;
													Switch
													{
														Case SuperScopeTablePtr.ReferentID > 0:
															DHCPMDhcpSuperScopeTable SuperScopeTable;
													}
													Align4 Pad;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 38:
						_Struct RDhcpDeleteSuperScopeV4
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s SuperScopeName=%s", ServerIpAddress.ToString, SuperScopeName.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													NdrWideString SuperScopeName;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%d: %s", ReturnValue, WinErrorCodeTable(ReturnValue ) )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 39:
						_Struct RDhcpServerSetConfigV4
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s FieldsToSet=%u", ServerIpAddress.ToString, FieldsToSet )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad1;
													DHCPMFieldsToSet FieldsToSet;
													NdrAlign Pad2;
													DHCPMDhcpServerConfigInfoV4 ConfigInfo;
													DHCPMDhcpServerConfigInfoV4Ref ConfigInfoRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%d: %s", ReturnValue, WinErrorCodeTable(ReturnValue ) )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 40:
						_Struct RDhcpServerGetConfigV4
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s", ServerIpAddress.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%d: %s", ReturnValue, WinErrorCodeTable(ReturnValue ) )]
												Struct
												{
													NdrPtr ConfigInfoPtr;
													Switch
													{
														case ConfigInfoPtr.ReferentID > 0:
															Struct
															{
																DHCPMDhcpServerConfigInfoV4 ConfigInfo;
																DHCPMDhcpServerConfigInfoV4Ref ConfigInfoRef;
															}
													}
													Align4 Pad;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 41:
						_Struct RDhcpServerSetConfigVQ
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s FieldsToSet=%u", ServerIpAddress.ToString, FieldsToSet )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad1;
													DHCPMFieldsToSet FieldsToSet;
													NdrAlign Pad2;
													DHCPMDhcpServerConfigInfoVq ConfigInfo;
													DHCPMDhcpServerConfigInfoVqRef ConfigInfoRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%d: %s", ReturnValue, WinErrorCodeTable(ReturnValue ) )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 42:
						_Struct RDhcpServerGetConfigVQ
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s", ServerIpAddress.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%d: %s", ReturnValue, WinErrorCodeTable(ReturnValue ) )]
												Struct
												{
													NdrPtr ConfigInfoPtr;
													Switch
													{
														case ConfigInfoPtr.ReferentID > 0:
															Struct
															{
																DHCPMDhcpServerConfigInfoVq ConfigInfo;
																DHCPMDhcpServerConfigInfoVqRef ConfigInfoRef;
															}
													}
													Align4 Pad;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 43:
						_Struct RDhcpGetMibInfoVQ
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s", ServerIpAddress.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%d: %s", ReturnValue, WinErrorCodeTable(ReturnValue ) )]
												Struct
												{
													NdrPtr MibInfoPtr;
													Switch
													{
														Case MibInfoPtr.ReferentID > 0:
															DhcpMibInfoVq MibInfo;
													}
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 44:
						_Struct RDhcpCreateClientInfoVQ
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s", ServerIpAddress.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													NdrAlign Pad;
													DHCPMDhcpClientInfoVq ClientInfo;
													DHCPMDhcpClientInfoVqRef ClientInfoRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%d: %s", ReturnValue, WinErrorCodeTable(ReturnValue ) )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 45:
						_Struct RDhcpSetClientInfoVQ
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s", ServerIpAddress.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													NdrAlign Pad;
													DHCPMDhcpClientInfoVq ClientInfo;
													DHCPMDhcpClientInfoVqRef ClientInfoRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%d: %s", ReturnValue, WinErrorCodeTable(ReturnValue ) )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 46:
						_Struct RDhcpGetClientInfoVQ
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s", ServerIpAddress.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													NdrAlign Pad;
													DHCPMDhcpClientSearchInfo SearchInfo;
													DHCPMDhcpClientSearchInfoRef SearchInfoRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%d: %s", ReturnValue, WinErrorCodeTable(ReturnValue ) )]
												Struct
												{
													NdrPtr ClientInfoPtr;
													Switch
													{
														Case ClientInfoPtr.ReferentID > 0:
															Struct
															{
																DHCPMDhcpClientInfoVq ClientInfo;
																DHCPMDhcpClientInfoVqRef ClientInfoRef;
															}
													}
													Align4 Pad;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 47:
						_Struct RDhcpEnumSubnetClientsVQ
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s SubnetAddress=%u ResumeHandle=%u PreferredMaximum=%u", ServerIpAddress.ToString, SubnetAddress, ResumeHandle, PreferredMaximum )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad;
													IPv4Address SubnetAddress;
													UINT32 ResumeHandle;
													UINT32 PreferredMaximum;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ResumeHandle=%u ClientsRead=%u ClientsTotal=%u ReturnValue=%u", ResumeHandle, ClientsRead, ClientsTotal, ReturnValue )]
												Struct
												{
													UINT32 ResumeHandle;
													NdrPtr ClientInfoPtr;
													Switch
													{
														Case ClientInfoPtr.ReferentID > 0:
															DHCPMDhcpClientInfoArrayVq ClientInfo;
													}
													Align4 Pad;
													UINT32 ClientsRead;
													UINT32 ClientsTotal;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 48:
						_Struct RDhcpCreateSubnetVQ
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s SubnetAddress=%u", ServerIpAddress.ToString, SubnetAddress )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad1;
													IPv4Address SubnetAddress;
													Align8 Pad2;
													DHCPMDhcpSubnetInfoVq SubnetInfoVQ;
													DHCPMDhcpSubnetInfoVqRef SubnetInfoVQRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%d: %s", ReturnValue, WinErrorCodeTable(ReturnValue ) )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 49:
						_Struct RDhcpGetSubnetInfoVQ
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s SubnetAddress=%u", ServerIpAddress.ToString, SubnetAddress )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad;
													IPv4Address SubnetAddress;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%d: %s", ReturnValue, WinErrorCodeTable(ReturnValue ) )]
												Struct
												{
													NdrPtr SubnetInfoVQPtr;
													Switch
													{
														Case SubnetInfoVQPtr.ReferentID > 0:
															Struct
															{
																Align8 Pad1;
																DHCPMDhcpSubnetInfoVq SubnetInfoVQ;
																DHCPMDhcpSubnetInfoVqRef SubnetInfoVQRef;
															}
													}
													Align4 Pad2;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 50:
						_Struct RDhcpSetSubnetInfoVQ
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s SubnetAddress=%u", ServerIpAddress.ToString, SubnetAddress )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad1;
													IPv4Address SubnetAddress;
													Align8 Pad2;
													DHCPMDhcpSubnetInfoVq SubnetInfoVQ;
													DHCPMDhcpSubnetInfoVqRef SubnetInfoVQRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%d: %s", ReturnValue, WinErrorCodeTable(ReturnValue ) )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Default:
						Switch
						{
							case IsValueNone(Property.MSRPCOpnum):
								struct
								{
									Blob( FrameLength - Offset ) data;
									ReportParserWarning("DHCPM", "Property MSRPCOpnum is missing") ParserWarning;
								}
							default:
								ReportParserError( ParserErrorProtocolClassWindows, "DHCPM", "Unknown dhcpsrv method, Opnum:" + Property.MSRPCOpnum ) UnknownMethod;
						}
				}
			}
		
		Case "{5B821720-F63B-11D0-AAD2-00C04FC324DB}":
			[Property.DHCPMMethodName = "dhcpsrv2:" + DHCPMdhcpsrv2MethodNameTable( Property.MSRPCOpnum )]
			_Struct dhcpsrv2
			{
				Switch( Property.MSRPCOpnum )
				{
					Case 0:
						_Struct RDhcpEnumSubnetClientsV5
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s SubnetAddress=%s ResumeHandle=%u PreferredMaximum=%u", ServerIpAddress.ToString, SubnetAddress.ToString, ResumeHandle, PreferredMaximum )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad;
													IPv4Address SubnetAddress;
													UINT32 ResumeHandle;
													UINT32 PreferredMaximum;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ResumeHandle=%u ClientsRead=%u ClientsTotal=%u ReturnValue=%u", ResumeHandle, ClientsRead, ClientsTotal, ReturnValue )]
												Struct
												{
													UINT32 ResumeHandle;
													NdrPtr ClientInfoPtr;
													Switch
													{
														Case ClientInfoPtr.ReferentID > 0:
															DHCPMDhcpClientInfoArrayV5 ClientInfo;
													}
													Align4 Pad;
													UINT32 ClientsRead;
													UINT32 ClientsTotal;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 1:
						_Struct RDhcpSetMScopeInfo
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s MScopeName=%s NewScope=%d", ServerIpAddress.ToString, MScopeName.ToString, NewScope )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													NdrWideString MScopeName;
													NdrAlign Pad1;
													DhcpMscopeInfo MScopeInfo;
													DhcpMscopeInfoRef MScopeInfoRef;
													Align4 Pad2;
													BOOL NewScope;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 2:
						_Struct RDhcpGetMScopeInfo
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s MScopeName=%s", ServerIpAddress.ToString, MScopeName.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													NdrWideString MScopeName;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													NdrPtr MScopeInfoPtr;
													Switch
													{
														Case MScopeInfoPtr.ReferentID > 0:
															Struct
															{
																DhcpMscopeInfo MScopeInfo;
																DhcpMscopeInfoRef MScopeInfoRef;
															}
													}
													Align4 Pad;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 3:
						_Struct RDhcpEnumMScopes
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s ResumeHandle=%u PreferredMaximum=%u", ServerIpAddress.ToString, ResumeHandle, PreferredMaximum )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad;
													UINT32 ResumeHandle;
													UINT32 PreferredMaximum;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ResumeHandle=%u ElementsRead=%u ElementsTotal=%u ReturnValue=%u", ResumeHandle, ElementsRead, ElementsTotal, ReturnValue )]
												Struct
												{
													UINT32 ResumeHandle;
													NdrPtr MScopeTablePtr;
													Switch
													{
														Case MScopeTablePtr.ReferentID > 0:
															DhcpMscopeTable MScopeTable;
													}
													UINT32 ElementsRead;
													UINT32 ElementsTotal;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 4:
						_Struct RDhcpAddMScopeElement
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s MScopeName=%s", ServerIpAddress.ToString, MScopeName.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													NdrWideString MScopeName;
													NdrAlign Pad;
													DHCPMDhcpSubnetElementDataV4 AddElementInfo;
													DHCPMDhcpSubnetElementDataV4Ref AddElementInfoRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 5:
						_Struct RDhcpEnumMScopeElements
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s MScopeName=%s ResumeHandle=%u PreferredMaximum=%u", ServerIpAddress.ToString, MScopeName.ToString, ResumeHandle, PreferredMaximum )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													NdrWideString MScopeName;
													NdrEnum EnumElementType = DHCPMDhcpSubnetElementTypeTable(this.value);
													Align4 Pad;
													UINT32 ResumeHandle;
													UINT32 PreferredMaximum;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ResumeHandle=%u ElementsRead=%u ElementsTotal=%u ReturnValue=%u", ResumeHandle, ElementsRead, ElementsTotal, ReturnValue )]
												Struct
												{
													UINT32 ResumeHandle;
													NdrPtr EnumElementInfoPtr;
													Switch {
														Case EnumElementInfoPtr.ReferentID > 0:
															DHCPMDhcpSubnetElementInfoArrayV4 EnumElementInfo;
													}
													Align4 Pad;
													UINT32 ElementsRead;
													UINT32 ElementsTotal;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 6:
						_Struct RDhcpRemoveMScopeElement
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s MScopeName=%s", ServerIpAddress.ToString, MScopeName.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													NdrWideString MScopeName;
													NdrAlign Pad;
													DHCPMDhcpSubnetElementDataV4 RemoveElementInfo;
													DHCPMDhcpSubnetElementDataV4Ref RemoveElementInfoRef;
													NdrEnum ForceFlag = DHCPMDhcpForceFlagTable(this.value);
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 7:
						_Struct RDhcpDeleteMScope
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s MScopeName=%s", ServerIpAddress.ToString, MScopeName.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													NdrWideString MScopeName;
													NdrEnum ForceFlag = DHCPMDhcpForceFlagTable(this.value);
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 8:
						_Struct RDhcpScanMDatabase
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s MScopeName=%s FixFlag=%u", ServerIpAddress.ToString, MScopeName.ToString, FixFlag )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													NdrWideString MScopeName;
													Align4 Pad;
													UINT32 FixFlag;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													NdrPtr ScanListPtr;
													Switch
													{
														Case ScanListPtr.ReferentID > 0:
															DHCPMDhcpScanList ScanList;
													}
													Align4 Pad;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 9:
						_Struct RDhcpCreateMClientInfo
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s MScopeName=%s", ServerIpAddress.ToString, MScopeName.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													NdrWideString MScopeName;
													NdrAlign Pad;
													DhcpMclientInfo ClientInfo;
													DhcpMclientInfoRef ClientInfoRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 10:
						_Struct RDhcpSetMClientInfo
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s", ServerIpAddress.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													NdrAlign Pad;
													DhcpMclientInfo ClientInfo;
													DhcpMclientInfoRef ClientInfoRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 11:
						_Struct RDhcpGetMClientInfo
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s", ServerIpAddress.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													NdrAlign Pad;
													DHCPMDhcpClientSearchInfo SearchInfo;
													DHCPMDhcpClientSearchInfoRef SearchInfoRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													NdrPtr ClientInfoPtr;
													Switch
													{
														Case ClientInfoPtr.ReferentID > 0:
															Struct
															{	
																DhcpMclientInfo ClientInfo;
																DhcpMclientInfoRef ClientInfoRef;
															}
													}
													Align4 Pad;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 12:
						_Struct RDhcpDeleteMClientInfo
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s", ServerIpAddress.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													NdrAlign Pad;
													DHCPMDhcpClientSearchInfo SearchInfo;
													DHCPMDhcpClientSearchInfoRef SearchInfoRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 13:
						_Struct RDhcpEnumMScopeClients
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s MScopeName=%s ResumeHandle=%u PreferredMaximum=%u", ServerIpAddress.ToString, MScopeName.ToString, ResumeHandle, PreferredMaximum )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													NdrWideString MScopeName;
													Align4 Pad;
													UINT32 ResumeHandle;
													UINT32 PreferredMaximum;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ResumeHandle=%u ClientsRead=%u ClientsTotal=%u ReturnValue=%u", ResumeHandle, ClientsRead, ClientsTotal, ReturnValue )]
												Struct
												{
													UINT32 ResumeHandle;
													NdrPtr DhcpMclientInfoArrayPtr;
													Switch
													{
														Case DhcpMclientInfoArrayPtr.ReferentID > 0:
															DhcpMclientInfoArray DhcpMclientInfoArray;
													}
													Align4 Pad;
													UINT32 ClientsRead;
													UINT32 ClientsTotal;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 14:
						_Struct RDhcpCreateOptionV5
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s Flags=%u OptionId=%u ClassName=%s VendorName=%s", ServerIpAddress.ToString, Flags, OptionId, ClassName.ToString, VendorName.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad1;
													UINT32 Flags = DHCPMRDhcpCreateOptionV5FlagsTable(this);
													UINT32 OptionId;
													NdrWideStringPtr ClassName;
													NdrWideStringPtr VendorName;
													NdrAlign Pad2;
													DHCPMDhcpOption OptionInfo;
													DHCPMDhcpOptionRef OptionInfoRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 15:
						_Struct RDhcpSetOptionInfoV5
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s Flags=%u OptionID=%u ClassName=%s VendorName=%s", ServerIpAddress.ToString, Flags, OptionID, ClassName.ToString, VendorName.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad1;
													UINT32 Flags = DHCPMRDhcpSetOptionInfoV5FlagsTable(this);
													UINT32 OptionID;
													NdrWideStringPtr ClassName;
													NdrWideStringPtr VendorName;
													NdrAlign Pad2;
													DHCPMDhcpOption OptionInfo;
													DHCPMDhcpOptionRef OptionInfoRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 16:
						_Struct RDhcpGetOptionInfoV5
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s Flags=%u OptionID=%u ClassName=%s VendorName=%s", ServerIpAddress.ToString, Flags, OptionID, ClassName.ToString, VendorName.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad;
													UINT32 Flags = DHCPMRDhcpGetOptionInfoV5FlagsTable(this);
													UINT32 OptionID;
													NdrWideStringPtr ClassName;
													NdrWideStringPtr VendorName;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													NdrPtr OptionInfoPtr;
													Switch {
														Case OptionInfoPtr.ReferentID > 0:
															Struct
															{
																DHCPMDhcpOption OptionInfo;
																DHCPMDhcpOptionRef OptionInfoRef;
															}
													}
													ALign4 Pad;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 17:
						_Struct RDhcpEnumOptionsV5
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s Flags=%u ClassName=%s VendorName=%s ResumeHandle=%u PreferredMaximum=%u", ServerIpAddress.ToString, Flags, ClassName.ToString, VendorName.ToString, ResumeHandle, PreferredMaximum )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad1;
													UINT32 Flags = DHCPMRDhcpEnumOptionsV5FlagsTable(this);
													NdrWideStringPtr ClassName;
													NdrWideStringPtr VendorName;
													Align4 Pad2;
													UINT32 ResumeHandle;
													UINT32 PreferredMaximum;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ResumeHandle=%u OptionsRead=%u OptionsTotal=%u ReturnValue=%u", ResumeHandle, OptionsRead, OptionsTotal, ReturnValue )]
												Struct
												{
													UINT32 ResumeHandle;
													NdrPtr OptionsPtr;
													Switch
													{
														Case OptionsPtr.ReferentID > 0:
															DHCPMDhcpOptionArray Options;
													}
													Align4 Pad;
													UINT32 OptionsRead;
													UINT32 OptionsTotal;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 18:
						_Struct RDhcpRemoveOptionV5
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s Flags=%u OptionID=%u ClassName=%s VendorName=%s", ServerIpAddress.ToString, Flags, OptionID, ClassName.ToString, VendorName.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad;
													UINT32 Flags = DHCPMRDhcpRemoveOptionV5FlagsTable(this);
													UINT32 OptionID;
													NdrWideStringPtr ClassName;
													NdrWideStringPtr VendorName;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 19:
						_Struct RDhcpSetOptionValueV5
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s Flags=%u OptionId=%u ClassName=%s VendorName=%s", ServerIpAddress.ToString, Flags, OptionId, ClassName.ToString, VendorName.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad1;
													UINT32 Flags = DHCPMRDhcpSetOptionValueV5FlagsTable(this);
													UINT32 OptionId;
													NdrWideStringPtr ClassName;
													NdrWideStringPtr VendorName;
													NdrAlign Pad2;
													DHCPMDhcpOptionScopeInfo ScopeInfo;
													DHCPMDhcpOptionScopeInfoRef ScopeInfoRef;
													NdrAlign Pad3;
													DHCPMDhcpOptionData OptionValue;
													DHCPMDhcpOptionDataRef OptionValueRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 20:
						_Struct RDhcpSetOptionValuesV5
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s Flags=%u ClassName=%s VendorName=%s", ServerIpAddress.ToString, Flags, ClassName.ToString, VendorName.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad1;
													UINT32 Flags = DHCPMRDhcpSetOptionValuesV5FlagsTable(this);
													NdrWideStringPtr ClassName;
													NdrWideStringPtr VendorName;
													NdrAlign Pad2;
													DHCPMDhcpOptionScopeInfo ScopeInfo;
													DHCPMDhcpOptionScopeInfoRef ScopeInfoRef;
													NdrAlign Pad3;
													DHCPMDhcpOptionValueArray OptionValues;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 21:
						_Struct RDhcpGetOptionValueV5
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s Flags=%u OptionID=%u ClassName=%s VendorName=%s", ServerIpAddress.ToString, Flags, OptionID, ClassName.ToString, VendorName.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad1;
													UINT32 Flags = DHCPMRDhcpGetOptionValueV5FlagsTable(this);
													UINT32 OptionID;
													NdrWideStringPtr ClassName;
													NdrWideStringPtr VendorName;
													NdrAlign Pad2;
													DHCPMDhcpOptionScopeInfo ScopeInfo;
													DHCPMDhcpOptionScopeInfoRef ScopeInfoRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													NdrPtr OptionValuePtr;
													Switch
													{
														Case OptionValuePtr.ReferentID > 0:
															Struct
															{
																DHCPMDhcpOptionValue OptionValue;
																DHCPMDhcpOptionValueRef OptionValueRef;
															}
													}
													Align4 Pad;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 22:
						_Struct RDhcpEnumOptionValuesV5
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s Flags=%u ClassName=%s VendorName=%s ResumeHandle=%u PreferredMaximum=%u", ServerIpAddress.ToString, Flags, ClassName.ToString, VendorName.ToString, ResumeHandle, PreferredMaximum )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad1;
													UINT32 Flags = DHCPMRDhcpEnumOptionValuesV5FlagsTable(this);
													NdrWideStringPtr ClassName;
													NdrWideStringPtr VendorName;
													NdrAlign Pad2;
													DHCPMDhcpOptionScopeInfo ScopeInfo;
													DHCPMDhcpOptionScopeInfoRef ScopeInfoRef;
													Align4 Pad3;
													UINT32 ResumeHandle;
													UINT32 PreferredMaximum;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ResumeHandle=%u OptionsRead=%u OptionsTotal=%u ReturnValue=%u", ResumeHandle, OptionsRead, OptionsTotal, ReturnValue )]
												Struct
												{
													UINT32 ResumeHandle;
													NdrPtr OptionValuesPtr;
													Switch
													{
														Case OptionValuesPtr.ReferentID > 0:
															DHCPMDhcpOptionValueArray OptionValues;
													}
													Align4 Pad;
													UINT32 OptionsRead;
													UINT32 OptionsTotal;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 23:
						_Struct RDhcpRemoveOptionValueV5
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s Flags=%u OptionID=%u ClassName=%s VendorName=%s", ServerIpAddress.ToString, Flags, OptionID, ClassName.ToString, VendorName.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad1;
													UINT32 Flags = DHCPMRDhcpRemoveOptionValueV5FlagsTable(this);
													UINT32 OptionID;
													NdrWideStringPtr ClassName;
													NdrWideStringPtr VendorName;
													NdrAlign Pad2;
													DHCPMDhcpOptionScopeInfo ScopeInfo;
													DHCPMDhcpOptionScopeInfoRef ScopeInfoRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 24:
						_Struct RDhcpCreateClass
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s ReservedMustBeZero=%u", ServerIpAddress.ToString, ReservedMustBeZero )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad1;
													UINT32 ReservedMustBeZero;
													DHCPMDhcpClassInfo ClassInfo;
													DHCPMDhcpClassInfoRef ClassInfoRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 25:
						_Struct RDhcpModifyClass
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s ReservedMustBeZero=%u", ServerIpAddress.ToString, ReservedMustBeZero )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad;
													UINT32 ReservedMustBeZero;
													DHCPMDhcpClassInfo ClassInfo;
													DHCPMDhcpClassInfoRef ClassInfoRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 26:
						_Struct RDhcpDeleteClass
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s ReservedMustBeZero=%u ClassName=%s", ServerIpAddress.ToString, ReservedMustBeZero, ClassName.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad;
													UINT32 ReservedMustBeZero;
													NdrWideStringPtr ClassName;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 27:
						_Struct RDhcpGetClassInfo
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s ReservedMustBeZero=%u", ServerIpAddress.ToString, ReservedMustBeZero )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad;
													UINT32 ReservedMustBeZero;
													DHCPMDhcpClassInfo PartialClassInfo;
													DHCPMDhcpClassInfoRef PartialClassInfoRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													NdrPtr FilledClassInfoPtr;
													Switch
													{
														Case FilledClassInfoPtr.ReferentID > 0:
															Struct
															{
																DHCPMDhcpClassInfo FilledClassInfo;
																DHCPMDhcpClassInfoRef FilledClassInfoRef;
															}
													}
													Align4 Pad;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 28:
						_Struct RDhcpEnumClasses
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s ReservedMustBeZero=%u ResumeHandle=%u PreferredMaximum=%u", ServerIpAddress.ToString, ReservedMustBeZero, ResumeHandle, PreferredMaximum )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad;
													UINT32 ReservedMustBeZero;
													UINT32 ResumeHandle;
													UINT32 PreferredMaximum;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ResumeHandle=%u Read=%u Total=%u ReturnValue=%u", ResumeHandle, Read, Total, ReturnValue )]
												Struct
												{
													UINT32 ResumeHandle;
													NdrPtr ClassInfoArrayPtr;
													Switch
													{
														Case ClassInfoArrayPtr.ReferentID > 0:
															DHCPMDhcpClassInfoArray ClassInfoArray;
													}
													Align4 Pad;
													UINT32 Read;
													UINT32 Total;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 29:
						_Struct RDhcpGetAllOptions
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s Flags=%u", ServerIpAddress.ToString, Flags )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad;
													UINT32 Flags = DHCPMRDhcpGetAllOptionsFlagsTable(this);
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													NdrPtr OptionStructPtr;
													Switch
													{
														Case OptionStructPtr.ReferentID > 0:
															Struct
															{
																DHCPMDhcpAllOptions OptionStruct;
																DHCPMDhcpAllOptionsRef OptionStructRef;
															}
													}
													Align4 Pad;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 30:
						_Struct RDhcpGetAllOptionValues
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s Flags=%u", ServerIpAddress.ToString, Flags )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													UINT32 Flags;
													DHCPMDhcpOptionScopeInfo ScopeInfo;
													DHCPMDhcpOptionScopeInfoRef ScopeInfoRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													NdrPtr ValuesPtr;
													Switch
													{
														Case ValuesPtr.ReferentID > 0:
															Struct
															{
																DHCPMDhcpAllOptionValues Values;
																DHCPMDhcpAllOptionValuesRef ValuesRef;
															}
													}
													Align4 Pad;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 31:
						_Struct RDhcpGetMCastMibInfo
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s", ServerIpAddress.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													NdrPtr MibInfoPtr;
													Switch
													{
														Case MibInfoPtr.ReferentID > 0:
															Struct
															{
																DhcpMcastMibInfo MibInfo;
																DhcpMcastMibInfoRef MibInfoRef;
															}
													}
													Align4 Pad;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 32:
						_Struct RDhcpAuditLogSetParams
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s Flags=%u AuditLogDir=%s DiskCheckInterval=%u MaxLogFilesSize=%u MinSpaceOnDisk=%u", ServerIpAddress.ToString, Flags, AuditLogDir.ToString, DiskCheckInterval, MaxLogFilesSize, MinSpaceOnDisk )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													ALign4 Pad1;
													UINT32 Flags = DHCPMRDhcpAuditLogSetParamsFlagsTable(this);
													NdrWideString AuditLogDir;
													ALign4 Pad2;
													UINT32 DiskCheckInterval;
													UINT32 MaxLogFilesSize;
													UINT32 MinSpaceOnDisk;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 33:
						_Struct RDhcpAuditLogGetParams
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s Flags=%u", ServerIpAddress.ToString, Flags )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													ALign4 Pad;
													UINT32 Flags = DHCPMRDhcpAuditLogGetParamsFlagsTable(this);
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "AuditLogDir=%s DiskCheckInterval=%u MaxLogFilesSize=%u MinSpaceOnDisk=%u ReturnValue=%u", AuditLogDir.ToString, DiskCheckInterval, MaxLogFilesSize, MinSpaceOnDisk, ReturnValue )]
												Struct
												{
													NdrWideStringPtr AuditLogDir;
													Align4 Pad;
													UINT32 DiskCheckInterval;
													UINT32 MaxLogFilesSize;
													UINT32 MinSpaceOnDisk;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 34:
						_Struct RDhcpServerQueryAttribute
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s Reserved=%u DhcpAttribId=%u", ServerIpAddress.ToString, Reserved, DhcpAttribId )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad;
													UINT32 Reserved = DHCPMRDhcpServerQueryAttributeReservedTable(this);
													UINT32 DhcpAttribId = DHCPMAttribID(this);
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													NdrPtr DhcpAttribPtr;
													Switch
													{
														Case DhcpAttribPtr.ReferentID > 0:
															DHCPMDhcpAttrib DhcpAttrib;
													}
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 35:
						_Struct RDhcpServerQueryAttributes
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s Reserved=%u AttribCount=%u", ServerIpAddress.ToString, Reserved, AttribCount )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad;
													UINT32 Reserved = DHCPMRDhcpServerQueryAttributesReservedTable(this);
													UINT32 AttribCount;
													NdrPtr DhcpAttribsPtr;
													Struct DhcpAttribs
													{
														NdrConformant DhcpAttribsConf;
														[ Local.DhcpAttribsCount = 0, MaxLoopCount = DhcpAttribsConf.MaxCount ]
														While [ Local.DhcpAttribsCount < DhcpAttribsConf.MaxCount ]
														{
															[ Local.DhcpAttribsCount = Local.DhcpAttribsCount + 1 ]
															UINT32 DhcpAttribId = DHCPMAttribID(this);
														}
													}
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													NdrPtr DhcpAttribArrPtr;
													Switch
													{
														Case DhcpAttribArrPtr.ReferentID > 0:
															DHCPMDhcpAttribArray DhcpAttribArr;
													}
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 36:
						_Struct RDhcpServerRedoAuthorization
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s Reserved=%u", ServerIpAddress.ToString, Reserved )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 pad;
													UINT32 Reserved;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 37:
						_Struct RDhcpAddSubnetElementV5
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s SubnetAddress=%s", ServerIpAddress.ToString, SubnetAddress )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad1;
													IPv4Address SubnetAddress;
													NdrAlign Pad2;
													DHCPMDhcpSubnetElementDataV5 AddElementInfo;
													DHCPMDhcpSubnetElementDataV5Ref AddElementInfoRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 38:
						_Struct RDhcpEnumSubnetElementsV5
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s SubnetAddress=%s ResumeHandle=%u PreferredMaximum=%u", ServerIpAddress.ToString, SubnetAddress.ToString, ResumeHandle, PreferredMaximum )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad1;
													IPv4Address SubnetAddress;
													NdrEnum EnumElementType = DHCPMDhcpSubnetElementTypeTable(this.value);
													Align4 Pad2;
													UINT32 ResumeHandle;
													UINT32 PreferredMaximum;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ResumeHandle=%u ElementsRead=%u ElementsTotal=%u ReturnValue=%u", ResumeHandle, ElementsRead, ElementsTotal, ReturnValue )]
												Struct
												{
													UINT32 ResumeHandle;
													NdrPtr EnumElementInfoPtr;
													Switch
													{
														Case EnumElementInfoPtr.ReferentID > 0:
															DHCPMDhcpSubnetElementInfoArrayV5 EnumElementInfo;
													}
													Align4 Pad;
													UINT32 ElementsRead;
													UINT32 ElementsTotal;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 39:
						_Struct RDhcpRemoveSubnetElementV5
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s SubnetAddress=%s", ServerIpAddress.ToString, SubnetAddress )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad1;
													IPv4Address SubnetAddress;
													NdrAlign Pad2;
													DHCPMDhcpSubnetElementDataV5 RemoveElementInfo;
													DHCPMDhcpSubnetElementDataV5Ref RemoveElementInfoRef;
													NdrEnum ForceFlag = DHCPMDhcpForceFlagTable(this.value);
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 40:
						_Struct RDhcpGetServerBindingInfo
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s Flags=%u", ServerIpAddress.ToString, Flags )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad;
													UINT32 Flags;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													NdrPtr BindElementsInfoPtr;
													Switch
													{
														Case BindElementsInfoPtr.ReferentID > 0:
															DHCPMDhcpBindElementArray BindElementsInfo;
													}
													Align4 Pad;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 41:
						_Struct RDhcpSetServerBindingInfo
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s Flags=%u", ServerIpAddress.ToString, Flags )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad;
													UINT32 Flags = DHCPMRDhcpSetServerBindingInfoFlagsTable(this);
													DHCPMDhcpBindElementArray BindElementsInfo;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 42:
						_Struct RDhcpQueryDnsRegCredentials
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s UnameSize=%u DomainSize=%u", ServerIpAddress.ToString, UnameSize, DomainSize )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad;
													UINT32 UnameSize;
													UINT32 DomainSize;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "Uname=%s Domain=%s ReturnValue=%u", Uname.ToString, Domain.ToString, ReturnValue )]
												Struct
												{
													NdrConformant UnameConf;
													Switch
													{
														Case UnameConf.MaxCount > 0:
															UnicodeString(UnameConf.MaxCount) Uname;
													}
													NdrConformant DomainConf;
													Switch
													{
														Case DomainConf.MaxCount > 0:
															UnicodeString(DomainConf.MaxCount) Domain;
													}
													ALign4 Pad;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 43:
						_Struct RDhcpSetDnsRegCredentials
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s Uname=%s Domain=%s Passwd=%s", ServerIpAddress.ToString, Uname.ToString, Domain.ToString, Passwd.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													NdrWideStringPtr Uname;
													NdrWideStringPtr Domain;
													NdrWideStringPtr Passwd;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 44:
						_Struct RDhcpBackupDatabase
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s Path=%s", ServerIpAddress.ToString, Path.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													NdrWideString Path;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 45:
						_Struct RDhcpRestoreDatabase
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s Path=%s", ServerIpAddress.ToString, Path.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													NdrWideString Path;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 46:
						_Struct RDhcpGetServerSpecificStrings
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s", ServerIpAddress.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													NdrPtr ServerSpecificStringsPtr;
													Switch
													{
														Case ServerSpecificStringsPtr.ReferentID > 0:
															Struct
															{
																DHCPMDhcpServerSpecificStrings ServerSpecificStrings;
																DHCPMDhcpServerSpecificStringsRef ServerSpecificStringsRef;
															}
													}
													Align4 Pad;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 47:
						_Struct RDhcpCreateOptionV6
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s Flags=%u OptionId=%u ClassName=%s VendorName=%s", ServerIpAddress.ToString, Flags, OptionId, ClassName.ToString, VendorName.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad1;
													UINT32 Flags = DHCPMRDhcpCreateOptionV6FlagsTable(this);
													UINT32 OptionId;
													NdrWideStringPtr ClassName;
													NdrWideStringPtr VendorName;
													NdrAlign Pad2;
													DHCPMDhcpOption OptionInfo;
													DHCPMDhcpOptionRef OptionInfoRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 48:
						_Struct RDhcpSetOptionInfoV6
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s Flags=%u OptionID=%u ClassName=%s VendorName=%s", ServerIpAddress.ToString, Flags, OptionID, ClassName.ToString, VendorName.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad1;
													UINT32 Flags = DHCPMRDhcpSetOptionInfoV6FlagsTable(this);
													UINT32 OptionID;
													NdrWideStringPtr ClassName;
													NdrWideStringPtr VendorName;
													NdrAlign Pad2;
													DHCPMDhcpOption OptionInfo;
													DHCPMDhcpOptionRef OptionInfoRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 49:
						_Struct RDhcpGetOptionInfoV6
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s Flags=%u OptionID=%u ClassName=%s VendorName=%s", ServerIpAddress.ToString, Flags, OptionID, ClassName.ToString, VendorName.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad;
													UINT32 Flags = DHCPMRDhcpGetOptionInfoV6FlagsTable(this);
													UINT32 OptionID;
													NdrWideStringPtr ClassName;
													NdrWideStringPtr VendorName;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													NdrPtr OptionInfoPtr;
													Switch {
														Case OptionInfoPtr.ReferentID > 0:
															Struct
															{
																DHCPMDhcpOption OptionInfo;
																DHCPMDhcpOptionRef OptionInfoRef;
															}
													}
													Align4 Pad;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 50:
						_Struct RDhcpEnumOptionsV6
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s Flags=%u ClassName=%s VendorName=%s ResumeHandle=%u PreferredMaximum=%u", ServerIpAddress.ToString, Flags, ClassName.ToString, VendorName.ToString, ResumeHandle, PreferredMaximum )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad1;
													UINT32 Flags = DHCPMRDhcpEnumOptionsV6FlagsTable(this);
													NdrWideStringPtr ClassName;
													NdrWideStringPtr VendorName;
													Align4 Pad2;
													UINT32 ResumeHandle;
													UINT32 PreferredMaximum;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ResumeHandle=%u OptionsRead=%u OptionsTotal=%u ReturnValue=%u", ResumeHandle, OptionsRead, OptionsTotal, ReturnValue )]
												Struct
												{
													UINT32 ResumeHandle;
													NdrPtr OptionsPtr;
													Switch
													{
														Case OptionsPtr.ReferentID > 0:
															DHCPMDhcpOptionArray Options;
													}
													Align4 Pad;
													UINT32 OptionsRead;
													UINT32 OptionsTotal;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 51:
						_Struct RDhcpRemoveOptionV6
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s Flags=%u OptionID=%u ClassName=%s VendorName=%s", ServerIpAddress.ToString, Flags, OptionID, ClassName.ToString, VendorName.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													ALign4 Pad;
													UINT32 Flags = DHCPMRDhcpRemoveOptionV6FlagsTable(this);
													UINT32 OptionID;
													NdrWideStringPtr ClassName;
													NdrWideStringPtr VendorName;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 52:
						_Struct RDhcpSetOptionValueV6
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s Flags=%u OptionId=%u ClassName=%s VendorName=%s", ServerIpAddress.ToString, Flags, OptionId, ClassName.ToString, VendorName.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad1;
													UINT32 Flags = DHCPMRDhcpSetOptionValueV6FlagsTable(this);
													UINT32 OptionId;
													NdrWideStringPtr ClassName;
													NdrWideStringPtr VendorName;
													Align8 Pad2;
													DHCPMDhcpOptionScopeInfo6 ScopeInfo;
													NdrAlign Pad3;
													DHCPMDhcpOptionData OptionValue;
													DHCPMDhcpOptionDataRef OptionValueRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 53:
						_Struct RDhcpEnumOptionValuesV6
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s Flags=%u ClassName=%s VendorName=%s ResumeHandle=%u PreferredMaximum=%u", ServerIpAddress.ToString, Flags, ClassName.ToString, VendorName.ToString, ResumeHandle, PreferredMaximum )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad1;
													UINT32 Flags = DHCPMRDhcpEnumOptionValuesV6FlagsTable(this);
													NdrWideStringPtr ClassName;
													NdrWideStringPtr VendorName;
													Align8 Pad2;
													DHCPMDhcpOptionScopeInfo6 ScopeInfo;
													UINT32 ResumeHandle;
													UINT32 PreferredMaximum;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ResumeHandle=%u OptionsRead=%u OptionsTotal=%u ReturnValue=%u", ResumeHandle, OptionsRead, OptionsTotal, ReturnValue )]
												Struct
												{
													UINT32 ResumeHandle;
													NdrPtr OptionValuesPtr;
													Switch
													{
														Case OptionValuesPtr.ReferentID > 0:
															DHCPMDhcpOptionValueArray OptionValues;
													}
													UINT32 OptionsRead;
													UINT32 OptionsTotal;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 54:
						_Struct RDhcpRemoveOptionValueV6
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s Flags=%u OptionID=%u ClassName=%s VendorName=%s", ServerIpAddress.ToString, Flags, OptionID, ClassName.ToString, VendorName.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad1;
													UINT32 Flags = DHCPMRDhcpRemoveOptionValueV6FlagsTable(this);
													UINT32 OptionID;
													NdrWideStringPtr ClassName;
													NdrWideStringPtr VendorName;
													Align8 Pad2;
													DHCPMDhcpOptionScopeInfo6 ScopeInfo;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 55:
						_Struct RDhcpGetAllOptionsV6
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s Flags=%u", ServerIpAddress.ToString, Flags )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad;
													UINT32 Flags = DHCPMRDhcpGetAllOptionsV6FlagsTable(this);
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													NdrPtr OptionStructPtr;
													Switch
													{
														Case OptionStructPtr.ReferentID > 0:
															Struct
															{
																DHCPMDhcpAllOptions OptionStruct;
																DHCPMDhcpAllOptionsRef OptionStructRef;
															}
													}
													Align4 Pad;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 56:
						_Struct RDhcpGetAllOptionValuesV6
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s Flags=%u", ServerIpAddress.ToString, Flags )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad1;
													UINT32 Flags;
													Align8 Pad2;
													DHCPMDhcpOptionScopeInfo6 ScopeInfo;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													NdrPtr ValuesPtr;
													Switch
													{
														Case ValuesPtr.ReferentID > 0:
															Struct
															{
																DHCPMDhcpAllOptionValues Values;
																DHCPMDhcpAllOptionValuesRef ValuesRef;
															}
													}
													Align4 Pad;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 57:
						_Struct RDhcpCreateSubnetV6
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s", ServerIpAddress.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align8 Pad;
													DHCPMDhcpIpv6Address SubnetAddress;
													DHCPMDhcpSubnetInfoV6 SubnetInfo;
													DHCPMDhcpSubnetInfoV6Ref SubnetInfoRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 58:
						_Struct RDhcpEnumSubnetsV6
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s ResumeHandle=%u PreferredMaximum=%u", ServerIpAddress.ToString, ResumeHandle, PreferredMaximum )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad;
													UINT32 ResumeHandle;
													UINT32 PreferredMaximum;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ResumeHandle=%u ElementsRead=%u ElementsTotal=%u ReturnValue=%u", ResumeHandle, ElementsRead, ElementsTotal, ReturnValue )]
												Struct
												{
													UINT32 ResumeHandle;
													NdrPtr EnumInfoPtr;
													Switch
													{
														Case EnumInfoPtr.ReferentID > 0:
															DHCPMDhcpv6IpArray EnumInfo;
													}
													UINT32 ElementsRead;
													UINT32 ElementsTotal;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 59:
						_Struct RDhcpAddSubnetElementV6
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s", ServerIpAddress.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													ALign8 Pad1;
													DHCPMDhcpIpv6Address SubnetAddress;
													DHCPMDhcpSubnetElementDataV6 AddElementInfo;
													Align8 Pad2;
													DHCPMDhcpSubnetElementDataV6Ref AddElementInfoRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 60:
						_Struct RDhcpEnumSubnetElementsV6
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s ResumeHandle=%u PreferredMaximum=%u", ServerIpAddress.ToString, ResumeHandle, PreferredMaximum )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align8 Pad1;
													DHCPMDhcpIpv6Address SubnetAddress;
													NdrEnum EnumElementType = DHCPMDhcpSubnetElementTypeV6Table(this.value);
													Align4 Pad2;
													UINT32 ResumeHandle;
													UINT32 PreferredMaximum;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ResumeHandle=%u ElementsRead=%u ElementsTotal=%u ReturnValue=%u", ResumeHandle, ElementsRead, ElementsTotal, ReturnValue )]
												Struct
												{
													UINT32 ResumeHandle;
													NdrPtr EnumElementInfoPtr;
													Switch
													{
														Case EnumElementInfoPtr.ReferentID > 0:
															DHCPMDhcpSubnetElementInfoArrayV6 EnumElementInfo;
													}
													UINT32 ElementsRead;
													UINT32 ElementsTotal;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 61:
						_Struct RDhcpRemoveSubnetElementV6
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s", ServerIpAddress.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align8 Pad1;
													DHCPMDhcpIpv6Address SubnetAddress;
													DHCPMDhcpSubnetElementDataV6 RemoveElementInfo;
													Align8 Pad2;
													DHCPMDhcpSubnetElementDataV6Ref RemoveElementInfoRef;
													NdrEnum ForceFlag = DHCPMDhcpForceFlagTable(this.value);
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 62:
						_Struct RDhcpDeleteSubnetV6
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s", ServerIpAddress.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align8 Pad;
													DHCPMDhcpIpv6Address PrefixAddress;
													NdrEnum ForceFlag = DHCPMDhcpForceFlagTable(this.value);
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 63:
						_Struct RDhcpGetSubnetInfoV6
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s", ServerIpAddress.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align8 Pad;
													DHCPMDhcpIpv6Address SubnetAddress;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													NdrPtr SubnetInfoPtr;
													Switch
													{
														Case SubnetInfoPtr.ReferentID > 0:
															Struct
															{
																ALign8 Pad1;
																DHCPMDhcpSubnetInfoV6 SubnetInfo;
																DHCPMDhcpSubnetInfoV6Ref SubnetInfoRef;
															}
													}
													Align4 Pad2;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 64:
						_Struct RDhcpEnumSubnetClientsV6
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s PreferredMaximum=%u", ServerIpAddress.ToString, PreferredMaximum )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align8 Pad;
													DHCPMDhcpIpv6Address SubnetAddress;
													DHCPMDhcpIpv6Address ResumeHandle;
													UINT32 PreferredMaximum;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ClientsRead=%u ClientsTotal=%u ReturnValue=%u", ClientsRead, ClientsTotal, ReturnValue )]
												Struct
												{
													DHCPMDhcpIpv6Address ResumeHandle;
													NdrPtr ClientInfoPtr;
													Switch
													{
														Case ClientInfoPtr.ReferentID > 0:
															DHCPMDhcpClientInfoArrayV6 ClientInfo;
													}
													Align4 Pad;
													UINT32 ClientsRead;
													UINT32 ClientsTotal;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 65:
						_Struct RDhcpServerSetConfigV6
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s FieldsToSet=%u", ServerIpAddress.ToString, FieldsToSet )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align8 Pad;
													DHCPMDhcpOptionScopeInfo6 ScopeInfo;
													UINT32 FieldsToSet = DHCPMRDhcpServerSetConfigV6FieldsToSetTable(this);
													DHCPMDhcpServerConfigInfoV6 ConfigInfo;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 66:
						_Struct RDhcpServerGetConfigV6
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s", ServerIpAddress.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align8 Pad;
													DHCPMDhcpOptionScopeInfo6 ScopeInfo;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													NdrPtr ConfigInfoPtr;
													Switch
													{
														Case ConfigInfoPtr.ReferentID > 0:
															DHCPMDhcpServerConfigInfoV6 ConfigInfo;
													}
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 67:
						_Struct RDhcpSetSubnetInfoV6
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s", ServerIpAddress.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													ALign8 Pad;
													DHCPMDhcpIpv6Address SubnetAddress;
													DHCPMDhcpSubnetInfoV6 SubnetInfo;
													DHCPMDhcpSubnetInfoV6Ref SubnetInfoRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 68:
						_Struct RDhcpGetMibInfoV6
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s", ServerIpAddress.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													NdrPtr MibInfoPtr;
													Switch {
														Case MibInfoPtr.ReferentID > 0:
															DhcpMibInfoV6 MibInfo;
													}
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 69:
						_Struct RDhcpGetServerBindingInfoV6
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s Flags=%u", ServerIpAddress.ToString, Flags )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad;
													UINT32 Flags = DHCPMRDhcpGetServerBindingInfoV6FlagsTable(this);
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													NdrPtr BindElementsInfoPtr;
													Switch {
														Case BindElementsInfoPtr.ReferentID > 0:
															DHCPMDhcpv6BindElementArray BindElementsInfo;
													}
													Align4 Pad;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 70:
						_Struct RDhcpSetServerBindingInfoV6
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s Flags=%u", ServerIpAddress.ToString, Flags )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad1;
													UINT32 Flags = DHCPMRDhcpSetServerBindingInfoV6FlagsTable(this);
													NdrAlign Pad2;
													DHCPMDhcpv6BindElementArray BindElementsInfo;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 71:
						_Struct RDhcpSetClientInfoV6
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s", ServerIpAddress.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align8 Pad;
													DHCPMDhcpClientInfoV6 ClientInfo;
													DHCPMDhcpClientInfoV6Ref ClientInfoRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 72:
						_Struct RDhcpGetClientInfoV6
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s", ServerIpAddress.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align8 Pad;
													DHCPMDhcpClientSearchInfoV6 SearchInfo;
													DHCPMDhcpClientSearchInfoV6Ref SearchInfoRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													NdrPtr ClientInfoPtr;
													Switch {
														Case ClientInfoPtr.ReferentID > 0:
															Struct
															{
																Align8 Pad1;
																DHCPMDhcpClientInfoV6 ClientInfo;
																DHCPMDhcpClientInfoV6Ref ClientInfoRef;
															}
													}
													Align4 Pad2;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 73:
						_Struct RDhcpDeleteClientInfoV6
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s", ServerIpAddress.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align8 Pad;
													DHCPMDhcpClientSearchInfoV6 ClientInfo;
													DHCPMDhcpClientSearchInfoV6Ref ClientInfoRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 74:
						_Struct RDhcpCreateClassV6
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s ReservedMustBeZero=%u", ServerIpAddress.ToString, ReservedMustBeZero )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad1;
													UINT32 ReservedMustBeZero;
													NdrAlign Pad2;
													DHCPMDhcpClassInfoV6 ClassInfo;
													DHCPMDhcpClassInfoV6Ref ClassInfoRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 75:
						_Struct RDhcpModifyClassV6
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s ReservedMustBeZero=%u", ServerIpAddress.ToString, ReservedMustBeZero )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad1;
													UINT32 ReservedMustBeZero;
													NdrAlign Pad2;
													DHCPMDhcpClassInfoV6 ClassInfo;
													DHCPMDhcpClassInfoV6Ref ClassInfoRef;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 76:
						_Struct RDhcpDeleteClassV6
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s ReservedMustBeZero=%u ClassName=%s", ServerIpAddress.ToString, ReservedMustBeZero, ClassName.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad;
													UINT32 ReservedMustBeZero;
													NdrWideStringPtr ClassName;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 77:
						_Struct RDhcpEnumClassesV6
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s ReservedMustBeZero=%u ResumeHandle=%u PreferredMaximum=%u", ServerIpAddress.ToString, ReservedMustBeZero, ResumeHandle, PreferredMaximum )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad;
													UINT32 ReservedMustBeZero;
													UINT32 ResumeHandle;
													UINT32 PreferredMaximum;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ResumeHandle=%u Read=%u Total=%u ReturnValue=%u", ResumeHandle, Read, Total, ReturnValue )]
												Struct
												{
													UINT32 ResumeHandle;
													NdrPtr ClassInfoArrayPtr;
													Switch
													{
														Case ClassInfoArrayPtr.ReferentID > 0:
															DHCPMDhcpClassInfoArrayV6 ClassInfoArray;
													}
													Align4 Pad;
													UINT32 Read;
													UINT32 Total;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 78:
						_Struct RDhcpGetOptionValueV6
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s Flags=%u OptionID=%u ClassName=%s VendorName=%s", ServerIpAddress.ToString, Flags, OptionID, ClassName.ToString, VendorName.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad1;
													UINT32 Flags = DHCPMRDhcpGetOptionValueV6FlagsTable(this);
													UINT32 OptionID;
													NdrWideStringPtr ClassName;
													NdrWideStringPtr VendorName;
													Align8 Pad2;
													DHCPMDhcpOptionScopeInfo6 ScopeInfo;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													NdrPtr DhcpOptionValuePtr;
													Switch
													{
														Case DhcpOptionValuePtr.ReferentID > 0:
															Struct
															{
																DHCPMDhcpOptionValue OptionValue;
																DHCPMDhcpOptionValueRef OptionValueRef;
															}
													}
													Align4 Pad;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 79:
						_Struct RDhcpSetSubnetDelayOffer
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s SubnetAddress=%s TimeDelayInMilliseconds=%u", ServerIpAddress.ToString, SubnetAddress.ToString, TimeDelayInMilliseconds )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad;
													IPv4Address SubnetAddress;
													UINT16 TimeDelayInMilliseconds = DHCPMRDhcpSetSubnetDelayOfferTimeDelayInMillisecondsTable(this);
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 80:
						_Struct RDhcpGetSubnetDelayOffer
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s SubnetAddress=%s", ServerIpAddress.ToString, SubnetAddress )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad;
													IPv4Address SubnetAddress;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "TimeDelayInMilliseconds=%u ReturnValue=%u", TimeDelayInMilliseconds, ReturnValue )]
												Struct
												{
													UINT16 TimeDelayInMilliseconds;
													Align4 pad;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 81:
						_Struct RDhcpGetMibInfoV5
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s", ServerIpAddress.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													NdrPtr MibInfoPtr;
													Switch
													{
														Case MibInfoPtr.ReferentID > 0:
															DhcpMibInfoV5 MibInfo;
													}
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 82:
						_Struct RDhcpAddFilterV4
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s ForceFlag=%d", ServerIpAddress.ToString, ForceFlag )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													NdrAlign Pad1;
													DHCPMDhcpFilterAddInfov4 AddFilterInfo;
													DHCPMDhcpFilterAddInfov4Ref AddFilterInfoRef;
													Align4 Pad2;
													BOOL ForceFlag;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 83:
						_Struct RDhcpDeleteFilterV4
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s", ServerIpAddress.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad;
													DHCPMDhcpAddrPattern DeleteFilterInfo;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 84:
						_Struct RDhcpSetFilterV4
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s", ServerIpAddress.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad;
													DHCPMDhcpFilterGlobalInfo GlobalFilterInfo;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 85:
						_Struct RDhcpGetFilterV4
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s", ServerIpAddress.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													DHCPMDhcpFilterGlobalInfo GlobalFilterInfo;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 86:
						_Struct RDhcpEnumFilterV4
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s PreferredMaximum=%u", ServerIpAddress.ToString, PreferredMaximum )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad1;
													DHCPMDhcpAddrPattern ResumeHandle;
													Align4 Pad2;
													UINT32 PreferredMaximum;
													NdrEnum ListType = DHCPMDhcpFilterListTypeTable(this.value);
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ElementsRead=%u ElementsTotal=%u ReturnValue=%u", ElementsRead, ElementsTotal, ReturnValue )]
												Struct
												{
													DHCPMDhcpAddrPattern ResumeHandle;
													NdrPtr EnumFilterInfoPtr;
													Switch
													{
														Case EnumFilterInfoPtr.ReferentID > 0:
															DHCPMDhcpFilterEnumInfo EnumFilterInfo;
													}
													Align4 Pad;
													UINT32 ElementsRead;
													UINT32 ElementsTotal;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 87:
						_Struct RDhcpSetDnsRegCredentialsV5
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s Uname=%s Domain=%s Passwd=%s", ServerIpAddress.ToString, Uname.ToString, Domain.ToString, Passwd.ToString )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													NdrWideStringPtr Uname;
													NdrWideStringPtr Domain;
													NdrWideStringPtr Passwd;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ReturnValue=%u", ReturnValue )]
												Struct
												{
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Case 88:
						_Struct RDhcpEnumSubnetClientsFilterStatusInfo
						{
							Switch( Property.MSRPCPType )
							{
								Case 0x00: //REQUEST
									_Struct Request
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ServerIpAddress=%s SubnetAddress=%s ResumeHandle=%u PreferredMaximum=%u", ServerIpAddress.ToString, SubnetAddress.ToString, ResumeHandle, PreferredMaximum )]
												Struct
												{
													NdrWideStringPtr ServerIpAddress;
													Align4 Pad;
													IPv4Address SubnetAddress;
													UINT32 ResumeHandle;
													UINT32 PreferredMaximum;
												}
										}
									}
								
								Case 0x02: //RESPONSE
									_Struct Response
									{
										Switch
										{
											Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
											Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob (FrameLength - Frameoffset) PayloadData = MSRPCEncryptionTable( Property.MSRPCEncrypted );
											Default:
												[DHCPMSummary = FormatString( "ResumeHandle=%u ClientRead=%u ClientsTotal=%u ReturnValue=%u", ResumeHandle, ClientRead, ClientsTotal, ReturnValue )]
												Struct
												{
													UINT32 ResumeHandle;
													NdrPtr ClientInfoPtr;
													Switch
													{
														Case ClientInfoPtr.ReferentID > 0:
															DHCPMDhcpClientFilterStatusInfoArray ClientInfo;
													}
													Align4 Pad;
													UINT32 ClientRead;
													UINT32 ClientsTotal;
													UINT32 ReturnValue = WinErrorCodeTable( this );
												}
										}
									}
							}
						}
					
					Default:
						Switch
						{
							case IsValueNone(Property.MSRPCOpnum):
								struct
								{
									Blob( FrameLength - Offset ) data;
									ReportParserWarning("DHCPM", "Property MSRPCOpnum is missing") ParserWarning;
								}
							default:
								ReportParserError( ParserErrorProtocolClassWindows, "DHCPM", "Unknown dhcpsrv2 method, Opnum:" + Property.MSRPCOpnum ) UnknownMethod;
						}
				}
			}
	}
}

//
//	_DHCP_MCAST_MIB_INFO
//  Alignment: Ndr
//
Struct DhcpMcastMibInfo
{
	UINT32 Discovers;
	UINT32 Offers;
	UINT32 Requests;
	UINT32 Renews;
	UINT32 Acks;
	UINT32 Naks;
	UINT32 Releases;
	UINT32 Informs;
	DHCPMDateTime ServerStartTime;
	UINT32 Scopes;
	[ Property.DHCPMScopeInfoPtr = this.ReferentID ]
	NdrPtr ScopeInfoPtr;
}

Struct DhcpMcastMibInfoRef
{
	Switch
	{
		Case Property.DHCPMScopeInfoPtr > 0:
			Struct ScopeInfo
			{
				NdrConformant ScopeInfoConf;
				[ Property.DHCPMScopeInfoCount = 0 , MaxLoopCount = ScopeInfoConf.Maxcount ]
				while[ Property.DHCPMScopeInfoCount < ScopeInfoConf.Maxcount ]
				{
					[ Property.DHCPMScopeInfoCount = Property.DHCPMScopeInfoCount + 1]
					DHCPMMscopeMibInfo ScopeMibInfo;
				}
				[ Property.DHCPMScopeInfoRefCount = 0 ,MaxLoopCount = ScopeInfoConf.Maxcount ]
				while[ Property.DHCPMScopeInfoRefCount < ScopeInfoConf.Maxcount ]
				{
					[ Property.DHCPMScopeInfoRefCount = Property.DHCPMScopeInfoRefCount + 1]
					DHCPMMscopeMibInfoRef ScopeMibInfoRef;
				}
			}
	}
}

//
//	_DHCP_MCLIENT_INFO
//  Alignment: Ndr
//
Struct DhcpMclientInfo
{
	IPv4Address ClientIpAddress;
	UINT32 MScopeId;
	DHCPMDhcpBinaryData ClientId;
	[ Property.DHCPMClientNamePtr = this.ReferentID ]
	NdrPtr ClientNamePtr;
	DHCPMDateTime ClientLeaseStarts;
	DHCPMDateTime ClientLeaseEnds;
	DHCPMDhcpHostInfo OwnerHost;
	UINT32 AddressFlags;
	CHAR AddressState = DhcpMclientInfoAddressStateTable(this);
	Switch
	{
		Case Property.MSRPCNdr64:
			Align8 Pad;
	}
}

Struct DhcpMclientInfoRef
{
	DHCPMDhcpBinaryDataRef ClientIdRef;
	Switch
	{
		case Property.DHCPMClientNamePtr > 0:
			NdrWideString ClientName;
	}
	DHCPMDhcpHostInfoRef OwnerHostRef;
}

Table DhcpMclientInfoAddressStateTable( Value )
{
	Switch( Value )
	{
		Case 0x00000000: "ADDRESS_STATE_OFFERED - The DHCPv4 client has been offered this IPv4 address.";
		Case 0x00000001: "ADDRESS_STATE_ACTIVE - The IPv4 address is active and has an active DHCPv4 client lease record.";
		Case 0x00000002: "ADDRESS_STATE_DECLINED - The IPv4 address request was declined by the DHCPv4 client; hence it is a bad IPv4 address.";
		Case 0x00000003: "ADDRESS_STATE_DOOM - The IPv4 address is in DOOMED state and is due to be deleted.";
		Default: "Unknown";
	}
}

//
//	_DHCP_MCLIENT_INFO_ARRAY
//  Alignment: Ndr
//
Struct DhcpMclientInfoArray
{
	UINT32 NumElements;
	NDRPtr ClientsPtr;
	Switch 
	{
		Case ClientsPtr.ReferentID > 0:
			Struct 
			{
				NdrConformant ClientsConf;
				Struct
				{
						[ Property.DHCPMClientsCount = 0 , MaxLoopCount = ClientsConf.Maxcount ]
						while[ Property.DHCPMClientsCount < ClientsConf.Maxcount ]
						{
							[ Property.DHCPMClientsCount = Property.DHCPMClientsCount + 1]
							NDRPtr ClientPtr;
						}
						[ MaxLoopCount = ClientsConf.Maxcount ]
						while[ Property.DHCPMClientsCount > 0 ]
						{
							[ Property.DHCPMClientsCount = Property.DHCPMClientsCount - 1]
							DhcpMclientInfo Client;
							DhcpMclientInfoRef ClientRef;
						}
				}
			}
	}
}

//
//	_DATE_TIME
//  Alignment: 4
//
Struct DHCPMDateTime
{
	UINT32 LowDateTime;
	UINT32 HighDateTime;
}

//
//	_DHCP_ADDR_PATTERN
//  Alignment: 4
//
Struct DHCPMDhcpAddrPattern
{
	BOOL MatchHWType;
	CHAR HwType;
	Align4 Pad;
	BOOL IsWildcard = DHCPMDhcpAddrPatternIsWildcardTable(this);
	CHAR Length;
	CHAR Pattern[Length];
	Switch
	{
		Case Property.MSRPCNdr64:
			Align4 Pad;
	}
}

Table DHCPMDhcpAddrPatternIsWildcardTable( Value )
{
	Switch( Value )
	{
		Case 1: "TRUE - The pattern is a wildcard pattern.";
		Case 0: "FALSE - The pattern is a hardware address.";
		Default: "Unknown";
	}
}

//
//	_DHCP_ALL_OPTIONS
//  Alignment: Ndr
//
Struct DHCPMDhcpAllOptions
{
	UINT32 Flags;
	[ Property.DHCPMNonVendorOptionsPtr = this.ReferentID ]
	NdrPtr NonVendorOptionsPtr;
	UINT32 NumVendorOptions;
	[ Property.DHCPMVendorOptionsPtr = this.ReferentID ]
	NdrPtr VendorOptionsPtr;
}

Struct DHCPMVendorOptions
{
	[
	  Property.DHCPMOptionNamePtr$[ Property.DHCPMVendorOptionsCount ] = this.OptionNamePtr.ReferentID,
	  Property.DHCPMOptionCommentPtr$[ Property.DHCPMVendorOptionsCount ] = this.OptionCommentPtr.ReferentID,
	  Property.DHCPMElementsPtr$[ Property.DHCPMVendorOptionsCount ] = this.DefaultValue.ElementsPtr.ReferentID
	]
	DHCPMDhcpOption Option;
	[ Property.DHCPMVendorNamePtr$[ Property.DHCPMVendorOptionsCount ] = this.ReferentID ]
	NdrPtr VendorNamePtr;
	[ Property.DHCPMClassNamePtr$[ Property.DHCPMVendorOptionsCount ] = this.ReferentID ]
	NdrPtr ClassNamePtr;
}

Struct DHCPMVendorOptionsRef
{
	Switch
	{
		Case Property.DHCPMOptionNamePtr$[ Property.DHCPMVendorOptionsRefCount ] > 0:
			NdrWideString OptionName;
	}
	
	Switch
	{
		Case Property.DHCPMOptionCommentPtr$[ Property.DHCPMVendorOptionsRefCount ] > 0:
			NdrWideString OptionComment;
	}
	
	Switch
	{
		Case Property.DHCPMElementsPtr$[ Property.DHCPMVendorOptionsRefCount ] != 0:
			Struct
			{
				NdrConformant ElementsConf;
				[ Property.DHCPMElementsCount = 0, MaxLoopCount = ElementsConf.MaxCount ]
				while[ Property.DHCPMElementsCount < ElementsConf.MaxCount ]
				{
					[ Property.DHCPMElementsCount = Property.DHCPMElementsCount + 1 ]
					DHCPMDhcpOptionDataElement Element;
				}
				[ Property.DHCPMElementsRefCount = 0, MaxLoopCount = ElementsConf.MaxCount ]
				while[ Property.DHCPMElementsRefCount < ElementsConf.MaxCount ]
				{
					[ Property.DHCPMElementsRefCount = Property.DHCPMElementsRefCount + 1 ]
					DHCPMDhcpOptionDataElementRef ElementRef;
				}
			}
	}
	
	Switch
	{
		Case Property.DHCPMVendorNamePtr$[ Property.DHCPMVendorOptionsRefCount ] > 0:
			NdrWideString VendorName;
	}
	
	Switch
	{
		Case Property.DHCPMClassNamePtr$[ Property.DHCPMVendorOptionsRefCount ] > 0:
			NdrWideString ClassName;
	}
}

Struct DHCPMDhcpAllOptionsRef
{
	Switch
	{
		Case Property.DHCPMNonVendorOptionsPtr> 0:
			DHCPMDhcpOptionArray NonVendorOptions;
	}
	
	Switch
	{
		Case Property.DHCPMVendorOptionsPtr > 0:
			Struct VendorOptions
			{
				NdrConformant VendorOptionsConf;
				[ Property.DHCPMVendorOptionsCount = 0, MaxLoopCount = VendorOptionsConf.MaxCount ]
				while[ Property.DHCPMVendorOptionsCount < VendorOptionsConf.MaxCount ]
				{
					[ Property.DHCPMVendorOptionsCount = Property.DHCPMVendorOptionsCount + 1]
					DHCPMVendorOptions VendorOption;
				}
				[ Property.DHCPMVendorOptionsRefCount = 0,MaxLoopCount = VendorOptionsConf.MaxCount ]
				while[ Property.DHCPMVendorOptionsRefCount < VendorOptionsConf.MaxCount ]
				{
					[ Property.DHCPMVendorOptionsRefCount = Property.DHCPMVendorOptionsRefCount + 1]
					DHCPMVendorOptionsRef VendorOptionRef;
				}
			}
	}
}

//
//	_DHCP_ALL_OPTION_VALUES
//  Alignment: Ndr
//
Struct DHCPMDhcpAllOptionValues
{
	UINT32 Flags;
	UINT32 NumElements;
	[ Property.DHCPMOptionsPtr = this.ReferentID ]
	NdrPtr OptionsPtr;
}

Struct DHCPMDhcpAllOptionValuesRef
{
	Switch
	{
		Case Property.DHCPMOptionsPtr > 0:
			Struct Options
			{
				NdrConformant OptionsConf;
				[ Property.DHCPMOptionsCount = 0, MaxLoopCount = OptionsConf.MaxCount ]
				while[ Property.DHCPMOptionsCount < OptionsConf.MaxCount ]
				{
					[ Property.DHCPMOptionsCount = Property.DHCPMOptionsCount + 1]
					DHCPMOptions Option;
				}
				[ Property.DHCPMOptionsRefCount = 0,MaxLoopCount = OptionsConf.MaxCount ]
				while[ Property.DHCPMOptionsRefCount < OptionsConf.MaxCount ]
				{
					[ Property.DHCPMOptionsRefCount = Property.DHCPMOptionsRefCount + 1]
					DHCPMOptionsRef OptionRef;
				}
			}
	}
}

Struct DHCPMOptions
{
	[ Property.DHCPMClassNamePtr$[ Property.DHCPMOptionsCount ] = this.ReferentID ]
	NdrPtr ClassNamePtr;
	[ Property.DHCPMVendorNamePtr$[ Property.DHCPMOptionsCount ] = this.ReferentID ]
	NdrPtr VendorNamePtr;
	BOOL IsVendor;
	[ Property.DHCPMOptionsArrayPtr$[ Property.DHCPMOptionsCount ] = this.ReferentID ]
	NdrPtr OptionsArrayPtr;
}

Struct DHCPMOptionsRef
{
	Switch
	{
		Case Property.DHCPMClassNamePtr$[ Property.DHCPMOptionsRefCount ] > 0:
			NdrWideString ClassName;
	}
	Switch
	{
		Case Property.DHCPMVendorNamePtr$[ Property.DHCPMOptionsRefCount ] > 0:
			NdrWideString VendorName;
	}
	Switch
	{
		Case Property.DHCPMOptionsArrayPtr$[ Property.DHCPMOptionsRefCount ] > 0:
			DHCPMDhcpOptionValueArray OptionsArray;
	}
}

//
//	_DHCP_ATTRIB
//  Alignment: 4
//
Struct DHCPMDhcpAttrib
{
	UINT32 DhcpAttribId = DHCPMAttribID(this);
	UINT32 DhcpAttribType = DHCPMDhcpAttribDhcpAttribTypeTable(this);
	UINT32 SwitchValue = DHCPMDhcpAttribDhcpAttribTypeTable(this);
	Switch(SwitchValue)
	{
		case 0x00000001:
			BOOL DhcpAttribBool;
		Case 0x00000002:
			UINT32 DhcpAttribUlong;
		Default:
			ReportParserError( ParserErrorProtocolClassWindows, "DHCPM", "Unknown Union Switch Value" ) Unknown;
	}
}

//
//	_DHCP_ATTRIB_ARRAY
//  Alignment: Ndr
//
Struct DHCPMDhcpAttribArray
{
	UINT32 NumElements;
	NdrPtr DhcpAttribsPtr;
	Switch
	{
		Case DhcpAttribsPtr.ReferentID > 0:
			Struct DhcpAttribs
			{
				NdrConformant DhcpAttribsConf;
				[ Local.DhcpAttribsCount = 0, MaxLoopCount = DhcpAttribsConf.MaxCount ]
				While[ Local.DhcpAttribsCount < DhcpAttribsConf.MaxCount ]
				{
					[ Local.DhcpAttribsCount = Local.DhcpAttribsCount + 1 ]
					DHCPMDhcpAttrib DhcpAttrib;
				}
			}
	}
}

Table DHCPMDhcpAttribDhcpAttribTypeTable( Value )
{
	Switch( Value )
	{
		Case 0x00000001: "DHCP_ATTRIB_TYPE_BOOL - The attribute value is of BOOL type, and DhcpAttribBool is chosen from the following union.";
		Case 0x00000002: "DHCP_ATTRIB_TYPE_ULONG - The attribute value is of ULONG type, and DhcpAttribUlong is chosen from the following union.";
		Default: "Unknown";
	}
}

//
//	_DHCP_BINARY_DATA
//  Alignment: Ndr
//
Struct DHCPMDhcpBinaryData
{
	UINT32 DataLength;
	[ Property.DHCPMDataPtr$[ Property.DHCPMElementsCount ] = this.ReferentID ]
	NdrPtr DataPtr;
}

Struct DHCPMDhcpBinaryDataRef
{
	Switch 
	{
		Case Property.DHCPMDataPtr$[ Property.DHCPMElementsRefCount ] != 0:
			Struct Data
			{
				Ndrconformant DataConf;
				[ Property.DHCPMDataCount = 0, MaxLoopCount = DataConf.MaxCount ]
				while[ Property.DHCPMDataCount < DataConf.MaxCount ]
				{
					[ Property.DHCPMDataCount = Property.DHCPMDataCount + 1]
					UINT8 Data;
				}
			}
	}
}

//
//	_DHCP_BIND_ELEMENT
//  Alignment: Ndr
//
Struct DHCPMDhcpBindElement
{
	DHCPMDhcpBindElementFlags Flags;
	INT32 BoundToDHCPServer = DHCPMDhcpBindElementBoundToDHCPServerTable(this);
	IPv4Address AdapterPrimaryAddress;
	IPv4Address AdapterSubnetAddress;
	[ Property.DHCPMIfDescriptionPtr$[ Property.DHCPMElementsCount ] = this.ReferentID ]
	NdrPtr IfDescriptionPtr;
	UINT32 IfIdSize;
	[ Property.DHCPMIfIdPtr$[ Property.DHCPMElementsCount ] = this.ReferentID ]
	NdrPtr IfIdPtr;
}

Struct DHCPMDhcpBindElementRef
{
	Switch
	{
		Case Property.DHCPMIfDescriptionPtr$[ Property.DHCPMElementsRefCount ] > 0:
			NdrWideString IfDescription;
	}
	Switch
	{
		Case Property.DHCPMIfIdPtr$[ Property.DHCPMElementsRefCount ] > 0:
			Struct IfId
			{
				NdrConformant IfIdConf;
				[ Local.IfIdCount = 0, MaxLoopCount = IfIdConf.MaxCount ]
				while[ Local.IfIdCount < IfIdConf.MaxCount ]
				{
					[ Local.IfIdCount = Local.IfIdCount + 1 ]
					UINT8 IfIdData;
				}
			}
	}
}

//
//	_DHCP_BIND_ELEMENT_ARRAY
//  Alignment: Ndr
//
Struct DHCPMDhcpBindElementArray
{
	UINT32 NumElements;
	NdrPtr ElementsPtr;
	Switch
	{
		Case ElementsPtr.ReferentID > 0:
			Struct Elements
			{
				NdrConformant ElementsConf;
				[ Property.DHCPMElementsCount = 0, MaxLoopCount = ElementsConf.MaxCount ]
				While[ Property.DHCPMElementsCount < ElementsConf.MaxCount ]
				{
					[ Property.DHCPMElementsCount = Property.DHCPMElementsCount + 1 ]
					DHCPMDhcpBindElement Element;
				}
				[ Property.DHCPMElementsRefCount = 0, MaxLoopCount = ElementsConf.MaxCount ]
				While[ Property.DHCPMElementsRefCount < ElementsConf.MaxCount ]
				{
					[ Property.DHCPMElementsRefCount = Property.DHCPMElementsRefCount + 1 ]
					DHCPMDhcpBindElementRef ElementRef;
				}
			}
	}
}

Table DHCPMDhcpBindElementBoundToDHCPServerTable( Value )
{
	Switch( Value )
	{
		Case 0x00000000: "FALSE - It specifies that the interface is not bound to the DHCP server.";
		Case 0x00000001: "TRUE - It specifies whether the interface is bound to the DHCP server.";
		Default: "Unknown";
	}
}

Struct DHCPMDhcpBindElementFlags = FormatString( "0x%08X", UINT32( FrameData, FrameOffset ) )
{
	Switch( Property.MSRPCByteOrder )
	{
		Case LittleEndian:
		Struct
		{
			UINT32 Values = FormatString( "0x%08X", this )
			{
				UINT32 DhcpEndpointFlagCantModify:1 = FormatString("(%s) %s",this.ToBitString, this ? "The endpoints cannot be modified" : "The endpoints can be modified");
				UINT32 NotUsed:31 = FormatString("                   (%s) %s",this.ToBitString, this ? "Not Used" : "Not Used");
			}
		}
		Default:
		Struct
		{
			UINT32 Attributes = FormatString( "0x%08X", this )
			{
				UINT32 NotUsed:31 = FormatString("                   (%s) %s",this.ToBitString, this ? "Not Used" : "Not Used");
				UINT32 DhcpEndpointFlagCantModify:1 = FormatString("(%s) %s",this.ToBitString, this ? "The endpoints cannot be modified" : "The endpoints can be modified");
			}
		}
	}
}

//
//	_DHCP_CLASS_INFO
//  Alignment: None
//
Struct DHCPMDhcpClassInfo
{
	[ Property.DHCPMClassNamePtr$[ Property.DHCPMClassCount ] = this.ReferentID ]
	NdrPtr ClassNamePtr;
	[ Property.DHCPMClassCommentPtr$[ Property.DHCPMClassCount ] = this.ReferentID ]
	NdrPtr ClassCommentPtr;
	UINT32 ClassDataLength;
	BOOL IsVendor = DHCPMDhcpClassInfoIsVendorTable(this);
	UINT32 Flags;
	[ Property.DHCPMClassDataPtr$[ Property.DHCPMClassCount ] = this.ReferentID ]
	NdrPtr ClassDataPtr;
}

Struct DHCPMDhcpClassInfoRef
{
	Switch
	{
		Case Property.DHCPMClassNamePtr$[ Property.DHCPMClassRefCount ] > 0:
			NdrWideString ClassName;
	}
	Switch
	{
		Case Property.DHCPMClassCommentPtr$[ Property.DHCPMClassRefCount ] > 0:
			NdrWideString ClassComment;
	}
	Switch
	{
		Case Property.DHCPMClassDataPtr$[ Property.DHCPMClassRefCount ] > 0:
			Struct ClassData
			{
				NdrConformant ClassDataRef;
				
				[ Property.DHCPMClassDataCount = 0, MaxLoopCount = ClassDataRef.MaxCount ]
				while[ Property.DHCPMClassDataCount < ClassDataRef.MaxCount ]
				{
					[ Property.DHCPMClassDataCount = Property.DHCPMClassDataCount + 1]
					CHAR Data;
				}
			}
	}
}

//
//	_DHCP_CLASS_INFO_ARRAY
//  Alignment: Ndr
//
Struct DHCPMDhcpClassInfoArray
{
	UINT32 NumElements;
	NdrPtr  ClassesPtr;
	Switch 
	{
		Case ClassesPtr.referentID!=0:
			Struct Classes
			{
				NdrConformant ClassesConf;
				[ Property.DHCPMClassCount = 0 , MaxLoopCount = ClassesConf.Maxcount ]
				while[ Property.DHCPMClassCount < ClassesConf.Maxcount ]
				{
					[ Property.DHCPMClassCount = Property.DHCPMClassCount + 1]
					DHCPMDhcpClassInfo Class;
				}
				[ Property.DHCPMClassRefCount = 0 , MaxLoopCount = ClassesConf.Maxcount ]
				while[ Property.DHCPMClassRefCount < ClassesConf.Maxcount ]
				{
					[ Property.DHCPMClassRefCount = Property.DHCPMClassRefCount + 1]
					DHCPMDhcpClassInfoRef ClassRef;
				}
			}
			
	}
}

//
//	_DHCP_CLASS_INFO_ARRAY_V6
//  Alignment: Ndr
//
Struct DHCPMDhcpClassInfoArrayV6
{
	UINT32 NumElements;
	NdrPtr  ClassesPtr;
	Switch 
	{
		Case ClassesPtr.ReferentID!=0:
			Struct Classes
			{
				NdrConformant ClassesConf;
				[ Property.DHCPMClassCount = 0 , MaxLoopCount = ClassesConf.Maxcount ]
				while[ Property.DHCPMClassCount < ClassesConf.Maxcount ]
				{
					[ Property.DHCPMClassCount = Property.DHCPMClassCount + 1]
					DHCPMDhcpClassInfoV6 Class;
				}
				[ Property.DHCPMClassRefCount = 0 , MaxLoopCount = ClassesConf.Maxcount ]
				while[ Property.DHCPMClassRefCount < ClassesConf.Maxcount ]
				{
					[ Property.DHCPMClassRefCount = Property.DHCPMClassRefCount + 1]
					DHCPMDhcpClassInfoV6Ref ClassRef;
				}
			}
			
	}
}

Table DHCPMDhcpClassInfoIsVendorTable( Value )
{
	Switch( Value )
	{
		Case 0x00000000: "V1 - Class specified is a user class.";
		Case 0x00000001: "V2 - Class specified is a vendor class.";
		Default: "Unknown";
	}
}

//
//	_DHCP_CLASS_INFO_V6
//  Alignment: Ndr
//
Struct DHCPMDhcpClassInfoV6
{
	[ Property.DHCPMClassNamePtr$[ Property.DHCPMClassCount ] = this.ReferentID ]
	NdrPtr ClassNamePtr;
	[ Property.DHCPMClassCommentPtr$[ Property.DHCPMClassCount ] = this.ReferentID ]
	NdrPtr ClassCommentPtr;
	UINT32 ClassDataLength;
	BOOL IsVendor = DHCPMDhcpClassInfoV6IsVendorTable(this);
	UINT32 EnterpriseNumber;
	UINT32 Flags;
	[ Property.DHCPMClassDataPtr$[ Property.DHCPMClassCount ] = this.ReferentID ]
	NdrPtr ClassDataPtr;
}

Struct DHCPMDhcpClassInfoV6Ref
{
	Switch
	{
		Case Property.DHCPMClassNamePtr$[ Property.DHCPMClassRefCount ] > 0:
			NdrWideString ClassName;
	}
	Switch
	{
		Case Property.DHCPMClassCommentPtr$[ Property.DHCPMClassRefCount ] > 0:
			NdrWideString ClassComment;
	}
	Switch
	{
		Case Property.DHCPMClassDataPtr$[ Property.DHCPMClassRefCount ] > 0:
			Struct ClassData
			{
				NdrConformant ClassDataRef;
				
				[ Property.DHCPMClassDataCount = 0, MaxLoopCount = ClassDataRef.MaxCount ]
				while[ Property.DHCPMClassDataCount < ClassDataRef.MaxCount ]
				{
					[ Property.DHCPMClassDataCount = Property.DHCPMClassDataCount + 1]
					UINT8 Data;
				}
			}
	}
}

Table DHCPMDhcpClassInfoV6IsVendorTable( Value )
{
	Switch( Value )
	{
		Case 0x00000000: "V1 - Class specified is a user class.";
		Case 0x00000001: "V2 - Class specified is a vendor class.";
		Default: "Unknown";
	}
}

//
//	_DHCP_CLIENT_FILTER_STATUS_INFO
//  Alignment: Ndr
//
Struct DHCPMDhcpClientFilterStatusInfo
{
	IPv4Address ClientIpAddress;
	IPv4Address SubnetMask;
	DHCPMDhcpBinaryData ClientHardwareAddress;
	[ Property.DHCPMClientNamePtr = this.ReferentID ]
	NdrPtr ClientNamePtr;
	[ Property.DHCPMClientCommentPtr = this.ReferentID ]
	NdrPtr ClientCommentPtr;
	DHCPMDateTime ClientLeaseExpires;
	DHCPMDhcpHostInfo OwnerHost;
	CHAR ClientType = DHCPMDhcpClientFilterStatusInfoClientTypeTable(this);
	CHAR AddressState = DHCPMDhcpClientFilterStatusInfoAddressStateTable(this);
	NdrEnum Status = DHCPMQuarantineStatusTable(this.value);
	DHCPMDateTime ProbationEnds;
	BOOL QuarantineCapable;
	UINT32 FilterStatus = DHCPMDhcpClientFilterStatusInfoFilterStatusTable(this);
	Switch
	{
		Case Property.MSRPCNdr64:
			Align8 Pad;
	}
}

Struct DHCPMDhcpClientFilterStatusInfoRef
{
	DHCPMDhcpBinaryDataRef ClientHardwareAddressRef;
	Switch
	{
		Case Property.DHCPMClientNamePtr > 0:
			NdrWideString ClientName;
	}
	Switch
	{
		Case Property.DHCPMClientCommentPtr > 0:
			NdrWideString ClientComment;
	}
	DHCPMDhcpHostInfoRef OwnerHostRef;
}

Table DHCPMDhcpClientFilterStatusInfoAddressStateTable( Value )
{
	Switch( Value )
	{
		Case 0x00: "ADDRESS_STATE_OFFERED - The DHCPv4 client has been offered this IPv4 address.";
		Case 0x01: "ADDRESS_STATE_ACTIVE - The IPv4 address is Active and has an active DHCPv4 client lease record.";
		Case 0x02: "ADDRESS_STATE_DECLINED - The IPv4 address request was declined by the DHCPv4 client; hence it is a bad IPv4 address.";
		Case 0x03: "ADDRESS_STATE_DOOM - The IPv4 address is in DOOMED state and is due to be deleted.";
		Default: "Unknown";
	}
}

//
//	_DHCP_CLIENT_FILTER_STATUS_INFO_ARRAY
//  Alignment: Ndr
//
Struct DHCPMDhcpClientFilterStatusInfoArray
{
	UINT32 NumElements;
	NDRPtr ClientsPtr;
	Switch 
	{
		Case ClientsPtr.ReferentID > 0:
			Struct 
			{
				NdrConformant ClientsConf;
				Struct
				{
						[ Property.DHCPMClientsCount = 0 , MaxLoopCount = ClientsConf.Maxcount ]
						while[ Property.DHCPMClientsCount < ClientsConf.Maxcount ]
						{
							[ Property.DHCPMClientsCount = Property.DHCPMClientsCount + 1]
							NDRPtr ClientPtr;
						}
						[ MaxLoopCount = ClientsConf.Maxcount ]
						while[ Property.DHCPMClientsCount > 0 ]
						{
							[ Property.DHCPMClientsCount = Property.DHCPMClientsCount - 1]
							DHCPMDhcpClientFilterStatusInfo Client;
							DHCPMDhcpClientFilterStatusInfoRef ClientRef;
						}
				}
			}
	}
}

Table DHCPMDhcpClientFilterStatusInfoClientTypeTable( Value )
{
	Switch( Value )
	{
		Case 0x00: "CLIENT_TYPE_UNSPECIFIED - A DHCPv4 client other than ones defined in this table.";
		Case 0x01: "CLIENT_TYPE_DCHP - The DHCPv4 client supports the DHCP protocol.";
		Case 0x02: "CLIENT_TYPE_BOOTP - The client supports the BOOTP protocol.";
		Case 0x03: "CLIENT_TYPE_BOTH - The DHCPv4 client understands both the DHCP and BOOTP protocol.";
		Case 0x04: "CLIENT_TYPE_RESERVATION_FLAG - There is an IPv4 reservation created for the DHCP client.";
		Case 0x05: "CLIENT_TYPE_NONE - Backward compatibility for manual addressing.";
		Default: "Unknown";
	}
}

Table DHCPMDhcpClientFilterStatusInfoFilterStatusTable( Value )
{
	Switch( Value )
	{
		Case 0x00000001: "FILTER_STATUS_NONE - The DHCPv4 client MAC address does not match any filter.";
		Case 0x00000002: "FILTER_STATUS_FULL_MATCH_IN_ALLOW_LIST - The DHCv4P client MAC address fully matches an allow list filter.";
		Case 0x00000004: "FILTER_STATUS_FULL_MATCH_IN_DENY_LIST - The DHCPv4 client MAC address fully matches a deny list filter.";
		Case 0x00000008: "FILTER_STATUS_WILDCARD_MATCH_IN_ALLOW_LIST - The DHCPv4 client MAC address has a wild card match in the allow list.";
		Case 0x00000010: "FILTER_STATUS_WILDCARD_MATCH_IN_DENY_LIST - Possible value.";
		Default: "Unknown";
	}
}

//
//	_DHCP_CLIENT_INFO
//  Alignment: NDR
//
Struct DHCPMDhcpClientInfo
{
	IPv4Address ClientIpAddress;
	IPv4Address SubnetMask;
	DHCPMDhcpBinaryData ClientHardwareAddress;
	[Property.DHCPMClientNamePtr = this.ReferentID]
	NdrPtr ClientNamePtr;
	[Property.DHCPMClientCommentPtr = this.ReferentID]
	NdrPtr ClientCommentPtr;
	DHCPMDateTime ClientLeaseExpires;
	DHCPMDhcpHostInfo OwnerHost;
}

Struct DHCPMDhcpClientInfoRef
{
	DHCPMDhcpBinaryDataRef ClientHardwareAddressRef;
	Switch
	{
		Case Property.DHCPMClientNamePtr > 0:
			NdrWideString ClientName;
	}
	Switch
	{
		Case Property.DHCPMClientCommentPtr > 0:
			NdrWideString ClientComment;
	}
	DHCPMDhcpHostInfoRef OwnerHostRef;
}

//
//	_DHCP_CLIENT_INFO_ARRAY
//  Alignment: Ndr
//
Struct DHCPMDhcpClientInfoArray = FormatString( "Client Count: %u",NumElements)
{
	UINT32 NumElements;
	NdrPtr ClientsPointer;
	Switch
	{
		case ClientsPointer.ReferentID > 0:
			Struct
			{
				NdrConformant ClientsConf;
				[ Property.DHCPMDhcpClientInfoCount = 0, MaxLoopCount = ClientsConf.MaxCount ]
				while[ Property.DHCPMDhcpClientInfoCount < ClientsConf.MaxCount ]
				{
					[ Property.DHCPMDhcpClientInfoCount = Property.DHCPMDhcpClientInfoCount + 1 ]
					NdrPtr ClientInfoPtr;
				}
				[ Property.DHCPMDhcpClientInfoRefCount = 0, MaxLoopCount = ClientsConf.MaxCount ]
				while[ Property.DHCPMDhcpClientInfoRefCount < ClientsConf.MaxCount ]
				{
					[ Property.DHCPMDhcpClientInfoRefCount = Property.DHCPMDhcpClientInfoRefCount + 1 ]
					DHCPMDhcpClientInfo Client;
					DHCPMDhcpClientInfoRef ClientRef;
				}
			}
	}
}

//
//	_DHCP_CLIENT_INFO_ARRAY_V4
//  Alignment: 4
//
Struct DHCPMDhcpClientInfoArrayV4
{	
	UINT32 NumElements;
	NdrPtr ClientsPtr;
	switch
	{
		Case ClientsPtr.ReferentID > 0:
			Struct Clients
			{
				NdrConformant ClientsConf;
				[ Property.DHCPMClientInfoCount = 0, MaxLoopCount = ClientsConf.MaxCount ]
				while[ Property.DHCPMClientInfoCount < ClientsConf.MaxCount ]
				{
					[ Property.DHCPMClientInfoCount = Property.DHCPMClientInfoCount + 1 ]
					DHCPMDhcpClientInfoV4 Client;
				}
				[ Property.DHCPMClientInfoRefCount = 0, MaxLoopCount = ClientsConf.MaxCount ]
				while[ Property.DHCPMClientInfoRefCount < ClientsConf.MaxCount ]
				{
					[ Property.DHCPMClientInfoRefCount = Property.DHCPMClientInfoRefCount + 1 ]
					DHCPMDhcpClientInfoV4Ref ClientRef;
				}
			}
	}
}

//
//	_DHCP_CLIENT_INFO_ARRAY_V5
//  Alignment: Ndr
//
Struct DHCPMDhcpClientInfoArrayV5
{
	UINT32 NumElements;
	NdrPtr ClientsPtr;
	switch
	{
		Case ClientsPtr.ReferentID > 0:
			Struct Clients
			{
				NdrConformant ClientsConf;
				[ Property.DHCPMClientInfoCount = 0, MaxLoopCount = ClientsConf.MaxCount ]
				while[ Property.DHCPMClientInfoCount < ClientsConf.MaxCount ]
				{
					[ Property.DHCPMClientInfoCount = Property.DHCPMClientInfoCount + 1,
					Property.DHCPMClientPtr$[ Property.DHCPMClientInfoCount ] = this.ReferentID ]
					NdrPtr ClientPtr;
				}
				[ Property.DHCPMClientInfoRefCount = 0, MaxLoopCount = ClientsConf.MaxCount ]
				while[ Property.DHCPMClientInfoRefCount < ClientsConf.MaxCount ]
				{
					[ Property.DHCPMClientInfoRefCount = Property.DHCPMClientInfoRefCount + 1 ]
					Switch
					{
						Case Property.DHCPMClientPtr$[ Property.DHCPMClientInfoRefCount ] > 0:
							Struct
							{
								DHCPMDhcpClientInfoV5 Client;
								DHCPMDhcpClientInfoV5Ref ClientRef;
							}
					}
				}
			}
	}
}

//
//	_DHCP_CLIENT_INFO_ARRAY_V6
//  ALignment: Ndr
//
Struct DHCPMDhcpClientInfoArrayV6
{	
	UINT32 NumElements;
	NdrPtr ClientsPtr;
	switch
	{
		Case ClientsPtr.ReferentID > 0:
			Struct Clients
			{
				NdrConformant ClientsConf;
				[ Property.DHCPMClientInfoCount = 0, MaxLoopCount = ClientsConf.MaxCount ]
				while[ Property.DHCPMClientInfoCount < ClientsConf.MaxCount ]
				{
					[ Property.DHCPMClientInfoCount = Property.DHCPMClientInfoCount + 1,
					Property.DHCPMClientPtr$[ Property.DHCPMClientInfoCount ] = this.ReferentID ]
					NdrPtr ClientPtr;
				}
				[ Property.DHCPMClientInfoRefCount = 0, MaxLoopCount = ClientsConf.MaxCount ]
				while[ Property.DHCPMClientInfoRefCount < ClientsConf.MaxCount ]
				{
					[ Property.DHCPMClientInfoRefCount = Property.DHCPMClientInfoRefCount + 1 ]
					Switch
					{
						Case Property.DHCPMClientPtr$[ Property.DHCPMClientInfoRefCount ] > 0:
							Struct
							{
								DHCPMDhcpClientInfoV6 Client;
								DHCPMDhcpClientInfoV6Ref ClientRef;
							}
					}
				}
			}
	}
}

//
//	_DHCP_CLIENT_INFO_ARRAY_VQ
//  Alignment: 4
//
Struct DHCPMDhcpClientInfoArrayVq
{	
	UINT32 NumElements;
	NdrPtr ClientsPtr;
	Switch
	{
		case ClientsPtr.ReferentID > 0:
			Struct Clients
			{
				NdrConformant ClientsConf;
				Struct
				{
					[ Property.DHCPMClientsCount = 0, MaxLoopCount = ClientsConf.MaxCount ]
					while[ Property.DHCPMClientsCount < ClientsConf.MaxCount ]
					{
						[ Property.DHCPMClientsCount = Property.DHCPMClientsCount + 1,
						Property.DHCPMClientPtr$[ Property.DHCPMClientsCount ] = this.ReferentID ]
						NdrPtr ClientPtr;
					}
					[ Property.DHCPMClientsRefCount = 0, MaxLoopCount = ClientsConf.MaxCount ]
					while[ Property.DHCPMClientsRefCount < ClientsConf.MaxCount ]
					{
						[ Property.DHCPMClientsRefCount = Property.DHCPMClientsRefCount + 1 ]
						Switch
						{
							case Property.DHCPMClientPtr$[ Property.DHCPMClientsRefCount ] > 0:
								struct
								{
									DHCPMDhcpClientInfoVq Client;
									DHCPMDhcpClientInfoVqRef ClientRef;
								}
						}
					}
				}
			}
	}
}

//
//	_DHCP_CLIENT_INFO_V4
//  Alignment: Ndr
//
Struct DHCPMDhcpClientInfoV4
{
	IPv4Address ClientIpAddress;
	IPv4Address SubnetMask;
	[ Property.DHCPMClientHardwareAddressPtr$[ Property.DHCPMClientInfoCount ] = this.DataPtr.ReferentID ]
	DHCPMDhcpBinaryData ClientHardwareAddress;
	[ Property.DHCPMClientNamePtr$[ Property.DHCPMClientInfoCount ] = this.ReferentID ]
	NdrPtr ClientNamePtr;
	[ Property.DHCPMClientCommentPtr$[ Property.DHCPMClientInfoCount ] = this.ReferentID ]
	NdrPtr ClientCommentPtr;
	DHCPMDateTime ClientLeaseExpires;
	DHCPMDhcpHostInfo OwnerHost;
	CHAR ClientType = DHCPMDhcpClientInfoV4ClientTypeTable(this);
	Switch
	{
		Case Property.MSRPCNdr64:
			Align8 Pad;
	}
}

Struct DHCPMDhcpClientInfoV4Ref
{
	Switch
	{
		Case Property.DHCPMClientHardwareAddressPtr$[ Property.DHCPMClientInfoRefCount ] > 0:
			Struct Data
			{
				Ndrconformant DataConf;
				[ Property.DHCPMDataCount = 0, MaxLoopCount = DataConf.MaxCount ]
				while[ Property.DHCPMDataCount < DataConf.MaxCount ]
				{
					[ Property.DHCPMDataCount = Property.DHCPMDataCount + 1]
					UINT8 Data;
				}
			}
	}
	Switch
	{
		Case Property.DHCPMClientNamePtr$[ Property.DHCPMClientInfoRefCount ] > 0:
			NdrWideString ClientName;
	}
	Switch
	{
		Case Property.DHCPMClientCommentPtr$[ Property.DHCPMClientInfoRefCount ] > 0:
			NdrWideString ClientComment;
	}
	DHCPMDhcpHostInfoRef OwnerHostRef;
}

Table DHCPMDhcpClientInfoV4ClientTypeTable( Value )
{
	Switch( Value )
	{
		Case 0x00: "CLIENT_TYPE_UNSPECIFIED - A DHCPv4 client other than ones defined in this table.";
		Case 0x01: "CLIENT_TYPE_DHCP - The DHCPv4 client supports the DHCPv4 protocol.";
		Case 0x02: "CLIENT_TYPE_BOOTP - The client supports the BOOTP protocol.";
		Case 0x03: "CLIENT_TYPE_BOTH - The DHCPv4 client understands both the DHCPv4 and the BOOTP protocols.";
		Case 0x04: "CLIENT_TYPE_RESERVATION_FLAG - There is an IPv4 reservation created for the DHCPv4 client.";
		Case 0x64: "CLIENT_TYPE_NONE - Backward compatibility for manual addressing.";
		Default: "Unknown";
	}
}

//
//	_DHCP_CLIENT_INFO_V5
//
Struct DHCPMDhcpClientInfoV5
{
	IPv4Address ClientIpAddress;
	IPv4Address SubnetMask;
	DHCPMDhcpBinaryData ClientHardwareAddress;
	[ Property.DHCPMClientNamePtr = this.ReferentID ]
	NdrPtr ClientNamePtr;
	[ Property.DHCPMClientCommentPtr = this.ReferentID ]
	NdrPtr ClientCommentPtr;
	DHCPMDateTime ClientLeaseExpires;
	DHCPMDhcpHostInfo OwnerHost;
	CHAR ClientType = DHCPMDhcpClientInfoV4ClientTypeTable(this);
	CHAR AddressState = DHCPMDhcpClientInfoV5AddressStateTable(this);
	Switch
	{
		Case Property.MSRPCNdr64:
			Align8 Pad;
	}
}

Struct DHCPMDhcpClientInfoV5Ref
{
	DHCPMDhcpBinaryDataRef ClientHardwareAddressRef;
	Switch
	{
		Case Property.DHCPMClientNamePtr > 0:
			NdrWideString ClientName;
	}
	Switch
	{
		Case Property.DHCPMClientCommentPtr > 0:
			NdrWideString ClientComment;
	}
	DHCPMDhcpHostInfoRef OwnerHostRef;
}


Table DHCPMDhcpClientInfoV5AddressStateTable( Value )
{
	Switch( Value )
	{
		Case 0x00: "ADDRESS_STATE_OFFERED - The DHCPv4 client has been offered this IPv4 address.";
		Case 0x01: "ADDRESS_STATE_ACTIVE - The IPv4 address is active and has an active DHCPv4 client lease record.";
		Case 0x02: "ADDRESS_STATE_DECLINED - The IPv4 address request was declined by the DHCPv4 client; hence it is a bad IPv4 address.";
		Case 0x03: "ADDRESS_STATE_DOOM - The IPv4 address is in DOOMED state and is due to be deleted.";
		Default: "Unknown";
	}
}

Table DHCPMDhcpClientInfoV5ClientTypeTable( Value )
{
	Switch( Value )
	{
		Case 0x00: "CLIENT_TYPE_UNSPECIFIED - A DHCPv4 client other than ones defined in this table.";
		Case 0x01: "CLIENT_TYPE_DHCP - The DHCPv4 client supports the DHCP protocol.";
		Case 0x02: "CLIENT_TYPE_BOOTP - The client supports the BOOTP protocols.";
		Case 0x03: "CLIENT_TYPE_BOTH - The DHCPv4 client understands both the DHCPv4 and the BOOTP protocols.";
		Case 0x04: "CLIENT_TYPE_RESERVATION_FLAG - There is an IPv4 reservation created for the DHCPv4 client.";
		Case 0x64: "CLIENT_TYPE_NONE - Backward compatibility for manual addressing.";
		Default: "Unknown";
	}
}

//
//	_DHCP_CLIENT_INFO_V6
//  Alignment: 8
//
Struct DHCPMDhcpClientInfoV6
{
	DHCPMDhcpIpv6Address ClientIpAddress;
	DHCPMDhcpBinaryData ClientDUID;
	UINT32 AddressType = DHCPMDhcpClientInfoV6AddressTypeTable(this);
	UINT32 IAID;
	[ Property.DHCPMClientNamePtr = this.ReferentID ]
	NdrPtr ClientNamePtr;
	[ Property.DHCPMClientCommentPtr = this.ReferentID ]
	NdrPtr ClientCommentPtr;
	DHCPMDateTime ClientValidLeaseExpires;
	DHCPMDateTime ClientPrefLeaseExpires;
	DHCPMDhcpHostInfoV6 OwnerHost;
}

Struct DHCPMDhcpClientInfoV6Ref
{
	DHCPMDhcpBinaryDataRef ClientDUIDRef;
	Switch
	{
		Case Property.DHCPMClientNamePtr > 0:
			NdrWideString ClientName;
	}
	Switch
	{
		Case Property.DHCPMClientCommentPtr > 0:
			NdrWideString ClientComment;
	}
	DHCPMDhcpHostInfoRef OwnerHostRef;
}

Table DHCPMDhcpClientInfoV6AddressTypeTable( Value )
{
	Switch( Value )
	{
		Case 0x00000000: "ADDRESS_TYPE_IANA - Indicates an IANA address. [RFC3315]";
		Case 0x00000001: "ADDRESS_TYPE_IATA - Indicates an IATA address. [RFC3315]";
		Default: "Unknown";
	}
}

//
//	_DHCP_CLIENT_INFO_VQ
//  Alignment: Ndr
//
Struct DHCPMDhcpClientInfoVq
{
	IPv4Address ClientIpAddress;
	IPv4Address SubnetMask;
	DHCPMDhcpBinaryData ClientHardwareAddress;
	[ Property.DHCPMClientNamePtr = this.ReferentID ]
	NdrPtr ClientNamePtr;
	[ Property.DHCPMClientCommentPtr = this.ReferentID ]
	NdrPtr ClientCommentPtr;
	DHCPMDateTime ClientLeaseExpires;
	DHCPMDhcpHostInfo OwnerHost;
	CHAR ClientType = DHCPMDhcpClientInfoVqClientTypeTable(this);
	CHAR AddressState = DHCPMDhcpClientInfoVqAddressStateTable(this);
	NdrEnum Status = DHCPMQuarantineStatusTable(this.value);
	ALign4 Pad;
	DHCPMDateTime ProbationEnds;
	BOOL QuarantineCapable;
	Switch
	{
		Case Property.MSRPCNdr64:
			Align8 Pad;
	}
}

Struct DHCPMDhcpClientInfoVqRef
{
	DHCPMDhcpBinaryDataRef ClientHardwareAddressRef;
	Switch
	{
		Case Property.DHCPMClientNamePtr > 0:
			NdrWideString ClientName;
	}
	Switch
	{
		Case Property.DHCPMClientCommentPtr > 0:
			NdrWideString ClientComment;
	}
	DHCPMDhcpHostInfoRef OwnerHostRef;
}

Table DHCPMDhcpClientInfoVqAddressStateTable( Value )
{
	Switch( Value )
	{
		Case 0x00: "ADDRESS_STATE_OFFERED - The DHCPv4 client has been offered this IPv4 address.";
		Case 0x01: "ADDRESS_STATE_ACTIVE - The IPv4 address is active and has an active DHCPv4 client lease record.";
		Case 0x02: "ADDRESS_STATE_DECLINED - The IPv4 address request was declined by the DHCPv4 client; hence, it is a bad IPv4 address.";
		Case 0x03: "ADDRESS_STATE_DOOM - The IPv4 address is in DOOMED state and is due to be deleted.";
		Default: "Unknown";
	}
}

Table DHCPMDhcpClientInfoVqClientTypeTable( Value )
{
	Switch( Value )
	{
		Case 0x00: "CLIENT_TYPE_UNSPECIFIED - A DHCPv4 client other than ones defined in this table.";
		Case 0x01: "CLIENT_TYPE_DHCP - The DHCPv4 client supports the DHCP protocol.";
		Case 0x02: "CLIENT_TYPE_BOOTP - The DHCPv4 client supports the BOOTP protocol.";
		Case 0x03: "CLIENT_TYPE_BOTH - The DHCPv4 client understands both the DHCPv4 and the BOOTP protocols.";
		Case 0x04: "CLIENT_TYPE_RESERVATION_FLAG - There is an IPv4 reservation created for the DHCPv4 client.";
		Case 0x64: "CLIENT_TYPE_NONE - Backward compatibility for manual addressing.";
		Default: "Unknown";
	}
}

//
//	_DHCP_CLIENT_SEARCH_INFO
//  Alignment: Ndr
//
Struct DHCPMDhcpClientSearchInfo
{
	NdrEnum SearchType = DHCPMDhcpClientSearchTypeTable(this.value);
	Switch
	{
		Case Property.MSRPCNdr64:
			Align8 Pad1;
	}
	[ Property.DHCPMSearchInfoSwitchValue = this.value ]
	NdrEnum SwitchValue = DHCPMDhcpClientSearchInfoSearchTypeTable(this.value);
	Switch
	{
		Case Property.MSRPCNdr64:
			Align8 Pad2;
	}
	Switch( SwitchValue.value )
	{
		Case 0:
			Struct
			{
				IPv4Address ClientIpAddress;
			}
		Case 1:
			Struct
			{
				NdrAlign Pad;
				DHCPMDhcpBinaryData ClientHardwareAddress;
			}
		Case 2:
			Struct
			{
				[ Property.DHCPMClientNamePtr = this.ReferentID ]
				NdrPtr ClientNamePtr;
			}
		Default:
			ReportParserError( ParserErrorProtocolClassWindows, "DHCPM", "Unknown Union Switch Value" ) Unknown;
	}
	Switch
	{
		Case Property.MSRPCNdr64:
			NdrAlign Pad;
	}
}

Struct DHCPMDhcpClientSearchInfoRef
{
	Switch ( Property.DHCPMSearchInfoSwitchValue )
	{
		case 0:
			_struct{}
		case 1:
			DHCPMDhcpBinaryDataRef ClientHardwareAddressRef;
		case 2:
			Switch
			{
				case Property.DHCPMClientNamePtr > 0:
					NdrWideString	ClientName;
			}
		Default:
			ReportParserError( ParserErrorProtocolClassWindows, "DHCPM", "Unknown Union Switch Value" ) Unknown;
	}
}

Table DHCPMDhcpClientSearchInfoSearchTypeTable( Value )
{
	Switch( Value )
	{
		Case 0: "DhcpClientIpAddress - A pointer to a null-terminated Unicode string, which contains the DHCPv4 client IPv4 address specified in a subsequent field, that is used to search for the DHCPv4 client lease record in the DHCP server database.";
		Case 1: "DhcpClientHardwareAddress - The DHCPv4 client hardware address (MAC address) specified in a subsequent field is used to search for the DHCPv4 client lease record in the DHCPv4 server database.";
		Case 2: "DhcpClientName - A pointer to a null-terminated Unicode string (contains the name of the DHCPv4 client) that is used to search for the DHCPv4 client lease record in the DHCPv4 server database.";
		Default: "Unknown";
	}
}

//
//	_DHCP_CLIENT_SEARCH_INFO_V6
//  Alignment: 8
//
Struct DHCPMDhcpClientSearchInfoV6
{
	NdrEnum SearchType = DHCPMDhcpClientSearchTypeV6Table(this.value);
	Switch
	{
		Case Property.MSRPCNdr64:
			Align8 Pad1;
	}
	[ Property.DHCPMSearchInfoV6SwitchValue = this.value ]
	NdrEnum SwitchValue = DHCPMDhcpClientSearchTypeV6Table(this.value);
	Switch
	{
		Case Property.MSRPCNdr64:
			Align8 Pad2;
	}
	Switch( SwitchValue.value )
	{
		Case 0:
			Struct
			{
				ALign8 Pad;
				DHCPMDhcpIpv6Address ClientIpAddress;
			}
		Case 1:
			Struct
			{
				NdrAlign Pad;
				DHCPMDhcpBinaryData ClientHardwareAddress;
			}
		Case 2:
			Struct
			{
				[ Property.DHCPMClientNamePtr = this.ReferentID ]
				NdrPtr ClientNamePtr;
			}
		Default:
			ReportParserError( ParserErrorProtocolClassWindows, "DHCPM", "Unknown Union Switch Value" ) Unknown;
	}
	Switch
	{
		Case Property.MSRPCNdr64:
			Align8 Pad;
	}
}

Struct DHCPMDhcpClientSearchInfoV6Ref
{
	Switch ( Property.DHCPMSearchInfoV6SwitchValue )
	{
		case 0:
			_struct{}
		case 1:
			DHCPMDhcpBinaryDataRef ClientHardwareAddressRef;
		case 2:
			Switch
			{
				case Property.DHCPMClientNamePtr > 0:
					NdrWideString	ClientName;
			}
		Default:
			ReportParserError( ParserErrorProtocolClassWindows, "DHCPM", "Unknown Union Switch Value" ) Unknown;
	}
}

Table DHCPMDhcpClientSearchTypeTable( Value )
{
	Switch( Value )
	{
		Case 0: "DhcpClientIpAddress - The DHCPv4 client IP address MUST be used for querying the DHCPv4 client lease records from the database on the DHCPv4 server.";
		Case 1: "DhcpClientHardwareAddress - The DHCPv4 client hardware address (MAC address) MUST be used for querying the DHCPv4 client lease records from the database on the DHCPv4 server.";
		Case 2: "DhcpClientName - The null-terminated Unicode string containing the name of the DHCPv4 client MUST be used for querying the DHCPv4 client lease records on the DHCPv4 server.";
		Default:"Unknown";
	}
}

Table DHCPMDhcpClientSearchTypeV6Table( Value )
{
	Switch( Value )
	{
		Case 0: "Dhcpv6ClientIpAddress - Use DHCPv6 client IPv6 address for searching the DHCPv6 IPv6 client lease record in the DHCP server.";
		Case 1: "Dhcpv6ClientDUID - Use DHCPv6 client DUID for searching the DHCP IPv6 client lease record in the DHCPv6 server.";
		Case 2: "Dhcpv6ClientName - Use a null-terminated Unicode string containing the name of the DHCPv6 IPv6 client for searching for the DHCPv6 client lease record in the DHCPv6 server database.";
		Default:"Unknown";
	}
}

//
//	_DHCP_FILTER_ADD_INFOV4
//  Alignment: Ndr
//
Struct DHCPMDhcpFilterAddInfov4
{
	DHCPMDhcpAddrPattern AddrPatt;
	[ Property.DHCPMCommentPtr = this.ReferentID ]
	NdrPtr CommentPtr;
	NdrEnum ListType = DHCPMDhcpFilterListTypeTable(this.value);
	Switch
	{
		Case Property.MSRPCNdr64:
			Align8 Pad;
	}
}

Struct DHCPMDhcpFilterAddInfov4Ref
{
	Switch
	{
		Case Property.DHCPMCommentPtr > 0:
			NdrWideString Comment;
	}
}

//
//	_DHCP_FILTER_ENUM_INFO
//  Alignment: Ndr
//
Struct DHCPMDhcpFilterEnumInfo
{
	UINT32 NumElements;
	NdrPtr EnumRecordsPtr;
	Switch 
	{
		Case EnumRecordsPtr.ReferentID > 0:
			_struct EnumRecords
			{
				Ndrconformant ElementConf;
				[ Property.DHCPMEnumRecordsCount = 0, MaxLoopCount = ElementConf.MaxCount ]
				while[ Property.DHCPMEnumRecordsCount < ElementConf.MaxCount ]
				{
					[ Property.DHCPMEnumRecordsCount = Property.DHCPMEnumRecordsCount + 1]
					DHCPMDhcpFilterRecord EnumRecord;
				}
				[ Property.DHCPMEnumRecordsRefCount = 0, MaxLoopCount = ElementConf.MaxCount ]
				while[ Property.DHCPMEnumRecordsRefCount < ElementConf.MaxCount ]
				{
					[ Property.DHCPMEnumRecordsRefCount = Property.DHCPMEnumRecordsRefCount + 1 ]
					DHCPMDhcpFilterRecordRef EnumRecordRef;
				}
			}
	}
}

//
//	_DHCP_FILTER_GLOBAL_INFO
//  Alignment: 4
//
Struct DHCPMDhcpFilterGlobalInfo
{
	BOOL EnforceAllowList;
	BOOL EnforceDenyList;
}

Table DHCPMDhcpFilterListTypeTable( Value )
{
	Switch( Value )
	{
		Case 0: "Deny - Add the link-layer filter to the deny list.";
		Case 1: "Allow - Add the link-layer filter to the allow list.";
		Default:"Unknown";
	}
}

//
//	_DHCP_FILTER_RECORD
//  Alignment: Ndr
//
Struct DHCPMDhcpFilterRecord
{
	DHCPMDhcpAddrPattern AddrPatt;
	[ Property.DHCPMCommentPtr$[ Property.DHCPMEnumRecordsCount ] = this.ReferentID ]
	NdrPtr CommentPtr;
}

Struct DHCPMDhcpFilterRecordRef
{
	Switch
	{
		Case Property.DHCPMCommentPtr$[ Property.DHCPMEnumRecordsRefCount ] > 0:
			NdrWideString Comment;
	}
}

Table DHCPMDhcpForceFlagTable( Value )
{
	Switch( Value )
	{
		Case 0: "DhcpFullForce - The DHCP server deletes all the active DHCP client lease records for the specified subnet and then deletes all the configurations associated with that subnet.";
		Case 1: "DhcpNoForce - The DHCP server deletes only the configuration associated with the specified subnet. It leaves intact all the active DHCP client lease records for the specified subnet.";
		Default:"Unknown";
	}
}

//
//	_DHCP_HOST_INFO
//  Alignment: Ndr
//
Struct DHCPMDhcpHostInfo
{
	IPv4Address IpAddress;
	[ Property.DHCPMNetBiosNamePtr = NetBiosNamePtr.ReferentID ]
	NdrPtr NetBiosNamePtr;
	[ Property.DHCPMHostNamePtr = HostNamePtr.ReferentID ]
	NdrPtr HostNamePtr;
}

Struct DHCPMDhcpHostInfoRef
{
	Switch 
	{
		Case Property.DHCPMNetBiosNamePtr != 0:
			NdrWideString NetBiosName;
	}
	Switch 
	{
		Case Property.DHCPMHostNamePtr != 0:
			NdrWideString HostName;
	}
}

//
//	_DHCP_HOST_INFO_V6
//  Alignment: 8
//
Struct DHCPMDhcpHostInfoV6
{
	DHCPMDhcpIpv6Address IpAddress;
	[ Property.DHCPMNetBiosNamePtr = NetBiosNamePtr.ReferentID ]
	NdrPtr NetBiosNamePtr;
	[ Property.DHCPMHostNamePtr = HostNamePtr.ReferentID ]
	NdrPtr HostNamePtr;
}

//
//	_DHCP_IP_ARRAY
//  Alignment: NDR
//
Struct DHCPMDhcpIpArray
{
	UINT32 NumElements;
	NdrPtr ElementsPtr;
	Switch 
	{
		Case ElementsPtr.ReferentID > 0:
			_struct Elements
			{
				Ndrconformant ElementConf;
				[ Property.DHCPMElementsCount = 0, MaxLoopCount = ElementConf.MaxCount ]
				while[ Property.DHCPMElementsCount < ElementConf.MaxCount ]
				{
					[ Property.DHCPMElementsCount = Property.DHCPMElementsCount + 1]
					IPv4Address Element;
				}
			}
	}
}

//
//	_DHCP_IP_CLUSTER
//  Alignment: 4
//
Struct DHCPMDhcpIpCluster
{
	IPV4Address ClusterAddress;
	UINT32 ClusterMask;
}

//
//	_DHCP_IP_RANGE
//  Alignment: 4
//
Struct DHCPMDhcpIpRange
{
	IPv4Address StartAddress;
	IPv4Address EndAddress;
}

//
//	_DHCP_BOOTP_IP_RANGE
//  Alignment: 4
//
Struct DHCPMDhcpBootPIpRange
{
	IPv4Address StartAddress;
	IPv4Address EndAddress;
	UINT32 BootpAllocated;
	UINT32 MaxBootpAllowed;
}

//
//	_DHCP_IP_RANGE_V6
//  Alignment: 8
//
Struct DHCPMDhcpIpRangeV6
{
	DHCPMDhcpIpv6Address StartAddress;
	DHCPMDhcpIpv6Address EndAddress;
}

//
//	_DHCP_IP_RESERVATION
//  Alignment: Ndr
//
Struct DHCPMDhcpIpReservation
{
	IPv4Address ReservedIpAddress;
	NdrPtr ReservedForClientPtr;
	Switch 
	{
		Case ReservedForClientPtr.ReferentID > 0:
			_struct
			{
				DHCPMDhcpBinaryData ReservedForClient;
				DHCPMDhcpBinaryDataRef ReservedForClientRef;
			}
	}
}

//
//	_DHCP_IP_RESERVATION_V4
//  Alignment:Ndr
//
Struct DHCPMDhcpIpReservationV4
{
	IPv4Address ReservedIpAddress;
	NdrPtr ReservedForClientPtr;
	CHAR AllowedClientTypes = DHCPMDhcpIpReservationV4AllowedClientTypesTable(this);
	Switch
	{
		Case Property.MSRPCNdr64:
			Align8 Pad;
	}
	Switch 
	{
		Case ReservedForClientPtr.ReferentID > 0:
			struct ReservedForClient
			{
				NdrAlign Pad;
				DHCPMDhcpBinaryData ReservedForClient;
				DHCPMDhcpBinaryDataRef ReservedForClientRef;
			}
	}
}

Table DHCPMDhcpIpReservationV4AllowedClientTypesTable( Value )
{
	Switch( Value )
	{
		Case 0x01: "CLIENT_TYPE_DHCP - The IPv4 reservation is for a DHCPv4 client.";
		Case 0x02: "CLIENT_TYPE_BOOTP - The IPv4 reservation is for a BOOTP client.";
		Case 0x03: "CLIENT_TYPE_BOTH - The IPv4 reservation is for both kinds of clients.";
		Default: "Unknown";
	}
}

//
//	_DHCP_IP_RESERVATION_V6
//  Alignment: 8
//
Struct DHCPMDhcpIpReservationV6
{
	DHCPMDhcpIpv6Address ReservedIpAddress;
	NdrPtr ReservedForClientPtr;
	UINT32 InterfaceId;
	Switch
	{
		Case Property.MSRPCNdr64:
			Align8 Pad;
	}
	Switch 
	{
		Case ReservedForClientPtr.ReferentID > 0:
			struct ReservedForClient
			{
				DHCPMDhcpBinaryData ReservedForClient;
				DHCPMDhcpBinaryDataRef ReservedForClientRef;
			}
	}
}

//
//	_DHCP_IPV6_ADDRESS
//  ALignment: 8
//
Struct DHCPMDhcpIpv6Address
{
	UINT64 HighOrderBits;
	UINT64 LowOrderBits;
}

//
//	_DHCP_OPTION
//  Alignment: NDR
//
Struct DHCPMDhcpOption
{
	UINT32 OptionID;
	[ Property.DHCPMOptionNamePtr$[ Property.DHCPMOptionsCount ] = this.ReferentID ]
	NdrPtr OptionNamePtr;
	[ Property.DHCPMOptionCommentPtr$[ Property.DHCPMOptionsCount ] = this.ReferentID ]
	NdrPtr OptionCommentPtr;
	[ Property.DHCPMElementsPtr$[ Property.DHCPMOptionsCount ] = this.ElementsPtr.ReferentID ]
	DHCPMDhcpOptionData DefaultValue;
	NdrEnum OptionType = DHCPMDhcpOptionTypeTable(this.value);
	Switch
	{
		Case Property.MSRPCNdr64:
			Align8 Pad;
	}
}

Struct DHCPMDhcpOptionRef
{
	Switch
	{
		Case Property.DHCPMOptionNamePtr$[ Property.DHCPMOptionsRefCount ] > 0:
			NdrWideString OptionName;
	}
	
	Switch
	{
		Case Property.DHCPMOptionCommentPtr$[ Property.DHCPMOptionsRefCount ] > 0:
			NdrWideString OptionComment;
	}
	
	Switch
	{
		Case Property.DHCPMElementsPtr$[ Property.DHCPMOptionsRefCount ] != 0:
			Struct
			{
				NdrConformant ElementsConf;
				[ Property.DHCPMElementsCount = 0, MaxLoopCount = ElementsConf.MaxCount ]
				while[ Property.DHCPMElementsCount < ElementsConf.MaxCount ]
				{
					[ Property.DHCPMElementsCount = Property.DHCPMElementsCount + 1 ]
					DHCPMDhcpOptionDataElement Element;
				}
				[ Property.DHCPMElementsRefCount = 0, MaxLoopCount = ElementsConf.MaxCount ]
				while[ Property.DHCPMElementsRefCount < ElementsConf.MaxCount ]
				{
					[ Property.DHCPMElementsRefCount = Property.DHCPMElementsRefCount + 1 ]
					DHCPMDhcpOptionDataElementRef ElementRef;
				}
			}
	}
}

//
//	_DHCP_OPTION_ARRAY
//  Alignment: Ndr
//
Struct DHCPMDhcpOptionArray
{	
	UINT32 NumElements;
	NdrPtr OptionsPtr;
	switch
	{
		Case OptionsPtr.ReferentID > 0:
			Struct Options
			{
				NdrConformant OptionsConf;
				Struct
				{
					[ Property.DHCPMOptionsCount = 0, MaxLoopCount = OptionsConf.MaxCount ]
					while[ Property.DHCPMOptionsCount < OptionsConf.MaxCount ]
					{
						[ Property.DHCPMOptionsCount = Property.DHCPMOptionsCount + 1 ]
						DHCPMDhcpOption Option;
					}
					
					[ Property.DHCPMOptionsRefCount = 0, MaxLoopCount = OptionsConf.MaxCount ]
					while[ Property.DHCPMOptionsRefCount < OptionsConf.MaxCount ]
					{
						[ Property.DHCPMOptionsRefCount = Property.DHCPMOptionsRefCount + 1 ]
						DHCPMDhcpOptionRef OptionRef;
					}
				}
			}
	}
}

//
//	_DHCP_OPTION_DATA
//  Alignment: Ndr
//
Struct DHCPMDhcpOptionData
{
	UINT32 NumElements;
	[ Property.DHCPMElementsPtr = this.ReferentID ]
	NdrPtr ElementsPtr;
}

Struct DHCPMDhcpOptionDataRef
{
	Switch
	{
		Case Property.DHCPMElementsPtr != 0:
			Struct
			{
				NdrConformant ElementsConf;
				[ Property.DHCPMElementsCount = 0, MaxLoopCount = ElementsConf.MaxCount ]
				while[ Property.DHCPMElementsCount < ElementsConf.MaxCount ]
				{
					[ Property.DHCPMElementsCount = Property.DHCPMElementsCount + 1 ]
					DHCPMDhcpOptionDataElement Element;
				}
				[ Property.DHCPMElementsRefCount = 0, MaxLoopCount = ElementsConf.MaxCount ]
				while[ Property.DHCPMElementsRefCount < ElementsConf.MaxCount ]
				{
					[ Property.DHCPMElementsRefCount = Property.DHCPMElementsRefCount + 1 ]
					DHCPMDhcpOptionDataElementRef ElementRef;
				}
			}
	}
}

//
//	_DHCP_OPTION_DATA_ELEMENT
//  Alignment: Ndr
//
Struct DHCPMDhcpOptionDataElement
{
	NdrEnum OptionType = DHCPMDhcpOptionDataTypeTable(this.value);
	Switch
	{
		Case Property.MSRPCNdr64:
			Align8 Pad1;
	}
	[ Property.DHCPMDataElementSwitchValue$[ Property.DHCPMElementsCount ] = this.value ]
	NdrEnum SwitchValue = DHCPMDhcpOptionDataTypeTable(this.value);
	Switch
	{
		Case Property.MSRPCNdr64:
			Align8 Pad2;
	}
	Switch( SwitchValue.value )
	{
		Case 0:
			Struct
			{
				CHAR ByteOption;
			}
			
		Case 1:
			Struct
			{
				UINT16 WordOption;
			}
		Case 2:
			Struct
			{
				UINT32 DWordOption;
			}
		Case 3:
			Struct
			{
				DHCPMDwordDword DWordDWordOption;
			}
		Case 4:
			Struct
			{
				Ipv4Address IpAddressOption;
			}
		Case 5:
			Struct
			{
				[ Property.DHCPMStringDataOptionPtr$[ Property.DHCPMElementsCount ] = this.ReferentID ]
				NdrPtr StringDataOptionPtr;
			}
		Case 6:
			Struct
			{
				NdrAlign Pad;
				DHCPMDhcpBinaryData BinaryDataOption;
			}
		Case 7:
			Struct
			{
				NdrAlign Pad;
				DHCPMDhcpBinaryData EncapsulatedDataOption;
			}
		Case 8:
			Struct
			{
				[ Property.DHCPMIpv6AddressDataOptionPtr = this.ReferentID ] 
				NdrPtr Ipv6AddressDataOptionPtr;
			}
		Default:
			ReportParserError( ParserErrorProtocolClassWindows, "DHCPM", "Unknown Union Switch Value" ) Unknown;
	}
	Switch
	{
		Case Property.MSRPCNdr64:
			NdrAlign Pad;
	}
}

Struct DHCPMDhcpOptionDataElementRef
{
	Switch ( Property.DHCPMDataElementSwitchValue$[ Property.DHCPMElementsRefCount ] )
	{
		case 0:
		case 1:
		case 2:
		case 3:
		case 4:
			_struct{}
		case 5:
			Switch
			{
				case Property.DHCPMStringDataOptionPtr$[ Property.DHCPMElementsRefCount ] > 0:
					NdrWideString StringDataOption;
			}
		case 6:
			DHCPMDhcpBinaryDataRef BinaryDataOptionRef;
		case 7:
			DHCPMDhcpBinaryDataRef EncapsulatedDataOptionRef;
		case 8:
			Switch
			{
				case Property.DHCPMIpv6AddressDataOptionPtr > 0:
					NdrWideString Ipv6AddressDataOption;
			}
		Default:
			ReportParserError( ParserErrorProtocolClassWindows, "DHCPM", "Unknown Union Switch Value" ) Unknown;
	}
}

Table DHCPMDhcpOptionDataTypeTable( Value )
{
	Switch( Value )
	{
		Case 0: "DhcpByteOption - The option value is of type BYTE.";
		Case 1: "DhcpWordOption - The option value is of type WORD.";
		Case 2: "DhcpDWordOption - The option value is of type DWORD.";
		Case 3: "DhcpDWordDWordOption - The option value is of type DWORD_DWORD.";
		Case 4: "DhcpIpAddressOption - The option value is of type DHCP_IP_ADDRESS.";
		Case 5: "DhcpStringDataOption - The option value is a null-terminated Unicode string.";
		Case 6: "DhcpBinaryDataOption - The option value is of type DHCP_BINARY_DATA.";
		Case 7: "DhcpEncapsulatedDataOption - The option value is encapsulated and of type DHCP_BINARY_DATA.";
		Case 8: "DhcpIpv6AddressOption - The option value is an IPv6 address represented as a null-terminated Unicode string.";
		Default:"Unknown";
	}
}

//
//	_DHCP_OPTION_VALUE
//  Alignment NDR
//
Struct DHCPMDhcpOptionValue
{
	UINT32 OptionID;
	NdrAlign Pad;
	[ Property.DHCPMElementsPtr$[ Property.DHCPMOptionCount ] = Value.ElementsPtr.ReferentID,
	Property.DHCPMValuesPtr$[ Property.DHCPMValuesCount ] = Value.ElementsPtr.ReferentID ]
	DHCPMDhcpOptionData Value;
}

Struct DHCPMDhcpOptionValueRef
{
	Switch
	{
		Case Property.DHCPMElementsPtr$[ Property.DHCPMOptionCountRef ] > 0:
		Case Property.DHCPMValuesPtr$[ Property.DHCPMValuesCount ] > 0:
			Struct
			{
				NdrConformant ElementsConf;
				[ Property.DHCPMElementsCount = 0, MaxLoopCount = ElementsConf.MaxCount ]
				while[ Property.DHCPMElementsCount < ElementsConf.MaxCount ]
				{
					[ Property.DHCPMElementsCount = Property.DHCPMElementsCount + 1 ]
					DHCPMDhcpOptionDataElement Element;
				}
				[ Property.DHCPMElementsRefCount = 0, MaxLoopCount = ElementsConf.MaxCount ]
				while[ Property.DHCPMElementsRefCount < ElementsConf.MaxCount ]
				{
					[ Property.DHCPMElementsRefCount = Property.DHCPMElementsRefCount + 1 ]
					DHCPMDhcpOptionDataElementRef ElementRef;
				}
			}		
	}
}

//
//	_DHCP_OPTION_LIST
//  Alignment: NDR
//
Struct DHCPMDhcpOptionList
{	
	UINT32 NumOptions;
	NdrPtr OptionsPtr;
	Switch
	{
		case OptionsPtr.ReferentID > 0:
			Struct Options
			{
				NdrConformant OptionsConf;
				Struct
				{
					[ Property.DHCPMOptionCount = 0, MaxLoopCount = OptionsConf.MaxCount ]
					while[ Property.DHCPMOptionCount < NdrConformant.MaxCount ]
					{
						[ Property.DHCPMOptionCount = Property.DHCPMOptionCount + 1 ]
						DHCPMDhcpOptionValue Option;
					}
					
					[ Property.DHCPMOptionCountRef = 0, MaxLoopCount = OptionsConf.MaxCount ]
					while[ Property.DHCPMOptionCountRef < NdrConformant.MaxCount ]
					{
						[ Property.DHCPMOptionCountRef = Property.DHCPMOptionCountRef + 1 ]
						DHCPMDhcpOptionValueRef OptionRef;
					}
				}
			}
	}
}

//
//	_DHCP_OPTION_SCOPE_INFO
//  Alignment: NDR
//
Struct DHCPMDhcpOptionScopeInfo
{
	NdrEnum ScopeType = DHCPMDhcpOptionScopeTypeTable(this.value);
	Switch
	{
		Case Property.MSRPCNdr64:
			Align8 Pad1;
	}
	[ Property.DHCPMScopeInfoSwitchValue = this.value ]
	NdrEnum SwitchValue = DHCPMDhcpOptionScopeTypeTable(this.value);
	Switch
	{
		Case Property.MSRPCNdr64:
			Align8 Pad2;
	}
	Switch( SwitchValue.value )
	{
		Case 0:
		Case 1:
			_struct{}
		Case 2:
			Ipv4Address SubnetScopeInfo;
		Case 3:
			DHCPMDhcpReservedScope ReservedScopeInfo;
		Case 4:
			[ Property.DHCPMMScopeInfoPtr = this.ReferentID ]
			NdrPtr MScopeInfoPtr;
		Default:
			ReportParserError( ParserErrorProtocolClassWindows, "DHCPM", "Unknown Union Switch Value" ) Unknown;
	}
	Switch
	{
		Case Property.MSRPCNdr64:
			NdrAlign Pad;
	}
}

Struct DHCPMDhcpOptionScopeInfoRef
{
	Switch ( Property.DHCPMScopeInfoSwitchValue )
	{
		case 0:
		case 1:
		case 2:
		case 3:
			_struct{}
		case 4:
			Switch
			{
				case Property.DHCPMMScopeInfoPtr > 0:
					NdrWideString MScopeInfo;
			}
		Default:
			ReportParserError( ParserErrorProtocolClassWindows, "DHCPM", "Unknown Union Switch Value" ) Unknown;
	}
}

//
//	_DHCP_OPTION_SCOPE_INFO6
//  Alignment: 8
//
Struct DHCPMDhcpOptionScopeInfo6
{
	NdrEnum ScopeType = DHCPMDhcpOptionScopeType6Table(this.value);
	switch
	{
		case Property.MSRPCNdr64: Align8 Pad1;
	}
	NdrEnum SwitchValue = DHCPMDhcpOptionScopeType6Table(this.value);
	switch
	{
		case Property.MSRPCNdr64: Align8 Pad2;
	}
	Switch( SwitchValue.value )
	{
		Case 0:
		Case 1:
			DHCPMDhcpIpv6Address SubnetScopeInfo;
		Case 2:
			DHCPMDhcpReservedScope6 ReservedScopeInfo;
		Default:
			ReportParserError( ParserErrorProtocolClassWindows, "DHCPM", "Unknown Union Switch Value" ) Unknown;
	}
}

Table DHCPMDhcpOptionScopeType6Table( Value )
{
	Switch( Value )
	{
		Case 0: "DhcpDefaultOptions6 - Option is defined at the default level. The option definition is created or modified on the DHCPv6 server and the default value of the option is stored.";
		Case 1: "DhcpScopeOptions6 - Option is defined at the scope level. The option value is added or modified at the scope and is valid for that particular scope.";
		Case 2: "DhcpReservedOptions6 - Option is defined for a specific IP address reservation. The option value is added or modified for a particular IP reservation in a scope.";
		Case 3: "DhcpGlobalOptions6 - Option is defined at the global level. The option value is added or modified at the DHCPv6 server, which is valid for all scopes in that server.";
		Default:"Unknown";
	}
}

Table DHCPMDhcpOptionScopeTypeTable( Value )
{
	Switch( Value )
	{
		Case 0: "DhcpDefaultOptions - Option is defined at the default level. The option definition is created or modified on the DHCPv4 server and the default value of the option is stored.";
		Case 1: "DhcpGlobalOptions - Option is defined at the server level. The option value is added or modified at the DHCPv4 server, which is valid for all scopes in that server.";
		Case 2: "DhcpSubnetOptions - Option is defined at the scope level. The option value is added or modified at the scope and is valid for that particular scope.";
		Case 3: "DhcpReservedOptions - Option is defined for a specific IP address reservation. The option value is added or modified for a particular IP reservation in a scope.";
		Case 4: "DhcpMScopeOptions - Option is defined for a multicast scope. The option value is added or modified for a multicast scope.";
		Default:"Unknown";
	}
}

Table DHCPMDhcpOptionTypeTable( Value )
{
	Switch( Value )
	{
		Case 0: "DhcpUnaryElementTypeOption - The option value is single-valued.";
		Case 1: "DhcpArrayTypeOption - The option value is multivalued.";
		Default:"Unknown";
	}
}

//
//	_DHCP_OPTION_VALUE_ARRAY
//  Alignment: Ndr
//
Struct DHCPMDhcpOptionValueArray
{
	UINT32 NumElements;
	NdrPtr ValuesPtr;
	switch
	{
		Case ValuesPtr.ReferentID > 0:
			Struct Values
			{
				NdrConformant ValuesConf;
				[ Property.DHCPMValuesCount = 0, MaxLoopCount = ValuesConf.MaxCount ]
				while[ Property.DHCPMValuesCount < ValuesConf.MaxCount ]
				{
					[ Property.DHCPMValuesCount = Property.DHCPMValuesCount + 1 ]
					DHCPMDhcpOptionValue Value;
				}
				[ Property.DHCPMValuesRefCount = 0, MaxLoopCount = ValuesConf.MaxCount ]
				while[ Property.DHCPMValuesRefCount < ValuesConf.MaxCount ]
				{
					[ Property.DHCPMValuesRefCount = Property.DHCPMValuesRefCount + 1 ]
					DHCPMDhcpOptionValueRef ValueRef;
				}
			}
	}
}

//
//	_DHCP_RESERVED_SCOPE
//  Alignment: 4
//
Struct DHCPMDhcpReservedScope
{
	Ipv4Address ReservedIpAddress;
	Ipv4Address ReservedIpSubnetAddress;
}

//
//	_DHCP_RESERVED_SCOPE6
//  Alignment: 8
//
Struct DHCPMDhcpReservedScope6
{
	DHCPMDhcpIpv6Address ReservedIpAddress;
	DHCPMDhcpIpv6Address ReservedIpSubnetAddress;
}

Table DHCPMDhcpScanFlagTable( Value )
{
	Switch( Value )
	{
		Case 0: "DhcpRegistryFix - The DHCPv4 server sets this value in DHCP_SCAN_ITEM when the DHCPv4 client lease record is found in the DHCPv4 server database but not in the in-memory bitmask representation.";
		Case 1: "DhcpDatabaseFix - The DHCPv4 server sets this value in DHCP_SCAN_ITEM when the DHCP clientv4 IPv4 address is found in the in-memory bitmask representation but not in the DHCPv4 server database.";
		Default:"Unknown";
	}
}

//
//	_DHCP_SCAN_ITEM
//  Alignment: 4
//
Struct DHCPMDhcpScanItem
{
	IPv4Address IpAddress;
	NdrEnum ScanFlag = DHCPMDhcpScanFlagTable(this.value);
}

//
//	_DHCP_SCAN_LIST
//  Alignment: Ndr
//
Struct DHCPMDhcpScanList
{
	UINT32 NumScanItems;
	NdrPtr ScanItemsPtr;
	Switch 
	{
		Case ScanItemsPtr.ReferentID > 0:
			Struct ScanItems
			{
				NdrConformant ScanItemsConf;
				[ Property.DHCPMScanItemsCount = 0, MaxLoopCount = ScanItemsConf.MaxCount ]
				while[ Property.DHCPMScanItemsCount < ScanItemsConf.MaxCount ]
				{
					[ Property.DHCPMScanItemsCount = Property.DHCPMScanItemsCount + 1 ]
					Align4 Pad;
					DHCPMDhcpScanItem ScanItem;
				}
			}
	}
}

//
//	_DHCP_SERVER_CONFIG_INFO
//  Alignment: Ndr
//
Struct DHCPMDhcpServerConfigInfo
{
	UINT32 APIProtocolSupport = DHCPMDhcpServerConfigInfoAPIProtocolSupportTable(this);
	NdrPtr DatabaseNamePtr;
	NdrPtr DatabasePathPtr;
	NdrPtr BackupPathPtr;
	UINT32 BackupInterval;
	UINT32 DatabaseLoggingFlag;
	UINT32 RestoreFlag;
	UINT32 DatabaseCleanupInterval;
	DHCPMDebugFlag DebugFlag;
	Switch
	{
		Case Property.MSRPCNdr64:
			Align8 Pad;
	}
	Switch {
		Case DatabaseNamePtr.ReferentID > 0:
			NdrWideString DatabaseName;
	}
	Switch {
		Case DatabasePathPtr.ReferentID > 0:
			NdrWideString DatabasePath;
	}
	Switch {
		Case BackupPathPtr.ReferentID > 0:
			NdrWideString BackupPath;
	}
}

Table DHCPMDhcpServerConfigInfoAPIProtocolSupportTable( Value )
{
	Switch( Value )
	{
		Case 0x00000001: "DHCP_SERVER_USE_RPC_OVER_TCPIP - RPC protocol over TCP is used by the DHCP server to register.";
		Case 0x00000002: "DHCP_SERVER_USE_RPC_OVER_NP - RPC protocol over named pipes is used by the DHCP server to register.DHCPM on windows_server_2008does not and windows_server_7 does not support registration using RPC over named pipes.";
		Case 0x00000004: "DHCP_SERVER_USE_RPC_OVER_LPC - RPC protocol over local procedure call (LPC) is used by the DHCP server to register.DHCPM on windows_server_2008does not and windows_server_7 does not support registration using LPC.";
		Case 0x00000007: "DHCP_SERVER_USE_RPC_OVER_ALL - The DHCP server supports all of the preceding protocols.";
		Default: "Unknown";
	}
}

Struct DHCPMDebugFlag = FormatString( "0x%08X", UINT32( FrameData, FrameOffset ) )
{
	Switch( Property.MSRPCByteOrder )
	{
		Case LittleEndian:
		Struct
		{
			UINT32 Values = FormatString( "0x%08X", this )
			{
				UINT32 DebugAddress:1 = FormatString("   (%s) %s",this.ToBitString, this ? "Enable IP address-related logging" : "Not Enable IP address-related logging");
				UINT32 DebugClient:1 = FormatString("    (%s) %s",this.ToBitString, this ? "Enable DHCP-client-API-related logging" : "Not Enable DHCP-client-API-related logging");
				UINT32 DebugParameters:1 = FormatString("(%s) %s",this.ToBitString, this ? "Enable DHCP-server-parameters-related logging" : "Not Enable DHCP-server-parameters-related logging");
				UINT32 DebugOptions:1 = FormatString("   (%s) %s",this.ToBitString, this ? "Enable DHCP-options-related logging" : "Not Enable DHCP-options-related logging");
				UINT32 DebugErrors:1 = FormatString("    (%s) %s",this.ToBitString, this ? "Enable DHCP-errors-related logging" : "Not Enable DHCP-errors-related logging");
				UINT32 DebugStoc:1 = FormatString("      (%s) %s",this.ToBitString, this ? "Enable DHCPv4 and DCHPv6-protocol-errors-related logging" : "Not Enable DHCPv4 and DCHPv6-protocol-errors-related logging");
				UINT32 DebugInit:1 = FormatString("      (%s) %s",this.ToBitString, this ? "Enable DHCP-server-initialization-related logging" : "Not Enable DHCP-server-initialization-related logging");
				UINT32 DebugScavenger:1 = FormatString(" (%s) %s",this.ToBitString, this ? "Enable scavenger's-error-related logging" : "Not Enable scavenger's-error-related logging");
				UINT32 DebugTimeStamp:1 = FormatString(" (%s) %s",this.ToBitString, this ? "Enable timing-errors-related logging" : "Not Enable timing-errors-related logging");
				UINT32 DebugAPIs:1 = FormatString("      (%s) %s",this.ToBitString, this ? "Enable DHCP-APIs-related logging" : "Not Enable DHCP-APIs-related logging");
				UINT32 DebugRegistry:1 = FormatString("  (%s) %s",this.ToBitString, this ? "Enable the logging of errors caused by registry setting operations" : "Not Enable the logging of errors caused by registry setting operations");
				UINT32 DebugJet:1 = FormatString("       (%s) %s",this.ToBitString, this ? "Enable the logging of the DHCP server database errors" : "Not Enable the logging of the DHCP server database errors");
				UINT32 DebugThreadPool:1 = FormatString("(%s) %s",this.ToBitString, this ? "Enable the logging related to executing thread pool operations" : "Not Enable the logging related to executing thread pool operations");
				UINT32 DebugAuditLog:1 = FormatString("  (%s) %s",this.ToBitString, this ? "Enable the logging related to errors caused by auditlog operations" : "Not Enable the logging related to errors caused by auditlog operations");
				UINT32 DebugQuarantine:1 = FormatString(" %s) %s",this.ToBitString, this ? "Enable the logging of errors caused by quarantine errors" : "Not Enable the logging of errors caused by quarantine errors");
				UINT32 DebugMisc:1 = FormatString("      (%s) %s",this.ToBitString, this ? "Enable the logging caused by miscellaneous errors" : "Not Enable the logging caused by miscellaneous errors");
				UINT32 DebugMessage:1 = FormatString("   (%s) %s",this.ToBitString, this ? "Enable the logging related to debug messages" : "Not Enable the logging related to debug messages");
				UINT32 DebugAPIVerbose:1 = FormatString("(%s) %s",this.ToBitString, this ? "Enable the logging related to DHCP API verbose errors" : "Not Enable the logging related to DHCP API verbose errors");
				UINT32 DebugDNS:1 = FormatString("       (%s) %s",this.ToBitString, this ? "Enable the logging related to Domain Name System (DNS) messages" : "Not Enable the logging related to Domain Name System (DNS) messages");
				UINT32 DebugMStoc:1 = FormatString("     (%s) %s",this.ToBitString, this ? "Enable the logging related to multicast protocol layer errors" : "Not Enable the logging related to multicast protocol layer errors");
				UINT32 DebugTrack:1 = FormatString("     (%s) %s",this.ToBitString, this ? "Enable the logging tracking specific problems" : "Not Enable the logging tracking specific problems");
				UINT32 DebugRogue:1 = FormatString("     (%s) %s",this.ToBitString, this ? "Enable the logging related to a ROGUE DHCP server" : "Not Enable the logging related to a ROGUE DHCP server");
				UINT32 DebugPNP:1 = FormatString("       (%s) %s",this.ToBitString, this ? "Enable the logging related to PNP interface errors" : "Not Enable the logging related to PNP interface errors");
				UINT32 NotUsed:1 = FormatString("        (%s) %s",this.ToBitString, this ? "Not Used" : "Not Used");
				UINT32 DebugPerf:1 = FormatString("      (%s) %s",this.ToBitString, this ? "Enable the logging of performance-related messages" : "Not Enable the logging of performance-related messages");
				UINT32 DebugAlloc:1 = FormatString("     (%s) %s",this.ToBitString, this ? "Enable the logging of messages related to allocation and de-allocation" : "Not Enable the logging of messages related to allocation and de-allocation");
				UINT32 DebugPing:1 = FormatString("      (%s) %s",this.ToBitString, this ? "Enable the logging of synchronous-ping-related messages" : "Not Enable the logging of synchronous-ping-related messages");
				UINT32 DebugThread:1 = FormatString("    (%s) %s",this.ToBitString, this ? "Enable the logging of thread-related messages" : "Not Enable the logging of thread-related messages");
				UINT32 DebugTrace:1 = FormatString("     (%s) %s",this.ToBitString, this ? "Enable the logging for tracing through code messages" : "Not Enable the logging for tracing through code messages");
				UINT32 DebugTraceCalls:1 = FormatString("(%s) %s",this.ToBitString, this ? "Enable the logging for tracing through piles of code" : "Not Enable the logging for tracing through piles of code");
				UINT32 DebugStartUpBrk:1 = FormatString("(%s) %s",this.ToBitString, this ? "Enable the logging related to debugger break during setup messages" : "Not Enable the logging related to debugger break during setup messages");
				UINT32 DebugLogInFile:1 = FormatString(" (%s) %s",this.ToBitString, this ? "Enable the logging of debug output in a file" : "Not Enable the logging of debug output in a file");
			}
		}
		Default:
		Struct
		{
			UINT32 Attributes = FormatString( "0x%08X", this )
			{
				UINT32 DebugLogInFile:1 = FormatString(" (%s) %s",this.ToBitString, this ? "Enable the logging of debug output in a file" : "Not Enable the logging of debug output in a file");
				UINT32 DebugStartUpBrk:1 = FormatString("(%s) %s",this.ToBitString, this ? "Enable the logging related to debugger break during setup messages" : "Not Enable the logging related to debugger break during setup messages");
				UINT32 DebugTraceCalls:1 = FormatString("(%s) %s",this.ToBitString, this ? "Enable the logging for tracing through piles of code" : "Not Enable the logging for tracing through piles of code");
				UINT32 DebugTrace:1 = FormatString("     (%s) %s",this.ToBitString, this ? "Enable the logging for tracing through code messages" : "Not Enable the logging for tracing through code messages");
				UINT32 DebugThread:1 = FormatString("    (%s) %s",this.ToBitString, this ? "Enable the logging of thread-related messages" : "Not Enable the logging of thread-related messages");
				UINT32 DebugPing:1 = FormatString("      (%s) %s",this.ToBitString, this ? "Enable the logging of synchronous-ping-related messages" : "Not Enable the logging of synchronous-ping-related messages");
				UINT32 DebugAlloc:1 = FormatString("     (%s) %s",this.ToBitString, this ? "Enable the logging of messages related to allocation and de-allocation" : "Not Enable the logging of messages related to allocation and de-allocation");
				UINT32 DebugPerf:1 = FormatString("      (%s) %s",this.ToBitString, this ? "Enable the logging of performance-related messages" : "Not Enable the logging of performance-related messages");
				UINT32 NotUsed:1 = FormatString("        (%s) %s",this.ToBitString, this ? "Not Used" : "Not Used");
				UINT32 DebugPNP:1 = FormatString("       (%s) %s",this.ToBitString, this ? "Enable the logging related to PNP interface errors" : "Not Enable the logging related to PNP interface errors");
				UINT32 DebugRogue:1 = FormatString("     (%s) %s",this.ToBitString, this ? "Enable the logging related to a ROGUE DHCP server" : "Not Enable the logging related to a ROGUE DHCP server");
				UINT32 DebugTrack:1 = FormatString("     (%s) %s",this.ToBitString, this ? "Enable the logging tracking specific problems" : "Not Enable the logging tracking specific problems");
				UINT32 DebugMStoc:1 = FormatString("     (%s) %s",this.ToBitString, this ? "Enable the logging related to multicast protocol layer errors" : "Not Enable the logging related to multicast protocol layer errors");
				UINT32 DebugDNS:1 = FormatString("       (%s) %s",this.ToBitString, this ? "Enable the logging related to Domain Name System (DNS) messages" : "Not Enable the logging related to Domain Name System (DNS) messages");
				UINT32 DebugAPIVerbose:1 = FormatString("(%s) %s",this.ToBitString, this ? "Enable the logging related to DHCP API verbose errors" : "Not Enable the logging related to DHCP API verbose errors");
				UINT32 DebugMessage:1 = FormatString("   (%s) %s",this.ToBitString, this ? "Enable the logging related to debug messages" : "Not Enable the logging related to debug messages");
				UINT32 DebugMisc:1 = FormatString("      (%s) %s",this.ToBitString, this ? "Enable the logging caused by miscellaneous errors" : "Not Enable the logging caused by miscellaneous errors");
				UINT32 DebugQuarantine:1 = FormatString(" %s) %s",this.ToBitString, this ? "Enable the logging of errors caused by quarantine errors" : "Not Enable the logging of errors caused by quarantine errors");
				UINT32 DebugAuditLog:1 = FormatString("  (%s) %s",this.ToBitString, this ? "Enable the logging related to errors caused by auditlog operations" : "Not Enable the logging related to errors caused by auditlog operations");
				UINT32 DebugThreadPool:1 = FormatString("(%s) %s",this.ToBitString, this ? "Enable the logging related to executing thread pool operations" : "Not Enable the logging related to executing thread pool operations");
				UINT32 DebugJet:1 = FormatString("       (%s) %s",this.ToBitString, this ? "Enable the logging of the DHCP server database errors" : "Not Enable the logging of the DHCP server database errors");
				UINT32 DebugRegistry:1 = FormatString("  (%s) %s",this.ToBitString, this ? "Enable the logging of errors caused by registry setting operations" : "Not Enable the logging of errors caused by registry setting operations");
				UINT32 DebugAPIs:1 = FormatString("      (%s) %s",this.ToBitString, this ? "Enable DHCP-APIs-related logging" : "Not Enable DHCP-APIs-related logging");
				UINT32 DebugTimeStamp:1 = FormatString(" (%s) %s",this.ToBitString, this ? "Enable timing-errors-related logging" : "Not Enable timing-errors-related logging");
				UINT32 DebugScavenger:1 = FormatString(" (%s) %s",this.ToBitString, this ? "Enable scavenger's-error-related logging" : "Not Enable scavenger's-error-related logging");
				UINT32 DebugInit:1 = FormatString("      (%s) %s",this.ToBitString, this ? "Enable DHCP-server-initialization-related logging" : "Not Enable DHCP-server-initialization-related logging");
				UINT32 DebugStoc:1 = FormatString("      (%s) %s",this.ToBitString, this ? "Enable DHCPv4 and DCHPv6-protocol-errors-related logging" : "Not Enable DHCPv4 and DCHPv6-protocol-errors-related logging");
				UINT32 DebugErrors:1 = FormatString("    (%s) %s",this.ToBitString, this ? "Enable DHCP-errors-related logging" : "Not Enable DHCP-errors-related logging");
				UINT32 DebugOptions:1 = FormatString("   (%s) %s",this.ToBitString, this ? "Enable DHCP-options-related logging" : "Not Enable DHCP-options-related logging");
				UINT32 DebugParameters:1 = FormatString("(%s) %s",this.ToBitString, this ? "Enable DHCP-server-parameters-related logging" : "Not Enable DHCP-server-parameters-related logging");
				UINT32 DebugClient:1 = FormatString("    (%s) %s",this.ToBitString, this ? "Enable DHCP-client-API-related logging" : "Not Enable DHCP-client-API-related logging");
				UINT32 DebugAddress:1 = FormatString("   (%s) %s",this.ToBitString, this ? "Enable IP address-related logging" : "Not Enable IP address-related logging");
			}
		}
	}
}

//
//	_DHCP_SERVER_CONFIG_INFO_V4
//  Alignment: Ndr
//
Struct DHCPMDhcpServerConfigInfoV4
{
	UINT32 APIProtocolSupport = DHCPMDhcpServerConfigInfoV4APIProtocolSupportTable(this);
	[ Property.DHCPMDatabaseNamePtr = this.ReferentID ]
	NdrPtr DatabaseNamePtr;
	[ Property.DHCPMDatabasePathPtr = this.ReferentID ]
	NdrPtr DatabasePathPtr;
	[ Property.DHCPMBackupPathPtr = this.ReferentID ]
	NdrPtr BackupPathPtr;
	UINT32 BackupInterval;
	UINT32 DatabaseLoggingFlag;
	UINT32 RestoreFlag;
	UINT32 DatabaseCleanupInterval;
	DHCPMDebugFlag DebugFlag;
	UINT32 PingRetries;
	UINT32 BootTableString;
	[ Property.DHCPMBootTableStringPtr = this.ReferentID ]
	NdrPtr BootTableStringPtr;
	BOOL AuditLog;
	Switch
	{
		Case Property.MSRPCNdr64:
			Align8 Pad;
	}
}

Struct DHCPMDhcpServerConfigInfoV4Ref
{
	Switch
	{
		case Property.DHCPMDatabaseNamePtr > 0:
			NdrWideString DatabaseName;
	}
	Switch
	{
		case Property.DHCPMDatabasePathPtr > 0:
			NdrWideString DatabasePath;
	}
	Switch
	{
		case Property.DHCPMBackupPathPtr > 0:
			NdrWideString BackupPath;
	}
	Switch
	{
		case Property.DHCPMBootTableStringPtr > 0:
			Struct
			{
				NdrConformant BootTableStringConf;
				Switch
				{
					case BootTableStringConf.MaxCount > 0:
						UnicodeString( BootTableStringConf.MaxCount / 2 ) BootTableString;
				}
			}
	}
}

Table DHCPMDhcpServerConfigInfoV4APIProtocolSupportTable( Value )
{
	Switch( Value )
	{
		Case 0x00000001: "DHCP_SERVER_USE_RPC_OVER_TCPIP - RPC protocol over TCP is used by the DHCP server to register.";
		Case 0x00000002: "DHCP_SERVER_USE_RPC_OVER_NP - RPC protocol over named pipes is used by the DHCP server to register.DHCPM on windows_server_2008does not and windows_server_7 does not support registration using RPC over named pipes.";
		Case 0x00000004: "DHCP_SERVER_USE_RPC_OVER_LPC - RPC protocol over LPC is used by the DHCP server to register.DHCPM on windows_server_2008does not and windows_server_7 does not support registration using LPC.";
		Case 0x00000007: "DHCP_SERVER_USE_RPC_OVER_ALL - The DHCP server supports all of the preceding protocols.";
		Default: "Unknown";
	}
}

//
//	_DHCP_SERVER_CONFIG_INFO_V6
//  Alignment: 4
//
Struct DHCPMDhcpServerConfigInfoV6
{
	BOOL UnicastFlag;
	BOOL RapidCommitFlag;
	UINT32 PreferredLifetime;
	UINT32 ValidLifetime;
	UINT32 T1;
	UINT32 T2;
	UINT32 PreferredLifetimeIATA;
	UINT32 ValidLifetimeIATA;
	BOOL AuditLog;
}

//
//	_DHCP_SERVER_CONFIG_INFO_VQ
//  Alignment: Ndr
//
Struct DHCPMDhcpServerConfigInfoVq
{
	UINT32 APIProtocolSupport = DHCPMDhcpServerConfigInfoVqAPIProtocolSupportTable(this);
	[ Property.DHCPMDatabaseNamePtr = this.ReferentID ]
	NdrPtr DatabaseNamePtr;
	[ Property.DHCPMDatabasePathPtr = this.ReferentID ]
	NdrPtr DatabasePathPtr;
	[ Property.DHCPMBackupPathPtr = this.ReferentID ]
	NdrPtr BackupPathPtr;
	UINT32 BackupInterval;
	UINT32 DatabaseLoggingFlag;
	UINT32 RestoreFlag;
	UINT32 DatabaseCleanupInterval;
	DHCPMDebugFlag DebugFlag;
	UINT32 PingRetries;
	UINT32 BootTableString;
	[ Property.DHCPMBootTableStringPtr = this.ReferentID ]
	NdrPtr BootTableStringPtr;
	BOOL AuditLog;
	BOOL QuarantineOn;
	UINT32 QuarDefFail;
	BOOL QuarRuntimeStatus;
}

Struct DHCPMDhcpServerConfigInfoVqRef
{
	Switch
	{
		case Property.DHCPMDatabaseNamePtr > 0:
			NdrWideString DatabaseName;
	}
	Switch
	{
		case Property.DHCPMDatabasePathPtr > 0:
			NdrWideString DatabasePath;
	}
	Switch
	{
		case Property.DHCPMBackupPathPtr > 0:
			NdrWideString BackupPath;
	}
	Switch
	{
		case Property.DHCPMBootTableStringPtr > 0:
			Struct
			{
				NdrConformant BootTableStringConf;
				Switch
				{
					case BootTableStringConf.MaxCount > 0:
						UnicodeString( BootTableStringConf.MaxCount / 2 ) BootTableString;
				}
			}
	}
}

Table DHCPMDhcpServerConfigInfoVqAPIProtocolSupportTable( Value )
{
	Switch( Value )
	{
		Case 0x00000001: "DHCP_SERVER_USE_RPC_OVER_TCPIP - RPC protocol over TCP is used by the DHCP server to register.";
		Case 0x00000002: "DHCP_SERVER_USE_RPC_OVER_NP - RPC protocol over named pipes is used by the DHCP server to register.DHCPM on windows_server_2008does not and windows_server_7 does not support registration using RPC over named pipes.";
		Case 0x00000004: "DHCP_SERVER_USE_RPC_OVER_LPC - RPC protocol over LPC is used by the DHCP server to register.DHCPM on windows_server_2008does not and windows_server_7 does not support registration using LPC.";
		Case 0x00000007: "DHCP_SERVER_USE_RPC_OVER_ALL - The DHCP server supports all of the preceding protocols.";
		Default: "Unknown";
	}
}

//
//	_DHCP_SERVER_SPECIFIC_STRINGS
//  Alignment: None
//
Struct DHCPMDhcpServerSpecificStrings
{
	[ Property.DHCPMDefaultVendorClassNamePtr = this.ReferentID ]
	NdrPtr DefaultVendorClassNamePtr;
	[ Property.DHCPMDefaultUserClassNamePtr = this.ReferentID ]
	NdrPtr DefaultUserClassNamePtr;
}

Struct DHCPMDhcpServerSpecificStringsRef
{
	Switch
	{
		Case Property.DHCPMDefaultVendorClassNamePtr > 0:
			NdrWideString DefaultVendorClassName;
	}
	Switch
	{
		Case Property.DHCPMDefaultUserClassNamePtr > 0:
			NdrWideString DefaultUserClassName;
	}
}

//
//	_DHCP_SUBNET_ELEMENT_DATA
//  Alignment: NDR
//
Struct DHCPMDhcpSubnetElementData
{
	NDREnum ElementType = DHCPMDhcpSubnetElementTypeTable(this.value);
	Switch
	{
		Case Property.MSRPCNdr64:
			Align8 Pad;
	}
	[ Property.DHCPMElementDataSwitchValue$[ Property.DHCPMElementsCount ] = this.value ]
	NDREnum SwitchValue = DHCPMDhcpSubnetElementTypeTable(this.value);
	Switch( SwitchValue.value )
	{
		Case 0:
			Struct
			{
				[ Property.DHCPMIpRangePtr$[ Property.DHCPMElementsCount ] = this.ReferentID ]
				NdrPtr IpRangePtr;
			}
		Case 1:
			Struct
			{
				[ Property.DHCPMSecondaryHostPtr$[ Property.DHCPMElementsCount ] = this.ReferentID ]
				NdrPtr SecondaryHostPtr;
			}
		Case 2:
			Struct
			{
				[ Property.DHCPMReservedIpPtr$[ Property.DHCPMElementsCount ] = this.ReferentID ]
				NdrPtr ReservedIpPtr;
			}
		Case 3:
			Struct
			{
				[ Property.DHCPMExcludeIpRangePtr$[ Property.DHCPMElementsCount ] = this.ReferentID ]
				NdrPtr ExcludeIpRangePtr;
			}
		Case 4:
			Struct
			{
				[ Property.DHCPMIpUsedClusterPtr$[ Property.DHCPMElementsCount ] = this.ReferentID ]
				NdrPtr IpUsedClusterPtr;
			}
		Default:
			ReportParserError( ParserErrorProtocolClassWindows, "DHCPM", "Unknown Union Switch Value" ) Unknown;
	}
}

Struct DHCPMDhcpSubnetElementDataRef
{
	Switch ( Property.DHCPMElementDataSwitchValue$[ Property.DHCPMElementsRefCount ] )
	{
		case 0:
			Switch
			{
				case Property.DHCPMIpRangePtr$[ Property.DHCPMElementsRefCount ] > 0:DHCPMDhcpIpRange IpRange;
			}
		case 1:
			Switch
			{
				case Property.DHCPMSecondaryHostPtr$[ Property.DHCPMElementsRefCount ] > 0:
					_struct
					{
						DHCPMDhcpHostInfo SecondaryHost;
						DHCPMDhcpHostInfoRef SecondaryHostRef;
					}
			}
		case 2:
			Switch
			{
				case Property.DHCPMReservedIpPtr$[ Property.DHCPMElementsRefCount ] > 0:DHCPMDhcpIpReservation ReservedIp;
			}
		case 3:
			Switch
			{
				case Property.DHCPMExcludeIpRangePtr$[ Property.DHCPMElementsRefCount ] > 0:DHCPMDhcpIpRange IpRange;
			}
		case 4:
			Switch
			{
				case Property.DHCPMIpUsedClusterPtr$[ Property.DHCPMElementsRefCount ] > 0:DHCPMDhcpIpCluster IpUsedCluster;
			}
		Default:
			ReportParserError( ParserErrorProtocolClassWindows, "DHCPM", "Unknown Union Switch Value" ) Unknown;
	}
}

//
//	_DHCP_SUBNET_ELEMENT_DATA_V4
//  Alignment: Ndr
//
Struct DHCPMDhcpSubnetElementDataV4
{
	NdrEnum ElementType = DHCPMDhcpSubnetElementTypeTable(this.value);
	Switch
	{
		Case Property.MSRPCNdr64:
			Align8 Pad;
	}
	[ Property.DHCPMElementDataV4SwitchValue$[ Property.DHCPMElementsCount ] = this.value ]
	NDREnum SwitchValue = DHCPMDhcpSubnetElementTypeTable(this.value);
	Switch( SwitchValue.value )
	{
		Case 0:
			[ Property.DHCPMIpRangePtr$[ Property.DHCPMElementsCount ] = this.ReferentID ]
			NdrPtr IpRangePtr;
		Case 1:
			[ Property.DHCPMSecondaryHostPtr$[ Property.DHCPMElementsCount ] = this.ReferentID ]
			NdrPtr SecondaryHostPtr;
		Case 2:
			[ Property.DHCPMReservedIpPtr$[ Property.DHCPMElementsCount ] = this.ReferentID ]
			NdrPtr ReservedIpPtr;
		Case 3:
			[ Property.DHCPMExcludeIpRangePtr$[ Property.DHCPMElementsCount ] = this.ReferentID ]
			NdrPtr ExcludeIpRangePtr;
		Case 4:
			[ Property.DHCPMIpUsedClusterPtr$[ Property.DHCPMElementsCount ] = this.ReferentID ]
			NdrPtr IpUsedClusterPtr;
		Default:
			ReportParserError( ParserErrorProtocolClassWindows, "DHCPM", "Unknown Union Switch Value" ) Unknown;
	}
}

Struct DHCPMDhcpSubnetElementDataV4Ref
{
	Switch( Property.DHCPMElementDataV4SwitchValue$[ Property.DHCPMElementsRefCount ] )
	{
		Case 0:
			Switch
			{
				case Property.DHCPMIpRangePtr$[ Property.DHCPMElementsRefCount ] > 0:
					DHCPMDhcpIpRange IpRange;
			}
		Case 1:
			Switch
			{
				case Property.DHCPMSecondaryHostPtr$[ Property.DHCPMElementsRefCount ] > 0:
					_struct
					{
						DHCPMDhcpHostInfo SecondaryHost;
						DHCPMDhcpHostInfoRef SecondaryHostRef;
					}
			}
		Case 2:
			Switch
			{
				case Property.DHCPMReservedIpPtr$[ Property.DHCPMElementsRefCount ] > 0:
					DHCPMDhcpIpReservationV4 ReservedIp;
			}
		Case 3:
			Switch
			{
				case Property.DHCPMExcludeIpRangePtr$[ Property.DHCPMElementsRefCount ] > 0:
					DHCPMDhcpIpRange ExcludeIpRange;
			}
		Case 4:
			Switch
			{
				case Property.DHCPMIpUsedClusterPtr$[ Property.DHCPMElementsRefCount ] > 0:
					DHCPMDhcpIpCluster IpUsedCluster;
			}
		Default:
			ReportParserError( ParserErrorProtocolClassWindows, "DHCPM", "Unknown Union Switch Value" ) Unknown;
	}
}

//
//	_DHCP_SUBNET_ELEMENT_DATA_V5
//  Alignment: Ndr
//
Struct DHCPMDhcpSubnetElementDataV5
{
	NdrEnum EnumElementType = DHCPMDhcpSubnetElementTypeTable(this.value);
	Switch
	{
		Case Property.MSRPCNdr64:
			Align8 Pad;
	}
	[ Property.DHCPMElementDataV5SwitchValue$[ Property.DHCPMElementsCount ] = this.value ]
	NDREnum SwitchValue = DHCPMDhcpSubnetElementTypeTable(this.value);
	Switch( SwitchValue.value )
	{
		Case 0:
			[ Property.DHCPMIpRangePtr$[ Property.DHCPMElementsCount ] = this.ReferentID ]
			NdrPtr IpRangePtr;
		Case 1:
			[ Property.DHCPMSecondaryHostPtr$[ Property.DHCPMElementsCount ] = this.ReferentID ]
			NdrPtr SecondaryHostPtr;
		Case 2:
			[ Property.DHCPMReservedIpPtr$[ Property.DHCPMElementsCount ] = this.ReferentID ]
			NdrPtr ReservedIpPtr;
		Case 3:
			[ Property.DHCPMExcludeIpRangePtr$[ Property.DHCPMElementsCount ] = this.ReferentID ]
			NdrPtr ExcludeIpRangePtr;
		Case 4:
			[ Property.DHCPMIpUsedClusterPtr$[ Property.DHCPMElementsCount ] = this.ReferentID ]
			NdrPtr IpUsedClusterPtr;
		Default:
			ReportParserError( ParserErrorProtocolClassWindows, "DHCPM", "Unknown Union Switch Value" ) Unknown;
	}
}

Struct DHCPMDhcpSubnetElementDataV5Ref
{
	Switch( Property.DHCPMElementDataV5SwitchValue$[ Property.DHCPMElementsRefCount ] )
	{
		Case 0:
			Switch
			{
				case Property.DHCPMIpRangePtr$[ Property.DHCPMElementsRefCount ] > 0:
					DHCPMDhcpBootPIpRange IpRange;
			}
		Case 1:
			Switch
			{
				case Property.DHCPMSecondaryHostPtr$[ Property.DHCPMElementsRefCount ] > 0:
					_struct
					{
						DHCPMDhcpHostInfo SecondaryHost;
						DHCPMDhcpHostInfoRef SecondaryHostRef;
					}
			}
		Case 2:
			Switch
			{
				case Property.DHCPMReservedIpPtr$[ Property.DHCPMElementsRefCount ] > 0:
					DHCPMDhcpIpReservationV4 ReservedIp;
			}
		Case 3:
			Switch
			{
				case Property.DHCPMExcludeIpRangePtr$[ Property.DHCPMElementsRefCount ] > 0:
					DHCPMDhcpIpRange ExcludeIpRange;
			}
		Case 4:
			Switch
			{
				case Property.DHCPMIpUsedClusterPtr$[ Property.DHCPMElementsRefCount ] > 0:
					DHCPMDhcpIpCluster IpUsedCluster;
			}
		Default:
			ReportParserError( ParserErrorProtocolClassWindows, "DHCPM", "Unknown Union Switch Value" ) Unknown;
	}
}

//
//	DHCP_SUBNET_ELEMENT_DATA_V6
//  Alignment: Ndr
//
Struct DHCPMDhcpSubnetElementDataV6
{
	NdrEnum ElementType = DHCPMDhcpSubnetElementTypeV6Table(this.value);
	Switch
	{
		Case Property.MSRPCNdr64:
			Align8 Pad;
	}
	[ Property.DHCPMElementDataV6SwitchValue$[ Property.DHCPMElementsCount ] = this.value ]
	NDREnum SwitchValue = DHCPMDhcpSubnetElementTypeTable(this.value);
	Switch( SwitchValue.value )
	{
		Case 0:
			[ Property.DHCPMIpRangePtr$[ Property.DHCPMElementsCount ] = this.ReferentID ]
			NdrPtr IpRangePtr;
		Case 1:
			[ Property.DHCPMReservedIpPtr$[ Property.DHCPMElementsCount ] = this.ReferentID ]
			NdrPtr ReservedIpPtr;
		Case 2:
			[ Property.DHCPMExcludeIpRangePtr$[ Property.DHCPMElementsCount ] = this.ReferentID ]
			NdrPtr ExcludeIpRangePtr;
		Default:
			ReportParserError( ParserErrorProtocolClassWindows, "DHCPM", "Unknown Union Switch Value" ) Unknown;
	}
}

Struct DHCPMDhcpSubnetElementDataV6Ref
{
	Switch( Property.DHCPMElementDataV6SwitchValue$[ Property.DHCPMElementsRefCount ] )
	{
		Case 0:
			Switch
			{
				case Property.DHCPMIpRangePtr$[ Property.DHCPMElementsRefCount ] > 0:
					DHCPMDhcpIpRangeV6 IpRange;
			}
		Case 1:
			Switch
			{
				case Property.DHCPMReservedIpPtr$[ Property.DHCPMElementsRefCount ] > 0:
					DHCPMDhcpIpReservationV6 ReservedIp;
			}
		Case 2:
			Switch
			{
				case Property.DHCPMExcludeIpRangePtr$[ Property.DHCPMElementsRefCount ] > 0:
					DHCPMDhcpIpRangeV6 ExcludeIpRange;
			}
		Default:
			ReportParserError( ParserErrorProtocolClassWindows, "DHCPM", "Unknown Union Switch Value" ) Unknown;
	}
}

//
//	_DHCP_SUBNET_ELEMENT_INFO_ARRAY
//  Alignment: NDR
//
Struct DHCPMDhcpSubnetElementInfoArray
{
	UINT32 NumElements;
	NdrPtr ElementsPtr;
	Switch
	{
		case ElementsPtr.ReferentID > 0:
		Struct ElementsArray
		{
			Ndrconformant ElementsConf;
			[ Property.DHCPMElementsCount = 0, MaxLoopCount = ElementsConf.MaxCount ]
			while[ Property.DHCPMElementsCount < ElementsConf.MaxCount ]
			{
				[ Property.DHCPMElementsCount = Property.DHCPMElementsCount + 1 ]
				DHCPMDhcpSubnetElementData Element;
			}
			[ Property.DHCPMElementsRefCount = 0, MaxLoopCount = ElementsConf.MaxCount ]
			while[ Property.DHCPMElementsRefCount < ElementsConf.MaxCount ]
			{
				[ Property.DHCPMElementsRefCount = Property.DHCPMElementsRefCount + 1 ]
				DHCPMDhcpSubnetElementDataRef ElementRef;
			}
		}
	}
}

//
//	_DHCP_SUBNET_ELEMENT_INFO_ARRAY_V4
//  Alignment: Ndr
//
Struct DHCPMDhcpSubnetElementInfoArrayV4
{	
	UINT32 NumElements;
	NdrPtr ElementsPtr;
	Switch 
	{
		Case ElementsPtr.ReferentID > 0:
			Struct Elements
			{
				Ndrconformant ElementsConf;
				[ Property.DHCPMElementsCount = 0, MaxLoopCount = ElementsConf.MaxCount ]
				while[ Property.DHCPMElementsCount < ElementsConf.MaxCount ]
				{
					[ Property.DHCPMElementsCount = Property.DHCPMElementsCount + 1 ]
					DHCPMDhcpSubnetElementDataV4 Element;
				}
				[ Property.DHCPMElementsRefCount = 0, MaxLoopCount = ElementsConf.MaxCount ]
				while[ Property.DHCPMElementsRefCount < ElementsConf.MaxCount ]
				{
					[ Property.DHCPMElementsRefCount = Property.DHCPMElementsRefCount + 1 ]
					DHCPMDhcpSubnetElementDataV4Ref ElementRef;
				}
			}
	}
}

//
//	_DHCP_SUBNET_ELEMENT_INFO_ARRAY_V5
//  Alignment: Ndr
//
Struct DHCPMDhcpSubnetElementInfoArrayV5
{
	UINT32 NumElements;
	NdrPtr ElementsPtr;
	Switch 
	{
		Case ElementsPtr.ReferentID > 0:
			Struct Elements
			{
				Ndrconformant ElementsConf;
				[ Property.DHCPMElementsCount = 0, MaxLoopCount = ElementsConf.MaxCount ]
				while[ Property.DHCPMElementsCount < ElementsConf.MaxCount ]
				{
					[ Property.DHCPMElementsCount = Property.DHCPMElementsCount + 1 ]
					DHCPMDhcpSubnetElementDataV5 Element;
				}
				[ Property.DHCPMElementsRefCount = 0, MaxLoopCount = ElementsConf.MaxCount ]
				while[ Property.DHCPMElementsRefCount < ElementsConf.MaxCount ]
				{
					[ Property.DHCPMElementsRefCount = Property.DHCPMElementsRefCount + 1 ]
					DHCPMDhcpSubnetElementDataV5Ref ElementRef;
				}
			}
	}
}

//
//	_DHCP_SUBNET_ELEMENT_INFO_ARRAY_V6
//
Struct DHCPMDhcpSubnetElementInfoArrayV6
{
	UINT32 NumElements;
	NdrPtr ElementsPtr;
	Switch 
	{
		Case ElementsPtr.ReferentID > 0:
			Struct Elements
			{
				Ndrconformant ElementsConf;
				[ Property.DHCPMElementsCount = 0, MaxLoopCount = ElementsConf.MaxCount ]
				while[ Property.DHCPMElementsCount < ElementsConf.MaxCount ]
				{
					[ Property.DHCPMElementsCount = Property.DHCPMElementsCount + 1 ]
					DHCPMDhcpSubnetElementDataV6 Element;
				}
				[ Property.DHCPMElementsRefCount = 0, MaxLoopCount = ElementsConf.MaxCount ]
				while[ Property.DHCPMElementsRefCount < ElementsConf.MaxCount ]
				{
					[ Property.DHCPMElementsRefCount = Property.DHCPMElementsRefCount + 1 ]
					DHCPMDhcpSubnetElementDataV6Ref ElementRef;
				}
			}
	}
}

Table DHCPMDhcpSubnetElementTypeTable( Value )
{
	Switch( Value )
	{
		Case 0: "DhcpIpRanges - The configuration parameter is the IP range of a DHCPv4 scope configured on the DHCP server.";
		Case 1: "DhcpSecondaryHosts - This enumeration type is unused, and the DHCP server returns ERROR_NOT_SUPPORTED when specified.";
		Case 2: "DhcpReservedIps - The configuration parameter is a reservation for a DHCPv4 client in a DHCPv4 scope element configured on the DHCP server.";
		Case 3: "DhcpExcludedIpRanges - The configuration parameter is the exclusion range of a DHCPv4 scope configured on the DHCPv4 server.";
		Case 4: "DhcpIpUsedClusters - This enumeration type is unused, and the DHCP server returns ERROR_INVALID_PARAMETER when specified.";
		Case 5: "DhcpIpRangesDhcpOnly - The configuration parameter is an IP range of a DHCPv4 scope configured on the DHCPv4 server, which MUST be used only for assignment of addresses to DHCPv4 clients on the subnet. The IP addresses from this range MUST NOT be assigned to BOOTP clients.";
		Case 6: "DhcpIpRangesDhcpBootp - The configuration parameter is an IP range of a DHCPv4 scope configured on the DHCPv4 server, which can be used for assignment of addresses to both DHCPv4 and BOOTP.";
		Case 7: "DhcpIpRangesBootpOnly - The configuration parameter is an IP range of a DHCPv4 scope configured on the DHCPv4 server, which MUST be used only for assignment of IPv4 addresses to BOOTP clients.";
		Default:"Unknown";
	}
}

Table DHCPMDhcpSubnetElementTypeV6Table( Value )
{
	Switch( Value )
	{
		Case 0: "Dhcpv6IpRanges - The configuration parameter is not used, and it MUST NOT be used by an RPC method defined in this specification. If this is used in any of the methods, the method would return ERROR_INVALID_PARAMETER, except for R_DhcpAddSubnetElementV6 and R_DhcpRemoveSubnetElementV6, which return ERROR_SUCCESS.";
		Case 1: "Dhcpv6ReservedIps - The configuration parameter is a reservation for a DHCPv6 client in a DHCPv6 scope element configured on the DHCP server.";
		Case 2: "Dhcpv6ExcludedIpRanges - The configuration parameter is the exclusion range of a DHCPv6 subnet configured on the DHCPv6 server.";
		Default:"Unknown";
	}
}

//
//	_DHCP_SUBNET_INFO
//  Alignment: Ndr
//
Struct DHCPMDhcpSubnetInfo = FormatString("SubnetName: %s, SubnetComment: %s",SubnetName, SubnetComment)
{
	IPv4Address SubnetAddress;
	IPv4Address SubnetMask;
	NdrPtr SubnetNamePtr;
	NdrPtr SubnetCommentPtr;
	DHCPMDhcpHostInfo PrimaryHost;
	UINT32 SubnetState = DHCPMDhcpSubnetStateTable(this);
	Switch
	{
		Case Property.MSRPCNdr64:
			Align8 Pad;
	}
	Switch 
	{
		Case SubnetNamePtr.ReferentID > 0:
			NdrWideString SubnetName;
	}
	Switch 
	{
		Case SubnetCommentPtr.ReferentID > 0:
			NdrWideString SubnetComment;
	}
	DHCPMDhcpHostInfoRef PrimaryHostRef
}

//
//	_DHCP_SUBNET_INFO_V6
//  Alignment: 8
//
Struct DHCPMDhcpSubnetInfoV6
{
	DHCPMDhcpIpv6Address SubnetAddress;
	UINT32 Prefix;
	UINT16 Preference;
	[ Property.DHCPMSubnetNamePtr = this.ReferentID ]
	NdrPtr SubnetNamePtr;
	[ Property.DHCPMSubnetCommentPtr = this.ReferentID ]
	NdrPtr SubnetCommentPtr;
	UINT32 State;
	UINT32 ScopeId;
}

Struct DHCPMDhcpSubnetInfoV6Ref
{
	Switch
	{
		Case Property.DHCPMSubnetNamePtr > 0:
			NdrWideString SubnetName;
	}
	Switch
	{
		Case Property.DHCPMSubnetCommentPtr > 0:
			NdrWideString SubnetComment;
	}
}

//
//	_DHCP_SUBNET_INFO_VQ
//  Alignment: 8
//
Struct DHCPMDhcpSubnetInfoVq
{
	IPv4Address SubnetAddress;
	IPv4Address SubnetMask;
	[ Property.DHCPMSubnetNamePtr = SubnetNamePtr.ReferentID ]
	NdrPtr SubnetNamePtr;
	[ Property.DHCPMSubnetCommentPtr = SubnetCommentPtr.ReferentID ]
	NdrPtr SubnetCommentPtr;
	NdrAlign Pad1;
	DHCPMDhcpHostInfo PrimaryHost;
	UINT32 SubnetState = DHCPMDhcpSubnetStateTable(this);
	UINT32 QuarantineOn;
	UINT32 Reserved1;
	UINT32 Reserved2;
	Align8 Pad3;
	INT64 Reserved3;
	INT64 Reserved4;
}

Struct DHCPMDhcpSubnetInfoVqRef
{
	Switch
	{
		case Property.DHCPMSubnetNamePtr > 0:
			NdrWideString SubnetName;
	}
	Switch
	{
		case Property.DHCPMSubnetCommentPtr > 0:
			NdrWideString SubnetComment;
	}
	DHCPMDhcpHostInfoRef PrimaryHostRef;
}

Table DHCPMDhcpSubnetStateTable( Value )
{
	Switch( Value )
	{
		Case 0: "DhcpSubnetEnabled - The subnet is enabled; the DHCP server assigns IP addresses, extends IP address leases, and releases unused IP addresses for DHCP clients on this subnet.";
		Case 1: "DhcpSubnetDisabled - The subnet is disabled; the DHCP server does not assign IP addresses or extend IP address leases for DHCP clients on this subnet. However, the DHCP server still releases unused IP addresses for DHCP clients on this subnet.";
		Case 2: "DhcpSubnetEnabledSwitched - The subnet is enabled; the DHCP server assigns IP addresses, extends IP address leases, and releases unused IP addresses for DHCP clients on this subnet. In addition, the default gateway for the DHCP client is set to on-link route.";
		Case 3: "DhcpSubnetDisabledSwitched - The subnet is disabled; the DHCP server does not distribute addresses or extend leases within the subnet range to clients. However, the DHCP server still releases addresses within the subnet range.";
		Case 4: "DhcpSubnetInvalidState - The subnet is not valid, and hence no address will be distributed or extended.";
		Default:"Unknown";
	}
}

//
//	_DHCP_SUPER_SCOPE_TABLE
//  Alignment: 4
//
Struct DHCPMDhcpSuperScopeTable
{	
	UINT32 Entries;
	NdrPtr EntriesPtr;
	Switch 
	{
		Case EntriesPtr.ReferentID > 0:
			Struct Entries
			{
				NdrConformant EntriesConf;
				[ Property.DHCPMEntriesCount = 0, MaxLoopCount = EntriesConf.MaxCount ]
				While[ Property.DHCPMEntriesCount < EntriesConf.MaxCount ]
				{
					[ Property.DHCPMEntriesCount = Property.DHCPMEntriesCount + 1 ]
					DHCPMDhcpSuperScopeTableEntry Entry;
				}
				[ Property.DHCPMEntriesRefCount = 0, MaxLoopCount = EntriesConf.MaxCount ]
				While[ Property.DHCPMEntriesRefCount < EntriesConf.MaxCount ]
				{
					[ Property.DHCPMEntriesRefCount = Property.DHCPMEntriesRefCount + 1 ]
					DHCPMDhcpSuperScopeTableEntryRef EntryRef;
				}
			}
	}
}

//
//	_DHCP_SUPER_SCOPE_TABLE_ENTRY
//  Alignment: Ndr
//
Struct DHCPMDhcpSuperScopeTableEntry
{
	IPv4Address SubnetAddress;
	UINT32 SuperScopeNumber;
	UINT32 NextInSuperScope;
	[ Property.DHCPMSuperScopeNamePtr$[ Property.DHCPMEntriesCount ] = this.ReferentID ]
	NdrPtr SuperScopeNamePtr;
}

Struct DHCPMDhcpSuperScopeTableEntryRef
{
	Switch
	{
		case Property.DHCPMSuperScopeNamePtr$[ Property.DHCPMEntriesRefCount ] > 0:
			NdrWideString SuperScopeName;
	}
}

//
//	_DHCPV6_BIND_ELEMENT
//  Alignment: 8
//
Struct DHCPMDhcpv6BindElement
{
	DHCPMDhcpBindElementFlags Flags;
	INT32 BoundToDHCPServer = DHCPMDhcpv6BindElementBoundToDHCPServerTable(this);
	DHCPMDhcpIpv6Address AdapterPrimaryAddress;
	DHCPMDhcpIpv6Address AdapterSubnetAddress;
	[ Property.DHCPMIfDescriptionPtr$[ Property.DHCPMElementsCount ] = this.ReferentID ]
	NdrPtr IfDescriptionPtr;
	UINT32 IpV6IfIndex;
	UINT32 IfIdSize;
	[ Property.DHCPMIfIdPtr$[ Property.DHCPMElementsCount ] = this.ReferentID ]
	NdrPtr IfIdPtr;
}

Struct DHCPMDhcpv6BindElementRef
{
	Switch
	{
		Case Property.DHCPMIfDescriptionPtr$[ Property.DHCPMElementsRefCount ] > 0:
			NdrWideString IfDescription;
	}
	Switch
	{
		Case Property.DHCPMIfIdPtr$[ Property.DHCPMElementsRefCount ] > 0:
			Struct IfId
			{
				NdrConformant IfIdConf;
				[ Local.IfIdCount = 0, MaxLoopCount = IfIdConf.MaxCount ]
				while[ Local.IfIdCount < IfIdConf.MaxCount ]
				{
					[ Local.IfIdCount = Local.IfIdCount + 1 ]
					UINT8 IfIdData;
				}
			}
	}
}

//
//	_DHCPV6_BIND_ELEMENT_ARRAY
//  Alignment: Ndr
//
Struct DHCPMDhcpv6BindElementArray
{	
	UINT32 NumElements;
	NdrPtr ElementsPtr;
	Switch
	{
		Case ElementsPtr.ReferentID > 0:
			Struct Elements
			{
				NdrConformant ElementsConf;
				Align8 Pad;
				[ Property.DHCPMElementsCount = 0, MaxLoopCount = ElementsConf.MaxCount ]
				While[ Property.DHCPMElementsCount < ElementsConf.MaxCount ]
				{
					[ Property.DHCPMElementsCount = Property.DHCPMElementsCount + 1 ]
					DHCPMDhcpv6BindElement Element;
				}
				[ Property.DHCPMElementsRefCount = 0, MaxLoopCount = ElementsConf.MaxCount ]
				While[ Property.DHCPMElementsRefCount < ElementsConf.MaxCount ]
				{
					[ Property.DHCPMElementsRefCount = Property.DHCPMElementsRefCount + 1 ]
					DHCPMDhcpv6BindElementRef ElementRef;
				}
			}
	}
}

Table DHCPMDhcpv6BindElementBoundToDHCPServerTable( Value )
{
	Switch( Value )
	{
		Case 0x00000000: "FALSE - It specifies that the interface is not bound to the DHCP server.";
		Case 0x00000001: "TRUE - It specifies whether the interface is bound to the DHCP server.";
		Default: "Unknown";
	}
}

Table DHCPMDhcpv6BindElementFlagsTable( Value )
{
	Switch( Value )
	{
		Case 0x00000001: "DHCP_ENDPOINT_FLAG_CANT_MODIFY - The endpoints cannot be modified.";
		Default: "Unknown";
	}
}

//
//	_DHCPV6_IP_ARRAY
//  Alignment: Ndr
//
Struct DHCPMDhcpv6IpArray
{
	UINT32 NumElements;
	NdrPtr ElementsPtr;
	Switch
	{
		Case ElementsPtr.ReferentID > 0:
			Struct Elements
			{
				NdrConformant ElementsConf;
				Align8 Pad;
				[ Local.ElementsCount = 0, MaxLoopCount = ElementsConf.MaxCount ]
				while [ Local.ElementsCount < ElementsConf.MaxCount ]
				{
					[ Local.ElementsCount = Local.ElementsCount + 1 ]
					DHCPMDhcpIpv6Address Element;
				}
			}
	}
}

//
//	_DWORD_DWORD
//  Alignment: 4
//
Struct DHCPMDwordDword
{
	UINT32 DWord1;
	UINT32 DWord2;
}

//
//	_DHCP_MIB_INFO
//  Alignment: Ndr
//
Struct DhcpMibInfo
{
	UINT32 Discovers;
	UINT32 Offers;
	UINT32 Requests;
	UINT32 Acks;
	UINT32 Naks;
	UINT32 Declines;
	UINT32 Releases;
	DHCPMDateTime ServerStartTime;
	UINT32 Scopes;
	NdrPtr ScopeInfoPtr;
	Switch 
	{
		Case ScopeInfoPtr.ReferentID > 0:
			Struct
			{
				NdrConformant ScopeInfoConf;
				Switch
				{
					case ScopeInfoConf.MaxCount > 0:
						[ Property.DHCPMScopeInfoCount = 0, MaxLoopCount = ScopeInfoConf.MaxCount ]
						while[ Property.DHCPMScopeInfoCount < ScopeInfoConf.MaxCount ]
						{
							[ Property.DHCPMScopeInfoCount = Property.DHCPMScopeInfoCount + 1 ]
							DHCPMScopeMibInfo ScopeInfo;
						}
				}
			}
	}
}

//
//	_DHCP_MIB_INFO_V5
//  Alignment: Ndr
//
Struct DhcpMibInfoV5
{
	UINT32 Discovers;
	UINT32 Offers;
	UINT32 Requests;
	UINT32 Acks;
	UINT32 Naks;
	UINT32 Declines;
	UINT32 Releases;
	DHCPMDateTime ServerStartTime;
	UINT32 QtnNumLeases = DhcpMibInfoV5QtnNumLeasesTable(this);
	UINT32 QtnPctQtnLeases = DhcpMibInfoV5QtnPctQtnLeasesTable(this);
	UINT32 QtnProbationLeases = DhcpMibInfoV5QtnProbationLeasesTable(this);
	UINT32 QtnNonQtnLeases = DhcpMibInfoV5QtnNonQtnLeasesTable(this);
	UINT32 QtnExemptLeases = DhcpMibInfoV5QtnExemptLeasesTable(this);
	UINT32 QtnCapableClients = DhcpMibInfoV5QtnCapableClientsTable(this);
	UINT32 QtnIASErrors = DhcpMibInfoV5QtnIASErrorsTable(this);
	UINT32 DelayedOffers;
	UINT32 ScopesWithDelayedOffers;
	UINT32 Scopes;
	NdrPtr ScopeInfoPtr;
	Switch
	{
		Case ScopeInfoPtr.ReferentID > 0:
			Struct ScopeInfo
			{
				NdrConformant ScopeInfoConf;
				[ Property.DHCPMScopeInfoCount = 0, MaxLoopCount = ScopeInfoConf.MaxCount ]
				while [ Property.DHCPMScopeInfoCount < ScopeInfoConf.MaxCount ]
				{
					[ Property.DHCPMScopeInfoCount = Property.DHCPMScopeInfoCount + 1 ]
					DHCPMScopeMibInfoV5 ScopeInfo;
				}
			}
	}
}

Table DhcpMibInfoV5QtnCapableClientsTable( Value )
{
	Switch( Value )
	{
		Case 0x00000000: "V1 - Sending";
		Default: "Unknown";
	}
}

Table DhcpMibInfoV5QtnExemptLeasesTable( Value )
{
	Switch( Value )
	{
		Case 0x00000000: "V1 - Sending";
		Default: "Unknown";
	}
}

Table DhcpMibInfoV5QtnIASErrorsTable( Value )
{
	Switch( Value )
	{
		Case 0x00000000: "V1 - Sending";
		Default: "Unknown";
	}
}

Table DhcpMibInfoV5QtnNonQtnLeasesTable( Value )
{
	Switch( Value )
	{
		Case 0x00000000: "V1 - Sending";
		Default: "Unknown";
	}
}

Table DhcpMibInfoV5QtnNumLeasesTable( Value )
{
	Switch( Value )
	{
		Case 0x00000000: "V1 - Sending";
		Default: "Unknown";
	}
}

Table DhcpMibInfoV5QtnPctQtnLeasesTable( Value )
{
	Switch( Value )
	{
		Case 0x00000000: "V1 - Sending";
		Default: "Unknown";
	}
}

Table DhcpMibInfoV5QtnProbationLeasesTable( Value )
{
	Switch( Value )
	{
		Case 0x00000000: "V1 - Sending";
		Default: "Unknown";
	}
}

//
//	_DHCP_MIB_INFO_V6
//  Alignment: Ndr
//
Struct DhcpMibInfoV6
{
	UINT32 Solicits;
	UINT32 Advertises;
	UINT32 Requests;
	UINT32 Renews;
	UINT32 Rebinds;
	UINT32 Replies;
	UINT32 Confirms;
	UINT32 Declines;
	UINT32 Releases;
	UINT32 Informs;
	DHCPMDateTime ServerStartTime;
	UINT32 Scopes;
	NdrPtr ScopeInfoPtr;
	Switch
	{
		Case ScopeInfoPtr.ReferentID > 0:
			Struct ScopeInfo
			{
				NdrConformant ScopeInfoConf;
				Align8 Pad;
				[ Property.DHCPMScopeInfoCount = 0, MaxLoopCount = ScopeInfoConf.MaxCount ]
				while [ Property.DHCPMScopeInfoCount < ScopeInfoConf.MaxCount ]
				{
					[ Property.DHCPMScopeInfoCount = Property.DHCPMScopeInfoCount + 1 ]
					DHCPMScopeMibInfoV6 ScopeInfo;
				}
			}
	}
}

//
//	_DHCP_MIB_INFO_VQ
//  Alignment: Ndr
//
Struct DhcpMibInfoVq
{
	UINT32 Discovers;
	UINT32 Offers;
	UINT32 Requests;
	UINT32 Acks;
	UINT32 Naks;
	UINT32 Declines;
	UINT32 Releases;
	DHCPMDateTime ServerStartTime;
	UINT32 QtnNumLeases;
	UINT32 QtnPctQtnLeases;
	UINT32 QtnProbationLeases;
	UINT32 QtnNonQtnLeases;
	UINT32 QtnExemptLeases;
	UINT32 QtnCapableClients;
	UINT32 QtnIASErrors;
	UINT32 Scopes;
	NdrPtr ScopeInfoPtr;
	switch	
	{
		case ScopeInfoPtr.referentID!=0:
		Struct Scopes
			{
				NDRConformant ScopeInfoConf;
				[ Property.DHCPMScopeInfoCount = 0, MaxLoopCount = ScopeInfoConf.MaxCount ]
				while [ Property.DHCPMScopeInfoCount < ScopeInfoConf.MaxCount ]
				{
					[ Property.DHCPMScopeInfoCount = Property.DHCPMScopeInfoCount + 1 ]
					DHCPMScopeMibInfoVq ScopeInfo;
				}
			}
	}
}

//
//	_MSCOPE_MIB_INFO
//  Alignment: Ndr
//
Struct DHCPMMscopeMibInfo
{
	UINT32 MScopeId;
	[ Property.DHCPMMScopeNamePtr$[ Property.DHCPMScopeInfoCount ] = this.ReferentID ]
	NdrPtr MScopeNamePtr;
	UINT32 NumAddressesInuse;
	UINT32 NumAddressesFree;
	UINT32 NumPendingOffers;
	Switch
	{
		Case Property.MSRPCNdr64:
			Align8 Pad;
	}
}

Struct DHCPMMscopeMibInfoRef
{
	Switch
	{
		Case Property.DHCPMMScopeNamePtr$[ Property.DHCPMScopeInfoRefCount ] > 0:
			NdrWideString MScopeName;
	}
}

Table DHCPMNestedElementDhcpSubnetElementDataIpRangeTable( Value )
{
	Switch( Value )
	{
		Case 0: "DhcpIpRanges - The configuration parameter is the IP range of a DHCPv4 scope configured on the DHCP server.";
		Case 5: "DhcpIpRangesDhcpOnly - The configuration parameter is an IP range of a DHCPv4 scope configured on the DHCP server that MUST be used only for assignment of addresses to DHCP clients on the subnet. The IP addresses from this range MUST NOT be assigned to BOOTP clients.";
		Case 6: "DhcpIpRangesDhcpBootp - The configuration parameter is an IP range of a DHCPv4 scope configured on the DHCP server that can be used for assignment of addresses to both DHCP and BOOTP.";
		Case 7: "DhcpIpRangesBootpOnly - The configuration parameter is an IP range of a DHCPv4 scope configured on the DHCP server that MUST be used only for assignment of IPv4 addresses to BOOTP clients.";
		Default: "Unknown";
	}
}

Table DHCPMNestedElementDhcpSubnetElementDataV4IpRangeTable( Value )
{
	Switch( Value )
	{
		Case 0: "DhcpIpRanges - The configuration parameter is the IP range of a DHCPv4 scope configured on the DHCPv4 server.";
		Case 5: "DhcpIpRangesDhcpOnly - The configuration parameter is an IP range of a DHCPv4 scope configured on the DHCPv4 server that MUST be used only for assignment of addresses to DHCPv4 clients on the subnet. The IP addresses from this range MUST NOT be assigned to BOOTP clients.";
		Case 6: "DhcpIpRangesDhcpBootp - The configuration parameter is an IP range of a DHCPv4 scope configured on the DHCPv4 server that can be used for assignment of addresses to both DHCPv4 and BOOTP.";
		Case 7: "DhcpIpRangesBootpOnly - The configuration parameter is an IP range of a DHCPv4 scope configured on the DHCPv4 server that MUST be used only for assignment of IPv4 addresses to BOOTP clients.";
		Default: "Unknown";
	}
}

Table DHCPMNestedElementDhcpSubnetElementDataV5IpRangeTable( Value )
{
	Switch( Value )
	{
		Case 0: "DhcpIpRanges - The configuration parameter is the IP range of a DHCPv4 scope configured on the DHCPv4 server.";
		Case 5: "DhcpIpRangesDhcpOnly - The configuration parameter is an IP range of a DHCPv4 scope configured on the DHCPv4 server that MUST be used only for assignment of addresses to DHCPv4 clients on the subnet. The IP addresses from this range MUST NOT be assigned to BOOTP clients.";
		Case 6: "DhcpIpRangesDhcpBootp - The configuration parameter is an IP range of a DHCPv4 scope configured on the DHCPv4 server that can be used for assignment of addresses to both DHCPv4 and BOOTP.";
		Case 7: "DhcpIpRangesBootpOnly - The configuration parameter is an IP range of a DHCPv4 scope configured on the DHCPv4 server that MUST be used only for assignment of IPv4 addresses to BOOTP clients.";
		Default: "Unknown";
	}
}

Table DHCPMQuarantineStatusTable( Value )
{
	Switch( Value )
	{
		Case 0: "NOQUARANTINE - The DHCP client is compliant with the health policies defined by the administrator and has normal access to the network.";
		Case 1: "RESTRICTEDACCESS - The DHCP client is not compliant with the health policies defined by the administrator and is being quarantined with restricted access to the network.";
		Case 2: "QUARANTINE - The DHCP client is not compliant with the health policies defined by the administrator and is being quarantined with restricted access to the network.";
		Case 3: "DROPPACKET - The DHCP client is not compliant with the health policies defined by the administrator and is being denied access to the network. The DHCP server does not grant an IP address lease to this client.";
		Case 4: "PROBATION - The DHCP client is not compliant with the health policies defined by the administrator and is being granted normal access to the network for a limited time.";
		Case 5: "EXEMPT - The DHCP client is exempt from compliance with the health policies defined by the administrator and is granted normal access to the network.";
		Case 6: "DEFAULTQUARSETTING - The default policy for DHCP NAP server, to put a DHCP client into Quarantine/unrestricted/Drop Request when a network policy server (NPS) is not reachable.";
		Case 7: "NOQUARINFO - No quarantine.";
	}
}

Table DHCPMRDhcpAuditLogGetParamsFlagsTable( Value )
{
	Switch( Value )
	{
		Case 0: "V1 - Possible value.";
		Default: "Unknown";
	}
}

Table DHCPMRDhcpAuditLogSetParamsFlagsTable( Value )
{
	Switch( Value )
	{
		Case 0: "V1 - Possible value.";
		Default: "Unknown";
	}
}

Table DHCPMRDhcpCreateOptionV5FlagsTable( Value )
{
	Switch( Value )
	{
		Case 0x00000000: "V1 - Option definition is created for the default vendor class.";
		Case 0x00000003: "DHCP_FLAGS_OPTION_IS_VENDOR - Option definition is created for a specific vendor class.";
		Default: "Unknown";
	}
}

Table DHCPMRDhcpCreateOptionV6FlagsTable( Value )
{
	Switch( Value )
	{
		Case 0x00000000: "V1 - Option definition is created for the default vendor class.";
		Case 0x00000003: "DHCP_FLAGS_OPTION_IS_VENDOR - Option definition is created for a specific vendor class.";
		Default: "Unknown";
	}
}

Table DHCPMRDhcpEnumOptionsV5FlagsTable( Value )
{
	Switch( Value )
	{
		Case 0x00000000: "V1 - Option definition is enumerated for a default vendor class.";
		Case 0x00000003: "DHCP_FLAGS_OPTION_IS_VENDOR - Option definition is enumerated for a specific vendor class.";
		Default: "Unknown";
	}
}

Table DHCPMRDhcpEnumOptionsV6FlagsTable( Value )
{
	Switch( Value )
	{
		Case 0x00000000: "V1 - Option definition is enumerated for a default vendor class.";
		Case 0x00000003: "DHCP_FLAGS_OPTION_IS_VENDOR - Option definition is enumerated for a specific vendor class.";
		Default: "Unknown";
	}
}

Table DHCPMRDhcpEnumOptionValuesV5FlagsTable( Value )
{
	Switch( Value )
	{
		Case 0x00000000: "V1 - Option values are enumerated for a default vendor class.";
		Case 0x00000003: "DHCP_FLAGS_OPTION_IS_VENDOR - Option values are enumerated for a specific vendor class.";
		Default: "Unknown";
	}
}

Table DHCPMRDhcpEnumOptionValuesV6FlagsTable( Value )
{
	Switch( Value )
	{
		Case 0x00000000: "V1 - Option definition is enumerated for the default vendor class.";
		Case 0x00000003: "DHCP_FLAGS_OPTION_IS_VENDOR - Option definition is enumerated for a specific vendor class.";
		Default: "Unknown";
	}
}

Table DHCPMRDhcpGetAllOptionsFlagsTable( Value )
{
	Switch( Value )
	{
		Case 0: "V1 - Possible value.";
		Default: "Unknown";
	}
}

Table DHCPMRDhcpGetAllOptionsV6FlagsTable( Value )
{
	Switch( Value )
	{
		Case 0: "V1 - Possible value.";
		Default: "Unknown";
	}
}

Table DHCPMRDhcpGetOptionInfoV5FlagsTable( Value )
{
	Switch( Value )
	{
		Case 0x00000000: "DHCP_FLAGS_OPTION_DEFAULT - Option definition is modified for a default vendor class.";
		Case 0x00000003: "DHCP_FLAGS_OPTION_IS_VENDOR - Option definition is retrieved for a specific vendor class.";
		Default: "Unknown";
	}
}

Table DHCPMRDhcpGetOptionInfoV6FlagsTable( Value )
{
	Switch( Value )
	{
		Case 0x00000000: "V1 - Option definition is retrieved for the default vendor class.";
		Case 0x00000003: "DHCP_FLAGS_OPTION_IS_VENDOR - Option definition is retrieved for a specific vendor class.";
		Default: "Unknown";
	}
}

Table DHCPMRDhcpGetOptionValueV5FlagsTable( Value )
{
	Switch( Value )
	{
		Case 0x00000000: "V1 - Option value is retrieved for a default vendor class.";
		Case 0x00000003: "DHCP_FLAGS_OPTION_IS_VENDOR - Option value is retrieved for a specific vendor class. This value MUST be set if a non-NULL parameter is passed in VendorName.";
		Default: "Unknown";
	}
}

Table DHCPMRDhcpGetOptionValueV6FlagsTable( Value )
{
	Switch( Value )
	{
		Case 0x00000000: "V1 - Option value is retrieved for the default vendor class.";
		Case 0x00000003: "DHCP_FLAGS_OPTION_IS_VENDOR - Option value is retrieved for the specified vendor class.";
		Default: "Unknown";
	}
}

Table DHCPMRDhcpGetServerBindingInfoFlagsTable( Value )
{
	Switch( Value )
	{
		Case 0: "V1 - Possible value.";
		Default: "Unknown";
	}
}

Table DHCPMRDhcpGetServerBindingInfoV6FlagsTable( Value )
{
	Switch( Value )
	{
		Case 0: "V1 - Possible value.";
		Default: "Unknown";
	}
}

Table DHCPMRDhcpRemoveOptionV5FlagsTable( Value )
{
	Switch( Value )
	{
		Case 0x00000000: "V1 - Option definition is removed for the default vendor class.";
		Case 0x00000003: "DHCP_FLAGS_OPTION_IS_VENDOR - Option definition is removed for a specific vendor class.";
		Default: "Unknown";
	}
}

Table DHCPMRDhcpRemoveOptionV6FlagsTable( Value )
{
	Switch( Value )
	{
		Case 0x00000000: "V1 - Option definition is removed for a default vendor class.";
		Case 0x00000003: "DHCP_FLAGS_OPTION_IS_VENDOR - Option definition is removed for a specific vendor class.";
		Default: "Unknown";
	}
}

Table DHCPMRDhcpRemoveOptionValueV5FlagsTable( Value )
{
	Switch( Value )
	{
		Case 0x00000000: "V1 - Option value is removed for a default vendor class.";
		Case 0x00000003: "DHCP_FLAGS_OPTION_IS_VENDOR - Option value is removed for a specific vendor class.";
		Default: "Unknown";
	}
}

Table DHCPMRDhcpRemoveOptionValueV6FlagsTable( Value )
{
	Switch( Value )
	{
		Case 0x00000000: "V1 - Option definition is removed for the default vendor class.";
		Case 0x00000003: "DHCP_FLAGS_OPTION_IS_VENDOR - Option definition is removed for a specific vendor class.";
		Default: "Unknown";
	}
}

Table DHCPMRDhcpServerQueryAttributeReservedTable( Value )
{
	Switch( Value )
	{
		Case 0: "V1 - Possible value.";
		Default: "Unknown";
	}
}

Table DHCPMRDhcpServerQueryAttributesReservedTable( Value )
{
	Switch( Value )
	{
		Case 0: "V1 - Possible value.";
		Default: "Unknown";
	}
}

Table DHCPMRDhcpServerSetConfigV6FieldsToSetTable( Value )
{
	Switch( Value )
	{
		Case 0x00000001: "Set_UnicastFlag - Set unicast option.";
		Case 0x00000002: "Set_RapidCommitFlag - Set rapid commit option.";
		Case 0x00000004: "Set_PreferredLifetime - Set preferred lifetime value for nontemporary IPv6 address.";
		Case 0x00000008: "Set_ValidLifetime - Set valid lifetime value for nontemporary IPv6 address.";
		Case 0x00000010: "Set_T1 - Set T1 time value.";
		Case 0x00000020: "Set_T2 - Set T2 time value.";
		Case 0x00000040: "Set_PreferredLifetimeIATA - Set preferred lifetime value for temporary IPv6 address.";
		Case 0x00000080: "Set_ValidLifetimeIATA - Set valid lifetime value for temporary IPv6 address.";
		Case 0x00000800: "Set_AuditLogState - Set audit log state in the registry.";
		Default: "Unknown";
	}
}

Table DHCPMRDhcpSetOptionInfoV5FlagsTable( Value )
{
	Switch( Value )
	{
		Case 0x00000000: "DHCP_FLAGS_OPTION_DEFAULT - Option definition is modified for a default vendor class.";
		Case 0x00000003: "DHCP_FLAGS_OPTION_IS_VENDOR - Option definition is modified for a specific vendor class.";
		Default: "Unknown";
	}
}

Table DHCPMRDhcpSetOptionInfoV6FlagsTable( Value )
{
	Switch( Value )
	{
		Case 0x00000000: "V1 - Option is modified for a default vendor class.";
		Case 0x00000003: "DHCP_FLAGS_OPTION_IS_VENDOR - Option is modified for a specific vendor class.";
		Default: "Unknown";
	}
}

Table DHCPMRDhcpSetOptionValuesV5FlagsTable( Value )
{
	Switch( Value )
	{
		Case 0: "V1 - Possible value.";
		Default: "Unknown";
	}
}

Table DHCPMRDhcpSetOptionValueV5FlagsTable( Value )
{
	Switch( Value )
	{
		Case 0x00000000: "V1 - Option definition is set for the default vendor class.";
		Case 0x00000003: "DHCP_FLAGS_OPTION_IS_VENDOR - Option definition is set for a specific vendor class.";
		Default: "Unknown";
	}
}

Table DHCPMRDhcpSetOptionValueV6FlagsTable( Value )
{
	Switch( Value )
	{
		Case 0x00000000: "V1 - Option definition is set/modified for a default vendor class.";
		Case 0x00000003: "DHCP_FLAGS_OPTION_IS_VENDOR - Option definition is set/modified for a specific vendor class.";
		Default: "Unknown";
	}
}

Table DHCPMRDhcpSetServerBindingInfoFlagsTable( Value )
{
	Switch( Value )
	{
		Case 0: "V1 - Possible value.";
		Default: "Unknown";
	}
}

Table DHCPMRDhcpSetServerBindingInfoV6FlagsTable( Value )
{
	Switch( Value )
	{
		Case 0: "V1 - Possible value.";
		Default: "Unknown";
	}
}

Table DHCPMRDhcpSetSubnetDelayOfferTimeDelayInMillisecondsTable( Value )
{
	Switch( Value )
	{
		Case 0: "V1 - Minimum Delay (default)";
		Case 1000: "V2 - Maximum Delay";
		Default: "Unknown";
	}
}

Table DHCPMAttribID( Value )
{
	Switch( Value )
	{
		Case 0x00000001: "DHCP_ATTRIB_BOOL_IS_ROGUE - The attribute is a BOOLEAN that indicates whether the DHCP server is rogue.";
		Case 0x00000002: "DHCP_ATTRIB_BOOL_IS_DYNBOOTP - The attribute is a BOOLEAN, which indicates whether the DHCP server supports BOOTP.";
		Case 0x00000003: "DHCP_ATTRIB_BOOL_IS_PART_OF_DSDC - The attribute is a BOOLEAN, which indicates whether the DHCP server is a domain member.";
		Case 0x00000004: "DHCP_ATTRIB_BOOL_IS_BINDING_AWARE - The attribute is a BOOLEAN. The DHCP server always returns a TRUE value for this.";
		Case 0x00000005: "DHCP_ATTRIB_BOOL_IS_ADMIN - The attribute is a BOOLEAN, which indicates whether the DHCPM client is a member of the DHCP Administrators security group.";
		Case 0x00000006: "DHCP_ATTRIB_ULONG_RESTORE_STATUS - This attribute is a ULONG, which indicates the status of the last DHCP server restore operation.";
		Default: "Unknown";
	}
}

//
//	_DHCP_MSCOPE_INFO
//  Alignment: Ndr
//
Struct DhcpMscopeInfo
{
	[ Property.DHCPMMScopeNamePtr = this.ReferentID ]
	NdrPtr MScopeNamePtr;
	[ Property.DHCPMMScopeCommentPtr = this.ReferentID ]
	NdrPtr MScopeCommentPtr;
	UINT32 MScopeId;
	UINT32 MScopeAddressPolicy;
	DHCPMDhcpHostInfo PrimaryHost;
	UINT32 MScopeState = DHCPMDhcpSubnetStateTable(this);
	UINT32 MScopeFlags;
	DHCPMDateTime ExpiryTime;
	[ Property.DHCPMLangTagPtr = this.ReferentID ]
	NdrPtr LangTagPtr;
	CHAR TTL;
	Switch
	{
		Case Property.MSRPCNdr64:
			Align8 Pad;
	}
}

Struct DhcpMscopeInfoRef
{
	Switch
	{
		case Property.DHCPMMScopeNamePtr > 0:
			NdrWideString MScopeName;
	}
	Switch
	{
		case Property.DHCPMMScopeCommentPtr > 0:
			NdrWideString MScopeComment;
	}
	DHCPMDhcpHostInfoRef PrimaryHostRef;
	Switch
	{
		case Property.DHCPMLangTagPtr > 0:
			NdrWideString LangTag;
	}
}

//
//	_SCOPE_MIB_INFO
//  Alignment: 4
//
Struct DHCPMScopeMibInfo
{
	IPv4Address Subnet;
	UINT32 NumAddressesInuse;
	UINT32 NumAddressesFree;
	UINT32 NumPendingOffers;
}

//
//	_SCOPE_MIB_INFO_V5
//  Alignment: 4
//
Struct DHCPMScopeMibInfoV5
{
	IPv4Address Subnet;
	UINT32 NumAddressesInuse;
	UINT32 NumAddressesFree;
	UINT32 NumPendingOffers;
}

//
//	_SCOPE_MIB_INFO_V6
//  Alignment: 8
//
Struct DHCPMScopeMibInfoV6
{
	DHCPMDhcpIpv6Address Subnet;
	UINT64 NumAddressesInuse;
	UINT64 NumAddressesFree;
	UINT64 NumPendingAdvertises;
}

//
//	_SCOPE_MIB_INFO_VQ
//  Alignment: 4
//
Struct DHCPMScopeMibInfoVq
{
	IPv4Address Subnet;
	UINT32 NumAddressesInuse;
	UINT32 NumAddressesFree;
	UINT32 NumPendingOffers;
	UINT32 QtnNumLeases;
	UINT32 QtnPctQtnLeases;
	UINT32 QtnProbationLeases;
	UINT32 QtnNonQtnLeases;
	UINT32 QtnExemptLeases;
	UINT32 QtnCapableClients;
}

//
//	_DHCP_MSCOPE_TABLE
//  Alignment: Ndr
//
Struct DhcpMscopeTable
{
	UINT32 NumElements;
	NdrPtr  MScopeNamesPtr;
	Switch 
	{
		Case MScopeNamesPtr.referentID!=0:
			Struct MScopeNames
			{
				NdrConformant MScopeNamesConf;
				Switch 
				{
					Case MScopeNamesConf.MaxCount > 0:
						Struct
						{
							[ Property.DHCPMMScopeNamesCount = 0, MaxLoopCount = MScopeNamesConf.MaxCount ]
							while[ Property.DHCPMMScopeNamesCount < MScopeNamesConf.Maxcount ]
							{
								[ Property.DHCPMMScopeNamesCount = Property.DHCPMMScopeNamesCount + 1 ]
								NdrPtr	MScopeNamesPtr;
							}
							[ MaxLoopCount = MScopeNamesConf.MaxCount ]
							while [ Property.DHCPMMScopeNamesCount > 0 ]
							{
								[ Property.DHCPMMScopeNamesCount = Property.DHCPMMScopeNamesCount - 1]
								NdrWideString MScopeName;
							}
						}
				}
			}
	}
}

Table DHCPMdhcpsrv2MethodNameTable( Opnum )
{
	Switch( Opnum )
	{
		Case 0: "R_DhcpEnumSubnetClientsV5";
		Case 1: "R_DhcpSetMScopeInfo";
		Case 2: "R_DhcpGetMScopeInfo";
		Case 3: "R_DhcpEnumMScopes";
		Case 4: "R_DhcpAddMScopeElement";
		Case 5: "R_DhcpEnumMScopeElements";
		Case 6: "R_DhcpRemoveMScopeElement";
		Case 7: "R_DhcpDeleteMScope";
		Case 8: "R_DhcpScanMDatabase";
		Case 9: "R_DhcpCreateMClientInfo";
		Case 10: "R_DhcpSetMClientInfo";
		Case 11: "R_DhcpGetMClientInfo";
		Case 12: "R_DhcpDeleteMClientInfo";
		Case 13: "R_DhcpEnumMScopeClients";
		Case 14: "R_DhcpCreateOptionV5";
		Case 15: "R_DhcpSetOptionInfoV5";
		Case 16: "R_DhcpGetOptionInfoV5";
		Case 17: "R_DhcpEnumOptionsV5";
		Case 18: "R_DhcpRemoveOptionV5";
		Case 19: "R_DhcpSetOptionValueV5";
		Case 20: "R_DhcpSetOptionValuesV5";
		Case 21: "R_DhcpGetOptionValueV5";
		Case 22: "R_DhcpEnumOptionValuesV5";
		Case 23: "R_DhcpRemoveOptionValueV5";
		Case 24: "R_DhcpCreateClass";
		Case 25: "R_DhcpModifyClass";
		Case 26: "R_DhcpDeleteClass";
		Case 27: "R_DhcpGetClassInfo";
		Case 28: "R_DhcpEnumClasses";
		Case 29: "R_DhcpGetAllOptions";
		Case 30: "R_DhcpGetAllOptionValues";
		Case 31: "R_DhcpGetMCastMibInfo";
		Case 32: "R_DhcpAuditLogSetParams";
		Case 33: "R_DhcpAuditLogGetParams";
		Case 34: "R_DhcpServerQueryAttribute";
		Case 35: "R_DhcpServerQueryAttributes";
		Case 36: "R_DhcpServerRedoAuthorization";
		Case 37: "R_DhcpAddSubnetElementV5";
		Case 38: "R_DhcpEnumSubnetElementsV5";
		Case 39: "R_DhcpRemoveSubnetElementV5";
		Case 40: "R_DhcpGetServerBindingInfo";
		Case 41: "R_DhcpSetServerBindingInfo";
		Case 42: "R_DhcpQueryDnsRegCredentials";
		Case 43: "R_DhcpSetDnsRegCredentials";
		Case 44: "R_DhcpBackupDatabase";
		Case 45: "R_DhcpRestoreDatabase";
		Case 46: "R_DhcpGetServerSpecificStrings";
		Case 47: "R_DhcpCreateOptionV6";
		Case 48: "R_DhcpSetOptionInfoV6";
		Case 49: "R_DhcpGetOptionInfoV6";
		Case 50: "R_DhcpEnumOptionsV6";
		Case 51: "R_DhcpRemoveOptionV6";
		Case 52: "R_DhcpSetOptionValueV6";
		Case 53: "R_DhcpEnumOptionValuesV6";
		Case 54: "R_DhcpRemoveOptionValueV6";
		Case 55: "R_DhcpGetAllOptionsV6";
		Case 56: "R_DhcpGetAllOptionValuesV6";
		Case 57: "R_DhcpCreateSubnetV6";
		Case 58: "R_DhcpEnumSubnetsV6";
		Case 59: "R_DhcpAddSubnetElementV6";
		Case 60: "R_DhcpEnumSubnetElementsV6";
		Case 61: "R_DhcpRemoveSubnetElementV6";
		Case 62: "R_DhcpDeleteSubnetV6";
		Case 63: "R_DhcpGetSubnetInfoV6";
		Case 64: "R_DhcpEnumSubnetClientsV6";
		Case 65: "R_DhcpServerSetConfigV6";
		Case 66: "R_DhcpServerGetConfigV6";
		Case 67: "R_DhcpSetSubnetInfoV6";
		Case 68: "R_DhcpGetMibInfoV6";
		Case 69: "R_DhcpGetServerBindingInfoV6";
		Case 70: "R_DhcpSetServerBindingInfoV6";
		Case 71: "R_DhcpSetClientInfoV6";
		Case 72: "R_DhcpGetClientInfoV6";
		Case 73: "R_DhcpDeleteClientInfoV6";
		Case 74: "R_DhcpCreateClassV6";
		Case 75: "R_DhcpModifyClassV6";
		Case 76: "R_DhcpDeleteClassV6";
		Case 77: "R_DhcpEnumClassesV6";
		Case 78: "R_DhcpGetOptionValueV6";
		Case 79: "R_DhcpSetSubnetDelayOffer";
		Case 80: "R_DhcpGetSubnetDelayOffer";
		Case 81: "R_DhcpGetMibInfoV5";
		Case 82: "R_DhcpAddFilterV4";
		Case 83: "R_DhcpDeleteFilterV4";
		Case 84: "R_DhcpSetFilterV4";
		Case 85: "R_DhcpGetFilterV4";
		Case 86: "R_DhcpEnumFilterV4";
		Case 87: "R_DhcpSetDnsRegCredentialsV5";
		Case 88: "R_DhcpEnumSubnetClientsFilterStatusInfo";
		Default: "Unknown";
	}
}

Table DHCPMdhcpsrvMethodNameTable( Opnum )
{
	Switch( Opnum )
	{
		Case 0: "R_DhcpCreateSubnet";
		Case 1: "R_DhcpSetSubnetInfo";
		Case 2: "R_DhcpGetSubnetInfo";
		Case 3: "R_DhcpEnumSubnets";
		Case 4: "R_DhcpAddSubnetElement";
		Case 5: "R_DhcpEnumSubnetElements";
		Case 6: "R_DhcpRemoveSubnetElement";
		Case 7: "R_DhcpDeleteSubnet";
		Case 8: "R_DhcpCreateOption";
		Case 9: "R_DhcpSetOptionInfo";
		Case 10: "R_DhcpGetOptionInfo";
		Case 11: "R_DhcpRemoveOption";
		Case 12: "R_DhcpSetOptionValue";
		Case 13: "R_DhcpGetOptionValue";
		Case 14: "R_DhcpEnumOptionValues";
		Case 15: "R_DhcpRemoveOptionValue";
		Case 16: "R_DhcpCreateClientInfo";
		Case 17: "R_DhcpSetClientInfo";
		Case 18: "R_DhcpGetClientInfo";
		Case 19: "R_DhcpDeleteClientInfo";
		Case 20: "R_DhcpEnumSubnetClients";
		Case 21: "R_DhcpGetClientOptions";
		Case 22: "R_DhcpGetMibInfo";
		Case 23: "R_DhcpEnumOptions";
		Case 24: "R_DhcpSetOptionValues";
		Case 25: "R_DhcpServerSetConfig";
		Case 26: "R_DhcpServerGetConfig";
		Case 27: "R_DhcpScanDatabase";
		Case 28: "R_DhcpGetVersion";
		Case 29: "R_DhcpAddSubnetElementV4";
		Case 30: "R_DhcpEnumSubnetElementsV4";
		Case 31: "R_DhcpRemoveSubnetElementV4";
		Case 32: "R_DhcpCreateClientInfoV4";
		Case 33: "R_DhcpSetClientInfoV4";
		Case 34: "R_DhcpGetClientInfoV4";
		Case 35: "R_DhcpEnumSubnetClientsV4";
		Case 36: "R_DhcpSetSuperScopeV4";
		Case 37: "R_DhcpGetSuperScopeInfoV4";
		Case 38: "R_DhcpDeleteSuperScopeV4";
		Case 39: "R_DhcpServerSetConfigV4";
		Case 40: "R_DhcpServerGetConfigV4";
		Case 41: "R_DhcpServerSetConfigVQ";
		Case 42: "R_DhcpServerGetConfigVQ";
		Case 43: "R_DhcpGetMibInfoVQ";
		Case 44: "R_DhcpCreateClientInfoVQ";
		Case 45: "R_DhcpSetClientInfoVQ";
		Case 46: "R_DhcpGetClientInfoVQ";
		Case 47: "R_DhcpEnumSubnetClientsVQ";
		Case 48: "R_DhcpCreateSubnetVQ";
		Case 49: "R_DhcpGetSubnetInfoVQ";
		Case 50: "R_DhcpSetSubnetInfoVQ";
		Default: "Unknown";
	}
}

Struct DHCPMFieldsToSet = FormatString( "0x%08X", UINT32( FrameData, FrameOffset ) )
{
	Switch( Property.MSRPCByteOrder )
	{
		Case LittleEndian:
		Struct
		{
			UINT32 Values = FormatString( "0x%08X", this )
			{
				UINT32 SetAPIProtocolSupport:1 = FormatString("           (%s) ", this.ToBitString);
				UINT32 SetDatabaseName:1 = FormatString("           (%s) ", this.ToBitString);
				UINT32 SetDatabasePath:1 = FormatString("             (%s) ", this.ToBitString);
				UINT32 SetBackupPath:1 = FormatString("     (%s) ", this.ToBitString);
				UINT32 SetBackupInterval:1 = FormatString("       (%s) ", this.ToBitString);
				UINT32 SetDatabaseLoggingFlag:1 = FormatString("        (%s) ", this.ToBitString);
				UINT32 SetRestoreFlag:1 = FormatString("      (%s) ", this.ToBitString);
				UINT32 SetDatabaseCleanupInterval:1 = FormatString(" (%s) ", this.ToBitString);
				UINT32 SetDebugFlag:1 = FormatString("         (%s) ", this.ToBitString);
				UINT32 SetPingRetries:1 = FormatString("        (%s) ", this.ToBitString);
				UINT32 SetBootFileTable:1 = FormatString("        (%s) ", this.ToBitString);
				UINT32 SetAuditLogState:1 = FormatString("          (%s) ", this.ToBitString);
				UINT32 SetQuarantineON:1 = FormatString("          (%s) ", this.ToBitString);
				UINT32 SetQuarantineDefFail:1 = FormatString("          (%s) ", this.ToBitString);
				UINT32 Reserved:18 = FormatString("          (%s) ", this.ToBitString);	
			}
		}
		Default:
		Struct
		{
			UINT32 Attributes = FormatString( "0x%08X", this )
			{
				UINT32 Reserved:18 = FormatString("          (%s) ", this.ToBitString);	
				UINT32 SetQuarantineDefFail:1 = FormatString("          (%s) ", this.ToBitString);
				UINT32 SetQuarantineON:1 = FormatString("          (%s) ", this.ToBitString);
				UINT32 SetAuditLogState:1 = FormatString("          (%s) ", this.ToBitString);
				UINT32 SetBootFileTable:1 = FormatString("        (%s) ", this.ToBitString);
				UINT32 SetPingRetries:1 = FormatString("        (%s) ", this.ToBitString);
				UINT32 SetDebugFlag:1 = FormatString("         (%s) ", this.ToBitString);
				UINT32 SetDatabaseCleanupInterval:1 = FormatString(" (%s) ", this.ToBitString);
				UINT32 SetRestoreFlag:1 = FormatString("      (%s) ", this.ToBitString);
				UINT32 SetDatabaseLoggingFlag:1 = FormatString("        (%s) ", this.ToBitString);
				UINT32 SetBackupInterval:1 = FormatString("       (%s) ", this.ToBitString);
				UINT32 SetBackupPath:1 = FormatString("     (%s) ", this.ToBitString);
				UINT32 SetDatabasePath:1 = FormatString("             (%s) ", this.ToBitString);
				UINT32 SetDatabaseName:1 = FormatString("           (%s) ", this.ToBitString);
				UINT32 SetAPIProtocolSupport:1 = FormatString("           (%s) ", this.ToBitString);
			}
		}
	}
}
