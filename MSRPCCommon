//#  (c) 2009 CodePlex Foundation
//#
//#  Title:                  Microsoft Remote Procedure Call Protocol (MSRPC)
//#
//#  Details:                
//#
//#  Public References:      CAE Specification
//#                          DCE 1.1: Remote Procedure Call
//#                          Document Number C706 at http://www.opengroup.org/onlinepubs/009629399/
//#  Microsoft References:   [MS-RPCE]: Remote Procedure Call Protocol Extensions
//#
//#  Comments:               
//#
//#  Revision Class and Date:Minor, 6/3/2010
//#
//####

[DefaultTimeOut = MSRPCConversationTimeout]
[Property.MSRPCDescription = MSRPC.ToString]
Protocol MSRPC = property.MSRPCSummary + " " + property.ParserErrorMessage + (Property.ParserWarning ? "Warning: " + Property.ParserWarningMessage : "")
{
	switch
	{
		//
		//  validate connection-oriented packet header
		//
		case 
			UINT8( Framedata, Offset ) == 0x05 &&
			( UINT8( Framedata, Offset + 1 ) == 0 || UINT8( Framedata, Offset + 1 ) == 1 ) &&
			( FrameLength - Offset >= 16 ) &&
			( UINT8( Framedata, Offset + 2 ) == 0 ||
			  UINT8( Framedata, Offset + 2 ) == 2 ||
			  UINT8( Framedata, Offset + 2 ) == 3 ||
			  ( UINT8( Framedata, Offset + 2 ) >= 11 &&
				UINT8( Framedata, Offset + 2 ) <= 19 )) &&
			( UINT8( Framedata, Offset + 4 ) & 0xEE ) == 0 &&
			UINT8( Framedata, Offset + 5 ) < 4 &&
			UINT8( Framedata, Offset + 6 ) == 0 &&
			UINT8( Framedata, Offset + 7 ) == 0 :
			Struct
			{
				[BuildConversationWithParent]
				[
					Post.Conversation.ConversationDescription = 
						Conversation.MSRPC.ConversationDescription ? Conversation.MSRPC.ConversationDescription : 
						( property.MSRPCIfUuid ? FormatString("(%s - %s) ", property.MSRPCInterfaceName, property.MSRPCIfUuid) : "" ) +
						( FormatString("ConvID = %d", ConvID) )
				]
				[DataFieldByteOrder = UINT8( Framedata, Offset + 4 ) & 0x10 ? LittleEndian : BigEndian]
				[DataFieldFrameLength = FrameOffset + UINT16( FrameData, Offset + 8 )]
				struct
				{
					switch ( UINT8( Framedata, Offset + 2 ) ) //PType
					{
						case 0x00: MSRPCRpcconnRequestHdrT	Request;
						case 0x02: MSRPCRpcconnResponseHdrT	Response;
						case 0x03: MSRPCRpcconnFaultHdrT	Fault;
						case 0x0B: MSRPCRpcconnBindHdrT		Bind;
						case 0x0C: MSRPCRpcconnBindAckHdrT	BindAck;
						case 0x0D: RPCEBindNak	BindNack;
						case 0x0E: MSRPCRpcconnAlterContextHdrT AlterContext;
						case 0x0F: MSRPCRpcconnAlterContextResponseHdrT AlterContextResponse;
						case 0x10: RPCERpcAuth3		Auth3;
						case 0x11: MSRPCRpcconnShutdownHdrT	Shutdown;
						case 0x12: MSRPCRpcconnCancelHdrT	Cancel;
						case 0x13: MSRPCRpcconnOrphanedHdrT	Orphaned;
						default: ReportParserError(ParserErrorProtocolClassWindows, "MSRPC", FormatString( "Unknown Packet Type 0x%02X", UINT8( Framedata, Offset + 2 ) ) ) MSRPCPacketError;
					}
					Switch
					{
						case FrameOffset < FrameLength:
							Struct
							{
								ReportParserWarning("MSRPC","RPC clients optionally append extra data to the end of an RPC request or response") ParserWarning;
								BLOB(FrameLength - FrameOffset) RPCAppendedExtraData;
							}
					}
				}
			}

		//
		//  validate datagram packet header
		//
		case
			UINT8( Framedata, Offset ) == 0x04 &&
			( FrameLength - Offset >= 80 ) &&
			UINT8( Framedata, Offset + 1 ) <= 10 &&
			( UINT8( Framedata, Offset + 3 ) & 0xF0 ) == 0 &&
			( UINT8( Framedata, Offset + 4 ) & 0xEE ) == 0 &&
			UINT8( Framedata, Offset + 5 ) < 4 &&
			UINT8( Framedata, Offset + 6 ) == 0 :
		
				[DataFieldByteOrder = (UINT8( Framedata, Offset + 4 ) & 0x10) ? LittleEndian : BigEndian]
				_struct Datagram
				{
					switch ( UINT8( Framedata, Offset + 1 ) )
					{
						case 0x00: MSRPCDgRequest	Request;
						case 0x01: MSRPCDgPing		Ping;
						case 0x02: MSRPCDgResponse	Response;
						case 0x04: MSRPCDgWorking	Working;
						case 0x03: MSRPCDgFault		Fault;
						case 0x05: MSRPCDgNoCall	NoCall;
						case 0x06: MSRPCDgFault		Reject;
						case 0x07: MSRPCDgAck		Ack;
						case 0x08: MSRPCDgCancel	Cancel;
						case 0x09: MSRPCDgFack		Fack;
						case 0x0A: MSRPCDgCancelAck CancelAck;
						default: 
							ReportParserError(ParserErrorProtocolClassWindows, "MSRPC", FormatString( "Unknown Packet Type 0x%02X", UINT8( Framedata, Offset + 2 ) ) ) MSRPCPacketError;
					}
				}
				
		Default:
		
			ReportParserError(ParserErrorProtocolClassWindows, "MSRPC", "Invalid RPC Header" ) MSRPCHeaderError;


	}
}
	
Protocol CONV = Property.ConvSummary
{
	Switch( Property.MSRPCPType )
		{
		Case 0x00 :
		_struct Request
		{
			Switch( Property.MSRPCOpnum )
			{
				Case 0x0000 : 
					[ConvSummary = FormatString( "ConvWhoAreYou Request, Actuid=%s", Actuid.ToString )]
					_Struct ConvWhoAreYou
					{
						MSRPCUuidT Actuid;
						UINT32 BootTime;
					}
				Case 0x0001 : 
					[ConvSummary = FormatString( "ConvWhoAreYou2 Request, Actuid=%s", Actuid.ToString )]
					_Struct ConvWhoAreYou2
					{
						MSRPCUuidT Actuid;
						UINT32 BootTime;
					}
				Case 0x0002 : 
					[ConvSummary = FormatString( "ConvAreYouThere Request, Actuid=%s", Actuid.ToString )]
					_Struct ConvAreYouThere
					{
						MSRPCUuidT actuid;
						UINT32 BootTime;
					}
				Case 0x0003 : 
					[ConvSummary = FormatString( "ConvWhoAreYouAuth Request, Actuid=%s", Actuid.ToString )]
					_Struct ConvWhoAreYouAuth
					{
						[MSRPCAuthProto = Global.MSRPCAuthProtoTable$[actuid.ToString]]
						MSRPCUuidT actuid;
						[Conversation.MSRPCAuthProtoTable$[Property.MSRPCActId] = MSRPCAuthProto]
						UINT32 BootTime;
						Struct InData
						{
							NdrConformant Size;
							Switch {
								Case AsciiString( FrameData, Offset, 7) == "Ntlmssp": 
								[Property.NLMPCurrentProtocol = "msrpc"]
									NLMP_struct NLMP;
								Default: Blob( Size.MaxCount ) blob;
							}
						}
						Align4 Pad;
						INT32 InLen;
						INT32 OutMaxLen;
					}
				Case 0x0004 : 
					[ConvSummary = FormatString( "ConvWhoAreYouAuthMore Request, Actuid=%s", Actuid.ToString )]
					_Struct ConvWhoAreYouAuthMore
					{
						MSRPCUuidT Actuid;
						UINT32 BootTime;
						INT32 Index;
						INT32 OutMaxLen;
					}
			}
		}
		Case 0x02 :
		_struct Response
		{
			Switch (Property.MSRPCOpnum )
			{
				Case 0x0000 : 
					[ConvSummary = FormatString( "ConvWhoAreYou Response" )]
					_Struct ConvWhoAreYou
					{
						UINT32 Seq;
						UINT32 St;
					}
				Case 0x0001 : 
					[ConvSummary = FormatString( "ConvWhoAreYou2 Response, CasUuid=%s", CasUuid.ToString )]
					_Struct ConvWhoAreYou2
					{
						UINT32 Seq;
						MSRPCUuidT CasUuid;
						UINT32 St;
					}
				Case 0x0002 : 
					[ConvSummary = FormatString( "ConvAreYouThere Response" )]
					_Struct ConvAreYouThere
					{
						UINT32 St;
					}
				Case 0x0003 : 
					[ConvSummary = FormatString( "ConvWhoAreYouAuth Response, CasUuid=%s", CasUuid.ToString )]
					_Struct ConvWhoAreYouAuth
					{
						[MSRPCAuthProto = Conversation.MSRPCAuthProtoTable$[Property.MSRPCActId]]
						UINT32 Seq;
						MSRPCUuidT CasUuid;
						Struct OutData
						{
							NdrConformantVarying Size;
							Switch {
								Case AsciiString( FrameData, Offset, 7) == "Ntlmssp": 
								[Property.NLMPCurrentProtocol = "msrpc"]
									NLMP_struct NLMP;
								Case MSRPCAuthProto == 0x10:
									KerberosV5_struct Kerberos;
								Default: Blob( Size.ActualCount ) blob;
							}
						}
						Align4 pad;
						INT32 OutLen;
						UINT32 St;
					}
				Case 0x0004 : 
					[ConvSummary = FormatString( "ConvWhoAreYouAuthMore Response" )]
					_Struct ConvWhoAreYouAuthMore
					{
						Struct OutData
						{
							NdrConformantVarying Size;
							Blob( Size.ActualCount ) Blob;
						}
						Align4 Pad;
						INT32 OutLen;
						UINT32 St;
					}
			}
		}
	}
}

[ MGMTSummary = "" ]
Protocol MGMT = FormatString( "%s %s: %s",
	(Property.MSRPCPType == 0x00) ? "Request:" : "Response:",
	MGMTMethodTable( Property.MSRPCOpnum ),
	MGMTSummary)
{
	Switch ( Property.MSRPCOpnum )
	{
		Case  0: // rpc__mgmt_inq_if_ids
		_struct RpcMgmtInqIfIds
		{
			Switch ( Property.MSRPCPType )
			{
				Case 0x00:
				_struct Request
				{
					switch
					{
						case Property.MSRPCAuthLevel == 6: Blob(Property.MSRPCStubDataLen) EncryptedData; 
					}
				}

				Case 0x02:
				_struct Response
				{
					switch
					{
						case Property.MSRPCAuthLevel == 6: Blob(Property.MSRPCStubDataLen) EncryptedData; 
					}
					struct MSRPCRpcIfIdVectorPT
					{
						NdrPtr Pointer;
						Switch 
						{
							Case Pointer.ReferentID > 0:
								RPCERpcIfIdVectorPT idVectorT;
						}
					}
					Align4 pad;
					UINT32	Status;
				}
			}
		}

		Case  1: // rpc__mgmt_inq_stats
			RPCERpcMgmtInqStats rpcMgmtInqStats;		
		Case  2: // rpc__mgmt_is_server_listening
		_struct RpcMgmtIsServerListening
		{
			Switch ( Property.MSRPCPType )
			{
				Case 0x00:
				_struct Request
				{
					switch
					{
						case Property.MSRPCAuthLevel == 6: Blob(Property.MSRPCStubDataLen) EncryptedData; 
					}
				}

				Case 0x02:
				_struct Response
				{
					switch
					{
						case Property.MSRPCAuthLevel == 6: Blob(Property.MSRPCStubDataLen) EncryptedData; 
					}
					UINT32	Status;
					UINT32	ReturnValue = this ? "True" : "False";
				}
			}
		}
		
		Case  3: // rpc__mgmt_stop_server_listening
		_struct RpcMgmtStopServerListening
		{
			Switch ( Property.MSRPCPType )
			{
				Case 0x00:
				_struct Request
				{
					switch
					{
						case Property.MSRPCAuthLevel == 6: Blob(Property.MSRPCStubDataLen) EncryptedData; 
					}
				}

				Case 0x02:
				_struct Response
				{
					switch
					{
						case Property.MSRPCAuthLevel == 6: Blob(Property.MSRPCStubDataLen) EncryptedData; 
					}
					UINT32	Status;
				}
			}
		}
		
		Case 4: // rpc__mgmt_inq_princ_name
			RPCERpcMgmtInqPrincName rpcMgmtInqPrincName;
	}
}

Struct MSRPCAccessRights = FormatString("0x%04X", UINT16(FrameData,FrameOffset))
{	
	Switch( Property.MSRPCByteOrder )
	{
		Case LittleEndian:
		Struct {
			UINT8 StandardRights = FormatString("0x%02X", UINT8(FrameData,FrameOffset))
			{
				UINT8 Delete:1 = FormatString("          (%s) %s",this.ToBitString,"Right to delete the object");
				UINT8 ReadWriteExecute:1 = FormatString("(%s) %s",this.ToBitString,"Right to read, write or execute the information in an object's SecurityDescriptor structure");
				UINT8 WriteDAC:1 = FormatString("        (%s) %s",this.ToBitString,"Right to change the DACL in the object's SecurityDescriptor structure");
				UINT8 WriteOwner:1 = FormatString("      (%s) %s",this.ToBitString,"Right to change the owner member in the object's SecurityDescriptor structure");
				UINT8 Synchronize:1 = FormatString("     (%s) %s",this.ToBitString,"Right to use the object for synchronization");
				UINT8 Reserved:3=FormatString("        (%s)", this.ToBitString);
			}
			UINT8 GenericRights = FormatString("0x%02X", UINT8(FrameData,FrameOffset))
			{
				UINT8 AccessSystemSecurity:1 = FormatString("(%s) %s", this.ToBitString,"Controls the ability to get or set the SACL in an object's security descriptor");
				UINT8 MaximumAllowed:1 = FormatString("      (%s) %s", this.ToBitString,"Maximum rights allowed");
				UINT8 Reserved:2 = FormatString("            (%s)", this.ToBitString);
				UINT8 GenericAll:1 = FormatString("          (%s) %s", this.ToBitString,"Right to perform all normal operations on the object");
				UINT8 GenericExecute:1 = FormatString("      (%s) %s", this.ToBitString,"Right to execute the object");
				UINT8 GenericWrite:1 = FormatString("        (%s) %s", this.ToBitString,"Right to perform normal write operations on the object");
				UINT8 GenericRead:1 = FormatString("         (%s) %s", this.ToBitString,"Right to perform normal read operations on the object");
			}
		};
		Default:
		Struct {
			UINT8 GenericRights = FormatString("0x%02X", UINT8(FrameData,FrameOffset))
			{
				UINT8 GenericRead:1 = FormatString("         (%s) %s", this.ToBitString,"Right to perform normal read operations on the object");
				UINT8 GenericWrite:1 = FormatString("        (%s) %s", this.ToBitString,"Right to perform normal write operations on the object");
				UINT8 GenericExecute:1 = FormatString("      (%s) %s", this.ToBitString,"Right to execute the object");
				UINT8 GenericAll:1 = FormatString("          (%s) %s", this.ToBitString,"Right to perform all normal operations on the object");
				UINT8 Reserved:2 = FormatString("            (%s)", this.ToBitString);
				UINT8 MaximumAllowed:1 = FormatString("      (%s) %s", this.ToBitString,"Maximum rights allowed");
				UINT8 AccessSystemSecurity:1 = FormatString("(%s) %s", this.ToBitString,"Controls the ability to get or set the SACL in an object's security descriptor");
			}
			UINT8 StandardRights = FormatString("0x%02X", UINT8(FrameData,FrameOffset))
			{
				UINT8 Reserved:3=FormatString("        (%s)", this.ToBitString);
				UINT8 Synchronize:1 = FormatString("     (%s) %s",this.ToBitString,"Right to use the object for synchronization");
				UINT8 WriteOwner:1 = FormatString("      (%s) %s",this.ToBitString,"Right to change the owner member in the object's SecurityDescriptor structure");
				UINT8 WriteDAC:1 = FormatString("        (%s) %s",this.ToBitString,"Right to change the DACL in the object's SecurityDescriptor structure");
				UINT8 ReadWriteExecute:1 = FormatString("(%s) %s",this.ToBitString,"Right to read, write or execute the information in an object's SecurityDescriptor structure");
				UINT8 Delete:1 = FormatString("          (%s) %s",this.ToBitString,"Right to delete the object");	
			}			
		};
	}
}


Struct MSRPCPUuidT = Pointer.ReferentID ? uuid.ToString : "NULL"
{
	NdrPtr Pointer;
	Switch {
		Case Pointer.ReferentID > 0: MSRPCUuidT	uuid;
	}
}

Struct MSRPCPGuid = Pointer.ReferentID ? guid.ToString : "NULL"
{
	NdrPtr Pointer;
	Switch {
		Case Pointer.ReferentID > 0: MSRPCGuid	guid;
	}
}

// Packet type name	table
TABLE MSRPCPTypeTable( value )
{
	switch (value)
	{
		case 0x00: "Request";	//CO/CL
		case 0x01: "Ping";		//CL
		case 0x02: "Response";	//CO/CL
		case 0x03: "Fault";		//CO/CL
		case 0x04: "Working";	//CL
		case 0x05: "NoCall";	//CL
		case 0x06: "Reject";	//CL 
		case 0x07: "Ack";		//CL
		case 0x08: "Cancel";	//CL
		case 0x09: "Fack";		//CL
		case 0x0A: "Cancel Ack";//CL
		case 0x0B: "Bind";		//CO
		case 0x0C: "Bind Ack";	//CO
		case 0x0D: "Bind Nack";	//CO
		case 0x0E: "Alter Context";		 //CO
		case 0x0F: "Alter Context Resp"; //CO
		case 0x10: "Auth3";		//CO
		case 0x11: "Shutdown";	//CO
		case 0x12: "Cancel";	//CO
		case 0x13: "Orphaned";	//CO
		default: "unknown";
	}
}

TABLE MSRPCRejectStatusCodes (value)
{
	switch (value)
	{
		case 0x1c000008: "nca_rpc_version_mismatch - The server	does not support the RPC protocol version specified	in the request PDU.";	//CO/CL
		case 0x1c000009: "nca_unspec_reject - The request is being rejected for unspecified reasons.";							//CO,CL
		case 0x1c00000A: "nca_s_bad_actid - The server has no state corresponding to the activity identifier in the message.";	//CL
		case 0x1c00000b: "nca_who_are_you_failed - The Conversation Manager callback failed.";	//CL
		case 0x1c00000c: "nca_manager_not_entered - The server manager routine has not been entered and executed.";				//CO,CL
		case 0x1c010002: "nca_op_rng_error - The operation number passed in the request PDU is greater than or equal to the number of operations in the interface."; //CO,CL
		case 0x1c010003: "nca_unk_if - The server does not export the requested interface.";	//CO,CL
		case 0x1c010006: "nca_wrong_boot_time - The server boot time passed in the request PDU does not match the actual server boot time.";	//CL
		case 0x1c010009: "nca_s_you_crashed - A restarted server called back a client.";		//CL
		case 0x1c01000b: "nca_proto_error - The RPC client or server protocol has been violated.";								//CO/CL
		case 0x1c010013: "nca_out_args_too_big - The output parameters of the operation exceed their declared maximum size.";	//CO,CL
		case 0x1c010014: "nca_server_too_busy - The server is too busy to handle the call.";	//CO,CL
		case 0x1c010017: "nca_unsupported_type - The server does not implement the requested operation for the type of the requested object.";	//CO,CL
		case 0x1c00001c: "nca_invalid_pres_context_id - Invalid presentation context ID.";		//CO
		case 0x1c00001d: "nca_unsupported_authn_level - The server did not support the requested authentication level.";		//CO,CL
		case 0x1c00001f: "nca_invalid_checksum - Invalid checksum.";							//CO,CL
		case 0x1c000020: "nca_invalid_crc - Invalid CRC.";										//CO,CL
		case 0x1C000024: "nca_s_fault_object_not_found";
		case 0x1C00000D: "nca_s_fault_cancel";
		case 0x1C000002: "nca_s_fault_addr_error";
		case 0x1C00001A: "nca_s_fault_context_mismatch";
		case 0x1C000003: "nca_s_fault_fp_div_zero";
		case 0x1C00000F: "nca_s_fault_fp_error";
		case 0x1C000005: "nca_s_fault_fp_overflow";
		case 0x1C000004: "nca_s_fault_fp_underflow";
		case 0x1C00000E: "nca_s_fault_ill_inst";
		case 0x1C000001: "nca_s_fault_int_div_by_zero";
		case 0x1C000010: "nca_s_fault_int_overflow";
		case 0x1C000007: "nca_s_fault_invalid_bound";
		case 0x1C000006: "nca_s_fault_invalid_tag";
		case 0x1C000015: "nca_s_fault_pipe_closed";
		case 0x1C000018: "nca_s_fault_pipe_comm_error";
		case 0x1C000017: "nca_s_fault_pipe_discipline";
		case 0x1C000014: "nca_s_fault_pipe_empty";
		case 0x1C000019: "nca_s_fault_pipe_memory";
		case 0x1C000016: "nca_s_fault_pipe_order";
		case 0x1C00001B: "nca_s_fault_remote_no_memory";
		case 0x1C000021: "ncs_s_fault_user_defined";
		case 0x1C000022: "nca_s_fault_tx_open_failed";
		case 0x1C000023: "nca_s_fault_codeset_conv_error";
		case 0x1C000025: "nca_s_fault_no_client_stub";
		default: "unknown";
	}
}

TABLE MSRPCAuthenticationProtocolIdentifiers( value )
{
	switch( value )
	{
		case 0:	"None";
		case 1:	"OSF DCE Private Key Authentication";
		case 0x0A: "RPC_C_AUTHN_WINNT - NTLM authentication will be used.";
		case 0x10: "RPC_C_AUTHN_GSS_KERBEROS - Kerberos authentication will be used.";
		default: "unknown";
	}
}

TABLE MSRPCFloatingPointRepresentation( value )
{
	switch( value )
	{
		case 0:	"IEEE";
		case 1:	"VAX";
		case 2:	"Cray";
		case 3:	"IBM";
		default: "unknown";
	}
}

struct MSRPCUuidT = FormatString( "{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}", 
	TimeLow, TimeMid, TimeHiAndVersion, ClockSeqHiAndReserved, ClockSeqLow, 
	UINT8( Framedata, Offset + 10 ), UINT8( Framedata, Offset + 11 ), UINT8( Framedata, Offset + 12 ), 
	UINT8( Framedata, Offset + 13 ), UINT8( Framedata, Offset + 14 ), UINT8( Framedata, Offset + 15 ))
{
	UINT32 TimeLow = FormatString("0x%08X", this);
	UINT16 TimeMid = FormatString("0x%04X", this);
	UINT16 TimeHiAndVersion = FormatString("0x%04X", this);
	UINT8  ClockSeqHiAndReserved = FormatString("0x%02X", this);
	UINT8  ClockSeqLow = FormatString("0x%02X", this);
	UINT8  Node[6] = FormatString("0x%02X", this);
}

struct MSRPCGuid = FormatString( "{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}", 
	Data1, Data2, Data3, UINT8( Framedata, Offset + 8 ), UINT8( Framedata, Offset + 9 ),
	UINT8( Framedata, Offset + 10 ), UINT8( Framedata, Offset + 11 ), UINT8( Framedata, Offset + 12 ), 
	UINT8( Framedata, Offset + 13 ), UINT8( Framedata, Offset + 14 ), UINT8( Framedata, Offset + 15 ))
{
	UINT32 Data1 = FormatString("0x%08X", this);
	UINT16 Data2 = FormatString("0x%04X", this);
	UINT16 Data3 = FormatString("0x%04X", this);
	UINT8  Data4[8] = FormatString("0x%02X", this);
}

struct MSRPCPSyntaxIdT = Property.MSRPCPSyntaxIdTSummary
{
	switch
	{
		case FormatString( "%08X-%04X-%04X", UINT32(FrameData, offset), UINT16(FrameData, offset+4), UINT16(FrameData, offset+6)) == "6CB71C2C-9812-4540":
			RPCEBTFNUuid BTFNUuid;
		default: 
			// Save server confirmed TransferSyntax 
			[Conversation.MSRPNDR64Table$[Conversation.PContIdTable$[MakeByteArray(Property.MsrpcElemcount,MSRPCCallId)]] = (IfUuid.ToString == "{71710533-BEBA-4937-8319-B5DBEF9CCC36}")]
			[Post.Property.MSRPCPSyntaxIdTSummary = IfUuid.ToString + " " + UUIDTable( IfUuid.ToString )]
			MSRPCUuidT	IfUuid;
	}
	[MSRPCIfVers]
	UINT32	IfVersion;
}

struct MSRPCPContElemT
{
	[Conversation.PContIdTable$[MakeByteArray(Property.MsrpcElemcount,MSRPCCallId)]]
	UINT16	PContId;
	UINT8	NTransferSyn;
	UINT8	Reserved;
	[
		post.Conversation.MSRPCUUIDTable$[PContId] = AbstractSyntax.IfUuid.ToString,
		post.Conversation.MSRPCIfVersTable$[PContId] = MSRPCIfVers
	]
	MSRPCPSyntaxIdT	AbstractSyntax;
	switch
	{
		case NTransferSyn > 0:
		// Try to bind the frist TransferSyntax before server confirm 
		[Conversation.MSRPNDR64Table$[PContId] = TransferSyntaxes[0].IfUuid.ToString == "{71710533-BEBA-4937-8319-B5DBEF9CCC36}"]
		MSRPCPSyntaxIdT	TransferSyntaxes[NTransferSyn];
		default:
		[Conversation.MSRPNDR64Table$[PContId] = false]
		struct{};
	}
}

struct MSRPCPContListT
{
	UINT8	NContextElem;
	UINT8	Reserved;
	UINT16	Reserved2;
	[MSRPCIfUuid = FormatString(
	"{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}", 
	UINT32(FrameData, offset+4), UINT16(FrameData, offset+8), 
	UINT16(FrameData, offset+10), UINT8( Framedata, Offset + 12 ), UINT8( Framedata, Offset + 13 ), 
	UINT8( Framedata, Offset + 14 ), UINT8( Framedata, Offset + 15 ), UINT8( Framedata, Offset + 16 ), 
	UINT8( Framedata, Offset + 17 ), UINT8( Framedata, Offset + 18 ), UINT8( Framedata, Offset + 19 ))]
	[property.MSRPCInterfaceName = UUIDTable( property.MSRPCIfUuid )]
	[Property.MsrpcElemcount = 0]
	while[Property.MsrpcElemcount < NContextElem]
	{
		[Post.Property.MsrpcElemcount = Property.MsrpcElemcount + 1]
		MSRPCPContElemT PContElem;
	}
}

struct MSRPCPortAnyT = PortSpec
{
	UINT16	Length;
	AsciiString(length)	PortSpec;
}

struct MSRPCPResultListT
{
	UINT8	NResults;
	UINT8	Reserved;
	UINT16	Reserved2;
	[Property.MsrpcElemcount = 0]
	while[Property.MsrpcElemcount < NResults]
	{
		[Post.Property.MsrpcElemcount = Property.MsrpcElemcount + 1]
		MSRPCPResultT PResults;
	}
}

TABLE MSRPCPContDefResultTable( value )
{
	switch( value )
	{
		case 0x00: "Acceptance";
		case 0x01: "User rejection";
		case 0x02: "Provider rejection";
		case 0x03: "Negotiate Ack";
		default:   "Unknown";
	}
}

TABLE MSRPCPProviderReasonTable( value )
{
	switch( value )
	{
		case 0x00: "Reason not specified";
		case 0x01: "Abstract syntax	not	supported";
		case 0x02: "Proposed transfer syntaxes not supported";
		case 0x03: "Local limit	exceeded";
		default:   "Unknown";
	}
}

struct MSRPCPResultT = FormatString( "%s, %s", Result.ToString, 
	bitmask ? bitmask.ToString : "Reason=" + Reason.ToString )
{
	UINT16	Result = MSRPCPContDefResultTable( this );
	switch {
		case Result != 0x03: UINT16	Reason = Result == 0 ? "n/a" : MSRPCPProviderReasonTable(this);
		default:
			RPCEBindTimeFeatureNegotiationResponseBitmask bitmask;
	}

	MSRPCPSyntaxIdT TransferSyntax;
}

TABLE MSRPCPRejectReasonTable( value )
{
	switch( value )
	{
		case 0x00: "REASON_NOT_SPECIFIED";
		case 0x01: "TEMPORARY_CONGESTION";
		case 0x02: "LOCAL_LIMIT_EXCEEDED";
		case 0x03: "CALLED_PADDR_UNKNOWN";			// not used
		case 0x04: "PROTOCOL_VERSION_NOT_SUPPORTED";
		case 0x05: "DEFAULT_CONTEXT_NOT_SUPPORTED";	// not used
		case 0x06: "USER_DATA_NOT_READABLE";		// not used
		case 0x07: "NO_PSAP_AVAILABLE";				// not used
		case 0x08: "authentication_type_not_recognized";
		case 0x09: "invalid_checksum";
		default:   "unknown";
	}
}

struct MSRPCPackedDrep = UINT32( FrameData, Offset )
{
	[MSRPCPackedDrep, MSRPCByteOrder = (this & 0x10) ? LittleEndian : BigEndian]
	UINT8 Octet0 =	FormatString("0x%02X - %s Integer, %s Character representation", this, 
									(this & 0x10) ? "Little-endian" : "Big-endian", 
									(this & 0x01) ? "EBCDIC" : "ASCII");
	[MSRPCFloatType = this]
	UINT8 Octet1 =	FormatString("0x%02X - ", this)
									+ MSRPCFloatingPointRepresentation( this ) + " Floating Point representation";
	UINT8 Octet2 =	FormatString("0x%02X - Reserved", this);
	UINT8 Octet3 =	FormatString("0x%02X - Reserved", this);
}

struct MSRPCRpcconnBindHdrT = property.MSRPCIfUuid + " " + property.MSRPCInterfaceName //Bind
{
	[Conversation.MSRPCServerAddress = (isvaluenone(Property.DestinationNetworkAddress) ? Property.DstIPXAddress : Property.DestinationNetworkAddress)]

	/* common fields */

	UINT8 RpcVers;
	UINT8 RpcVersMinor;
	[MSRPCPType]
	UINT8 PType = FormatString("0x%02X - %s", this, MSRPCPTypeTable(this));
	[MSRPCPfcFlags, MSRPCByteOrder = (UINT8( Framedata, Offset + 1 ) & 0x10) ? LittleEndian : BigEndian]
	UINT8 PfcFlags
	{
		Switch( Property.MSRPCByteOrder )
		{
			Case LittleEndian:
			Struct {
				[MSRPCFirstFrag]
				UINT8 Bit0:1 = this.ToBitString + " PFC_FIRST_FRAG - " + ( this ? "SET, Is first fragment" : "NOT set, Is NOT first fragment" );
				[MSRPCLastFrag]
				UINT8 Bit1:1 = this.ToBitString + " PFC_LAST_FRAG - " + ( this ? "SET, Is last fragment" : "NOT set,  SET, Is NOT last fragment" );
				UINT8 Bit2:1 = this.ToBitString + ((PType == 0x0B || PType == 0x0C || PType == 0x0E || PType == 0x0F) ? (" PFC_SUPPORT_HEADER_SIGN - " + ( this ? "SET, Header Sign was supported at sender" : "NOT set, Header Sign was NOT supported at sender" )) : (" PFC_PENDING_CANCEL - " + ( this ? "SET, Cancel was pending at sender" : "NOT set, Cancel was NOT pending at sender" )));
				UINT8 Bit3:1 = this.ToBitString + " PFC_RESERVED_1 - reserved";
				UINT8 Bit4:1 = this.ToBitString + " PFC_CONC_MPX - " + ( this ? "SET, Supports concurrent multiplexing of a single connection." : "NOT set, Does NOT support concurrent multiplexing of a single connection." );
				UINT8 Bit5:1 = this.ToBitString + " PFC_DID_NOT_EXECUTE - " + ( Property.MSRPCPType != 0x03 ? "N/A;" : ( this ? "SET, Guaranteed call was executed." : "NOT set, Guaranteed call was NOT executed." ) ) + " Only meaningful on `fault' packet.";
				UINT8 Bit6:1 = this.ToBitString + " PFC_MAYBE - " + ( this ? "SET, `maybe' call semantics requested" : "NOT set, `maybe' call semantics NOT requested" );
				[MSRPCObjUuid]
				UINT8 Bit7:1 = this.ToBitString + " PFC_OBJECT_UUID - " + ( this ? "SET, A non-nil object UUID was specified in the handle, and is present in the optional object field." : "NOT set, The object field is omitted." );
			}
			Case BigEndian:
			Struct {
				[MSRPCObjUuid]
				UINT8 Bit7:1 = this.ToBitString + " PFC_OBJECT_UUID - " + ( this ? "SET, A non-nil object UUID was specified in the handle, and is present in the optional object field." : "NOT set, The object field is omitted." );
				UINT8 Bit6:1 = this.ToBitString + " PFC_MAYBE - " + ( this ? "SET, `maybe' call semantics requested" : "NOT set, `maybe' call semantics NOT requested" );
				UINT8 Bit5:1 = this.ToBitString + " PFC_DID_NOT_EXECUTE - " + ( Property.MSRPCPType != 0x03 ? "N/A;" : ( this ? "SET, Guaranteed call was executed." : "NOT set, Guaranteed call was NOT executed." ) ) + " Only meaningful on `fault' packet.";
				UINT8 Bit4:1 = this.ToBitString + " PFC_CONC_MPX - " + ( this ? "SET, Supports concurrent multiplexing of a single connection." : "NOT set, Does NOT support concurrent multiplexing of a single connection." );
				UINT8 Bit3:1 = this.ToBitString + " PFC_RESERVED_1 - reserved";
				UINT8 Bit2:1 = this.ToBitString + ((PType == 0x0B || PType == 0x0C || PType == 0x0E || PType == 0x0F) ? (" PFC_SUPPORT_HEADER_SIGN - " + ( this ? "SET, Header Sign was supported at sender" : "NOT set, Header Sign was NOT supported at sender" )) : (" PFC_PENDING_CANCEL - " + ( this ? "SET, Cancel was pending at sender" : "NOT set, Cancel was NOT pending at sender" )));
				[MSRPCLastFrag]
				UINT8 Bit1:1 = this.ToBitString + " PFC_LAST_FRAG - " + ( this ? "SET, Is last fragment" : "NOT set,  SET, Is NOT last fragment" );
				[MSRPCFirstFrag]
				UINT8 Bit0:1 = this.ToBitString + " PFC_FIRST_FRAG - " + ( this ? "SET, Is first fragment" : "NOT set, Is NOT first fragment" );
			}
		}
	}
	MSRPCPackedDrep	PackedDrep;
	[MSRPCFragLength]
	UINT16	FragLength;
	UINT16	AuthLength;
	[MSRPCCallId]
	UINT32	CallId;

	/* end common fields */

	UINT16	 MaxXmitFrag;
	UINT16	 MaxRecvFrag;
	UINT32	 AssocGroupId;
	
	MSRPCPContListT  PContextElem;

	[MSRPCSummary = FormatString( "c/o Bind: %s UUID%s  Call=0x%X  Assoc Grp=0x%X  Xmit=0x%X  Recv=0x%X", 
	property.MSRPCInterfaceName, property.MSRPCIfUuid, CallId, AssocGroupId, MaxXmitFrag, MaxRecvFrag )]
	
	MSRPCAuthVerifierCoT( PType, AuthLength ) AuthVerifier;//[MS-RPCE]: 2.2.2.11   sec_trailer Structure
}

struct MSRPCRpcconnBindAckHdrT //Bind Ack
{
	/* common fields */

	UINT8 RpcVers;
	UINT8 RpcVersMinor;
	[MSRPCPType]
	UINT8 PType = FormatString("0x%02X - %s", this, MSRPCPTypeTable(this));
	[MSRPCPfcFlags, MSRPCByteOrder = (UINT8( Framedata, Offset + 1 ) & 0x10) ? LittleEndian : BigEndian]
	UINT8 PfcFlags
	{
		Switch( Property.MSRPCByteOrder )
		{
			Case LittleEndian:
			Struct {
				[MSRPCFirstFrag]
				UINT8 Bit0:1 = this.ToBitString + " PFC_FIRST_FRAG - " + ( this ? "SET, Is first fragment" : "NOT set, Is NOT first fragment" );
				[MSRPCLastFrag]
				UINT8 Bit1:1 = this.ToBitString + " PFC_LAST_FRAG - " + ( this ? "SET, Is last fragment" : "NOT set,  SET, Is NOT last fragment" );
				UINT8 Bit2:1 = this.ToBitString + ((PType == 0x0B || PType == 0x0C || PType == 0x0E || PType == 0x0F) ? (" PFC_SUPPORT_HEADER_SIGN - " + ( this ? "SET, Header Sign was supported at sender" : "NOT set, Header Sign was NOT supported at sender" )) : (" PFC_PENDING_CANCEL - " + ( this ? "SET, Cancel was pending at sender" : "NOT set, Cancel was NOT pending at sender" )));
				UINT8 Bit3:1 = this.ToBitString + " PFC_RESERVED_1 - reserved";
				UINT8 Bit4:1 = this.ToBitString + " PFC_CONC_MPX - " + ( this ? "SET, Supports concurrent multiplexing of a single connection." : "NOT set, Does NOT support concurrent multiplexing of a single connection." );
				UINT8 Bit5:1 = this.ToBitString + " PFC_DID_NOT_EXECUTE - " + ( Property.MSRPCPType != 0x03 ? "N/A;" : ( this ? "SET, Guaranteed call was executed." : "NOT set, Guaranteed call was NOT executed." ) ) + " Only meaningful on `fault' packet.";
				UINT8 Bit6:1 = this.ToBitString + " PFC_MAYBE - " + ( this ? "SET, `maybe' call semantics requested" : "NOT set, `maybe' call semantics NOT requested" );
				[MSRPCObjUuid]
				UINT8 Bit7:1 = this.ToBitString + " PFC_OBJECT_UUID - " + ( this ? "SET, A non-nil object UUID was specified in the handle, and is present in the optional object field." : "NOT set, The object field is omitted." );
			}
			Case BigEndian:
			Struct {
				[MSRPCObjUuid]
				UINT8 Bit7:1 = this.ToBitString + " PFC_OBJECT_UUID - " + ( this ? "SET, A non-nil object UUID was specified in the handle, and is present in the optional object field." : "NOT set, The object field is omitted." );
				UINT8 Bit6:1 = this.ToBitString + " PFC_MAYBE - " + ( this ? "SET, `maybe' call semantics requested" : "NOT set, `maybe' call semantics NOT requested" );
				UINT8 Bit5:1 = this.ToBitString + " PFC_DID_NOT_EXECUTE - " + ( Property.MSRPCPType != 0x03 ? "N/A;" : ( this ? "SET, Guaranteed call was executed." : "NOT set, Guaranteed call was NOT executed." ) ) + " Only meaningful on `fault' packet.";
				UINT8 Bit4:1 = this.ToBitString + " PFC_CONC_MPX - " + ( this ? "SET, Supports concurrent multiplexing of a single connection." : "NOT set, Does NOT support concurrent multiplexing of a single connection." );
				UINT8 Bit3:1 = this.ToBitString + " PFC_RESERVED_1 - reserved";
				UINT8 Bit2:1 = this.ToBitString + ((PType == 0x0B || PType == 0x0C || PType == 0x0E || PType == 0x0F) ? (" PFC_SUPPORT_HEADER_SIGN - " + ( this ? "SET, Header Sign was supported at sender" : "NOT set, Header Sign was NOT supported at sender" )) : (" PFC_PENDING_CANCEL - " + ( this ? "SET, Cancel was pending at sender" : "NOT set, Cancel was NOT pending at sender" )));
				[MSRPCLastFrag]
				UINT8 Bit1:1 = this.ToBitString + " PFC_LAST_FRAG - " + ( this ? "SET, Is last fragment" : "NOT set,  SET, Is NOT last fragment" );
				[MSRPCFirstFrag]
				UINT8 Bit0:1 = this.ToBitString + " PFC_FIRST_FRAG - " + ( this ? "SET, Is first fragment" : "NOT set, Is NOT first fragment" );
			}
		}
	}
	MSRPCPackedDrep	PackedDrep;
	[MSRPCFragLength]
	UINT16	FragLength;
	UINT16	AuthLength;
	[MSRPCCallId]
	UINT32	CallId;

	/* end common fields */

	UINT16	MaxXmitFrag;
	UINT16	MaxRecvFrag;
	UINT32	AssocGroupId;
	MSRPCPortAnyT SecAddr;

	[MSRPCSummary = FormatString( "c/o Bind Ack:  Call=0x%X  Assoc Grp=0x%X  Xmit=0x%X  Recv=0x%X", 
	CallId, AssocGroupId, MaxXmitFrag, MaxRecvFrag )]

	struct Pad2
	{
		UINT8 Pad[CurrentProtocolOffset % 4 ? 4 - CurrentProtocolOffset % 4 : 0];
	}

	MSRPCPResultListT	PResultList;
	
	MSRPCAuthVerifierCoT( PType, AuthLength ) AuthVerifier;//[MS-RPCE]: 2.2.2.11   sec_trailer Structure
}

struct MSRPCRpcconnAlterContextHdrT //Alter Context
{
	[Conversation.MSRPCServerAddress = (IsValueNone(Property.DestinationNetworkAddress) ? Property.DstIPXAddress : Property.DestinationNetworkAddress)]
	/* common fields */
	UINT8 RpcVers;
	UINT8 RpcVersMinor;
	[MSRPCPType]
	UINT8 PType = FormatString("0x%02X - %s", this, MSRPCPTypeTable(this));
	[MSRPCPfcFlags, MSRPCByteOrder = (UINT8( Framedata, Offset + 1 ) & 0x10) ? LittleEndian : BigEndian]
	UINT8 PfcFlags
	{
		Switch( Property.MSRPCByteOrder )
		{
			Case LittleEndian:
			Struct {
				[MSRPCFirstFrag]
				UINT8 Bit0:1 = this.ToBitString + " PFC_FIRST_FRAG - " + ( this ? "SET, Is first fragment" : "NOT set, Is NOT first fragment" );
				[MSRPCLastFrag]
				UINT8 Bit1:1 = this.ToBitString + " PFC_LAST_FRAG - " + ( this ? "SET, Is last fragment" : "NOT set,  SET, Is NOT last fragment" );
				UINT8 Bit2:1 = this.ToBitString + ((PType == 0x0B || PType == 0x0C || PType == 0x0E || PType == 0x0F) ? (" PFC_SUPPORT_HEADER_SIGN - " + ( this ? "SET, Header Sign was supported at sender" : "NOT set, Header Sign was NOT supported at sender" )) : (" PFC_PENDING_CANCEL - " + ( this ? "SET, Cancel was pending at sender" : "NOT set, Cancel was NOT pending at sender" )));
				UINT8 Bit3:1 = this.ToBitString + " PFC_RESERVED_1 - reserved";
				UINT8 Bit4:1 = this.ToBitString + " PFC_CONC_MPX - " + ( this ? "SET, Supports concurrent multiplexing of a single connection." : "NOT set, Does NOT support concurrent multiplexing of a single connection." );
				UINT8 Bit5:1 = this.ToBitString + " PFC_DID_NOT_EXECUTE - " + ( Property.MSRPCPType != 0x03 ? "N/A;" : ( this ? "SET, Guaranteed call was executed." : "NOT set, Guaranteed call was NOT executed." ) ) + " Only meaningful on `fault' packet.";
				UINT8 Bit6:1 = this.ToBitString + " PFC_MAYBE - " + ( this ? "SET, `maybe' call semantics requested" : "NOT set, `maybe' call semantics NOT requested" );
				[MSRPCObjUuid]
				UINT8 Bit7:1 = this.ToBitString + " PFC_OBJECT_UUID - " + ( this ? "SET, A non-nil object UUID was specified in the handle, and is present in the optional object field." : "NOT set, The object field is omitted." );
			}
			Case BigEndian:
			Struct {
				[MSRPCObjUuid]
				UINT8 Bit7:1 = this.ToBitString + " PFC_OBJECT_UUID - " + ( this ? "SET, A non-nil object UUID was specified in the handle, and is present in the optional object field." : "NOT set, The object field is omitted." );
				UINT8 Bit6:1 = this.ToBitString + " PFC_MAYBE - " + ( this ? "SET, `maybe' call semantics requested" : "NOT set, `maybe' call semantics NOT requested" );
				UINT8 Bit5:1 = this.ToBitString + " PFC_DID_NOT_EXECUTE - " + ( Property.MSRPCPType != 0x03 ? "N/A;" : ( this ? "SET, Guaranteed call was executed." : "NOT set, Guaranteed call was NOT executed." ) ) + " Only meaningful on `fault' packet.";
				UINT8 Bit4:1 = this.ToBitString + " PFC_CONC_MPX - " + ( this ? "SET, Supports concurrent multiplexing of a single connection." : "NOT set, Does NOT support concurrent multiplexing of a single connection." );
				UINT8 Bit3:1 = this.ToBitString + " PFC_RESERVED_1 - reserved";
				UINT8 Bit2:1 = this.ToBitString + ((PType == 0x0B || PType == 0x0C || PType == 0x0E || PType == 0x0F) ? (" PFC_SUPPORT_HEADER_SIGN - " + ( this ? "SET, Header Sign was supported at sender" : "NOT set, Header Sign was NOT supported at sender" )) : (" PFC_PENDING_CANCEL - " + ( this ? "SET, Cancel was pending at sender" : "NOT set, Cancel was NOT pending at sender" )));
				[MSRPCLastFrag]
				UINT8 Bit1:1 = this.ToBitString + " PFC_LAST_FRAG - " + ( this ? "SET, Is last fragment" : "NOT set,  SET, Is NOT last fragment" );
				[MSRPCFirstFrag]
				UINT8 Bit0:1 = this.ToBitString + " PFC_FIRST_FRAG - " + ( this ? "SET, Is first fragment" : "NOT set, Is NOT first fragment" );
			}
		}
	}
	MSRPCPackedDrep	PackedDrep;
	[MSRPCFragLength]
	UINT16	FragLength;
	UINT16	AuthLength;
	[MSRPCCallId]
	UINT32	CallId;

	/* end common fields */

	UINT16	 MaxXmitFrag = "ignored";
	UINT16	 MaxRecvFrag = "ignored";
	UINT32	 AssocGroupId = "ignored";
	
	MSRPCPContListT  PContextElem;

	[MSRPCSummary = FormatString( "c/o Alter Cont: %s  UUID%s  Call=0x%X", 
	 property.MSRPCInterfaceName, property.MSRPCIfUuid, CallId )]

	MSRPCAuthVerifierCoT( PType, AuthLength ) AuthVerifier;//[MS-RPCE]: 2.2.2.11   sec_trailer Structure
}

struct MSRPCRpcconnAlterContextResponseHdrT	//Alter	Context	Resp
{
	/* common fields */
	UINT8 RpcVers;
	UINT8 RpcVersMinor;
	[MSRPCPType]
	UINT8 PType = FormatString("0x%02X - %s", this, MSRPCPTypeTable(this));
	[MSRPCPfcFlags, MSRPCByteOrder = (UINT8( Framedata, Offset + 1 ) & 0x10) ? LittleEndian : BigEndian]
	UINT8 PfcFlags
	{
		Switch( Property.MSRPCByteOrder )
		{
			Case LittleEndian:
			Struct {
				[MSRPCFirstFrag]
				UINT8 Bit0:1 = this.ToBitString + " PFC_FIRST_FRAG - " + ( this ? "SET, Is first fragment" : "NOT set, Is NOT first fragment" );
				[MSRPCLastFrag]
				UINT8 Bit1:1 = this.ToBitString + " PFC_LAST_FRAG - " + ( this ? "SET, Is last fragment" : "NOT set,  SET, Is NOT last fragment" );
				UINT8 Bit2:1 = this.ToBitString + ((PType == 0x0B || PType == 0x0C || PType == 0x0E || PType == 0x0F) ? (" PFC_SUPPORT_HEADER_SIGN - " + ( this ? "SET, Header Sign was supported at sender" : "NOT set, Header Sign was NOT supported at sender" )) : (" PFC_PENDING_CANCEL - " + ( this ? "SET, Cancel was pending at sender" : "NOT set, Cancel was NOT pending at sender" )));
				UINT8 Bit3:1 = this.ToBitString + " PFC_RESERVED_1 - reserved";
				UINT8 Bit4:1 = this.ToBitString + " PFC_CONC_MPX - " + ( this ? "SET, Supports concurrent multiplexing of a single connection." : "NOT set, Does NOT support concurrent multiplexing of a single connection." );
				UINT8 Bit5:1 = this.ToBitString + " PFC_DID_NOT_EXECUTE - " + ( Property.MSRPCPType != 0x03 ? "N/A;" : ( this ? "SET, Guaranteed call was executed." : "NOT set, Guaranteed call was NOT executed." ) ) + " Only meaningful on `fault' packet.";
				UINT8 Bit6:1 = this.ToBitString + " PFC_MAYBE - " + ( this ? "SET, `maybe' call semantics requested" : "NOT set, `maybe' call semantics NOT requested" );
				[MSRPCObjUuid]
				UINT8 Bit7:1 = this.ToBitString + " PFC_OBJECT_UUID - " + ( this ? "SET, A non-nil object UUID was specified in the handle, and is present in the optional object field." : "NOT set, The object field is omitted." );
			}
			Case BigEndian:
			Struct {
				[MSRPCObjUuid]
				UINT8 Bit7:1 = this.ToBitString + " PFC_OBJECT_UUID - " + ( this ? "SET, A non-nil object UUID was specified in the handle, and is present in the optional object field." : "NOT set, The object field is omitted." );
				UINT8 Bit6:1 = this.ToBitString + " PFC_MAYBE - " + ( this ? "SET, `maybe' call semantics requested" : "NOT set, `maybe' call semantics NOT requested" );
				UINT8 Bit5:1 = this.ToBitString + " PFC_DID_NOT_EXECUTE - " + ( Property.MSRPCPType != 0x03 ? "N/A;" : ( this ? "SET, Guaranteed call was executed." : "NOT set, Guaranteed call was NOT executed." ) ) + " Only meaningful on `fault' packet.";
				UINT8 Bit4:1 = this.ToBitString + " PFC_CONC_MPX - " + ( this ? "SET, Supports concurrent multiplexing of a single connection." : "NOT set, Does NOT support concurrent multiplexing of a single connection." );
				UINT8 Bit3:1 = this.ToBitString + " PFC_RESERVED_1 - reserved";
				UINT8 Bit2:1 = this.ToBitString + ((PType == 0x0B || PType == 0x0C || PType == 0x0E || PType == 0x0F) ? (" PFC_SUPPORT_HEADER_SIGN - " + ( this ? "SET, Header Sign was supported at sender" : "NOT set, Header Sign was NOT supported at sender" )) : (" PFC_PENDING_CANCEL - " + ( this ? "SET, Cancel was pending at sender" : "NOT set, Cancel was NOT pending at sender" )));
				[MSRPCLastFrag]
				UINT8 Bit1:1 = this.ToBitString + " PFC_LAST_FRAG - " + ( this ? "SET, Is last fragment" : "NOT set,  SET, Is NOT last fragment" );
				[MSRPCFirstFrag]
				UINT8 Bit0:1 = this.ToBitString + " PFC_FIRST_FRAG - " + ( this ? "SET, Is first fragment" : "NOT set, Is NOT first fragment" );
			}
		}
	}
	MSRPCPackedDrep	PackedDrep;
	[MSRPCFragLength]
	UINT16	FragLength;
	UINT16	AuthLength;
	[MSRPCCallId]
	UINT32	CallId;

	/* end common fields */

	UINT16	MaxXmitFrag = "ignored";
	UINT16	MaxRecvFrag = "ignored";
	UINT32	AssocGroupId = "ignored";
	MSRPCPortAnyT SecAddr;

	[MSRPCSummary = FormatString( "c/o Alter Cont Resp:  Call=0x%X  Assoc Grp=0x%X  Xmit=0x%X  Recv=0x%X", 
	CallId, AssocGroupId, MaxXmitFrag, MaxRecvFrag )]

	struct Pad2
	{
		UINT8 Pad[CurrentProtocolOffset % 4 ? 4 - CurrentProtocolOffset % 4 : 0];
	}

	MSRPCPResultListT	PResultList;
	
	MSRPCAuthVerifierCoT( PType, AuthLength ) AuthVerifier;//[MS-RPCE]: 2.2.2.11   sec_trailer Structure
}

struct MSRPCRpcconnRequestHdrT //Request
{

	[MSRPCFromServer = IsValueNone(Conversation.MSRPCServerAddress) ? False : Conversation.MSRPCServerAddress == (IsValueNone(Property.SourceNetworkAddress) ? Property.SrcIPXAddress : Property.SourceNetworkAddress)]

	/* common fields */

	UINT8 RpcVers;
	UINT8 RpcVersMinor;
	[MSRPCPType]
	UINT8 PType = FormatString("0x%02X - %s", this, MSRPCPTypeTable(this));
	[MSRPCPfcFlags, MSRPCByteOrder = (UINT8( Framedata, Offset + 1 ) & 0x10) ? LittleEndian : BigEndian]
	UINT8 PfcFlags
	{
		Switch( Property.MSRPCByteOrder )
		{
			Case LittleEndian:
			Struct {
				[MSRPCFirstFrag]
				UINT8 Bit0:1 = this.ToBitString + " PFC_FIRST_FRAG - " + ( this ? "SET, Is first fragment" : "NOT set, Is NOT first fragment" );
				[MSRPCLastFrag]
				UINT8 Bit1:1 = this.ToBitString + " PFC_LAST_FRAG - " + ( this ? "SET, Is last fragment" : "NOT set,  SET, Is NOT last fragment" );
				UINT8 Bit2:1 = this.ToBitString + ((PType == 0x0B || PType == 0x0C || PType == 0x0E || PType == 0x0F) ? (" PFC_SUPPORT_HEADER_SIGN - " + ( this ? "SET, Header Sign was supported at sender" : "NOT set, Header Sign was NOT supported at sender" )) : (" PFC_PENDING_CANCEL - " + ( this ? "SET, Cancel was pending at sender" : "NOT set, Cancel was NOT pending at sender" )));
				UINT8 Bit3:1 = this.ToBitString + " PFC_RESERVED_1 - reserved";
				UINT8 Bit4:1 = this.ToBitString + " PFC_CONC_MPX - " + ( this ? "SET, Supports concurrent multiplexing of a single connection." : "NOT set, Does NOT support concurrent multiplexing of a single connection." );
				UINT8 Bit5:1 = this.ToBitString + " PFC_DID_NOT_EXECUTE - " + ( Property.MSRPCPType != 0x03 ? "N/A;" : ( this ? "SET, Guaranteed call was executed." : "NOT set, Guaranteed call was NOT executed." ) ) + " Only meaningful on `fault' packet.";
				UINT8 Bit6:1 = this.ToBitString + " PFC_MAYBE - " + ( this ? "SET, `maybe' call semantics requested" : "NOT set, `maybe' call semantics NOT requested" );
				[MSRPCObjUuid]
				UINT8 Bit7:1 = this.ToBitString + " PFC_OBJECT_UUID - " + ( this ? "SET, A non-nil object UUID was specified in the handle, and is present in the optional object field." : "NOT set, The object field is omitted." );
			}
			Case BigEndian:
			Struct {
				[MSRPCObjUuid]
				UINT8 Bit7:1 = this.ToBitString + " PFC_OBJECT_UUID - " + ( this ? "SET, A non-nil object UUID was specified in the handle, and is present in the optional object field." : "NOT set, The object field is omitted." );
				UINT8 Bit6:1 = this.ToBitString + " PFC_MAYBE - " + ( this ? "SET, `maybe' call semantics requested" : "NOT set, `maybe' call semantics NOT requested" );
				UINT8 Bit5:1 = this.ToBitString + " PFC_DID_NOT_EXECUTE - " + ( Property.MSRPCPType != 0x03 ? "N/A;" : ( this ? "SET, Guaranteed call was executed." : "NOT set, Guaranteed call was NOT executed." ) ) + " Only meaningful on `fault' packet.";
				UINT8 Bit4:1 = this.ToBitString + " PFC_CONC_MPX - " + ( this ? "SET, Supports concurrent multiplexing of a single connection." : "NOT set, Does NOT support concurrent multiplexing of a single connection." );
				UINT8 Bit3:1 = this.ToBitString + " PFC_RESERVED_1 - reserved";
				UINT8 Bit2:1 = this.ToBitString + ((PType == 0x0B || PType == 0x0C || PType == 0x0E || PType == 0x0F) ? (" PFC_SUPPORT_HEADER_SIGN - " + ( this ? "SET, Header Sign was supported at sender" : "NOT set, Header Sign was NOT supported at sender" )) : (" PFC_PENDING_CANCEL - " + ( this ? "SET, Cancel was pending at sender" : "NOT set, Cancel was NOT pending at sender" )));
				[MSRPCLastFrag]
				UINT8 Bit1:1 = this.ToBitString + " PFC_LAST_FRAG - " + ( this ? "SET, Is last fragment" : "NOT set,  SET, Is NOT last fragment" );
				[MSRPCFirstFrag]
				UINT8 Bit0:1 = this.ToBitString + " PFC_FIRST_FRAG - " + ( this ? "SET, Is first fragment" : "NOT set, Is NOT first fragment" );
			}
		}
	}
	MSRPCPackedDrep	PackedDrep;
	[MSRPCFragLength, MSRPCStubDataLen = FragLength - 24, 
		MSRPCCompleteFrag = FrameLength - Offset >= FragLength - CurrentProtocolOffset]
	UINT16	FragLength;
	[MSRPCAuthVerifierLen = AuthLength > 0 && MSRPCCompleteFrag ? AuthLength + 8 + UINT8( Framedata, FrameLength - AuthLength - 6 ) : 0 ]
	[Property.AuthLength]
	UINT16	AuthLength;
	[MSRPCCallId, MSRPCStubDataLen = MSRPCStubDataLen - MSRPCAuthVerifierLen]
	UINT32	CallId;

	/* end common fields */

	[MSRPCAuthLevel = AuthLength == 0 ? 0 : ( MSRPCCompleteFrag ? UINT8( Framedata, FrameLength - AuthLength - 7 ) : -1 ),
	 Property.MSRPCEncrypted = MSRPCAuthLevel >= 6 ? ConstEncTypeEncrypted : MSRPCAuthLevel == -1 ? ConstEncTypeUnknown : ConstEncTypeClearData]
	UINT32	AllocHint;
	[MSRPCIfUuid = Conversation.MSRPCUUIDTable$[PContId],
	MSRPCNdr64 = Conversation.MSRPNDR64Table$[PContId],
	MSRPCPContId]
	UINT16	PContId;
	[
		property.MSRPCInterfaceName = UUIDTable( property.MSRPCIfUuid ),
		property.MSRPCIfVers = conversation.MSRPCIfVersTable$[PContId]
	]
	[MSRPCOpnum, Conversation.MSRPCOpnumTable$[MakeByteArray(PContId, CallId, MSRPCFromServer)]]
	UINT16	Opnum;

	switch 
	{
		Case (PfcFlags & 0x80): 
			[MSRPCStubDataLen = MSRPCStubDataLen - 16]
			MSRPCUuidT Object;
	}
	[MSRPCSummary = FormatString( "c/o%s Request: %s  Call=0x%X  Opnum=0x%X  Context=0x%X  Hint=0x%X", 
	Property.MSRPCFirstFrag ? "" : " Continued", property.MSRPCInterfaceName + " " + Property.MSRPCIfUuid, CallId, Opnum, PContId, AllocHint) ]
	
	struct PDUBody = MSRPCStubDataLen + " bytes"
	{
		[DataFieldFrameLength = FrameOffset + MSRPCStubDataLen,
			PayloadStart(
			NetworkDirection, //direction
			PContId,	//identifier
			0,			//sequence token
			0,			//next sequence
			0,			//total payload length
			Property.MSRPCFirstFrag, //is first
			Property.MSRPCLastFrag, //is last
			RssmblyIndStartBit+RssmblyIndEndBit, 		//has start and end indication
			0x0000, /* Properties... */
			Property.MSRPCIfUuid,
			0x0000,
			Property.MSRPCOpnum,
			0x0000,
			Property.MSRPCPType,
			0x0000,
			Property.MSRPCEncrypted,
			0x0001,
			Property.MSRPCStubDataLen,
			0x0000,
			Property.MSRPCFromServer,
			0x0000,
			Property.MSRPCPackedDrep,
			0x0000,
			property.MSRPCNdr64,
			0x0000,
			property.MSRPCCallID,
			0x0000,
			property.MSRPCPContId)
		]

		Switch
		{
			Case (PfcFlags & 0x01):
				[Property.stubdatastart = FrameOffset]
				MSRPCStubData StubData;
			Default: Blob( FrameLength - Offset ) ContinuationData;
		}
		
		switch {
			case 
				FrameLength - Offset > MSRPCAuthVerifierLen &&
				( !(UINT8( Framedata, Offset ) == 0x8A) ||
				  !(UINT8( Framedata, Offset + 1 ) == 0xE3) ||
				  !(UINT8( Framedata, Offset + 2 ) == 0x13) ||
				  !(UINT8( Framedata, Offset + 3 ) == 0x71) ||
				  !(UINT8( Framedata, Offset + 4 ) == 0x02) ||
				  !(UINT8( Framedata, Offset + 5 ) == 0xF4) ||
				  !(UINT8( Framedata, Offset + 6 ) == 0x36) ||
				  !(UINT8( Framedata, Offset + 7 ) == 0x71) ):
					
				MSRPCRemainder( AuthLength ) Remainder;
		}
		
		switch {
			case 
				UINT8( Framedata, Offset ) == 0x8A &&
				UINT8( Framedata, Offset + 1 ) == 0xE3 &&
				UINT8( Framedata, Offset + 2 ) == 0x13 &&
				UINT8( Framedata, Offset + 3 ) == 0x71 &&
				UINT8( Framedata, Offset + 4 ) == 0x02 &&
				UINT8( Framedata, Offset + 5 ) == 0xF4 &&
				UINT8( Framedata, Offset + 6 ) == 0x36 &&
				UINT8( Framedata, Offset + 7 ) == 0x71 :
					RPCEVerificationTrailer VerificationTrailer;
		}
	}
	
	MSRPCAuthVerifierCoT( PType, AuthLength ) AuthVerifier;//[MS-RPCE]: 2.2.2.11   sec_trailer Structure
}

struct MSRPCRemainder( AuthLength )
{
	[Local.MSRPCRemainderOffset = FrameOffset]
	[DataFieldByteOrder = BigEndian]
	switch 
	{
		case 
			AuthLength != 0 && 
			MSRPCCompleteFrag && 
			( MSRPCAuthLevel == 0x05 || MSRPCAuthLevel == 0x06 ):

			struct 
			{
				Switch
				{
					case (FrameOffset < FrameLength - MSRPCAuthVerifierLen) && 
						( !(UINT8( Framedata, Offset ) == 0x8A) ||
						  !(UINT8( Framedata, Offset + 1 ) == 0xE3) ||
						  !(UINT8( Framedata, Offset + 2 ) == 0x13) ||
						  !(UINT8( Framedata, Offset + 3 ) == 0x71) ||
						  !(UINT8( Framedata, Offset + 4 ) == 0x02) ||
						  !(UINT8( Framedata, Offset + 5 ) == 0xF4) ||
						  !(UINT8( Framedata, Offset + 6 ) == 0x36) ||
						  !(UINT8( Framedata, Offset + 7 ) == 0x71) ) :
								while byte[ (FrameOffset < FrameLength - MSRPCAuthVerifierLen) && 
											( !(UINT8( Framedata, Offset ) == 0x8A) ||
											  !(UINT8( Framedata, Offset + 1 ) == 0xE3) ||
											  !(UINT8( Framedata, Offset + 2 ) == 0x13) ||
											  !(UINT8( Framedata, Offset + 3 ) == 0x71) ||
											  !(UINT8( Framedata, Offset + 4 ) == 0x02) ||
											  !(UINT8( Framedata, Offset + 5 ) == 0xF4) ||
											  !(UINT8( Framedata, Offset + 6 ) == 0x36) ||
											  !(UINT8( Framedata, Offset + 7 ) == 0x71) ) ]
											{
												UINT8 byte;
											}
				}
				switch
				{
					case Property.MSRPCFirstFrag&& Property.MSRPCLastFrag && (MSRPCStubDataLen == FrameLength - Property.stubdatastart - MSRPCAuthVerifierLen):
						switch
						{
							case FrameOffset - Local.MSRPCRemainderOffset > 3: 
							case FrameOffset == FrameLength: 
							ReportParserWarning("MSRPC", "RPC clients optionally append extra data to the end of an RPC request or response" ) ParserWarning;
						}
				}
			}
		default:
			struct
			{
				switch
				{
					case Property.MSRPCFirstFrag&& Property.MSRPCLastFrag && (MSRPCStubDataLen == FrameLength - Property.stubdatastart - MSRPCAuthVerifierLen) && Property.MSRPCAuthLevel != -1: 
						ReportParserWarning("MSRPC","RPC clients optionally append extra data to the end of an RPC request or response") MSRPCParserWarning;
				}
				BLOB(FrameLength - FrameOffset - MSRPCAuthVerifierLen) RPCAppendedExtraData;
			}
	}
}

struct MSRPCRpcSyntaxIdentifier
{
	MSRPCGuid SyntaxGuid;
	MSRPCRpcVersion SyntaxVersion;
}

struct MSRPCRpcVersion = FormatString( "%d.%d", MajorVersion, MinorVersion )
{
	UINT16 MajorVersion;
	UINT16 MinorVersion;
}

struct MSRPCRpcconnResponseHdrT //Response
{
	[MSRPCFromServer = IsValueNone(Conversation.MSRPCServerAddress) ? False : Conversation.MSRPCServerAddress == (IsValueNone(Property.SourceNetworkAddress) ? Property.SrcIPXAddress : Property.SourceNetworkAddress)]
	
	/* common fields */

	UINT8 RpcVers;
	UINT8 RpcVersMinor;
	[MSRPCPType]
	UINT8 PType = FormatString("0x%02X - %s", this, MSRPCPTypeTable(this));
	[MSRPCPfcFlags, MSRPCByteOrder = (UINT8( Framedata, Offset + 1 ) & 0x10) ? LittleEndian : BigEndian]
	UINT8 PfcFlags
	{
		Switch( Property.MSRPCByteOrder )
		{
			Case LittleEndian:
			Struct {
				[MSRPCFirstFrag]
				UINT8 Bit0:1 = this.ToBitString + " PFC_FIRST_FRAG - " + ( this ? "SET, Is first fragment" : "NOT set, Is NOT first fragment" );
				[MSRPCLastFrag]
				UINT8 Bit1:1 = this.ToBitString + " PFC_LAST_FRAG - " + ( this ? "SET, Is last fragment" : "NOT set,  SET, Is NOT last fragment" );
				UINT8 Bit2:1 = this.ToBitString + ((PType == 0x0B || PType == 0x0C || PType == 0x0E || PType == 0x0F) ? (" PFC_SUPPORT_HEADER_SIGN - " + ( this ? "SET, Header Sign was supported at sender" : "NOT set, Header Sign was NOT supported at sender" )) : (" PFC_PENDING_CANCEL - " + ( this ? "SET, Cancel was pending at sender" : "NOT set, Cancel was NOT pending at sender" )));
				UINT8 Bit3:1 = this.ToBitString + " PFC_RESERVED_1 - reserved";
				UINT8 Bit4:1 = this.ToBitString + " PFC_CONC_MPX - " + ( this ? "SET, Supports concurrent multiplexing of a single connection." : "NOT set, Does NOT support concurrent multiplexing of a single connection." );
				UINT8 Bit5:1 = this.ToBitString + " PFC_DID_NOT_EXECUTE - " + ( Property.MSRPCPType != 0x03 ? "N/A;" : ( this ? "SET, Guaranteed call was executed." : "NOT set, Guaranteed call was NOT executed." ) ) + " Only meaningful on `fault' packet.";
				UINT8 Bit6:1 = this.ToBitString + " PFC_MAYBE - " + ( this ? "SET, `maybe' call semantics requested" : "NOT set, `maybe' call semantics NOT requested" );
				[MSRPCObjUuid]
				UINT8 Bit7:1 = this.ToBitString + " PFC_OBJECT_UUID - " + ( this ? "SET, A non-nil object UUID was specified in the handle, and is present in the optional object field." : "NOT set, The object field is omitted." );
			}
			Case BigEndian:
			Struct {
				[MSRPCObjUuid]
				UINT8 Bit7:1 = this.ToBitString + " PFC_OBJECT_UUID - " + ( this ? "SET, A non-nil object UUID was specified in the handle, and is present in the optional object field." : "NOT set, The object field is omitted." );
				UINT8 Bit6:1 = this.ToBitString + " PFC_MAYBE - " + ( this ? "SET, `maybe' call semantics requested" : "NOT set, `maybe' call semantics NOT requested" );
				UINT8 Bit5:1 = this.ToBitString + " PFC_DID_NOT_EXECUTE - " + ( Property.MSRPCPType != 0x03 ? "N/A;" : ( this ? "SET, Guaranteed call was executed." : "NOT set, Guaranteed call was NOT executed." ) ) + " Only meaningful on `fault' packet.";
				UINT8 Bit4:1 = this.ToBitString + " PFC_CONC_MPX - " + ( this ? "SET, Supports concurrent multiplexing of a single connection." : "NOT set, Does NOT support concurrent multiplexing of a single connection." );
				UINT8 Bit3:1 = this.ToBitString + " PFC_RESERVED_1 - reserved";
				UINT8 Bit2:1 = this.ToBitString + ((PType == 0x0B || PType == 0x0C || PType == 0x0E || PType == 0x0F) ? (" PFC_SUPPORT_HEADER_SIGN - " + ( this ? "SET, Header Sign was supported at sender" : "NOT set, Header Sign was NOT supported at sender" )) : (" PFC_PENDING_CANCEL - " + ( this ? "SET, Cancel was pending at sender" : "NOT set, Cancel was NOT pending at sender" )));
				[MSRPCLastFrag]
				UINT8 Bit1:1 = this.ToBitString + " PFC_LAST_FRAG - " + ( this ? "SET, Is last fragment" : "NOT set,  SET, Is NOT last fragment" );
				[MSRPCFirstFrag]
				UINT8 Bit0:1 = this.ToBitString + " PFC_FIRST_FRAG - " + ( this ? "SET, Is first fragment" : "NOT set, Is NOT first fragment" );
			}
		}
	}
	MSRPCPackedDrep	PackedDrep;
	[MSRPCFragLength, MSRPCStubDataLen = FragLength - 24, 
		MSRPCCompleteFrag = FrameLength - Offset >= FragLength - CurrentProtocolOffset]
	UINT16	FragLength;
	[MSRPCAuthVerifierLen = AuthLength > 0 && MSRPCCompleteFrag ? AuthLength + 8 + UINT8( Framedata, FrameLength - AuthLength - 6 ) : 0 ]
	UINT16	AuthLength;
	[MSRPCCallId, MSRPCStubDataLen = MSRPCStubDataLen - MSRPCAuthVerifierLen]
	UINT32	CallId;

	/* end common fields */

	[MSRPCAuthLevel = AuthLength == 0 ? 0 : ( MSRPCCompleteFrag ? UINT8( Framedata, FrameLength - AuthLength - 7 ) : -1 ),
	 Property.MSRPCEncrypted = MSRPCAuthLevel >= 6 ? ConstEncTypeEncrypted : MSRPCAuthLevel == -1 ? ConstEncTypeUnknown : ConstEncTypeClearData]
	UINT32	AllocHint;
	[MSRPCIfUuid = Conversation.MSRPCUUIDTable$[PContId],
	MSRPCNdr64 = Conversation.MSRPNDR64Table$[PContId],
	Conversation.MSRPCPerFrameOpnumTable$[FrameNumber] = Conversation.MSRPCOpnumTable$[MakeByteArray(PContId, CallId, MSRPCFromServer ? False : True )],
	MSRPCIfVers = conversation.MSRPCIfVersTable$[PContId],
	MSRPCPContId]
	UINT16	PContId;
	[property.MSRPCInterfaceName = UUIDTable( property.MSRPCIfUuid )]
	UINT8	CancelCount;
	[MSRPCOpnum = Conversation.MSRPCPerFrameOpnumTable$[FrameNumber]]
	UINT8	Rsvd1;

	[MSRPCSummary = FormatString( "c/o%s Response: %s  Call=0x%X  Context=0x%X  Hint=0x%X  Cancels=0x%X", 
	Property.MSRPCFirstFrag ? "" : " Continued", property.MSRPCInterfaceName + " " + Property.MSRPCIfUuid, CallId, PContId, AllocHint, CancelCount )]
	//TSGU opnum 8 reassmbly doesn't match strict NDR rule
	[Local.MSRPCTSGURDPData = property.MSRPCIfUuid == "{44e265dd-7daf-42cd-8560-3cdb6e7a2729}" && Property.MSRPCOpnum == 0x8]
	struct PDUBody = MSRPCStubDataLen + " bytes"
	{
		[
			DataFieldFrameLength = FrameOffset + MSRPCStubDataLen,
			PayloadStart(
				NetworkDirection, //direction
				PContId,	//identifier
				0,			//sequence token
				0,			//next sequence
				0,			//total payload length
				Local.MSRPCTSGURDPData|| Property.MSRPCFirstFrag, //is first
				Local.MSRPCTSGURDPData|| Property.MSRPCLastFrag, //is last
				RssmblyIndStartBit+RssmblyIndEndBit, //has start and end indication
				0x0000, /* Properties... */
				Property.MSRPCIfUuid,
				0x0000,
				Property.MSRPCOpnum,
				0x0000,
				PType,
				0x0000,
				Property.MSRPCEncrypted,
				0x0001,
				Property.MSRPCStubDataLen,
				0x0000,
				Property.MSRPCFromServer,
				0x0000,
				property.MSRPCPackedDrep,
				0x0000,
				property.MSRPCNdr64,
				0x0000,
				property.MSRPCCallID,
				0x0000,
				property.MSRPCPContId)
		]
	
		Switch
		{
			Case (PfcFlags & 0x01):
				[Property.stubdatastart = FrameOffset]
				MSRPCStubData StubData;
			Default: Blob( FrameLength - Offset ) ContinuationData;
		}
		switch {
			case FrameLength - Offset > MSRPCAuthVerifierLen : 
				MSRPCRemainder( AuthLength ) Remainder;
		}
	}
	
	MSRPCAuthVerifierCoT( PType, AuthLength ) AuthVerifier;//[MS-RPCE]: 2.2.2.11   sec_trailer Structure
}

struct MSRPCRpcconnFaultHdrT //Fault
{
	/* common fields */

	UINT8 RpcVers;
	UINT8 RpcVersMinor;
	[MSRPCPType]
	UINT8 PType = FormatString("0x%02X - %s", this, MSRPCPTypeTable(this));
	[MSRPCPfcFlags, MSRPCByteOrder = (UINT8( Framedata, Offset + 1 ) & 0x10) ? LittleEndian : BigEndian]
	UINT8 PfcFlags
	{
		Switch( Property.MSRPCByteOrder )
		{
			Case LittleEndian:
			Struct {
				[MSRPCFirstFrag]
				UINT8 Bit0:1 = this.ToBitString + " PFC_FIRST_FRAG - " + ( this ? "SET, Is first fragment" : "NOT set, Is NOT first fragment" );
				[MSRPCLastFrag]
				UINT8 Bit1:1 = this.ToBitString + " PFC_LAST_FRAG - " + ( this ? "SET, Is last fragment" : "NOT set,  SET, Is NOT last fragment" );
				UINT8 Bit2:1 = this.ToBitString + ((PType == 0x0B || PType == 0x0C || PType == 0x0E || PType == 0x0F) ? (" PFC_SUPPORT_HEADER_SIGN - " + ( this ? "SET, Header Sign was supported at sender" : "NOT set, Header Sign was NOT supported at sender" )) : (" PFC_PENDING_CANCEL - " + ( this ? "SET, Cancel was pending at sender" : "NOT set, Cancel was NOT pending at sender" )));
				UINT8 Bit3:1 = this.ToBitString + " PFC_RESERVED_1 - reserved";
				UINT8 Bit4:1 = this.ToBitString + " PFC_CONC_MPX - " + ( this ? "SET, Supports concurrent multiplexing of a single connection." : "NOT set, Does NOT support concurrent multiplexing of a single connection." );
				UINT8 Bit5:1 = this.ToBitString + " PFC_DID_NOT_EXECUTE - " + ( Property.MSRPCPType != 0x03 ? "N/A;" : ( this ? "SET, Guaranteed call was executed." : "NOT set, Guaranteed call was NOT executed." ) ) + " Only meaningful on `fault' packet.";
				UINT8 Bit6:1 = this.ToBitString + " PFC_MAYBE - " + ( this ? "SET, `maybe' call semantics requested" : "NOT set, `maybe' call semantics NOT requested" );
				[MSRPCObjUuid]
				UINT8 Bit7:1 = this.ToBitString + " PFC_OBJECT_UUID - " + ( this ? "SET, A non-nil object UUID was specified in the handle, and is present in the optional object field." : "NOT set, The object field is omitted." );
			}
			Case BigEndian:
			Struct {
				[MSRPCObjUuid]
				UINT8 Bit7:1 = this.ToBitString + " PFC_OBJECT_UUID - " + ( this ? "SET, A non-nil object UUID was specified in the handle, and is present in the optional object field." : "NOT set, The object field is omitted." );
				UINT8 Bit6:1 = this.ToBitString + " PFC_MAYBE - " + ( this ? "SET, `maybe' call semantics requested" : "NOT set, `maybe' call semantics NOT requested" );
				UINT8 Bit5:1 = this.ToBitString + " PFC_DID_NOT_EXECUTE - " + ( Property.MSRPCPType != 0x03 ? "N/A;" : ( this ? "SET, Guaranteed call was executed." : "NOT set, Guaranteed call was NOT executed." ) ) + " Only meaningful on `fault' packet.";
				UINT8 Bit4:1 = this.ToBitString + " PFC_CONC_MPX - " + ( this ? "SET, Supports concurrent multiplexing of a single connection." : "NOT set, Does NOT support concurrent multiplexing of a single connection." );
				UINT8 Bit3:1 = this.ToBitString + " PFC_RESERVED_1 - reserved";
				UINT8 Bit2:1 = this.ToBitString + ((PType == 0x0B || PType == 0x0C || PType == 0x0E || PType == 0x0F) ? (" PFC_SUPPORT_HEADER_SIGN - " + ( this ? "SET, Header Sign was supported at sender" : "NOT set, Header Sign was NOT supported at sender" )) : (" PFC_PENDING_CANCEL - " + ( this ? "SET, Cancel was pending at sender" : "NOT set, Cancel was NOT pending at sender" )));
				[MSRPCLastFrag]
				UINT8 Bit1:1 = this.ToBitString + " PFC_LAST_FRAG - " + ( this ? "SET, Is last fragment" : "NOT set,  SET, Is NOT last fragment" );
				[MSRPCFirstFrag]
				UINT8 Bit0:1 = this.ToBitString + " PFC_FIRST_FRAG - " + ( this ? "SET, Is first fragment" : "NOT set, Is NOT first fragment" );
			}
		}
	}
	MSRPCPackedDrep	PackedDrep;
	[MSRPCFragLength]
	UINT16	FragLength;
	UINT16	AuthLength;
	[MSRPCCallId]
	UINT32	CallId;

	/* end common fields */

	UINT32	AllocHint;
	[MSRPCIfUuid = Conversation.MSRPCUUIDTable$[PContId],
	MSRPCNdr64 = Conversation.MSRPNDR64Table$[PContId],
	MSRPCOpnum = Conversation.MSRPCOpnumTable$[MakeByteArray(PContId, CallId, MSRPCFromServer ? False : True )]]
	UINT16	PContId;
	[property.MSRPCInterfaceName = UUIDTable( property.MSRPCIfUuid )]
	UINT8	CancelCount;
	UINT8	Reserved;
	UINT32	Status = FormatString( "0x%08X ", this ) + MSRPCRejectStatusCodes( this );
	UINT32	Reserved2;

	[MSRPCSummary = FormatString( "c/o Fault:  Call=0x%X  Context=0x%X  Status=0x%X  Cancels=0x%X", 
	CallId, PContId, Status, CancelCount )]

	switch
	{
		case Reserved == 1: EERRExtendedErrorInformationBlob ExtendedErrorInformationBlob;
	}
	switch
	{
		case Status == 0: 
			struct StubData
			{
				UINT8 StubDataBytes[AllocHint];
			}
	}

	switch 
	{
		case AuthLength > 0: MSRPCAuthVerifierCoT( PType, AuthLength ) AuthVerifier;
	}
}


struct MSRPCRpcconnCancelHdrT //Cancel
{
	/* common fields */

	UINT8 RpcVers;
	UINT8 RpcVersMinor;
	[MSRPCPType]
	UINT8 PType = FormatString("0x%02X - %s", this, MSRPCPTypeTable(this));
	[MSRPCPfcFlags, MSRPCByteOrder = (UINT8( Framedata, Offset + 1 ) & 0x10) ? LittleEndian : BigEndian]
	UINT8 PfcFlags
	{
		Switch( Property.MSRPCByteOrder )
		{
			Case LittleEndian:
			Struct {
				[MSRPCFirstFrag]
				UINT8 Bit0:1 = this.ToBitString + " PFC_FIRST_FRAG - " + ( this ? "SET, Is first fragment" : "NOT set, Is NOT first fragment" );
				[MSRPCLastFrag]
				UINT8 Bit1:1 = this.ToBitString + " PFC_LAST_FRAG - " + ( this ? "SET, Is last fragment" : "NOT set,  SET, Is NOT last fragment" );
				UINT8 Bit2:1 = this.ToBitString + ((PType == 0x0B || PType == 0x0C || PType == 0x0E || PType == 0x0F) ? (" PFC_SUPPORT_HEADER_SIGN - " + ( this ? "SET, Header Sign was supported at sender" : "NOT set, Header Sign was NOT supported at sender" )) : (" PFC_PENDING_CANCEL - " + ( this ? "SET, Cancel was pending at sender" : "NOT set, Cancel was NOT pending at sender" )));
				UINT8 Bit3:1 = this.ToBitString + " PFC_RESERVED_1 - reserved";
				UINT8 Bit4:1 = this.ToBitString + " PFC_CONC_MPX - " + ( this ? "SET, Supports concurrent multiplexing of a single connection." : "NOT set, Does NOT support concurrent multiplexing of a single connection." );
				UINT8 Bit5:1 = this.ToBitString + " PFC_DID_NOT_EXECUTE - " + ( Property.MSRPCPType != 0x03 ? "N/A;" : ( this ? "SET, Guaranteed call was executed." : "NOT set, Guaranteed call was NOT executed." ) ) + " Only meaningful on `fault' packet.";
				UINT8 Bit6:1 = this.ToBitString + " PFC_MAYBE - " + ( this ? "SET, `maybe' call semantics requested" : "NOT set, `maybe' call semantics NOT requested" );
				[MSRPCObjUuid]
				UINT8 Bit7:1 = this.ToBitString + " PFC_OBJECT_UUID - " + ( this ? "SET, A non-nil object UUID was specified in the handle, and is present in the optional object field." : "NOT set, The object field is omitted." );
			}
			Case BigEndian:
			Struct {
				[MSRPCObjUuid]
				UINT8 Bit7:1 = this.ToBitString + " PFC_OBJECT_UUID - " + ( this ? "SET, A non-nil object UUID was specified in the handle, and is present in the optional object field." : "NOT set, The object field is omitted." );
				UINT8 Bit6:1 = this.ToBitString + " PFC_MAYBE - " + ( this ? "SET, `maybe' call semantics requested" : "NOT set, `maybe' call semantics NOT requested" );
				UINT8 Bit5:1 = this.ToBitString + " PFC_DID_NOT_EXECUTE - " + ( Property.MSRPCPType != 0x03 ? "N/A;" : ( this ? "SET, Guaranteed call was executed." : "NOT set, Guaranteed call was NOT executed." ) ) + " Only meaningful on `fault' packet.";
				UINT8 Bit4:1 = this.ToBitString + " PFC_CONC_MPX - " + ( this ? "SET, Supports concurrent multiplexing of a single connection." : "NOT set, Does NOT support concurrent multiplexing of a single connection." );
				UINT8 Bit3:1 = this.ToBitString + " PFC_RESERVED_1 - reserved";
				UINT8 Bit2:1 = this.ToBitString + ((PType == 0x0B || PType == 0x0C || PType == 0x0E || PType == 0x0F) ? (" PFC_SUPPORT_HEADER_SIGN - " + ( this ? "SET, Header Sign was supported at sender" : "NOT set, Header Sign was NOT supported at sender" )) : (" PFC_PENDING_CANCEL - " + ( this ? "SET, Cancel was pending at sender" : "NOT set, Cancel was NOT pending at sender" )));
				[MSRPCLastFrag]
				UINT8 Bit1:1 = this.ToBitString + " PFC_LAST_FRAG - " + ( this ? "SET, Is last fragment" : "NOT set,  SET, Is NOT last fragment" );
				[MSRPCFirstFrag]
				UINT8 Bit0:1 = this.ToBitString + " PFC_FIRST_FRAG - " + ( this ? "SET, Is first fragment" : "NOT set, Is NOT first fragment" );
			}
		}
	}
	MSRPCPackedDrep	PackedDrep;
	[MSRPCFragLength]
	UINT16	FragLength;
	UINT16	AuthLength;
	[MSRPCCallId]
	UINT32	CallId;

	/* end common fields */

	[MSRPCSummary = FormatString( "c/o Cancel:  Call=0x%X", CallId )]
	
	switch
	{
		case AuthLength > 0: MSRPCAuthVerifierCoT( PType, AuthLength ) AuthVerifier;
	}
}

struct MSRPCRpcconnOrphanedHdrT //Orphaned
{
	/* common fields */

	UINT8 RpcVers;
	UINT8 RpcVersMinor;
	[MSRPCPType]
	UINT8 PType = FormatString("0x%02X - %s", this, MSRPCPTypeTable(this));
	[MSRPCPfcFlags, MSRPCByteOrder = (UINT8( Framedata, Offset + 1 ) & 0x10) ? LittleEndian : BigEndian]
	UINT8 PfcFlags
	{
		Switch( Property.MSRPCByteOrder )
		{
			Case LittleEndian:
			Struct {
				[MSRPCFirstFrag]
				UINT8 Bit0:1 = this.ToBitString + " PFC_FIRST_FRAG - " + ( this ? "SET, Is first fragment" : "NOT set, Is NOT first fragment" );
				[MSRPCLastFrag]
				UINT8 Bit1:1 = this.ToBitString + " PFC_LAST_FRAG - " + ( this ? "SET, Is last fragment" : "NOT set,  SET, Is NOT last fragment" );
				UINT8 Bit2:1 = this.ToBitString + ((PType == 0x0B || PType == 0x0C || PType == 0x0E || PType == 0x0F) ? (" PFC_SUPPORT_HEADER_SIGN - " + ( this ? "SET, Header Sign was supported at sender" : "NOT set, Header Sign was NOT supported at sender" )) : (" PFC_PENDING_CANCEL - " + ( this ? "SET, Cancel was pending at sender" : "NOT set, Cancel was NOT pending at sender" )));
				UINT8 Bit3:1 = this.ToBitString + " PFC_RESERVED_1 - reserved";
				UINT8 Bit4:1 = this.ToBitString + " PFC_CONC_MPX - " + ( this ? "SET, Supports concurrent multiplexing of a single connection." : "NOT set, Does NOT support concurrent multiplexing of a single connection." );
				UINT8 Bit5:1 = this.ToBitString + " PFC_DID_NOT_EXECUTE - " + ( Property.MSRPCPType != 0x03 ? "N/A;" : ( this ? "SET, Guaranteed call was executed." : "NOT set, Guaranteed call was NOT executed." ) ) + " Only meaningful on `fault' packet.";
				UINT8 Bit6:1 = this.ToBitString + " PFC_MAYBE - " + ( this ? "SET, `maybe' call semantics requested" : "NOT set, `maybe' call semantics NOT requested" );
				[MSRPCObjUuid]
				UINT8 Bit7:1 = this.ToBitString + " PFC_OBJECT_UUID - " + ( this ? "SET, A non-nil object UUID was specified in the handle, and is present in the optional object field." : "NOT set, The object field is omitted." );
			}
			Case BigEndian:
			Struct {
				[MSRPCObjUuid]
				UINT8 Bit7:1 = this.ToBitString + " PFC_OBJECT_UUID - " + ( this ? "SET, A non-nil object UUID was specified in the handle, and is present in the optional object field." : "NOT set, The object field is omitted." );
				UINT8 Bit6:1 = this.ToBitString + " PFC_MAYBE - " + ( this ? "SET, `maybe' call semantics requested" : "NOT set, `maybe' call semantics NOT requested" );
				UINT8 Bit5:1 = this.ToBitString + " PFC_DID_NOT_EXECUTE - " + ( Property.MSRPCPType != 0x03 ? "N/A;" : ( this ? "SET, Guaranteed call was executed." : "NOT set, Guaranteed call was NOT executed." ) ) + " Only meaningful on `fault' packet.";
				UINT8 Bit4:1 = this.ToBitString + " PFC_CONC_MPX - " + ( this ? "SET, Supports concurrent multiplexing of a single connection." : "NOT set, Does NOT support concurrent multiplexing of a single connection." );
				UINT8 Bit3:1 = this.ToBitString + " PFC_RESERVED_1 - reserved";
				UINT8 Bit2:1 = this.ToBitString + ((PType == 0x0B || PType == 0x0C || PType == 0x0E || PType == 0x0F) ? (" PFC_SUPPORT_HEADER_SIGN - " + ( this ? "SET, Header Sign was supported at sender" : "NOT set, Header Sign was NOT supported at sender" )) : (" PFC_PENDING_CANCEL - " + ( this ? "SET, Cancel was pending at sender" : "NOT set, Cancel was NOT pending at sender" )));
				[MSRPCLastFrag]
				UINT8 Bit1:1 = this.ToBitString + " PFC_LAST_FRAG - " + ( this ? "SET, Is last fragment" : "NOT set,  SET, Is NOT last fragment" );
				[MSRPCFirstFrag]
				UINT8 Bit0:1 = this.ToBitString + " PFC_FIRST_FRAG - " + ( this ? "SET, Is first fragment" : "NOT set, Is NOT first fragment" );
			}
		}
	}
	MSRPCPackedDrep	PackedDrep;
	[MSRPCFragLength]
	UINT16	FragLength;
	UINT16	AuthLength;
	[MSRPCCallId]
	UINT32	CallId;

	/* end common fields */

	[MSRPCSummary = FormatString( "c/o Orphaned:  Call=0x%X", CallId )]
	
	switch
	{
		case AuthLength > 0:  MSRPCAuthVerifierCoT( PType, AuthLength ) AuthVerifier;
	}
}

struct MSRPCRpcconnShutdownHdrT //Shutdown
{
	/* common fields */

	UINT8 RpcVers;
	UINT8 RpcVersMinor;
	[MSRPCPType]
	UINT8 PType = FormatString("0x%02X - %s", this, MSRPCPTypeTable(this));
	[MSRPCPfcFlags, MSRPCByteOrder = (UINT8( Framedata, Offset + 1 ) & 0x10) ? LittleEndian : BigEndian]
	UINT8 PfcFlags
	{
		Switch( Property.MSRPCByteOrder )
		{
			Case LittleEndian:
			Struct {
				[MSRPCFirstFrag]
				UINT8 Bit0:1 = this.ToBitString + " PFC_FIRST_FRAG - " + ( this ? "SET, Is first fragment" : "NOT set, Is NOT first fragment" );
				[MSRPCLastFrag]
				UINT8 Bit1:1 = this.ToBitString + " PFC_LAST_FRAG - " + ( this ? "SET, Is last fragment" : "NOT set,  SET, Is NOT last fragment" );
				UINT8 Bit2:1 = this.ToBitString + ((PType == 0x0B || PType == 0x0C || PType == 0x0E || PType == 0x0F) ? (" PFC_SUPPORT_HEADER_SIGN - " + ( this ? "SET, Header Sign was supported at sender" : "NOT set, Header Sign was NOT supported at sender" )) : (" PFC_PENDING_CANCEL - " + ( this ? "SET, Cancel was pending at sender" : "NOT set, Cancel was NOT pending at sender" )));
				UINT8 Bit3:1 = this.ToBitString + " PFC_RESERVED_1 - reserved";
				UINT8 Bit4:1 = this.ToBitString + " PFC_CONC_MPX - " + ( this ? "SET, Supports concurrent multiplexing of a single connection." : "NOT set, Does NOT support concurrent multiplexing of a single connection." );
				UINT8 Bit5:1 = this.ToBitString + " PFC_DID_NOT_EXECUTE - " + ( Property.MSRPCPType != 0x03 ? "N/A;" : ( this ? "SET, Guaranteed call was executed." : "NOT set, Guaranteed call was NOT executed." ) ) + " Only meaningful on `fault' packet.";
				UINT8 Bit6:1 = this.ToBitString + " PFC_MAYBE - " + ( this ? "SET, `maybe' call semantics requested" : "NOT set, `maybe' call semantics NOT requested" );
				[MSRPCObjUuid]
				UINT8 Bit7:1 = this.ToBitString + " PFC_OBJECT_UUID - " + ( this ? "SET, A non-nil object UUID was specified in the handle, and is present in the optional object field." : "NOT set, The object field is omitted." );
			}
			Case BigEndian:
			Struct {
				[MSRPCObjUuid]
				UINT8 Bit7:1 = this.ToBitString + " PFC_OBJECT_UUID - " + ( this ? "SET, A non-nil object UUID was specified in the handle, and is present in the optional object field." : "NOT set, The object field is omitted." );
				UINT8 Bit6:1 = this.ToBitString + " PFC_MAYBE - " + ( this ? "SET, `maybe' call semantics requested" : "NOT set, `maybe' call semantics NOT requested" );
				UINT8 Bit5:1 = this.ToBitString + " PFC_DID_NOT_EXECUTE - " + ( Property.MSRPCPType != 0x03 ? "N/A;" : ( this ? "SET, Guaranteed call was executed." : "NOT set, Guaranteed call was NOT executed." ) ) + " Only meaningful on `fault' packet.";
				UINT8 Bit4:1 = this.ToBitString + " PFC_CONC_MPX - " + ( this ? "SET, Supports concurrent multiplexing of a single connection." : "NOT set, Does NOT support concurrent multiplexing of a single connection." );
				UINT8 Bit3:1 = this.ToBitString + " PFC_RESERVED_1 - reserved";
				UINT8 Bit2:1 = this.ToBitString + ((PType == 0x0B || PType == 0x0C || PType == 0x0E || PType == 0x0F) ? (" PFC_SUPPORT_HEADER_SIGN - " + ( this ? "SET, Header Sign was supported at sender" : "NOT set, Header Sign was NOT supported at sender" )) : (" PFC_PENDING_CANCEL - " + ( this ? "SET, Cancel was pending at sender" : "NOT set, Cancel was NOT pending at sender" )));
				[MSRPCLastFrag]
				UINT8 Bit1:1 = this.ToBitString + " PFC_LAST_FRAG - " + ( this ? "SET, Is last fragment" : "NOT set,  SET, Is NOT last fragment" );
				[MSRPCFirstFrag]
				UINT8 Bit0:1 = this.ToBitString + " PFC_FIRST_FRAG - " + ( this ? "SET, Is first fragment" : "NOT set, Is NOT first fragment" );
			}
		}
	}
	MSRPCPackedDrep	PackedDrep;
	[MSRPCFragLength]
	UINT16	FragLength;
	UINT16	AuthLength;
	[MSRPCCallId,
	MSRPCSummary = FormatString( "c/o Shutdown:  Call=0x%X", CallId )]
	UINT32	CallId;

	/* end common fields */
}

TABLE MSRPCAuthTypeTable( value )
{
	switch( value )
	{
		case 0x00: "RPC_C_AUTHN_NONE";
		case 0x01: "RPC_C_AUTHN_DCE_PRIVATE - DCE's private-key authentication is derived from Kerberos";
		case 0x02: "RPC_C_AUTHN_DCE_PUBLIC - DCE public key authentication (reserved for future use).";
		case 0x04: "RPC_C_AUTHN_DEC_PUBLIC - DEC public key authentication (reserved for future use).";
		case 0x09: "RPC_C_AUTHN_GSS_NEGOTIATE - The Simple and Protected GSS-API Negotiation (SPNEGO) mechanism selects either NT LAN Manager (NTLM) or Kerberos authentication.";
		case 0x0A: "RPC_C_AUTHN_WINNT - NTLM authentication will be used.";
		case 0x0E: "RPC_C_AUTHN_GSS_SCHANNEL - Transport Layer Security (TLS) or Secure Socket Layer (SSL) authentication for packet privacy will be used.";
		case 0x10: "RPC_C_AUTHN_GSS_KERBEROS - Kerberos authentication will be used.";
		case 0x11: "RPC_C_AUTHN_DPA - Distributed Password Authentication.  Not currently supported.";
		case 0x12: "RPC_C_AUTHN_MSN - Authentication protocol SSP used for the Microsoft Network (MSN). Not currently supported.";
		case 0x15: "RPC_C_AUTHN_DIGEST - Not currently supported.";
		case 0x44: "RPC_C_AUTHN_NETLOGON - Netlogon authentication will be used.";
		case 0x64: "RPC_C_AUTHN_MQ - This SSP provides an SSPI-compatible wrapper for the Microsoft Message Queue (MSMQ) transport-level protocol. Not currently supported.";
		case 0xFF: "RPC_C_AUTHN_DEFAULT";
		default:   "unknown";
	}
}

TABLE MSRPCAuthLevelTable( value )
{
	switch ( value )
	{
		case 0x01: "dce_c_authn_level_none - The client has requested that no protection be performed.";
		case 0x02: "dce_c_authn_level_connect - The client and server identities are exchanged and cryptographically verified.";
		case 0x03: "dce_c_authn_level_call - This level offers the dce_c_authn_level_connect services plus integrity protection of the first fragment only of each call.";
		case 0x04: "dce_c_authn_level_pkt - This level offers the dce_c_authn_level_connect services plus per-PDU replay and misordering detection. It provides no per-PDU modification protection.";
		case 0x05: "dce_c_authn_level_pkt_integrity - This level offers the dce_c_authn_level_pkt services plus per-PDU modification and deletion detection.";
		case 0x06: "dce_c_authn_level_pkt_privacy - This level offers the dce_c_authn_level_pkt_integrity services plus privacy (encryption) of stub call arguments only. All run-time and lower-layer headers are still transmitted in clear text.";
		default:   "unknown";
	}
}

Table MSRPCEncryptionTable( EncType )
{
     switch(EncType)
     {
         case ConstEncTypeEncrypted: "Encrypted Payload";
         case ConstEncTypeClearData: "Clear Data Payload"; // never hit when uses this table
         case ConstEncTypeUnknown: "Un-Interpreted Payload"; // possible encrypted or encryption uncertain
         default: "Undefined Encryption";
     }
}

struct MSRPCAuthVerifierCoT( PType, AuthLength )
{
	[Local.MSRPCAuthPadLen = Property.MSRPCFragLength - AuthLength - 8 - CurrentProtocolOffset]
	BLOB(Local.MSRPCAuthPadLen) AuthPad;
	UINT8  AuthType = MSRPCAuthTypeTable( this );
	[MSRPCAuthLevel]
	UINT8  AuthLevel = MSRPCAuthLevelTable( this );
	UINT8  AuthPadLength;
	UINT8  AuthReserved;
	UINT32 AuthContextId;
	[MSRPCStartOffset = FrameOffset]
	switch(AuthLength != 0)
	{
		case true:
		[DataFieldFrameLength = Offset + AuthLength]
		struct AuthValue
		{
			switch
			{
				case AuthType == 0x09 && !(UINT16( FrameData, Offset ) == 0):
					GssApi GssApi;
					
				case AuthType == 0x0A && AsciiString( FrameData, Offset, 7)  == "Ntlmssp":
					[Property.NLMPCurrentProtocol = "msrpc"]
					NLMP_struct NLMP;
				case AuthType == 0x0A && UINT32( Framedata, Offset ) == 0x00000000:
				case AuthType == 0x0A && UINT32( Framedata, Offset ) == 0x01000000:
					NLMPMessageSignature NtlmToken;
				
				case AuthType == 0x0E && ptype == 0 && Property.MSRPCStubDataLen > 0: 
				case AuthType == 0x0E && ptype == 2 && Property.MSRPCStubDataLen > 0: 
					BLOB( AuthLength ) SSLToken;
				case AuthType == 0x0E: 
					while Record[ UINT8( Framedata, Offset ) >= 0x14 && UINT8( Framedata, Offset ) <= 0x17 ]
					{
						MSRPCSSLRecordLayer RecordLayer;
					}
	
				case AuthType == 0x10 && !(UINT8( Framedata, Offset ) == 0xFF): 
					GssapiKrb5 Kerberos;
				
				case AuthType == 0x44 && UINT8( Framedata, Offset ) == 0:
				case AuthType == 0x44 && UINT8( Framedata, Offset ) == 1:
					MSRPCNlAuthMessage NetlogonMessage;
				case AuthType == 0x44 && UINT16( FrameData, Offset + 4 ) == 0xFFFF:
					MSRPCNlAuthSignature NetlogonSignature;
				
			}
			Switch {
				case Offset < FrameLength && Property.MSRPCCompleteFrag:
				struct
				{
					ReportParserWarning("MSRPC","Octets trailer appends to authentication token") ParserWarning;
					BLOB( frameLength - Offset ) unused;
				}
			}
		}		
	}
}

Struct MSRPCAuthTrailerClT
{
	[MSRPCAuthLevel]
	UINT8 ProtectionLevel = MSRPCAuthLevelTable( this );
	UINT8 KeyVersNum;
	UINT8 Pad[2];
	Switch
	{
		Case MSRPCAuthLevel == 3 : 
			Struct
			{
				Struct Checksum
				{
					UINT32 SegNum;
					UINT32 FragNum;
				}
				UINT8 RestAuthValue[8];
			}
		Default: UINT8 AuthValue[16];
	}
}

//C706 12.5.2 Header Encoding
[DataTypeByteOrder = (UINT8( Framedata, Offset + 4 ) & 0x10) ? LittleEndian : BigEndian]
struct MSRPCDcRpcClPktHdrT
{
	UINT8	RpcVers;
	[MSRPCPType]
	UINT8	PType = FormatString("0x%02X - %s", this, MSRPCPTypeTable(this));
	[MSRPCByteOrder = (UINT8( Framedata, Offset + 2 ) & 0x10) ? LittleEndian : BigEndian]
	Switch( Property.MSRPCByteOrder )
	{
		Case LittleEndian:
		Struct {
			UINT8	Flags1 = FormatString( "0x%02X", this )
			{
				UINT8 Bit0:1 = this.ToBitString + " reserved_01 -  Reserved for use by implementations.";
				[MSRPCLastFrag]
				UINT8 Bit1:1 = this.ToBitString + " lastfrag - " + ( this ? "SET, " : "NOT set, " ) + "Meaningful in either direction. If set, the PDU is the last fragment of a multi-PDU transmission.";
				[MSRPCFrag]
				UINT8 Bit2:1 = this.ToBitString + " frag - " + ( this ? "SET, " : "NOT set, " ) + "Meaningful in either direction. If set, the PDU is a fragment of a multi-PDU transmission.";
				UINT8 Bit3:1 = this.ToBitString + " nofack - " + ( this ? "SET, " : "NOT set, " ) + "Meaningful for fragments sent in either direction. If set, the receiver is not requested to send a fack PDU for the fragment. Otherwise, if not set, the receiver acknowledges the received PDU with a fack PDU. Note that both client and server may send fack PDUs independent of the status of this flag.";
				UINT8 Bit4:1 = this.ToBitString + " maybe - " + ( this ? "SET, " : "NOT set, " ) + "Meaningful only from client to server. If set, the PDU is for a maybe request.";
				UINT8 Bit5:1 = this.ToBitString + " idempotent - " + ( this ? "SET, " : "NOT set, " ) + "Meaningful only from client to server. If set, the PDU is for an idempotent request.";
				UINT8 Bit6:1 = this.ToBitString + " broadcast - " + ( this ? "SET, " : "NOT set, " ) + "Meaningful only from client to server. If set, the PDU is for a broadcast request.";
				UINT8 Bit7:1 = this.ToBitString + " reserved_80 - Reserved for use by implementations.";
			};
		}
		Case BigEndian:
		Struct {
			UINT8	Flags1 = FormatString( "0x%02X", this )
			{
				UINT8 Bit7:1 = this.ToBitString + " reserved_80 - Reserved for use by implementations.";
				UINT8 Bit6:1 = this.ToBitString + " broadcast - " + ( this ? "SET, " : "NOT set, " ) + "Meaningful only from client to server. If set, the PDU is for a broadcast request.";
				UINT8 Bit5:1 = this.ToBitString + " idempotent - " + ( this ? "SET, " : "NOT set, " ) + "Meaningful only from client to server. If set, the PDU is for an idempotent request.";
				UINT8 Bit4:1 = this.ToBitString + " maybe - " + ( this ? "SET, " : "NOT set, " ) + "Meaningful only from client to server. If set, the PDU is for a maybe request.";
				UINT8 Bit3:1 = this.ToBitString + " nofack - " + ( this ? "SET, " : "NOT set, " ) + "Meaningful for fragments sent in either direction. If set, the receiver is not requested to send a fack PDU for the fragment. Otherwise, if not set, the receiver acknowledges the received PDU with a fack PDU. Note that both client and server may send fack PDUs independent of the status of this flag.";
				[MSRPCFrag]
				UINT8 Bit2:1 = this.ToBitString + " frag - " + ( this ? "SET, " : "NOT set, " ) + "Meaningful in either direction. If set, the PDU is a fragment of a multi-PDU transmission.";
				[MSRPCLastFrag]
				UINT8 Bit1:1 = this.ToBitString + " lastfrag - " + ( this ? "SET, " : "NOT set, " ) + "Meaningful in either direction. If set, the PDU is the last fragment of a multi-PDU transmission.";
				UINT8 Bit0:1 = this.ToBitString + " reserved_01 -  Reserved for use by implementations.";
			};
		}
	}
	Switch( Property.MSRPCByteOrder )
	{
		Case LittleEndian:
		Struct {
			UINT8	Flags2 = FormatString( "0x%02X", this )
			{
				UINT8 Bit0:1 = this.ToBitString + " reserved_01 - Reserved for use by implementations.";
				UINT8 Bit1:1 = this.ToBitString + " cancel_pending - " + ( this ? "SET, Cancel pending at the call end." : "NOT set, Cancel NOT pending at the call end." );
				UINT8 Bit2:1 = this.ToBitString + " reserved_04 - Reserved for future use. Must be set to 0.";
				UINT8 Bit3:1 = this.ToBitString + " reserved_08 - Reserved for future use. Must be set to 0.";
				UINT8 Bit4:1 = this.ToBitString + " reserved_10 - Reserved for future use. Must be set to 0.";
				UINT8 Bit5:1 = this.ToBitString + " reserved_20 - Reserved for future use. Must be set to 0.";
				UINT8 Bit6:1 = this.ToBitString + " reserved_40 - Reserved for future use. Must be set to 0.";
				UINT8 Bit7:1 = this.ToBitString + " reserved_80 - Reserved for future use. Must be set to 0.";
			};
		}
		Case BigEndian:
		Struct {
			UINT8	Flags2 = FormatString( "0x%02X", this )
			{
				UINT8 Bit7:1 = this.ToBitString + " reserved_80 - Reserved for future use. Must be set to 0.";
				UINT8 Bit6:1 = this.ToBitString + " reserved_40 - Reserved for future use. Must be set to 0.";
				UINT8 Bit5:1 = this.ToBitString + " reserved_20 - Reserved for future use. Must be set to 0.";
				UINT8 Bit4:1 = this.ToBitString + " reserved_10 - Reserved for future use. Must be set to 0.";
				UINT8 Bit3:1 = this.ToBitString + " reserved_08 - Reserved for future use. Must be set to 0.";
				UINT8 Bit2:1 = this.ToBitString + " reserved_04 - Reserved for future use. Must be set to 0.";
				UINT8 Bit1:1 = this.ToBitString + " cancel_pending - " + ( this ? "SET, Cancel pending at the call end." : "NOT set, Cancel NOT pending at the call end." );
				UINT8 Bit0:1 = this.ToBitString + " reserved_01 - Reserved for use by implementations.";
			};
		}
	}
	struct PackedDrep = UINT32( FrameData, Offset )
	{
		[MSRPCPackedDrep, MSRPCByteOrder = (this & 0x10) ? LittleEndian : BigEndian]
		UINT8 Octet0 = FormatString("0x%02X - %s Integer, %s Character representation", this, 
										 (this & 0x10) ? "Little-endian" : "Big-endian", 
										 (this & 0x01) ? "EBCDIC" : "ASCII");
		[MSRPCFloatType = this]
		UINT8 Octet1 = FormatString("0x%02X - ", this) 
										 + MSRPCFloatingPointRepresentation( this ) + " Floating Point representation";
		UINT8 Octet2 = FormatString("0x%02X - Reserved", this);
	}
	UINT8	SerialHi;
	MSRPCUuidT	Object;
	[MSRPCIfUuid = ifId.ToString]
	MSRPCUuidT	IfId;
	[property.MSRPCInterfaceName = UUIDTable( property.MSRPCIfUuid )]
	[BuildConversation( ActId.ToString )]
	[MSRPCActId = ActId.ToString]
	MSRPCUuidT	ActId;
	UNIXTIMESTAMP	ServerBoot;
	[MSRPCIfVers]
	UINT32	IfVers;
	[MSRPCSeqnum]
	UINT32	Seqnum;
	[MSRPCOpnum]
	UINT16	Opnum;
	UINT16	IHint;
	UINT16	AHint;
	UINT16	Len;
	UINT16	Fragnum;
	UINT8	AuthProto = MSRPCAuthenticationProtocolIdentifiers( this );
	[MSRPCSummary = FormatString( "dg %s:  Seq=0x%X  Opnum=0x%X  Frag=0x%X  Serial=0x%X  Act Id=%s", 
	MSRPCPTypeTable(PType), Seqnum, Opnum, Fragnum, SerialLo, ActId.ToString )]
	UINT8	SerialLo;
}


struct MSRPCDgFault
{
	MSRPCDcRpcClPktHdrT DgHeader;
	[DataFieldFrameLength = FrameOffset + DgHeader.len]
	struct DgFaultBodyT {
		UINT32 St = FormatString( "0x%08X %s", this, MSRPCRejectStatusCodes( this ) );
		switch {
			case FrameLength > FrameOffset :
				BLOB( FrameLength - FrameOffset ) BodyPadding;
		}
	}
	Switch {
		Case DgHeader.AuthProto != 0:
			struct {
				switch {
					case DgHeader.AuthProto == 1:
						ALIGN8 pad;
				}
				MSRPCAuthTrailerClT AuthVerifier;
			}
	}
}

struct MSRPCDgCancelAck
{
	MSRPCDcRpcClPktHdrT DgHeader;
	[DataFieldFrameLength = FrameOffset + DgHeader.len]
	struct DgCancelAckBodyT {
		UINT32 Vers;
		UINT32 CancelId;
		UINT8  ServerIsAccepting = this != 0 ? "True" : "False";
		switch {
			case FrameLength > FrameOffset :
				BLOB( FrameLength - FrameOffset ) BodyPadding;
		}
	}
	Switch {
		Case DgHeader.AuthProto != 0:
			struct {
				switch {
					case DgHeader.AuthProto == 1:
						ALIGN8 pad;
				}
				MSRPCAuthTrailerClT AuthVerifier;
			}
	}
	
}

struct MSRPCDgCancel
{
	MSRPCDcRpcClPktHdrT DgHeader;
	[DataFieldFrameLength = FrameOffset + DgHeader.len]
	struct DgCancelBodyT {
		UINT32 Vers;
		UINT32 CancelId;
		switch {
			case FrameLength > FrameOffset :
				BLOB( FrameLength - FrameOffset ) BodyPadding;
		}
	}
	Switch {
		Case DgHeader.AuthProto != 0:
			struct {
				switch {
					case DgHeader.AuthProto == 1:
						ALIGN8 pad;
				}
				MSRPCAuthTrailerClT AuthVerifier;
			}
	}
}

struct MSRPCDgFack
{
	MSRPCDcRpcClPktHdrT DgHeader;
	[DataFieldFrameLength = FrameOffset + DgHeader.len]
	struct DgFackBodyT {
		UINT8	Vers;
		UINT8	Pad1;
		UINT16	WindowSize;
		UINT32	MaxTsdu;
		UINT32	MaxFragSize;
		UINT16	SerialNum;
		UINT16	SelackLen;
		UINT32	Selack[SelackLen];
		switch {
			case FrameLength > FrameOffset :
				BLOB( FrameLength - FrameOffset ) BodyPadding;
		}
	}
	Switch {
		Case DgHeader.AuthProto != 0:
			struct {
				switch {
					case DgHeader.AuthProto == 1:
						ALIGN8 pad;
				}
				MSRPCAuthTrailerClT AuthVerifier;
			}
	}
}

struct MSRPCDgRequest
{
	MSRPCDcRpcClPktHdrT DgHeader;
	[Conversation.MSRPCOpnumTable$[MSRPCSeqnum] = MSRPCOpnum]
	[Conversation.MSRPCUUIDTable$[MSRPCSeqnum] = MSRPCIfUuid]
	[Conversation.MSRPCIfVersTable$[MSRPCSeqnum] = MSRPCIfVers]
	[DataFieldFrameLength = Offset + DgHeader.len]
	[PayloadStart(
			NetworkDirection,		//direction
			DgHeader.seqnum,		//identifier
			DgHeader.fragnum,		//sequence token
			DgHeader.fragnum+1,		//next sequence
			0,						//total payload length
			Property.MSRPCFrag && 
			DgHeader.fragnum == 0,	//is first
			Property.MSRPCLastFrag,	//is last
		    RssmblyIndStartBit+RssmblyIndEndBit+RssmblySequenceBit, 		//has start and end indication
			0x0000,		/* Properties... */
			MSRPCIfUuid,
			0x0000,
			DgHeader.Opnum,
			0x0000,
			DgHeader.PType,
			0x0000,
			DgHeader.AuthProto,
			0x0001,
			DgHeader.Len,
			0x0000,
			0,
			0x0000,
			property.MSRPCPackedDrep,
			0x0000,
			property.MSRPCNdr64,
			0x0000,
			0, //property.MSRPCCallId
			0x0000,
			0),//property.MSRPCPContID
		global.MSRPCAuthProtoTable$[MSRPCActId] = DgHeader.AuthProto]
	[Property.stubdatastart = FrameOffset,DatafieldFramelength = FrameOffset + DgHeader.Len]
	MSRPCStubData StubData;
	Align8 pad;
	Switch {
		Case DgHeader.AuthProto != 0 : MSRPCAuthTrailerClT AuthVerifier;
	}
}

struct MSRPCDgResponse
{
	MSRPCDcRpcClPktHdrT DgHeader;
	[MSRPCOpnum = Conversation.MSRPCOpnumTable$[MSRPCSeqnum]]
	[MSRPCIfUuid = Conversation.MSRPCUUIDTable$[MSRPCSeqnum]]
	[MSRPCIfVers = Conversation.MSRPCIfVersTable$[MSRPCSeqnum]]
	//TSGU opnum8 respone don't need reassmbly .it doesn't match strict NDR rule
	[Local.MSRPCTSGURDPData = property.MSRPCIfUuid == "{44e265dd-7daf-42cd-8560-3cdb6e7a2729}" && Property.MSRPCOpnum == 0x8]
	[DataFieldFrameLength = Offset + DgHeader.len]
	[PayloadStart(
			NetworkDirection,		//direction
			DgHeader.seqnum,		//identifier
			DgHeader.fragnum,		//sequence token
			DgHeader.fragnum+1,		//next sequence
			0,						//total payload length
			!Property.MSRPCFrag || (Property.MSRPCFrag && DgHeader.fragnum == 0) || Local.MSRPCTSGURDPData,	    //is first
			!Property.MSRPCFrag || (Property.MSRPCFrag && Property.MSRPCLastFrag) || Local.MSRPCTSGURDPData,	//is last
		    RssmblyIndStartBit+RssmblyIndEndBit+RssmblySequenceBit, 		//has start and end indication
			0x0000,		/* Properties... */
			MSRPCIfUuid,
			0x0000,
			MSRPCOpnum,
			0x0000,
			DgHeader.PType,
			0x0000,
			DgHeader.AuthProto,
			0x0001,
			DgHeader.Len,
			0x0000,
			1,
			0x0000,
			property.MSRPCPackedDrep,
			0x0000,
			property.MSRPCNdr64,
			0x0000,
			0, //property.MSRPCCallId
			0x0000,
			0),//property.MSRPCPContID
		global.MSRPCAuthProtoTable$[MSRPCActId] = DgHeader.AuthProto]
	[Property.stubdatastart = FrameOffset,DatafieldFramelength = FrameOffset + DgHeader.Len]
	MSRPCStubData StubData;
	Align8 pad;
	Switch {
		Case DgHeader.AuthProto != 0 : MSRPCAuthTrailerClT AuthVerifier;
	}
}

struct MSRPCDgNoCall
{
	MSRPCDcRpcClPktHdrT DgHeader;
	switch {
		case DgHeader.Len > 0:
			[DataFieldFrameLength = FrameOffset + DgHeader.len]
			struct DgNoCallBodyT {
				UINT8	Vers;
				UINT8	Pad1;
				UINT16	WindowSize;
				UINT32	MaxTsdu;
				UINT32	MaxFragSize;
				UINT16	SerialNum;
				UINT16	SelackLen;
				UINT32	Selack[SelackLen];
				switch{
					case FrameLength > FrameOffset :
						BLOB( FrameLength - FrameOffset ) BodyPadding;
				}
			}
	}
	Switch {
		Case DgHeader.AuthProto != 0:
			struct {
				switch {
					case DgHeader.AuthProto == 1:
						ALIGN8 pad;
				}
				MSRPCAuthTrailerClT AuthVerifier;
			}
	}
}

struct MSRPCDgPing
{
	MSRPCDcRpcClPktHdrT DgHeader;
	Switch {
		Case DgHeader.AuthProto != 0 : MSRPCAuthTrailerClT AuthVerifier;
	}
}

struct MSRPCDgWorking
{
	MSRPCDcRpcClPktHdrT DgHeader;
	Switch {
		Case DgHeader.AuthProto != 0 : MSRPCAuthTrailerClT AuthVerifier;
	}
}

struct MSRPCDgAck
{
	MSRPCDcRpcClPktHdrT DgHeader;
	Switch {
		Case DgHeader.AuthProto != 0 : MSRPCAuthTrailerClT AuthVerifier;
	}
}

struct MSRPCStubData
{
	switch
	{
		case !(ConvID > 0):
		_struct ReportWarning
		{
			ReportParserWarning( "MSRPC", "May not parsed correctly when conversation off") ParserWarning;
		};
	}
	[DataFieldByteOrder = Property.MSRPCByteOrder]
	switch (property.MSRPCIfUuid)
	{
		Case "{3DDE7C30-165D-11D1-AB8F-00805F14DB40}": BKRP BKRP;
		Case "{E3D0D746-D2AF-40FD-8A7A-0D7078BB7092}": BPAU BPAU;
		Case "{6BFFD098-A112-3610-9833-012892020162}": BRWSA brwsa;
		Case "{B97DB8B2-4C63-11CF-BFF6-08002BE23F2F}": CMRP cmrp;
		Case "{333A2276-0000-0000-0D00-00809C000000}": CONV Conv;
		Case "{12108A88-6858-4467-B92F-E6CF4568DFB6}": //CSVP - IClusterStorage2
		Case "{2931C32C-F731-4c56-9FEB-3D5F1C5E72BF}": //CSVP - IClusterNetwork2
		case "{D6105110-8917-41A5-AA32-8E0AA2933DC9}": //CSVP - IClusterCleanup
		case "{491260B5-05C9-40D9-B7F2-1F7BDAE0927F}": //CSVP - IClusterSetup
		case "{85923CA7-1B6B-4E83-A2E4-F5BA3BFBB8A3}": //CSVP - IClusterLog
													CSVP Csvp;
		Case "{4FC742E0-4A10-11CF-8273-00AA004AE673}": DFSNMGMT DFSNMgmt;
		Case "{897e2e5f-93f3-4376-9c9c-fd2277495c27}": FRS2 Frs2;
		Case "{6BFFD098-A112-3610-9833-46C3F874532D}":
		Case "{5B821720-F63B-11D0-AAD2-00C04FC324DB}":
													DHCPM Dhcpm;
		Case "{4DA1C422-943D-11D1-ACAE-00C04FC2AA3F}": //DLT - TrkSvr
		Case "{300F3532-38CC-11D0-A3F0-0020AF6B0ADD}": //DLT - TrkWks
													DLT Dlt;
		Case "{50ABC2A4-574D-40B3-9D66-EE4FD5FBA076}": DNSP DNSP;
		Case "{E3514235-4B06-11D1-AB04-00C04FC2DCD2}":
		Case "{7c44d7d4-31d5-424c-bd5e-2b3e1f323d22}":
												 DRSR Drsr;			
		Case "{3919286A-B10C-11D0-9BA8-00C04FD92EF5}": DSSETUP DsSetup;
		Case "{C681D488-D850-11D0-8C52-00C04FD90F7E}": 
		Case "{DF1941C5-fE89-4E79-BF10-463657ACf44D}": EFSR EFSR;
		Case "{E1AF8308-5D1F-11C9-91A4-08002B14A0FA}": EPM Epm;
		Case "{82273FDC-E32A-18C3-3F78-827929DC23EA}": //EventLog - EventLog
													EVEN EventLog;		
		Case "{F6BEAFF7-1E19-4FBB-9F8F-B89E2018337C}": //EventLog - IEventService
													EVEN6 EventLog6;
		Case "{6b5bdd1e-528c-422c-af8c-a4079be4fe48}": FASP FASP; // All Encrypted
		Case "{6099FC12-3EFF-11D0-ABD0-00C04FD91A4E}": //FAX - FaxClient
		Case "{EA0A3165-4834-11D2-A6F8-00C04FA346CC}": //FAX - Fax
													FAX Fax;
		Case "{D049B186-814F-11D1-9A3C-00C04FC9B232}": //FRS - FRSAPI
		Case "{F5CC59B4-4264-101A-8C59-08002B2F8426}": //FRS - FRSRPC
													FRS1 Frs1;
		Case "{91AE6020-9E3C-11CF-8D7C-00AA00C091BE}": ICPR ICPR;
		Case "{82AD4280-036B-11CF-972C-00AA006887B0}": INETINFO InetInfo;
		Case "{12345778-1234-ABCD-EF00-0123456789AB}": 
			switch (Property.MSRPCOpnum)
			{
				case 0x000E:
				case 0x000F:
				case 0x002D:
				Case 0x0039:
				Case 0x003A:
				Case 0x0044:
				Case 0x004C:
				Case 0x004D:
					LSAT Lsat;
				default:
					LSAD Lsad;
			}
		Case "{AFA8BD80-7D8A-11C9-BEF4-08002B102989}": MGMT MGMT;
		Case "{17FDD703-1827-4E34-79D4-24A55C53BB37}": MSGSVC MsgSvc;
		Case "{5A7B91F8-FF00-11D0-A9B2-00C04FB6E6FC}": MSGSVCSend MsgSvcSend;
		Case "{77DF7A80-F298-11D0-8358-00A024C480A8}": //MSMQR - DSCOMM
		Case "{708CCA10-9569-11D1-B2A5-0060977D8118}": //MSMQR - DSCOMM2
													MQDS Mqds;
		Case "{FDB3A030-065F-11D1-BB9B-00A024EA5525}": //MSMQR - QmComm
		Case "{76D12B80-3467-11D3-91FF-0090272F9EA3}": //MSMQR - QmComm2
													MQMP Mqmp;
		Case "{41208EE0-E970-11D1-9B9E-00E02C064C39}": //MSMQR - QmMgmt
													MQMR Mqmr;
		Case "{1088A980-EAE5-11D0-8D9B-00A02453C337}": //MSMQR - Qm2Qm
													MQQP Mqqp;
		Case "{1A9134DD-7B39-45BA-AD88-44D01CA47F28}": //MSMQR - RemoteRead
													MQRR Mqrr;
		Case "{12345678-1234-ABCD-EF00-01234567CFFB}": NRPC NRPC;
		Case "{906B0CE0-C70B-1067-B317-00DD010662DA}": CMPO CMPO;
		Case "{DA5A86C5-12C2-4943-AB30-7F74A813D853}": Pcq pcq;
		Case "{8D9F4E40-A03D-11CE-8F69-08003E30051B}": PNPR PNPR;
		Case "{0B6EDBFA-4A24-4FC6-8A23-942B1ECA65D1}": //PrintANot - IRPCAsyncNotify
		Case "{AE33069B-A2A8-46EE-A235-DDFD339BE281}": //PrintANot - IRPCRemoteObject
													PrintANot PrintANot;
		Case "{76F03F96-CDFD-44FC-A22C-64950A001209}": PAR Par;
		Case "{E33C0CC4-0482-101A-BC0C-02608C6BA218}": //RPCL - LOCtoLOC
		Case "{D3FBB514-0E3B-11CB-8FAD-08002B1D29C3}": //RPCL - NsiC
		Case "{D6D70EF0-0E3B-11CB-ACC3-08002B1D29C4}": //RPCL - NsiM
		Case "{D6D70EF0-0E3B-11CB-ACC3-08002B1D29C3}": //RPCL - NsiS
													RPCL RPCL;
		Case "{894DE0C0-0D55-11D3-A322-00C04FA321A1}": //RSP - InitShutdown
		Case "{D95AFE70-A6D5-4259-822E-2C84DA1DDB0D}": //RSP - WindowsShutdown
													RSP Rsp;
		Case "{338CD001-2244-31F1-AAAA-900038001003}": RRP Rrp;
		Case "{8f09f000-b7ed-11ce-bbd2-00001a181cad}": RRASM Rrasm;
		Case "{F5CC5A7C-4264-101A-8C59-08002B2F8426}": RXDS Rxds;
		Case "{12345778-1234-ABCD-EF00-0123456789AC}": SAMR Samr;
		Case "{4B324FC8-1670-01D3-1278-5A47BF6EE188}": SRVS SrvS;
		Case "{367ABB81-9844-35F1-AD32-98F038001003}": SCMR Scmr;						
		Case "{2F5F6521-CA47-1068-B319-00DD010662DB}": //TRP - RemoteSP;
		Case "{2F5F6520-CA46-1067-B319-00DD010662DA}": //TRP - TapSrv;
													TRP Trp;
		Case "{378E52B0-C0A9-11CF-822D-00AA0051E40F}": TSCH SaSec;
		Case "{1FF70682-0A51-30E8-076D-740BE8CEE98B}": TSCH AtSvc;
		Case "{86D35949-83C9-4044-B424-DB363231FD0C}": TSCH SchRpc;
		Case "{11899a43-2b68-4a76-92e3-a3d6ad8c26ce}": //TSTS - TermSrvNotification
		Case "{484809d6-4239-471b-b5bc-61df8c23ac48}": //TSTS - TermSrvSession
		Case "{bde95fdf-eee0-45de-9e12-e5a61cd0d4fe}": //TSTS - RCMPublic
		Case "{88143fd0-c28d-4b2b-8fef-8d882f6a9390}": //TSTS - TermSrvEnumeration
		Case "{497d95a6-2d27-4bf5-9bbd-a6046957133c}": //TSTS - RCMListener
		Case "{2f59a331-bf7d-48cb-9e5c-7c090d76e8b8}": //TSTS - LCRPC
		Case "{5ca4a760-ebb1-11cf-8611-00a0245420ed}": //TSTS - IcaApi
													TSTS Tsts;							
		Case "{8FB6D884-2388-11D0-8C35-00C04FDA2795}": W32T W32T;
		Case "{12345678-1234-ABCD-EF00-0123456789AB}": RPRN RPRN;
		Case "{6BFFD098-A112-3610-9833-46C3F87E345A}": WKST Wkst;
		//DCOM interfaces
		Case "{D99E6E71-FC88-11D0-B498-00A0C90312F3}": //CertAdmin - ICertAdminD
		Case "{7FE0D935-DDA6-443F-85D0-1CFB58FE41DD}": //CertAdmin - ICertAdminD2
		Case "{4E14FB9F-2E22-11D1-9964-00C04FBBB345}": //COMPES - IEventSystem
		Case "{FB2B72A0-7A68-11D1-88F9-0080C7D771BF}": //COMPES - IEventClass
		Case "{FB2B72A1-7A68-11D1-88F9-0080C7D771BF}": //COMPES - IEventClass2
		Case "{4A6B0E15-2E38-11D1-9965-00C04FBBB345}": //COMPES - IEventSubscription
		Case "{F4A07D63-2E25-11D1-9964-00C04FBBB345}": //COMPES - IEnumEventObject
		Case "{F89AC270-D4EB-11D1-B682-00805FC79216}": //COMPES - IEventObjectCollection
		Case "{7FB7EA43-2D76-4EA8-8CD9-3DECC270295E}": //COMPES - IEventClass3
		Case "{4A6B0E16-2E38-11D1-9965-00C04FBBB345}": //COMPES - IEventSubscription2
		Case "{FBC1D17D-C498-43A0-81AF-423DDD530AF6}": //COMPES - IEventSubscription3
		Case "{99CC098F-A48A-4E9C-8E58-965C0AFC19D5}": //COMPES - IEventSystem2
		Case "{A0E8F27A-888C-11D1-B763-00C04FB926AF}": //COMPES - IEventSystemInitialize
		Case "{C2BE6970-DF9E-11D1-8B87-00C04FD7A924}": //COMA - iimport
		Case "{0E3D6630-B46B-11D1-9D2D-006008B0E5CA}": //COMA - icatalogtableread
		Case "{971668DC-C3FE-4EA1-9643-0C7230F494A1}": //COMA - iregister2
		Case "{A8927A41-D3CE-11D1-8472-006008B0E5CA}": //COMA - icatalogtableinfo
		Case "{182C40FA-32E4-11D0-818B-00A0C9231C29}": //COMA - icatalogsession
		Case "{CFADAC84-E12C-11D1-B34C-00C04F990D54}": //COMA - iexport
		Case "{1F7B1697-ECB2-4CBB-8A0E-75C427F4A6F0}": //COMA - iimport2
		Case "{47CDE9A1-0BF6-11D2-8016-00C04FB9988E}": //COMA - icapabilitysupport
		Case "{6C935649-30A6-4211-8687-C4C83E5FE1C7}": //COMA - icontainercontrol2
		Case "{F131EA3E-B7BE-480E-A60D-51CB2785779E}": //COMA - iexport2
		Case "{C726744E-5735-4F08-8286-C510EE638FB6}": //COMA - ICatalogUtils2
		Case "{456129E2-1078-11D2-B0F9-00805FC73204}": //COMA - icatalogutils
		Case "{3F3B1B86-DBBE-11D1-9DA6-00805F85CFE3}": //COMA - icontainercontrol
		Case "{7F43B400-1A0E-4D57-BBC9-6B0C65F7A889}": //COMA - ialternatelaunch
		Case "{8DB2180E-BD29-11D1-8B7E-00C04FD7A924}": //COMA - iregister
		Case "{0E3D6631-B46B-11D1-9D2D-006008B0E5CA}": //COMA - icatalogtablewrite
		Case "{1D118904-94B3-4A64-9FA6-ED432666A7B9}": //COMA - icatalog64bitsupport
		Case "{98315903-7BE5-11D2-ADC1-00A02463D6E7}": //COMA - IReplicationUtil
		Case "{4E6CDCC9-FB25-4FD5-9CC5-C9F4B6559CEC}": //COMPTS - icomtrackinginfoevents
		Case "{B60040E0-BCF3-11D1-861D-0080C729264D}": //COMPTS - igettrackingdata
		Case "{00000131-0000-0000-C000-000000000046}": //DCOM - IRemUnknown
		Case "{00000143-0000-0000-C000-000000000046}": //DCOM - IRemUnknown2
		Case "{4D9F4AB8-7D1C-11CF-861E-0020AF6E7C57}": //DCOM - IActivation;
		Case "{99FCFEC4-5260-101B-BBCB-00AA0021347A}": //DCOM - IObjectExporter;
		Case "{000001A0-0000-0000-C000-000000000046}": //DCOM - IRemoteSCMActivator;
		Case "{8165B19E-8D3A-4D0B-80C8-97DE310DB583}": //DCOM - IServicedComponentInfo;
		Case "{C3FCC19E-A970-11D2-8B5A-00A0C9B7C9C4}": //DCOM - IManagedObject;
		Case "{6619A740-8154-43BE-A186-0319578E02DB}": //DCOM - IRemoteDispatch;
		Case "{D2D79DF7-3400-11D0-B40B-00AA005FF586}": //DMR - IDMNotify
		Case "{3A410F21-553F-11D1-8E5E-00A0C92C9D5D}": //DMR - IDMRemoteServer;
		Case "{D2D79DF5-3400-11D0-B40B-00AA005FF586}": //DMR - IVolumeClient;
		Case "{4BDAFC52-FE6A-11D2-93F8-00105A11164A}": //DMR - IVolumeClient2;
		Case "{135698D2-3A37-4D26-99DF-E2BB6AE3AC61}": //DMR - IVolumeClient3;
		Case "{DEB01010-3A37-4D26-99DF-E2BB6AE3AC61}": //DMR - IVolumeClient4;
		Case "{118610B7-8D94-4030-B5B8-500889788E4E}": //DMR - IEnumVdsObject;
		Case "{6E6F6B40-977C-4069-BDDD-AC710059F8C0}": //DMR - IVdsAdvancedDisk;
		Case "{8326CD1D-CF59-4936-B786-5EFC08798E25}": //DMR - IVdsAdviseSink;
		Case "{D5D23B6D-5A55-4492-9889-397A3C2D2DBC}": //DMR - IVdsAsync;
		Case "{07E5C822-F00C-47A1-8FCE-B244DA56FD06}": //DMR - IVdsDisk;
		Case "{3B69D7F5-9D94-4648-91CA-79939BA263BF}": //DMR - IVdsPack;
		Case "{10C5E575-7984-4E81-A56B-431F5F92AE42}": //DMR - IVdsProvider;
		Case "{0316560B-5DB4-4ED9-BBB5-213436DDC0D9}": //DMR - IVdsRemovable;
		Case "{0818A8EF-9BA9-40D8-A6F9-E22833CC771E}": //DMR - IVdsService;
		Case "{E0393303-90D4-4A97-AB71-E9B671EE2729}": //DMR - IVdsServiceLoader;
		Case "{9AA58360-CE33-4F92-B658-ED24B14425B8}": //DMR - IVdsSwProvider;
		Case "{88306BB2-E71F-478C-86A2-79DA200A0F11}": //DMR - IVdsVolume;
		Case "{EE2D5DED-6236-4169-931D-B9778CE03DC6}": //DMR - IVdsVolumeMF;
		Case "{4DAA0135-E1D1-40F1-AAA5-3CC1E53221C3}": //DMR - IVdsVolumePlex;
		Case "{2ABD757F-2851-4997-9A13-47D2A885D6CA}": //DMR - IVdsHbaPort;
		Case "{B07FEDD4-1682-4440-9189-A39B55194DC5}": //DMR - IVdsIscsiInitiatorAdapter;
		Case "{38A0A9AB-7CC8-4693-AC07-1F28BD03C3DA}": //DMR - IVdsIscsiInitiatorPortal;
		Case "{0AC13689-3134-47C6-A17C-4669216801BE}": //DMR - IVdsServiceHba;
		Case "{14FBE036-3ED7-4E10-90E9-A5FF991AFF01}": //DMR - IVdsServiceIscsi;
		Case "{B6B22DA8-F903-4BE7-B492-C09D875AC9DA}": //DMR - IVdsServiceUninstallDisk;
		Case "{83BFB87F-43FB-4903-BAA6-127F01029EEC}": //DMR - IVdsSubSystemImportTarget;
		Case "{13B50BFF-290A-47DD-8558-B7C58DB1A71A}": //DMR - IVdsPack2;
		Case "{40F73C8B-687D-4A13-8D96-3D7F2E683936}": //DMR - IVdsDisk2;
		Case "{9723F420-9355-42DE-AB66-E31BB15BEEAC}": //DMR - IVdsAdvancedDisk2;
		Case "{4DBCEE9A-6343-4651-B85F-5E75D74D983C}": //DMR - IVdsVolumeMF2;
		Case "{538684E0-BA3D-4BC0-ACA9-164AFF85C2A9}": //DMR - IVdsDiskPartitionMF;
		Case "{D68168C9-82A2-4F85-B6E9-74707C49A58F}": //DMR - IVdsVolumeShrink;
		Case "{1BE2275A-B315-4F70-9E44-879B3A2A53F2}": //DMR - IVdsVolumeOnline;
		Case "{B481498C-8354-45F9-84A0-0BDD2832A91F}": // VDS - IVdsVdProvider Interface
		Case "{4AFC3636-DB01-4052-80C3-03BBCB8D3C69}": // VDS - IVdsServiceInitialization Interface
		Case "{6788FAF9-214E-4B85-BA59-266953616E09}": // VDS - IVdsVolumeMF3 Interface
		Case "{D99BDAAE-B13A-4178-9FDB-E27F16B4603E}": // VDS - IVdsHwProvider Interface
		Case "{90681B1D-6A7F-48E8-9061-31B7AA125322}": // VDS - IVdsDiskOnline Interface
		Case "{FC5D23E8-A88B-41A5-8DE0-2D2F73C5A630}": // VDS - IVdsServiceSAN Interface
		Case "{1E062B84-E5E6-4B4B-8A25-67B81E8F13E8}": // VDS - IVdsVDisk Interface
		Case "{9CBE50CA-F2D2-4BF4-ACE1-96896B729625}": // VDS - IVdsDiskPartitionMF2 Interface
		Case "{9882F547-CFC3-420B-9750-00DFBEC50662}": // VDS - IVdsCreatePartitionEx Interface
		Case "{8F4B2F5D-EC15-4357-992F-473EF10975B9}": // VDS - IVdsDisk3 Interface
		Case "{72AE6713-DCBB-4A03-B36B-371F6AC6B53D}": // VDS - IVdsVolume2 Interface
		Case "{F76FBF3B-8DDD-4B42-B05A-CB1C3FF1FEE8}": //FSRM - IFsrmCollection
		Case "{1BB617B8-3886-49DC-AF82-A6C90FA35DDA}": //FSRM - IFsrmMutableCollection
		Case "{96DEB3B5-8B91-4A2A-9D93-80A35D8AA847}": //FSRM - IFsrmCommittableCollection
		Case "{6CD6408A-AE60-463B-9EF1-E117534D69DC}": //FSRM - IFsrmAction
		Case "{D646567D-26AE-4CAA-9F84-4E0AAD207FCA}": //FSRM - IFsrmActionEmail
		Case "{8276702F-2532-4839-89BF-4872609A2EA4}": //FSRM - IFsrmActionEmail2
		Case "{2DBE63C4-B340-48A0-A5B0-158E07FC567E}": //FSRM - IFsrmActionReport
		Case "{4C8F96C3-5D94-4F37-A4F4-F56AB463546F}": //FSRM - IFsrmActionEventLog
		Case "{12937789-E247-4917-9C20-F3EE9C7EE783}": //FSRM - IFsrmActionCommand
		Case "{22BCEF93-4A3F-4183-89F9-2F8B8A628AEE}": //FSRM - IFsrmObject
		Case "{F411D4FD-14BE-4260-8C40-03B7C95E608A}": //FSRM - IFsrmSetting
		Case "{6F4DBFFF-6920-4821-A6C3-B7E94C1FD60C}": //FSRM - IFsrmPathMapper
		Case "{EFCB0AB1-16C4-4A79-812C-725614C3306B}": //FSRM - IFsrmExportImport
		Case "{39322A2D-38EE-4D0D-8095-421A80849A82}": //FSRM - IFsrmDerivedObjectsResult
		Case "{1568A795-3924-4118-B74B-68D8F0FA5DAF}": //FSRM - IFsrmQuotaBase
		Case "{42DC3511-61D5-48AE-B6DC-59FC00C0A8D6}": //FSRM - IFsrmQuotaObject
		Case "{377F739D-9647-4B8E-97D2-5FFCE6D759CD}": //FSRM - IFsrmQuota
		Case "{F82E5729-6ABA-4740-BFC7-C7F58F75FB7B}": //FSRM - IFsrmAutoApplyQuota
		Case "{8BB68C7D-19D8-4FFB-809E-BE4FC1734014}": //FSRM - IFsrmQuotaMaagern
		Case "{A2EFAB31-295E-46BB-B976-E86D58B52E8B}": //FSRM - IFsrmQuotaTemplate
		Case "{9A2BF113-A329-44CC-809A-5C00FCE8DA40}": //FSRM - IFsrmQuotaTemplateImported
		Case "{4173AC41-172D-4D52-963C-FDC7E415F717}": //FSRM - IFsrmQuotaTemplateManager
		Case "{8DD04909-0E34-4D55-AFAA-89E1F1A1BBB9}": //FSRM - IFsrmFileGroup
		Case "{AD55F10B-5F11-4BE7-94EF-D9EE2E470DED}": //FSRM - IFsrmFileGroupImported
		Case "{426677D5-018C-485C-8A51-20B86D00BDC4}": //FSRM - IFsrmFileGroupManager
		Case "{F3637E80-5B22-4A2B-A637-BBB642B41CFC}": //FSRM - IFsrmFileScreenBase
		Case "{5F6325D3-CE88-4733-84C1-2D6AEFC5EA07}": //FSRM - IFsrmFileScreen
		Case "{BEE7CE02-DF77-4515-9389-78F01C5AFC1A}": //FSRM - IFsrmFileScreenException
		Case "{FF4FA04E-5A94-4BDA-A3A0-D5B4D3C52EBA}": //FSRM - IFsrmFileScreenManager
		Case "{205BEBF8-DD93-452A-95A6-32B566B35828}": //FSRM - IFsrmFileScreenTemplate
		Case "{E1010359-3E5D-4ECD-9FE4-EF48622FDF30}": //FSRM - IFsrmFileScreenTemplateImported
		Case "{CFE36CBA-1949-4E74-A14F-F1D580CEAF13}": //FSRM - IFsrmFileScreenTemplateManager
		Case "{27B899FE-6FFA-4481-A184-D3DAADE8A02B}": //FSRM - IFsrmReportManager
		Case "{38E87280-715C-4C7D-A280-EA1651A19FEF}": //FSRM - IFsrmReportJob
		Case "{D8CC81D9-46B8-4FA4-BFA5-4AA9DEC9B638}": //FSRM - IFsrmReport
		Case "{6879CAF9-6617-4484-8719-71C3D8645F94}": //FSRM - IFsrmReportScheduler
		Case "{EE321ECB-D95E-48E9-907C-C7685A013235}": //FSRM - IFsrmFileManagementJobManager
		Case "{0770687E-9F36-4D6F-8778-599D188461C9}": //FSRM - IFsrmFileManagementJob
		Case "{326AF66F-2AC0-4F68-BF8C-4759F054FA29}": //FSRM - IFsrmPropertyCondition
		Case "{EDE0150F-E9A3-419C-877C-01FE5D24C5D3}": //FSRM - IFsrmPropertyDefinition
		Case "{4A73FEE4-4102-4FCC-9FFB-38614F9EE768}": //FSRM - IFsrmProperty
		Case "{CB0DF960-16F5-4495-9079-3F9360D831DF}": //FSRM - IFsrmRule
		Case "{AFC052C2-5315-45AB-841B-C6DB0E120148}": //FSRM - IFsrmClassificationRule
		Case "{515C1277-2C81-440E-8FCF-367921ED4F59}": //FSRM - IFsrmPipelineModuleDefinition
		Case "{BB36EA26-6318-4B8C-8592-F72DD602E7A5}": //FSRM - IFsrmClassifierModuleDefinition
		Case "{B15C0E47-C391-45B9-95C8-EB596C853F3A}": //FSRM - IFsrmClassificationManager
		Case "{E8FB8620-588F-11D2-9D61-00C04F79C5FE}": //IISSvcCtl
		Case "{70B51430-B6CA-11D0-B9B9-00A0C922E750}": //IMSAdminBaseW - IMSAdminBaseW;
		Case "{8298D101-F992-43B7-8ECA-5052D885B995}": //IMSAdminBaseW - IMSAdminBase2W;
		Case "{F612954D-3B0B-4C56-9563-227B7BE624B4}": //IMSAdminBaseW - IMSAdminBase3W;
		Case "{29822AB8-F302-11D0-9953-00C04FD919C1}": //IWamAdmin2
		Case "{29822AB7-F302-11D0-9953-00C04FD919C1}": //IWamAdmin
		Case "{7C4E1804-E342-483D-A43E-A850CFCC8D18}": //IIISApplicationAdmin
		Case "{BD0C73BC-805B-4043-9C30-9A28D64DD7D2}": //IIISCertObj
		Case "{784B693D-95F3-420B-8126-365C098659F2}": //OCSPA - IOcspAdminD
		Case "{00020400-0000-0000-C000-000000000046}": //OLEAUT - IDispatch
		Case "{00020404-0000-0000-C000-000000000046}": //OLEAUT - IEnumVariant
		Case "{0000002F-0000-0000-C000-000000000046}": //OLEAUT - IID_IRecordInfo
		Case "{00020403-0000-0000-C000-000000000046}": //OLEAUT - IID_ITypeComp
		Case "{00020401-0000-0000-C000-000000000046}": //OLEAUT - IID_ITypeInfo
		Case "{00020412-0000-0000-C000-000000000046}": //OLEAUT - IID_ITypeInfo2
		Case "{00020402-0000-0000-C000-000000000046}": //OLEAUT - IID_ITypeLib
		Case "{00020411-0000-0000-C000-000000000046}": //OLEAUT - IID_ITypeLib2
		case "{03837520-098b-11d8-9414-505054503030}": //PLA IDataCollectorSet
		case "{03837541-098b-11d8-9414-505054503030}": //PLA IDataManager
		case "{03837543-098b-11d8-9414-505054503030}": //PLA IFolderAction
		case "{03837544-098b-11d8-9414-505054503030}": //PLA IFolderActionCollection
		Case "{038374FF-098B-11D8-9414-505054503030}": //PLA - IDataCollector
		Case "{03837506-098B-11D8-9414-505054503030}": //PLA - IPerformanceCounterDataCollector
		Case "{03837514-098B-11D8-9414-505054503030}": //PLA - IConfigurationDataCollector
		Case "{03837516-098B-11D8-9414-505054503030}": //PLA - IAlertDataCollector
		Case "{0383750B-098B-11D8-9414-505054503030}": //PLA - ITraceDataCollector
		Case "{0383751A-098B-11D8-9414-505054503030}": //PLA - IApiTracingDataCollector
		Case "{03837512-098B-11D8-9414-505054503030}": //PLA - ITraceDataProvider
		Case "{0383753A-098B-11D8-9414-505054503030}": //PLA - ISchedule
		Case "{03837510-098B-11D8-9414-505054503030}": //PLA - ITraceDataProviderCollection
		Case "{0383753D-098B-11D8-9414-505054503030}": //PLA - IScheduleCollection
		Case "{03837502-098B-11D8-9414-505054503030}": //PLA - IDataCollectorCollection
		Case "{03837524-098B-11D8-9414-505054503030}": //PLA - IDataCollectorSetCollection
		Case "{03837533-098B-11D8-9414-505054503030}": //PLA - IValueMapItem
		Case "{03837534-098B-11D8-9414-505054503030}": //PLA - IValueMap
		Case "{833E4100-AFF7-4AC3-AAC2-9F24C1457BCE}": //RAPRBIN - IPCHCollection
		Case "{833E4200-AFF7-4AC3-AAC2-9F24C1457BCE}": //RAPRBIN - IPCHService
		Case "{833E41AA-AFF7-4AC3-AAC2-9F24C1457BCE}": //RAPRBIN - ISAFSession
		Case "{F120A684-B926-447F-9DF4-C966CB785648}": //RAPRBIN - IRASrv
		Case "{4E934F30-341A-11D1-8FB1-00A024CB6019}": //RSM - INtmsLibraryControl1;
		Case "{D02E4BE0-3419-11D1-8FB1-00A024CB6019}": //RSM - INtmsMediaServices1;
		Case "{BB39332C-BFEE-4380-AD8A-BADC8AFF5BB6}": //RSM - INtmsNotifySink;
		Case "{69AB7050-3059-11D1-8FAF-00A024CB6019}": //RSM - INtmsObjectInfo1;
		Case "{B057DC50-3059-11D1-8FAF-00A024CB6019}": //RSM - INtmsObjectManagement1;
		Case "{8DA03F40-3419-11D1-8FB1-00A024CB6019}": //RSM - INtmsSession1;
		Case "{879C8BBE-41B0-11D1-BE11-00C04FB6BF70}": //RSM - IClientSink;
		Case "{081E7188-C080-4FF3-9238-29F66D6CABFD}": //RSM - IMessenger;
		Case "{DB90832F-6910-4D46-9F5E-9FD6BFA73903}": //RSM - INtmsLibraryControl2;
		Case "{895A2C86-270D-489D-A6C0-DC2A9B35280E}": //RSM - INtmsObjectManagement2;
		Case "{3BBED8D9-2C9A-4B21-8936-ACB2F995BE6C}": //RSM - INtmsObjectManagement3;
		Case "{7D07F313-A53F-459A-BB12-012C15B1846E}": //RSM - IRobustNtmsMediaServices1;
		Case "{D99E6E70-FC88-11D0-B498-00A0C90312F3}": //WCCE - ICertRequestD
		Case "{5422FD3A-D4B8-4CEF-A12E-E87D4CA22E90}": //WCCE - ICertRequestD2;
		Case "{6C19BE32-7500-11D1-AD94-00C04FD8FDFF}": //WMI - IWbemMetaData;
		Case "{755F9DA6-7508-11D1-AD94-00C04FD8FDFF}": //WMI - IWbemMultiTarget;
		Case "{755F9DA7-7508-11D1-AD94-00C04FD8FDFF}": //WMI - IWbemEventProviderRequirements;
		Case "{37196B38-CCCF-11D2-B35C-00105A1F8177}": //WMI - IWbemSmartMultiTarget;
		Case "{37196B39-CCCF-11D2-B35C-00105A1F8177}": //WMI - IWbemFetchSmartMultiTarget;
		Case "{60E512D4-C47B-11D2-B338-00105A1F4AAF}": //WMI - IWbemFilterProxy;
		Case "{6C19BE34-7500-11D1-AD94-00C04FD8FDFF}": //WMI - IWbemFilterStub;
		Case "{04963311-C399-408E-AD51-05D01506EED0}": //WMI - IWmiObjectSinkSecurity;
		Case "{F1E9C5B2-F59B-11D2-B362-00105A1F8177}": //WMI - IWbemRemoteRefresher;
		Case "{2C9273E0-1DC3-11D3-B364-00105A1F8177}": //WMI - IWbemRefreshingServices;
		Case "{423EC01E-2E35-11D2-B604-00104B703EFD}": //WMI - IWbemWCOSmartEnum;
		Case "{1C1C45EE-4395-11D2-B60B-00104B703EFD}": //WMI - IWbemFetchSmartEnum;
		Case "{D4781CD6-E5D3-44DF-AD94-930EFE48A887}": //WMI - IWbemLoginClientID;
		Case "{92B9503D-19C3-4181-9F42-57FFC1A4BF37}": //WMI - IWinmgmtMofCompilerOOP;
		Case "{2A504CA2-CA90-4731-87BC-6E99CA2019AF}": //WMI - IWmiProvSSSink;
		Case "{E8107BDF-BAAF-4C7C-BB5F-9D732E8D8F07}": //WMI - IWmiProvSS;
		Case "{07435309-D440-41B7-83F3-EB82DB6C622F}": //WMI - IWmiProviderHost;
		Case "{21CD80A2-B305-4F37-9D4C-4534A8D9B568}": //WMI - IWmiProviderFactory;
		Case "{BAC6B661-167E-4957-AD77-286AB256585E}": //WMI - IWmiDynamicPropertyResolver;
		Case "{5FBA5051-3124-4112-B723-46BFBAF1D622}": //WMI - IWmiProviderInitialize;
		Case "{B1B55910-8BA0-47A5-A16E-2B733B1D987C}": //WMI - IWmiProviderStack;
		Case "{06413D98-405C-4A5A-8D6F-19B8B7C6ACF7}": //WMI - IWmiProviderFactoryInitialize;
		Case "{FEC1B0AC-5808-4033-A915-C0185934581E}": //WMI - IWmiProviderSite;
		Case "{EB658B8A-7A64-4DDC-9B8D-A92610DB0206}": //WMI - IWmiProviderQuota;
		Case "{48FF3109-A366-4B56-B340-01FAE758BA64}": //WMI - IWmiProviderAbnormalShutdown;
		Case "{F0E4EDDE-475A-498A-93D7-D4347F68A8F3}": //WMI - IWmiProviderCache;
		Case "{6B3FC272-BF37-4968-933A-6DF9222A2607}": //WMI - IWmiProviderConfiguration;
		Case "{484E3ECE-1F81-4591-B9D4-943BA13B609D}": //WMI - IWmiProviderLoad;
		Case "{41AA40E6-2FBA-4E80-ADE9-34306567206D}": //WMI - IWmiProviderSubsystemRegistrar; 
		Case "{B60EF4F1-A411-462B-B51E-477CBDBB90B4}": //WMI - IWbemRefresherMgr;
		Case "{6963B029-B969-40AA-9180-2B2F84075973}": //WMI - IWbemFetchRefresherMgr;
		Case "{25411283-46FC-4326-8DF2-FF5D34B2DFEF}": //WMI - IWbemConfigureRefreshingSvcs;
		Case "{6919DD07-1637-4611-A8A7-C16FAC5B2D53}": //WMI - InternalIWbemProviderInit;
		Case "{2B322B6E-A9DF-44E3-97BF-259E3583FDA4}": //WMI - InternalIWbemProviderIdentity;
		Case "{F50A28CF-5C9C-4F7E-9D80-E25E16E18C59}": //WMI - InternalIWbemServices;
		Case "{2DB9FA90-9973-46CF-B310-9865B644699D}": //WMI - InternalIWbemObjectSink;
		Case "{AC9EA02A-2C8A-4ACD-B562-D7E8EBEE8E8E}": //WMI - InternalIEnumWbemClassObject;
		Case "{11CAA957-4E80-474E-A819-7FD72148ADA9}": //WMI - InternalIWbemPropertyProvider;
		Case "{FD450835-CF1B-4C87-9FD2-5E0D42FDE081}": //WMI - InternalIWbemEventProvider;
		Case "{DF2373F5-EFB2-475C-AD58-3102D61967D4}": //WMI - InternalIWbemEventProviderSecurity;
		Case "{854D745C-6742-42C0-8BB9-01EC466B6E87}": //WMI - InternalIWbemEventConsumerProvider;
		Case "{88F3781C-6902-4647-9A6B-A74F450AF861}": //WMI - InternalIWbemEventConsumerProviderEx;
		Case "{8A0DC377-A9D3-41CB-BD69-AE1FDAF2DC68}": //WMI - InternalIWbemEventProviderQuerySink;
		Case "{A210BFE9-C9F7-4919-B114-0D98B3D5341E}": //WMI - InternalIWbemUnboundObjectSink;
		Case "{0FC8C622-1728-4149-A57F-AD19D0970710}": //WMI - InternalIWmiProviderConfiguration;
		Case "{E246107B-B06E-11D0-AD61-00C04FD8FDFF}": //WMI - IWbemUnboundObjectSink;
		Case "{E245105B-B06E-11D0-AD61-00C04FD8FDFF}": //WMI - IWbemEventProvider;
		Case "{580ACAF8-FA1C-11D0-AD72-00C04FD8FDFF}": //WMI - IWbemEventProviderQuerySink;
		Case "{631F7D96-D993-11D2-B339-00105A1F4AAF}": //WMI - IWbemEventProviderSecurity;
		Case "{631F7D97-D993-11D2-B339-00105A1F4AAF}": //WMI - IWbemProviderIdentity;
		Case "{E246107A-B06E-11D0-AD61-00C04FD8FDFF}": //WMI - IWbemEventConsumerProvider;
		Case "{1BE41571-91DD-11D1-AEB2-00C04FB68820}": //WMI - IWbemProviderInitSink;
		Case "{1BE41572-91DD-11D1-AEB2-00C04FB68820}": //WMI - IWbemProviderInit;
		Case "{7EC196FE-7005-11D1-AD90-00C04FD8FDFF}": //WMI - IWbemQualifierSet;
		Case "{7C857801-7381-11CF-884D-00AA004B2E24}": //WMI - IWbemObjectSink;
		Case "{027947E1-D731-11CE-A357-000000000001}": //WMI - IEnumWbemClassObject;
		Case "{44ACA675-E8FC-11D0-A07C-00C04FB68820}": //WMI - IWbemCallResult;
		Case "{9556DC99-828C-11CF-A37E-00AA003240C7}": //WMI - IWbemServices;
		Case "{C1E2D759-CABD-11D3-A11B-00105A1F515A}": //WMI - IWbemRawSdAccessor;
		Case "{B7B31DF9-D515-11D3-A11C-00105A1F515A}": //WMI - IWbemShutdown;
		Case "{1CFABA8C-1523-11D1-AD79-00C04FD8FDFF}": //WMI - IUnsecuredApartment;
		Case "{C49E32C7-BC8B-11D2-85D4-00105A1F8304}": //WMI - IWbemBackupRestore;
		Case "{A359DEC5-E813-4834-8A2A-BA7F1D777D76}": //WMI - IWbemBackupRestoreEx;
		Case "{CE61E841-65BC-11D0-B6BD-00AA003240C7}": //WMI - IWbemPropertyProvider;
		Case "{3AE0080A-7E3A-4366-BF89-0FEEDC931659}": //WMI - IWbemEventSink;
		Case "{F309AD18-D86A-11D0-A075-00C04FB68820}": //WMI - IWbemLevel1Login;
		Case "{D8EC9CB1-B135-4F10-8B1B-C7188BB0D186}": //WMI - IWbemConnectorLogin;
		Case "{17CF534A-D8A3-4AD0-AC92-5E3D01717151}": //WMI - IWbemEventConsumerProviderEx;
		Case "{75ABD540-F492-4161-86A5-37FC8898F69E}": //WMI - IWbemSecureObjectSink;
		Case "{541679AB-2E5F-11d3-B34E-00104BCC4B4A}": //WMI - IWbemLoginClientID;
		Case "{BC681469-9DD9-4BF4-9B3D-709F69EFE431}": //WSRM - iwrmresourcegroup
		Case "{59602EB6-57B0-4FD8-AA4B-EBF06971FE15}": //WSRM - iwrmpolicy
		Case "{C5CEBEE2-9DF5-4CDD-A08C-C2471BC144B4}": //WSRM - iresourcemanager
		Case "{4F7CA01C-A9E5-45B6-B142-2332A1339C1D}": //WSRM - iwrmaccounting
		Case "{F31931A9-832D-481C-9503-887A0E6A79F0}": //WSRM - iwrmprotocol
		Case "{21546AE8-4DA5-445E-987F-627FEA39C5E8}": //WSRM - iwrmconfig
		Case "{481E06CF-AB04-4498-8FFE-124A0A34296D}": //WSRM - iwrmcalendar
		Case "{4BB8AB1D-9EF9-4100-8EB6-DD4B4E418B72}": //DFSRH - IADProxy
		Case "{C4B0C7D9-ABE0-4733-A1E1-9FDEDF260C7A}": //DFSRH - IADProxy2
		Case "{E65E8028-83E8-491b-9AF7-AAF6BD51A0CE}": //DFSRH - IServerHealthReport
		Case "{20D15747-6C48-4254-A358-65039FD8C63C}": //DFSRH - IServerHealthReport2
		Case "{FA7DF749-66E7-4986-A27F-E2F04AE53772}": //SCMP - IVssSnapshotMgmt
		Case "{AE1C7110-2F60-11d3-8A39-00C04F72D8E3}": //SCMP - IVssEnumObject
		Case "{214A0F28-B737-4026-B847-4F9E37D79529}": //SCMP - IVssDifferentialSoftwareSnapshotMgmt
		Case "{01954E6B-9254-4e6e-808C-C9E05D007696}": //SCMP - IVssEnumMgmtObject
		Case "{97199110-DB2E-11D1-A251-0000F805CA53}": //COM
		Case "{70184AC9-7673-4770-96B1-445CE035CF70}": //IISA - IAppHostMethodExtension
		Case "{31A83EA0-C0E4-4A2C-8A01-353CC2A4C60A}": //IISA - IAppHostMappingExtension
		Case "{0191775E-BCFF-445A-B4F4-3BDDA54E2816}": //IISA - IAppHostPropertyCollection
		Case "{9BE77978-73ED-4A9A-87FD-13F09FEC1B13}": //IISA - IAppHostAdminManager
		Case "{450386DB-7409-4667-935E-384DBBEE2A9E}": //IISA - IISAIAppHostPropertySchema
		Case "{370AF178-7758-4DAD-8146-7391F6E18585}": //IISA - IAppHostConfigLocation
		Case "{ADA4E6FB-E025-401E-A5D0-C3134A281F07}": //IISA - IAppHostConfigFile
		Case "{8BED2C68-A5FB-4B28-8581-A0DC5267419F}": //IISA - IAppHostPropertySchemaCollection
		Case "{832A32F7-B3EA-4B8C-B260-9A2923001184}": //IISA - IAppHostConfigLocationCollection
		Case "{ED35F7A1-5024-4E7B-A44D-07DDAF4B524D}": //IISA - IAppHostProperty
		Case "{FA7660F6-7B3F-4237-A8BF-ED0AD0DCBBD9}": //IISA - IAppHostWritableAdminManager
		Case "{64FF8CCC-B287-4DAE-B08A-A72CBF45F453}": //IISA - IAppHostElement
		Case "{C8550BFF-5281-4B1E-AC34-99B6FA38464D}": //IISA -	IAppHostElementCollection	
		Case "{09829352-87C2-418D-8D79-4133969A489D}": //IISA - IAppHostChangeHandler
		Case "{B80F3C42-60E0-4AE0-9007-F52852D3DBED}": //IISA - IAppHostMethodInstance
		Case "{E7927575-5CC3-403B-822E-328A6B904BEE}": //IISA - IAppHostPathMapper
		Case "{0F80E901-8F4C-449A-BF90-13D5D082F187}": //IISA - IAppHostPathMapper2
		Case "{8F6D760F-F0CB-4D69-B5F6-848B33E9BDC6}": //IISA - IAppHostConfigManager
		Case "{0716CAF8-7D05-4A46-8099-77594BE91394}": //IISA - IAppHostConstantValue
		Case "{B7D381EE-8860-47A1-8AF4-1F33B2B1F325}": //IISA - IAppHostSectionDefinitionCollection
		Case "{5B5A68E6-8B9F-45E1-8199-A95FFCCDFFFF}": //IISA - IAppHostConstantValueCollection
		Case "{0DD8A158-EBE6-4008-A1D9-B7ECC8F1104B}": //IISA - IAppHostSectionGroup
		Case "{7883CA1C-1112-4447-84C3-52FBEB38069D}": //IISA - IAppHostMethod
		Case "{DE095DB1-5368-4D11-81F6-EFEF619B7BCF}": //IISA - IAppHostCollectionSchema
		Case "{EF13D885-642C-4709-99EC-B89561C6BC69}": //IISA - IAppHostElementSchema
		Case "{D6C7CD8F-BB8D-4F96-B591-D3A5F1320269}": //IISA - IAppHostMethodCollection
		Case "{518EB37D-1FF4-42DD-86C3-3140BC35B823}": //IISA - IAppHostElementExtension
		Case "{88E220F3-33E8-4534-AFAC-B4A98ECCF9AE}": //IISA - IAppHostPropertyExtension
		Case "{08A90F5F-0702-48D6-B45F-02A9885A9768}": //IISA - IAppHostChildElementCollection
		Case "{4DFA1DF3-8900-4BC7-BBB5-D1A458C52410}": //IISA - IAppHostConfigException
		Case "{0344CDDA-151E-4CBF-82DA-66AE61E97754}": //IISA - IAppHostElementSchemaCollection
		Case "{C5C04795-321C-4014-8FD6-D44658799393}": //IISA - IAppHostSectionDefinition
		Case "{2D9915FB-9D42-4328-B782-1B46819FAB9E}": //IISA - IAppHostMethodSchema
		Case "{EAFE4895-A929-41EA-B14D-613E23F62B71}": //IISA - IAppHostPropertyException
		_struct
		{
			DCOM DCOM;
			switch
			{
				case (FrameLength - FrameOffset > 0) &&
				( !(UINT8( Framedata, Offset ) == 0x8A) ||
				  !(UINT8( Framedata, Offset + 1 ) == 0xE3) ||
				  !(UINT8( Framedata, Offset + 2 ) == 0x13) ||
				  !(UINT8( Framedata, Offset + 3 ) == 0x71) ||
				  !(UINT8( Framedata, Offset + 4 ) == 0x02) ||
				  !(UINT8( Framedata, Offset + 5 ) == 0xF4) ||
				  !(UINT8( Framedata, Offset + 6 ) == 0x36) ||
				  !(UINT8( Framedata, Offset + 7 ) == 0x71) ): 
					MSRPCRemainder( Property.AuthLength ) Remainder;
			}
		};
		Case "{F5CC5A18-4264-101A-8C59-08002B2F8426}":
			NSPI NSPI;
		Default:
			Blob( FrameLength - Offset ) MSRPCPayload;
	}
}

Table MSRPCTableSSLContentType( ContentType )
{
	switch( ContentType)
	{
		Case 0x14:	"Cipher Change Spec";
		Case 0x15:	"Alert";
		Case 0x16:	"HandShake";
		Case 0x17:	"Application Data";
		Default:	  "Unknown Content Type";
	}
}

struct MSRPCSSLVersion = FormatString("%s %d.%d",Major + Minor == 4 ? "TLS" : "SSL",Major,Minor)
{
	UINT8	Major;
	UINT8	Minor;
}

[DataTypeByteOrder = BigEndian]
struct MSRPCSSLRecordLayer = Version.ToString + " " + ContentType.ToString + SSLSummaryInfo
{
	[post.SSLRecordLayerType, SSLSummaryinfo = ""]
	UINT8	ContentType = MSRPCTableSSLContentType(this);
	MSRPCSSLVersion	Version;
	[DataFieldByteOrder = BigEndian]
	UINT16	Length;
	Blob( Length ) Data;
}

Table MSRPCNLRSignatureAlgorithmValues( Value )
{
	Switch( Value )
	{
		Case 0x00: "The packet is not signed";
		Case 0x77: "KERB_CHECKSUM_MD5_HMAC - The packet is signed using MD5-HMAC-64";
		Default: "unknown";
	}
}

Table MSRPCNLRSealAlgorithmValues( Value )
{
	Switch( Value )
	{
		Case 0x007A: "KERB_ETYPE_RC4_PLAIN_OLD - The packet is encrypted using RC4";
		Case 0xFFFF: "The packet is not encrypted";
		Default: "unknown";
	}
}

[DataTypeByteOrder = LittleEndian]
Struct MSRPCNlAuthMessage {
	UINT32 MessageType = FormatString( "0x%X, %s", this, this ? "Negotiate Response Message" : "Negotiate Message" );
	UINT32 Flags
	{
		UINT32 NLAuthNetbiosDomainName:1 = FormatString("       (%s) %s", this.ToBitString, this ? "Buffer contains NetBIOS domain name as an OEM string" : "Buffer does not contain NetBIOS domain name" );
		UINT32 NLAuthNetbiosComputerName:1 = FormatString("     (%s) %s", this.ToBitString, this ? "Buffer contains NetBIOS computer name as an OEM string" : "Buffer does not contain NetBIOS computer name" );
		UINT32 NLAuthDNSDomainName:1 = FormatString("           (%s) %s", this.ToBitString, this ? "Buffer contains DNS domain name as UTF-8 string" : "Buffer does not contain DNS domain name" );
		UINT32 NLAuthDNSHostName:1 = FormatString("             (%s) %s", this.ToBitString, this ? "Buffer contains DNS host name as UTF-8 string" : "Buffer does not contain DNS host name" );
		UINT32 NLAuthUTF8NetbiosComputerName:1 = FormatString(" (%s) %s", this.ToBitString, this ? "Buffer contains computer name as UTF-8 string" : "Buffer does not contain computer name" );
	}
	Switch { Case Flags.NLAuthNetbiosDomainName: AsciiString NetBiosDomainName; }
	Switch { Case Flags.NLAuthNetbiosComputerName: AsciiString NetBiosComputerName; }
	Switch { Case Flags.NLAuthDNSDomainName: DNSString DNSDomainName; }
	Switch { Case Flags.NLAuthDNSHostName: DNSString DNSHostName; }
	Switch { Case Flags.NLAuthUTF8NetbiosComputerName: DNSString UTF8NetBiosComputerName; }
	Switch { Case ( (FrameLength - Offset) > 0 ): Blob(FrameLength - Offset) Buffer; }
}

[DataTypeByteOrder = LittleEndian]
Struct MSRPCNlAuthSignature {
	UINT16 SignatureAlgorithm = FormatString( "0x%X %s", this, MSRPCNLRSignatureAlgorithmValues( this ) );
	UINT16 SealAlgorithm = FormatString( "0x%X %s", this, MSRPCNLRSealAlgorithmValues( this ) );
	UINT16 Pad;
	UINT16 Flags = FormatString( "0x%X No flags defined, must be 0", this );
	Blob(8) SequenceNumber;
	Blob(8) Checksum;
	Blob(8) Confounder;
}

Table MGMTMethodTable( value )
{
	Switch ( value )
	{
		Case  0: "RpcMgmtInqIfIds";
		Case  1: "RpcMgmtInqStats";
		Case  2: "RpcMgmtIsServerListening";
		Case  3: "RpcMgmtStopServerListening";
		Case  4: "RpcMgmtInqPrincName";
		Default: "Unknown Method"; 
	}
}
