//#  (c) 2009 CodePlex Foundation
//#
//#  Title:                  Distributed File System (DFS) Namespace Management Protocol
//#
//#  Details:                
//#
//#  Microsoft References:   [MS-DFSNM]: Distributed File System (DFS) Namespace Management Protocol Specification
//#
//#  Comments:               
//#
//#  Revision Class and Date:Major, 9/14/2009
//#                          Minor, 3/2/2010
//#
//####

Protocol DFSNMGMT = FormatString( "%s %s%s%s%s%s", 
	Property.DFSNMgmtMethodName,
	Property.MSRPCPType ? "Response" : "Request",
	( Property.MSRPCPfcFlags & 0x03 ) == 0x01 ? ", RPC first fragment" : "",
	Property.MSRPCCompleteFrag == 0 ? ", partial" : "",
	Property.MSRPCEncrypted == ConstEncTypeEncrypted ? ", *Encrypted*" : Property.MSRPCEncrypted == ConstEncTypeUnknown ? ", *Un-Interpreted*": "",
	Property.DFSNMgmtSummary && Property.MSRPCEncrypted == ConstEncTypeClearData ? ", " + Property.DFSNMgmtSummary : "" )
{
	[Property.DFSNMgmtSummary = ""]
	[Property.DFSNMgmtMethodName = DFSNMgmtMethodNameTable( Property.MSRPCOpnum )]
	Switch( Property.MSRPCOpnum )
	{
		Case 0:
			_Struct NetrDfsManagerGetVersion
			{
				Switch( Property.MSRPCPType )
				{
					Case 0x00: //REQUEST
						_Struct Request
						{
						}

					Case 0x02: //RESPONSE
						[DFSNMgmtSummary = FormatString( "ReturnValue=0x%X", ReturnValue )]
						_Struct Response
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										UINT32 ReturnValue = DFSNMgmtNetrDfsManagerGetVersionTable(this);
									}
							}
						}
				}
			}

		Case 1:
			_Struct NetrDfsAdd
			{
				Switch( Property.MSRPCPType )
				{
					Case 0x00: //REQUEST
						[DFSNMgmtSummary = FormatString( "DfsEntryPath=%s ServerName=%s ShareName=%s Comment=%s Flags=0x%X", DfsEntryPath, ServerName, ShareName, Comment, Flags )]
						_Struct Request
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										NdrWideString DfsEntryPath;
										NdrWideString ServerName;
										NdrWIDESTRINGPtr ShareName;
										NdrWIDESTRINGPtr Comment;
										Align4 Pad;
										UINT32 Flags = DFSNMgmtNetrDfsAddFlagsTable( this );
									}
							}
						}

					Case 0x02: //RESPONSE
						[DFSNMgmtSummary = FormatString( "ReturnValue=0x%X", ReturnValue )]
						_Struct Response
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										UINT32 ReturnValue = WinErrorCodeTable(this);
									}
							}
						}
				}
			}

		Case 2:
			_Struct NetrDfsRemove
			{
				Switch( Property.MSRPCPType )
				{
					Case 0x00: //REQUEST
						[DFSNMgmtSummary = FormatString( "DfsEntryPath=%s ServerName=%s ShareName=%s", DfsEntryPath, ServerName, ShareName )]
						_Struct Request
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										NdrWideString DfsEntryPath;
										NdrWIDESTRINGPtr ServerName;
										NdrWIDESTRINGPtr ShareName;
									}
							}
						}

					Case 0x02: //RESPONSE
						[DFSNMgmtSummary = FormatString( "ReturnValue=0x%X", ReturnValue )]
						_Struct Response
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										UINT32 ReturnValue;
									}
							}
						}
				}
			}

		Case 3:
			_Struct NetrDfsSetInfo
			{
				Switch( Property.MSRPCPType )
				{
					Case 0x00: //REQUEST
						[DFSNMgmtSummary = FormatString( "DfsEntryPath=%s ServerName=%s ShareName=%s Level=0x%X", DfsEntryPath, ServerName, ShareName, Level )]
						_Struct Request
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										NdrWideString DfsEntryPath;
										NdrWIDESTRINGPtr ServerName;
										NdrWIDESTRINGPtr ShareName;
										Align4 Pad1;
										UINT32 Level = DFSNMgmtNetrDfsSetInfoLevelTable( this );
										switch
										{
											case Property.MSRPCNdr64: Align8 Pad2;
										}
										DFSNMgmtDfsInfoStruct DfsInfo;
									}
							}
						}

					Case 0x02: //RESPONSE
						[DFSNMgmtSummary = FormatString( "ReturnValue=0x%X", ReturnValue )]
						_Struct Response
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										UINT32 ReturnValue;
									}
							}
						}
				}
			}

		Case 4:
			_Struct NetrDfsGetInfo
			{
				Switch( Property.MSRPCPType )
				{
					Case 0x00: //REQUEST
						[DFSNMgmtSummary = FormatString( "DfsEntryPath=%s ServerName=%s ShareName=%s Level=0x%X", DfsEntryPath, ServerName, ShareName, Level )]
						_Struct Request
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										NdrWideString DfsEntryPath;
										NdrWIDESTRINGPtr ServerName;
										NdrWIDESTRINGPtr ShareName;
										Align4 Pad;
										UINT32 Level = DFSNMgmtNetrDfsGetInfoLevelTable( this );
									}
							}
						}

					Case 0x02: //RESPONSE
						[DFSNMgmtSummary = FormatString( "ReturnValue=0x%X", ReturnValue )]
						_Struct Response
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										DFSNMgmtDfsInfoStruct DfsInfo;
										Align4 pad;
										UINT32 ReturnValue = WinErrorCodeTable(this);
									}
							}
						}
				}
			}

		Case 5:
			_Struct NetrDfsEnum
			{
				Switch( Property.MSRPCPType )
				{
					Case 0x00: //REQUEST
						[DFSNMgmtSummary = FormatString( "Level=0x%X PrefMaxLen=0x%X", Level, PrefMaxLen )]
						_Struct Request
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										UINT32 Level = DFSNMgmtNetrDfsEnumLevelTable( this );
										UINT32 PrefMaxLen;
										DFSNMgmtDfsInfoEnumStructPtr DfsEnum;
										Align4 Pad;
										UINT32Ptr ResumeHandle;
									}
							}
						}

					Case 0x02: //RESPONSE
						[DFSNMgmtSummary = FormatString( "ReturnValue=0x%X", ReturnValue )]
						_Struct Response
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										DFSNMgmtDfsInfoEnumStructPtr DfsEnum;
										ALign4 Pad;
										UINT32Ptr ResumeHandle;
										UINT32 ReturnValue = WinErrorCodeTable(this);
									}
							}
						}
				}
			}

		Case 6:
			_Struct NetrDfsMove
			{
				Switch( Property.MSRPCPType )
				{
					Case 0x00: //REQUEST
						[DFSNMgmtSummary = FormatString( "DfsEntryPath=%s NewDfsEntryPath=%s Flags=0x%X", DfsEntryPath, NewDfsEntryPath, Flags )]
						_Struct Request
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										NdrWideString DfsEntryPath;
										NdrWideString NewDfsEntryPath;
										Align4 Pad;
										UINT32 Flags = DFSNMgmtNetrDfsMoveFlagsTable( this );
									}
							}
						}

					Case 0x02: //RESPONSE
						[DFSNMgmtSummary = FormatString( "ReturnValue=0x%X", ReturnValue )]
						_Struct Response
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										UINT32 ReturnValue = WinErrorCodeTable(this);
									}
							}
						}
				}
			}
		
		Case 10:
			_Struct NetrDfsAddFtRoot
			{
				Switch( Property.MSRPCPType )
				{
					Case 0x00: //REQUEST
						[DFSNMgmtSummary = FormatString( "ServerName=%s DcName=%s RootShare=%s FtDfsName=%s Comment=%s ConfigDN=%s NewFtDfs=0x%X ApiFlags=0x%X", ServerName, DcName, RootShare, FtDfsName, Comment, ConfigDN, NewFtDfs, ApiFlags )]
						_Struct Request
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										NdrWideString ServerName;
										NdrWideString DcName;
										NdrWideString RootShare;
										NdrWideString FtDfsName;
										NdrWideString Comment;
										NdrWideString ConfigDN;
										BOOLEAN NewFtDfs;
										Align4 pad;
										UINT32 ApiFlags = MustBeSetToTable(this, 0);
										DFSNMgmtDfsmRootListPtrPtr RootList;
									}
							}
						}

					Case 0x02: //RESPONSE
						[DFSNMgmtSummary = FormatString( "ReturnValue=0x%X", ReturnValue )]
						_Struct Response
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										DFSNMgmtDfsmRootListPtrPtr RootList;
										Align4 pad;
										UINT32 ReturnValue = WinErrorCodeTable(this);
									}
							}
						}
				}
			}

		Case 11:
			_Struct NetrDfsRemoveFtRoot
			{
				Switch( Property.MSRPCPType )
				{
					Case 0x00: //REQUEST
						[DFSNMgmtSummary = FormatString( "ServerName=%s DcName=%s RootShare=%s FtDfsName=%s ApiFlags=0x%X", ServerName, DcName, RootShare, FtDfsName, ApiFlags )]
						_Struct Request
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										NdrWideString ServerName;
										NdrWideString DcName;
										NdrWideString RootShare;
										NdrWideString FtDfsName;
										Align4 Pad;
										UINT32 ApiFlags;
										DFSNMgmtDfsmRootListPtrPtr RootList;
									}
							}
						}

					Case 0x02: //RESPONSE
						[DFSNMgmtSummary = FormatString( "ReturnValue=0x%X", ReturnValue )]
						_Struct Response
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										DFSNMgmtDfsmRootListPtrPtr RootList;
										Align4 pad;
										UINT32 ReturnValue = WinErrorCodeTable(this);
									}
							}
						}
				}
			}

		Case 12:
			_Struct NetrDfsAddStdRoot
			{
				Switch( Property.MSRPCPType )
				{
					Case 0x00: //REQUEST
						[DFSNMgmtSummary = FormatString( "ServerName=%s RootShare=%s Comment=%s ApiFlags=0x%X", ServerName, RootShare, Comment, ApiFlags )]
						_Struct Request
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										NdrWideString ServerName;
										NdrWideString RootShare;
										NdrWideString Comment;
										Align4 Pad;
										UINT32 ApiFlags;
									}
							}
						}

					Case 0x02: //RESPONSE
						[DFSNMgmtSummary = FormatString( "ReturnValue=0x%X", ReturnValue )]
						_Struct Response
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										UINT32 ReturnValue=DFSNMgmtNetrDfsAddStdRootTable(this);
									}
							}
						}
				}
			}

		Case 13:
			_Struct NetrDfsRemoveStdRoot
			{
				Switch( Property.MSRPCPType )
				{
					Case 0x00: //REQUEST
						[DFSNMgmtSummary = FormatString( "ServerName=%s RootShare=%s ApiFlags=0x%X", ServerName, RootShare, ApiFlags )]
						_Struct Request
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										NdrWideString ServerName;
										NdrWideString RootShare;
										Align4 Pad;
										UINT32 ApiFlags;
									}
							}
						}

					Case 0x02: //RESPONSE
						[DFSNMgmtSummary = FormatString( "ReturnValue=0x%X", ReturnValue )]
						_Struct Response
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										UINT32 ReturnValue = WinErrorCodeTable(this);
									}
							}
						}
				}
			}

		Case 14:
			_Struct NetrDfsManagerInitialize
			{
				Switch( Property.MSRPCPType )
				{
					Case 0x00: //REQUEST
						[DFSNMgmtSummary = FormatString( "ServerName=%s Flags=0x%X", ServerName, Flags )]
						_Struct Request
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										NdrWideString ServerName;
										Align4 Pad;
										UINT32 Flags;
									}
							}
						}

					Case 0x02: //RESPONSE
						[DFSNMgmtSummary = FormatString( "ReturnValue=0x%X", ReturnValue )]
						_Struct Response
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										UINT32 ReturnValue = WinErrorCodeTable(this);
									}
							}
						}
				}
			}

		Case 15:
			_Struct NetrDfsAddStdRootForced
			{
				Switch( Property.MSRPCPType )
				{
					Case 0x00: //REQUEST
						[DFSNMgmtSummary = FormatString( "ServerName=%s RootShare=%s Comment=%s Share=%s", ServerName, RootShare, Comment, Share )]
						_Struct Request
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										NdrWideString ServerName;
										NdrWideString RootShare;
										NdrWideString Comment;
										NdrWideString Share;
									}
							}
						}

					Case 0x02: //RESPONSE
						[DFSNMgmtSummary = FormatString( "ReturnValue=0x%X", ReturnValue )]
						_Struct Response
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										UINT32 ReturnValue = WinErrorCodeTable(this);
									}
							}
						}
				}
			}

		Case 16:
			_Struct NetrDfsGetDcAddress
			{
				Switch( Property.MSRPCPType )
				{
					Case 0x00: //REQUEST
						[DFSNMgmtSummary = FormatString( "ServerName=%s DcName=%s IsRoot=0x%X Timeout=0x%X", ServerName, DcName, IsRoot, Timeout )]
						_Struct Request
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										NdrWideString ServerName;
										NdrWIDESTRINGPtr DcName;
										BOOLEAN IsRoot;
										Align4 Pad;
										UINT32 Timeout;
									}
							}
						}

					Case 0x02: //RESPONSE
						[DFSNMgmtSummary = FormatString( "DcName=%s IsRoot=0x%X Timeout=0x%X ReturnValue=0x%X", DcName, IsRoot, Timeout, ReturnValue )]
						_Struct Response
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										NdrWIDESTRINGPtr DcName;
										UINT8 IsRoot;
										Align4 Pad;
										UINT32 Timeout;
										UINT32 ReturnValue = WinErrorCodeTable(this);
									}
							}
						}
				}
			}

		Case 17:
			_Struct NetrDfsSetDcAddress
			{
				Switch( Property.MSRPCPType )
				{
					Case 0x00: //REQUEST
						[DFSNMgmtSummary = FormatString( "ServerName=%s DcName=%s Timeout=0x%X Flags=0x%X", ServerName, DcName, Timeout, Flags )]
						_Struct Request
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										NdrWideString ServerName;
										NdrWideString DcName;
										Align4 Pad;
										UINT32 Timeout;
										UINT32 Flags = DFSNMgmtNetrDfsSetDcAddressFlagsTable( this );
									}
							}
						}

					Case 0x02: //RESPONSE
						[DFSNMgmtSummary = FormatString( "ReturnValue=0x%X", ReturnValue )]
						_Struct Response
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										UINT32 ReturnValue = WinErrorCodeTable(this);
									}
							}
						}
				}
			}

		Case 18:
			_Struct NetrDfsFlushFtTable
			{
				Switch( Property.MSRPCPType )
				{
					Case 0x00: //REQUEST
						_Struct Request
						{
							NdrWideString DcName;
							NdrWideString wszFtDfsName;
						}

					Case 0x02: //RESPONSE
						_Struct Response
						{
							UINT32 ReturnValue = WinErrorCodeTable(this);
						}
				}
			}

		Case 19:
			_Struct NetrDfsAdd2
			{
				Switch( Property.MSRPCPType )
				{
					Case 0x00: //REQUEST
						[DFSNMgmtSummary = FormatString( "DfsEntryPath=%s DcName=%s ServerName=%s ShareName=%s Comment=%s Flags=0x%X", DfsEntryPath, DcName, ServerName, ShareName, Comment, Flags )]
						_Struct Request
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										NdrWideString DfsEntryPath;
										NdrWideString DcName;
										NdrWideString ServerName;
										NdrWIDESTRINGPtr ShareName;
										NdrWIDESTRINGPtr Comment;
										Align4 Pad;
										UINT32 Flags = DFSNMgmtNetrDfsAdd2FlagsTable( this );
										DFSNMgmtDfsmRootListPtrPtr RootList;
									}
							}
						}

					Case 0x02: //RESPONSE
						[DFSNMgmtSummary = FormatString( "ReturnValue=0x%X", ReturnValue )]
						_Struct Response
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										DFSNMgmtDfsmRootListPtrPtr RootList;
										Align4 pad;
										UINT32 ReturnValue = WinErrorCodeTable(this);
									}
							}
						}
				}
			}

		Case 20:
			_Struct NetrDfsRemove2
			{
				Switch( Property.MSRPCPType )
				{
					Case 0x00: //REQUEST
						[DFSNMgmtSummary = FormatString( "DfsEntryPath=%s DcName=%s ServerName=%s ShareName=%s", DfsEntryPath, DcName, ServerName, ShareName )]
						_Struct Request
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										NdrWideString DfsEntryPath;
										NdrWideString DcName;
										NdrWIDESTRINGPtr ServerName;
										NdrWIDESTRINGPtr ShareName;
										DFSNMgmtDfsmRootListPtrPtr RootList;
									}
							}
						}

					Case 0x02: //RESPONSE
						[DFSNMgmtSummary = FormatString( "ReturnValue=0x%X", ReturnValue )]
						_Struct Response
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										DFSNMgmtDfsmRootListPtrPtr RootList;
										Align4 pad;
										UINT32 ReturnValue = WinErrorCodeTable(this);
									}
							}
						}
				}
			}

		Case 21:
			_Struct NetrDfsEnumEx
			{
				Switch( Property.MSRPCPType )
				{
					Case 0x00: //REQUEST
						[DFSNMgmtSummary = FormatString( "DfsEntryPath=%s Level=0x%X PrefMaxLen=0x%X", DfsEntryPath, Level, PrefMaxLen )]
						_Struct Request
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										NdrWideString DfsEntryPath;
										Align4 Pad1;
										UINT32 Level = DFSNMgmtNetrDfsEnumExLevelTable( this );
										UINT32 PrefMaxLen;
										DFSNMgmtDfsInfoEnumStructPtr DfsEnum;
										Align4	Pad2;
										UINT32Ptr ResumeHandle;
									}
							}
						}

					Case 0x02: //RESPONSE
						[DFSNMgmtSummary = FormatString( "ReturnValue=0x%X", ReturnValue )]
						_Struct Response
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										DFSNMgmtDfsInfoEnumStructPtr DfsEnum;
										Align4 Pad;
										UINT32Ptr ResumeHandle;
										UINT32 ReturnValue=DFSNMgmtNetrDfsEnumExTable(this);
									}
							}
						}
				}
			}

		Case 22:
			_Struct NetrDfsSetInfo2
			{
				Switch( Property.MSRPCPType )
				{
					Case 0x00: //REQUEST
						[DFSNMgmtSummary = FormatString( "DfsEntryPath=%s DcName=%s ServerName=%s ShareName=%s Level=0x%X", DfsEntryPath, DcName, ServerName, ShareName, Level )]
						_Struct Request
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										NdrWideString DfsEntryPath;
										NdrWideString DcName;
										NdrWIDESTRINGPtr ServerName;
										NdrWIDESTRINGPtr ShareName;
										Align4 Pad1;
										UINT32 Level = DFSNMgmtNetrDfsSetInfo2LevelTable( this );
										switch
										{
											case Property.MSRPCNdr64: Align8 Pad2;
										}
										DFSNMgmtDfsInfoStruct DfsInfo;
										DFSNMgmtDfsmRootListPtrPtr RootList;
									}
							}
						}

					Case 0x02: //RESPONSE
						[DFSNMgmtSummary = FormatString( "ReturnValue=0x%X", ReturnValue )]
						_Struct Response
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										DFSNMgmtDfsmRootListPtrPtr RootList;
										Align4 pad;
										UINT32 ReturnValue = WinErrorCodeTable(this);
									}
							}
						}
				}
			}

		Case 23:
			_Struct NetrDfsAddRootTarget
			{
				Switch( Property.MSRPCPType )
				{
					Case 0x00: //REQUEST
						[DFSNMgmtSummary = FormatString( "DfsEntryPath=%s TargetPath=%s MajorVersion=%d Comment=%s", DfsEntryPath, TargetPath, MajorVersion, Comment )]
						_Struct Request
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										NdrWIDESTRINGPtr DfsEntryPath;
										NdrWIDESTRINGPtr TargetPath;
										Align4 Pad;
										UINT32 MajorVersion;
										NdrWIDESTRINGPtr Comment;
										BOOLEAN NewNamespace;
										Align4 AlignmentPadding1;
										UINT32 Flags;
									}
							}
						}

					Case 0x02: //RESPONSE
						[DFSNMgmtSummary = FormatString( "ReturnValue=0x%X", ReturnValue )]
						_Struct Response
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										UINT32 ReturnValue = WinErrorCodeTable(this);
									}
							}
						}
				}
			}

		Case 24:
			_Struct NetrDfsRemoveRootTarget
			{
				Switch( Property.MSRPCPType )
				{
					Case 0x00: //REQUEST
						[DFSNMgmtSummary = FormatString( "DfsPath=%s TargetPath=%s Flags=0x%X", DfsPath, TargetPath, Flags )]
						_Struct Request
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										NdrWIDESTRINGPtr DfsPath;
										NdrWIDESTRINGPtr TargetPath;
										Align4 Pad;
										UINT32 Flags = DFSNMgmtNetrDfsRemoveRootTargetFlagsTable( this );
									}
							}
						}

					Case 0x02: //RESPONSE
						[DFSNMgmtSummary = FormatString( "ReturnValue=0x%X", ReturnValue )]
						_Struct Response
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										UINT32 ReturnValue = WinErrorCodeTable(this);
									}
							}
						}
				}
			}

		Case 25:
			_Struct NetrDfsGetSupportedNamespaceVersion
			{
				Switch( Property.MSRPCPType )
				{
					Case 0x00: //REQUEST
						[DFSNMgmtSummary = FormatString( "DfsPath=%s ", DfsPath)]
						_Struct Request
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										DFSNMgmtDFSNAMESPACEVERSIONORIGIN DFSNAMESPACEVERSIONORIGIN;
										NdrWIDESTRINGPtr DfsPath;
									}
							}
						}

					Case 0x02: //RESPONSE
						[DFSNMgmtSummary = FormatString( "ReturnValue=0x%X", ReturnValue )]
						_Struct Response
						{
							Switch
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData: Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									Struct
									{
										DFSNMgmtDfsSupportedNamespaceVersionInfo DfsSupportedNamespaceVersionInfo;
										UINT32 ReturnValue = WinErrorCodeTable(this);
									}
							}
						}
				}
			}

		Case 7:
		Case 8:
		Case 9:
			Struct NotUsedOnWire
			{
				Switch (property.MSRPCPType)
				{
					Case 0x00:// REQUEST
					[post.Description = "OPNUM:" + Property.MSRPCOpnum + " request is Not used on wire"]
					Struct Request 
					{
						ReportParserWarning("DFSNMgmt", "Invalid dfsnmgmt method, Opnum:" + Property.MSRPCOpnum) ProtocolWarning;
						Blob(FrameLength - Offset) PayloadData;
					}
					
					Case 0x02:// RESPONSE
					[post.Description = "OPNUM:" + Property.MSRPCOpnum + " response is Not used on wire"]
					Struct Response
					{
						ReportParserWarning("DFSNMgmt", "Invalid dfsnmgmt method, Opnum:" + Property.MSRPCOpnum) ProtocolWarning;
						Blob(FrameLength - Offset) PayloadData;
					}
				}
			}

		Default:
			ReportParserError (2, "DFSNMgmt", "Unknown netdfs method, Opnum:" + Property.MSRPCOpnum ) UnknownMethod;
	}
}

//
//	 pKT Attribute Contents (Metadata for Domainv1-Based Namespace)
//
Struct DFSNMgmtpKT  //This struct will be called by Ldap,Temporary no use.
{
	UINT32 BLOBVersion;
	UINT32 BLOBElementCount;
	DFSNMgmtDFSNamespaceElementBLOB BLOBElement;
}

//
//	[MS-DFSNM] DFSNamespaceElementBLOB
//
Struct DFSNMgmtDFSNamespaceElementBLOB = FormatString("BLOBName = %s",DFSNMgmtDFSNamespaceElementBLOBBLOBNameTable( BLOBName ))
{
	UINT16 BLOBNameSize;
	UnicodeString BLOBName;
	UINT32 BLOBDataLength;
	switch
	{
		Case BLOBName.contains("\\siteroot"):
			DFSNMgmtSiteInformationBLOB SiteInformationBLOB;
		Case BLOBName.contains("\\domainroot"):
			DFSNMgmtDFSNamespaceRootOrLinkBLOB DFSNamespaceRootBLOB;
		Case BLOBName.contains("\\domainroot\\"):
			DFSNMgmtDFSNamespaceRootOrLinkBLOB DFSNamespaceLinkBLOB;
	}
}

Table DFSNMgmtDFSNamespaceElementBLOBBLOBNameTable( Value )
{
	Switch
	{
		Case Value.contains("\\siteroot"): "SiteInformationBLOB";
		Case Value.contains("\\domainroot"): "DFSNamespaceRootBLOB";
		Case Value.contains("\\domainroot\\"): "DFSNamespaceLinkBLOB";
		default:"Unknown";
	}
}

//
//	[MS-DFSNM] DFSNamespaceRootBLOB or DFSNamespaceLinkBLOB
//
Struct DFSNMgmtDFSNamespaceRootOrLinkBLOB
{
	DFSNMgmtDFSRootOrLinkIDBLOB DFSRootOrLinkIDBLOB;
	UINT32 DFSTargetListBLOBSize;
	DFSNMgmtDFSTargetListBLOB DFSTargetListBLOB;
	UINT32 ReservedBLOBSize;
	AsciiString ReservedBLOB;
	UINT32 ReferralTTL;
}

//
//	[MS-DFSNM] DFSRootOrLinkIDBLOB
//
Struct DFSNMgmtDFSRootOrLinkIDBLOB
{
	GUID(True) RootOrLinkGuid;
	UINT16 PrefixSize;
	UnicodeString Prefix;
	UINT16 ShortPrefixSize;
	UnicodeString ShortPrefix;
	UINT32 Type = DFSNMgmtDFSRootOrLinkIDBLOBTypeTable( this );
	UINT32 State = DFSNMgmtDFSRootOrLinkIDBLOBStateTable( this );
	UINT16 CommentSize;
	UnicodeString Comment;
	FILETIME PrefixTimeStamp;
	FILETIME StateTimeStamp;
	FILETIME CommentTimeStamp;
	UINT32 Version;
}

Table DFSNMgmtDFSRootOrLinkIDBLOBTypeTable( Value )
{
	Switch( Value )
	{
		Case 0x00000001: "PKT_ENTRY_TYPE_DFS - MUST be set to 1.";
		Case 0x00000010: "PKT_ENTRY_TYPE_OUTSIDE_MY_DOM - MUST NOT be set for a DFS root. This MUST be set only when at least one DFS link target points to another DFS namespace.";
		Case 0x00000020: "PKT_ENTRY_TYPE_INSITE_ONLY - When set, instructs the DFS server to enable the DFS in-site referral mode.";
		Case 0x00000040: "PKT_ENTRY_TYPE_COST_BASED_SITE_SELECTION - Enables DFS referral site costing. This SHOULD be supported.Only  and  support DFS referral site costing.";
		Case 0x00000080: "PKT_ENTRY_TYPE_REFERRAL_SVC - Identifies the DFS namespace root.";
		Case 0x00000200: "PKT_ENTRY_TYPE_ROOT_SCALABILITY - Enables DFS root scalability mode. This SHOULD be supported.Only  and  support DFS root scalability mode.";
		Case 0x00008000: "PKT_ENTRY_TYPE_TARGET_FAILBACK - Enables DFS client target failback for targets of this root or link. This SHOULD be supported.Only  and  support DFS client target failback.";
		Default: "unknown";
	}
}

Table DFSNMgmtDFSRootOrLinkIDBLOBStateTable( Value )
{
	Switch( Value )
	{
		Case 0x00000001: "DFS_VOLUME_STATE_OK - DFS root or DFS link state is okay.";
		Case 0x00000002: "DFS_VOLUME_STATE_INCONSISTENT - DFS root or DFS link state is inconsistent. This field MUST NOT be set by the RPC methods and is meant to reflect the current state of the DFS namespace as determined by the server.";
		Case 0x00000003: "DFS_VOLUME_STATE_OFFLINE - DFS root or DFS link is offline and not available for use.";
		Case 0x00000004: "DFS_VOLUME_STATE_ONLINE - DFS root or DFS link is online and available for use.";
		Default: "unknown";
	}
}

//
//	[MS-DFSNM] DFSTargetListBLOB
//
Struct DFSNMgmtDFSTargetListBLOB
{
	UINT32 TargetCount;
	DFSNMgmtTargetEntryBLOB TargetEntryBLOB[TargetCount];
}

//
//	[MS-DFSNM] TargetEntryBLOB
//
Struct DFSNMgmtTargetEntryBLOB
{
	UINT32 TargetEntrySize;
	FILETIME TargetTimeStamp;
	UINT32 TargetState = DFSNMgmtTargetEntryBLOBTargetStateTable( this );
	UINT32 TargetType;
	UINT16 ServerNameSize;
	UnicodeString ServerName;
	UINT16 ShareNameSize;
	UnicodeString ShareName;
}

Table DFSNMgmtTargetEntryBLOBTargetStateTable( Value )
{
	Switch( Value )
	{
		Case 0x00000001: "DFS_STORAGE_STATE_OFFLINE - This target is offline and unavailable for use.";
		Case 0x00000002: "DFS_STORAGE_STATE_ONLINE - This target is online and available for use.";
		Case 0x00000004: "DFS_STORAGE_STATE_ACTIVE - This target is active.";
		Default: "unknown";
	}
}

//
//	[MS-DFSNM] SiteInformationBLOB
//
Struct DFSNMgmtSiteInformationBLOB
{
	GUID(True) SiteTableGuid;
	UINT32 SiteEntryCount;
	DFSNMgmtSiteEntryBLOB SiteEntryBLOB[SiteEntryCount];
}

//
//	[MS-DFSNM] SiteEntryBLOB
//
Struct DFSNMgmtSiteEntryBLOB
{
	UINT16 ServerNameSize;
	UnicodeString ServerName;
	UINT32 SiteNameInfoCount;
	DFSNMgmtSiteNameInfoBLOB SiteNameInfoBLOB;
}

//
//	[MS-DFSNM] SiteNameInfoBLOB
//
Struct DFSNMgmtSiteNameInfoBLOB
{
	UINT32 Flags;
	UINT16 SiteNameSize;
	UnicodeString SiteName;
}

//
//	[MS-DFSNM] DFS_INFO_STRUCT
//	Alignment:NdrAlign
//

struct DFSNMgmtDfsInfoStruct
{
	UINT32 LevelConf;
	NDRPTR LevelPtr;
	Switch 
	{
		Case LevelPtr.ReferentID:
				switch(LevelConf)
				{
					Case 1:
						struct
						{
							DFSNMgmtDfsInfo1Ptr DfsInfo1Ptr;
							DFSNMgmtDfsInfo1Ref DfsInfo1Ref;
						}
			
					Case 2:
						struct
						{
							DFSNMgmtDfsInfo2Ptr DfsInfo2Ptr;
							DFSNMgmtDfsInfo2Ref DfsInfo2Ref;
						}
					Case 3:
						struct
						{
							DFSNMgmtDfsInfo3Ptr DfsInfo3Ptr;
							DFSNMgmtDfsInfo3Ref DfsInfo3Ref;
						}
			
					Case 4:
						struct
						{
							DFSNMgmtDfsInfo4Ptr DfsInfo4tr;
							DFSNMgmtDfsInfo4VariantRef DfsInfo4Ref;
						}
			
					Case 5:
						struct
						{
							DFSNMgmtDfsInfo5Ptr DfsInfo5Ptr;
							DFSNMgmtDfsInfo5Ref DfsInfo5Ref;
						};
			
					Case 6:
						struct
						{
							DFSNMgmtDfsInfo6Ptr DfsInfo6Ptr;
							DFSNMgmtDfsInfo6Ref DfsInfo6Ref;
						}
					Case 7:
							DFSNMgmtDfsInfo7 DfsInfo7;
			
					Case 8:
						struct
						{
							DFSNMgmtDfsInfo8Ptr DfsInfo8Ptr;
							DFSNMgmtDfsInfo8Ref DfsInfo8Ref;
						}
			
					Case 9:
						struct
						{
							DFSNMgmtDfsInfo9Ptr DfsInfo9Ptr;
							DFSNMgmtDfsInfo9Ref DfsInfo9Ref;
						}
			
					Case 50:
						struct 
						{
							Align8	Pad;
							DFSNMgmtDfsInfo50 DfsInfo50;
						}
			
					Case 100:
						DFSNMgmtDfsInfo100 DfsInfo100;
					
					Case 101:
						DFSNMgmtDfsInfo101 DfsInfo101;
			
					Case 102:
						DFSNMgmtDfsInfo102 DfsInfo102;
			
					Case 103:
						DFSNMgmtDfsInfo103 DfsInfo103;
			
					Case 104:
						DFSNMgmtDfsInfo104 DfsInfo104;
			
					Case 105:
						DFSNMgmtDfsInfo105 DfsInfo105;
			
					Case 106:
						DFSNMgmtDfsInfo106 DfsInfo106;
			
					Case 107:
						DFSNMgmtDfsInfo107 DfsInfo107;
			
					Case 150:
						struct 
						{
							NdrAlign	Pad;
							DFSNMgmtDfsInfo150 DfsInfo150;
						}
				}
	}	
}

//
//	[MS-DFSNM] DFS_INFO_ENUM_STRUCT
//	Alignment:NdrAlign
//

Struct DFSNMgmtDfsInfoEnumStruct
{
	UINT32 EMULevel;
	switch
	{
		case Property.MSRPCNdr64: Align8 Pad;
	}
	UINT32 EMULevelConformant;
	switch(EMULevel)
	{
		Case 1:
			Struct
			{
				NdrPtr DfsInfo1ContainerPtr;
				Switch
				{
					case DfsInfo1ContainerPtr.ReferentID: DFSNMgmtDfsInfo1Container DfsInfo1Container;
				}
			};
		Case 2:
			Struct
			{
				NdrPtr DfsInfo2ContainerPtr;
				Switch
				{
					case DfsInfo2ContainerPtr.ReferentID: DFSNMgmtDfsInfo2Container DfsInfo2Container;
				}
			};
		Case 3:
			Struct
			{
				NdrPtr DfsInfo3ContainerPtr;
				Switch
				{
					case DfsInfo3ContainerPtr.ReferentID: DFSNMgmtDfsInfo3Container DfsInfo3Container;
				}
			};
		Case 4:
			Struct
			{
				NdrPtr DfsInfo4ContainerPtr;
				Switch
				{
					case DfsInfo4ContainerPtr.ReferentID: DFSNMgmtDfsInfo4Container DfsInfo4Container;
				}
			};
		Case 5:
			Struct
			{
				NdrPtr DfsInfo5ContainerPtr;
				Switch
				{
					case DfsInfo5ContainerPtr.ReferentID: DFSNMgmtDfsInfo5Container DfsInfo5Container;
				}
			};
		Case 6:
			Struct
			{
				NdrPtr DfsInfo6ContainerPtr;
				Switch
				{
					case DfsInfo6ContainerPtr.ReferentID: DFSNMgmtDfsInfo6Container DfsInfo6Container;
				}
			};
		Case 8:
			Struct
			{
				NdrPtr DfsInfo8ContainerPtr;
				Switch
				{
					case DfsInfo8ContainerPtr.ReferentID: DFSNMgmtDfsInfo8Container DfsInfo8Container;
				}
			};
		Case 9:
			Struct
			{
				NdrPtr DfsInfo9ContainerPtr;
				Switch
				{
					case DfsInfo9ContainerPtr.ReferentID: DFSNMgmtDfsInfo9Container DfsInfo9Container;
				}
			};
		Case 200:
			Struct
			{
				NdrPtr DfsInfo200ContainerPtr;
				Switch
				{
					case DfsInfo200ContainerPtr.ReferentID: DFSNMgmtDfsInfo200Container DfsInfo200Container;
				}
			};
		Case 300:
			Struct
			{
				NdrPtr DfsInfo300ContainerPtr;
				Switch
				{
					case DfsInfo300ContainerPtr.ReferentID: DFSNMgmtDfsInfo300Container DfsInfo300Container;
				}
			};
		Default:
			ReportParserError( ParserErrorProtocolClassWindows, "DFSNMGMT", "Unknown Union Level Value" ) Unknown;
	}
}

//
//	[MS-DFSNM] DFS_STORAGE_INFO Pointer Part
//	Alignment:None
//
Struct DFSNMgmtDfsStorageInfoPtr
{
	NdrAlign pad;
	UINT32 State = DFSNMgmtDfsInfo2StateTable(this);
	[Post.property.DFSNMGMTServerNamePtr$[Property.DFSNMGMTStorageInfoPtrCount] = ServerNamePtr.ReferentID]
	NDRPTR ServerNamePtr;
	[Post.property.DFSNMGMTShareNamePtr$[Property.DFSNMGMTStorageInfoPtrCount] = ShareNamePtr.ReferentID]
	NDRPTR ShareNamePtr;
	[Property.DFSNMGMTStorageInfoPtrCount = Property.DFSNMGMTStorageInfoPtrCount + 1]
	struct {};
}

//
//	[MS-DFSNM] DFS_STORAGE_INFO Referent Part
//	Alignment:None
//
struct DFSNMgmtDfsStorageInfoRef
{
	switch
	{
		case property.DFSNMGMTServerNamePtr$[Property.DFSNMGMTStorageInfoRefCount] != 0:
			NdrWideString ServerName;
	}
	switch 
	{
		case property.DFSNMGMTShareNamePtr$[Property.DFSNMGMTStorageInfoRefCount] != 0:
			NdrWideString ShareName;
	}
}

//
//	[MS-DFSNM] DFS_STORAGE_INFO_1 Pointer Part
//	Alignment:None
//

Struct DFSNMgmtDfsStorageInfo1Ptr
{
	NdrAlign pad;
	UINT32 State = DFSNMgmtDfsInfo2StateTable(this);
	[Post.property.DFSNMGMTServerNamePtr$[Property.DFSNMGMTStorageInfoPtrCount] = ServerNamePtr.ReferentID]
	NDRPTR ServerNamePtr;
	[Post.property.DFSNMGMTShareNamePtr$[Property.DFSNMGMTStorageInfoPtrCount] = ShareNamePtr.ReferentID]
	NDRPTR ShareNamePtr;
	DFSNMgmtDfsTargetPriority TargetPriority;
	[Property.DFSNMGMTStorageInfoPtrCount = Property.DFSNMGMTStorageInfoPtrCount + 1]
	struct {};
}

//
//	[MS-DFSNM] DFS_STORAGE_INFO_1 Referent Part
//	Alignment:None
//
struct DFSNMgmtDfsStorageInfo1Ref
{
	Switch 
	{
		Case property.DFSNMGMTServerNamePtr$[Property.DFSNMGMTStorageInfoRefCount] != 0:
			NdrWideString ServerName;
	}
	Switch 
	{
		Case property.DFSNMGMTShareNamePtr$[Property.DFSNMGMTStorageInfoRefCount] != 0:
			NdrWideString ShareName;
	}
}

//
//	[MS-DFSNM] DFS_TARGET_PRIORITY
//	Alignment:None
//

Struct DFSNMgmtDfsTargetPriority
{
	DFSNMgmtDfsTargetPriorityClass TargetPriorityClass;
	UINT16 TargetPriorityRank;
	UINT16 Reserved;
	switch
	{
		case Property.MSRPCNdr64: Align4 Pad;
	}
}

Table DFSNMgmtDfsTargetPriorityClassTable( value )
{
	Switch( Value )
	{
		case 0: "DfsSiteCostNormalPriorityClass - The default or \"normal\" site cost priority class for a DFS target.";
		case 1: "DfsGlobalHighPriorityClass - The highest priority class for a DFS target. Targets assigned to this class receive global preference.";
		case 2: "DfsSiteCostHighPriorityClass - The highest site cost priority class for a DFS target. Targets assigned to this class receive the highest preference among targets of the same site cost for a given DFS client.";
		case 3: "DfsSiteCostLowPriorityClass - The lowest site cost priority class for a DFS target. Targets assigned to this class receive the least preference among targets of the same site cost for a given DFS client.";
		case 4: "DfsGlobalLowPriorityClass - The lowest priority class level for a DFS target. Targets assigned to this class receive the least preference globally.";
		default: "DfsInvalidPriorityClass - This is not a valid priority class.";
	}
}
//
//	[MS-DFSNM] DFS_TARGET_PRIORITY_CLASS
//
Struct DFSNMgmtDfsTargetPriorityClass
{
	NdrV1Enum(4) DfsTargetPriorityClass = DFSNMgmtDfsTargetPriorityClassTable(this);
}

//
//	[MS-DFSNM] DFSM_ROOT_LIST
//
Struct DFSNMgmtDfsmRootList
{
	UINT32 Entries;
	NdrConformant EntriesConf;
	switch
	{
		case EntriesConf.MaxCount!=0:
		struct
		{
			DFSNMgmtDfsmRootListEntryPtr EntryPtr[EntriesConf.MaxCount];
			DFSNMgmtDfsmRootListEntryRef EntryRef[EntriesConf.MaxCount];
		}		
	}
}

//
//	[MS-DFSNM] DFSM_ROOT_LIST_ENTRY
//
struct DFSNMgmtDfsmRootListEntryPtr
{
	NDRPTR ServerSharePtr;
}

struct DFSNMgmtDfsmRootListEntryRef
{
	NdrWideString ServerShare;
}

//
//	[MS-DFSNM] DFS_NAMESPACE_VERSION_ORIGIN
//
Struct DFSNMgmtDfsNamespaceVersionOrigin
{
	NDRENUM DfsNamespaceVersionOrigin;
}

//
//	[MS-DFSNM] DFS_SUPPORTED_NAMESPACE_VERSION_INFO
//
Struct DFSNMgmtDfsSupportedNamespaceVersionInfo
{
	UINT32 DomainDfsMajorVersion;
	UINT32 DomainDfsMinorVersion;
	UINT64 DomainDfsCapabilities;
	UINT32 StandaloneDfsMajorVersion;
	UINT32 StandaloneDfsMinorVersion;
	UINT64 StandaloneDfsCapabilities;
	switch
	{
		case Property.MSRPCNdr64: Align8 Pad;
	}
}

//
//	[MS-DFSNM] DFS_INFO_1 Pointer Part
//	Alignment:None
//

Struct DFSNMgmtDfsInfo1Ptr
{
	[Post.property.DFSNMGMTEntryPathPtr$[Property.DFSNMGMTDfsInfoPtrCount] = EntryPathPtr.ReferentID]
	NDRPTR EntryPathPtr;
	[Property.DFSNMGMTDfsInfoPtrCount = Property.DFSNMGMTDfsInfoPtrCount + 1]
	struct {};
}

//
//	[MS-DFSNM] DFS_INFO_1 Referent Part
//	Alignment:None
//
struct DFSNMgmtDfsInfo1Ref
{
	Switch {
		Case property.DFSNMGMTEntryPathPtr$[Property.DFSNMGMTDfsInfoRefCount] != 0:
			NdrWideString EntryPath;
	}
}

//
//	[MS-DFSNM] DFS_INFO_2 Pointer Part
//	Alignment:None
//

Struct DFSNMgmtDfsInfo2Ptr
{
	[Post.property.DFSNMGMTEntryPathPtr$[Property.DFSNMGMTDfsInfoPtrCount] = EntryPathPtr.ReferentID]
	NDRPTR EntryPathPtr;
	[Post.property.DFSNMGMTCommentPtr$[Property.DFSNMGMTDfsInfoPtrCount] = CommentPtr.ReferentID]
	NDRPTR CommentPtr;
	UINT32 State = DFSNMgmtDfsInfo2StateTable( this );
	UINT32 NumberOfStorages;
	[Property.DFSNMGMTDfsInfoPtrCount = Property.DFSNMGMTDfsInfoPtrCount + 1]
	struct {};
	switch
	{
		case Property.MSRPCNdr64: Align8 Pad;
	}
}
//
//	[MS-DFSNM] DFS_INFO_2 Referent Part
//	Alignment:None
//
struct DFSNMgmtDfsInfo2Ref
{
	Switch {
		Case property.DFSNMGMTEntryPathPtr$[Property.DFSNMGMTDfsInfoRefCount] != 0:
			NdrWideString EntryPath;
	}
	Switch {
		Case property.DFSNMGMTCommentPtr$[Property.DFSNMGMTDfsInfoRefCount] != 0:
			NdrWideString Comment;
	}
}

Table DFSNMgmtDfsInfo2StateTable(Value)
{
	Switch( Value )
	{
		Case 0x00000001: "DFS_VOLUME_STATE_OK ";
		Case 0x00000002: "DFS_VOLUME_STATE_INCONSISTENT";
		Case 0x00000003: "DFS_VOLUME_STATE_OFFLINE";
		Case 0x00000004: "DFS_VOLUME_STATE_ONLINE";
		Case 0x00000100: "DFS_VOLUME_FLAVOR_STANDALONE";
		Case 0x00000200: "DFS_VOLUME_FLAVOR_AD_BLOB";
		Default: "unknown";
	}
}

//
//	[MS-DFSNM] DFS_INFO_3 Pointer Part
//	Alignment:None
//

Struct DFSNMgmtDfsInfo3Ptr
{
	[Post.property.DFSNMGMTEntryPathPtr$[Property.DFSNMGMTDfsInfoPtrCount] = EntryPathPtr.ReferentID]
	NDRPTR EntryPathPtr;
	[Post.property.DFSNMGMTCommentPtr$[Property.DFSNMGMTDfsInfoPtrCount] = CommentPtr.ReferentID]
	NDRPTR CommentPtr;
	UINT32 State = DFSNMgmtDfsInfo2StateTable( this );
	UINT32 NumberOfStorages;
	[Post.property.DFSNMGMTStoragePtr$[Property.DFSNMGMTDfsInfoPtrCount] = StoragePtr.ReferentID]
	NDRPTR StoragePtr;
	[Property.DFSNMGMTDfsInfoPtrCount = Property.DFSNMGMTDfsInfoPtrCount + 1]
	struct {};
	
}
//
//	[MS-DFSNM] DFS_INFO_3 Referent Part
//	Alignment:None
//
struct DFSNMgmtDfsInfo3Ref
{
	switch {
		Case property.DFSNMGMTEntryPathPtr$[Property.DFSNMGMTDfsInfoRefCount] != 0:
			NdrWideString EntryPath;
	}
	Switch {
		Case property.DFSNMGMTCommentPtr$[Property.DFSNMGMTDfsInfoRefCount] != 0:
			NdrWideString Comment;
	}
	Switch {
		Case property.DFSNMGMTStoragePtr$[Property.DFSNMGMTDfsInfoRefCount] != 0:
			struct
			{
				NdrConformant	Size;
				[Property.DFSNMGMTStorageInfoPtrCount = 0]
				DFSNMgmtDfsStorageInfoPtr StorageInfoPtr[Size.MaxCount];
				[Property.DFSNMGMTStorageInfoRefCount = 0]
				[MaxLoopCount = Size.MaxCount]
				while[Property.DFSNMGMTStorageInfoRefCount < Size.MaxCount]
				{
					[Post.Property.DFSNMGMTStorageInfoRefCount = Property.DFSNMGMTStorageInfoRefCount + 1]
					DFSNMgmtDfsStorageInfoRef StorageInfoRef;
				}
			}
	}
}
//
//	[MS-DFSNM] DFS_INFO_4 Pointer Part
//	Alignment:None
//

Struct DFSNMgmtDfsInfo4Ptr 
{
	[Post.property.DFSNMGMTEntryPathPtr$[Property.DFSNMGMTDfsInfoPtrCount] = EntryPathPtr.ReferentID]
	NDRPTR EntryPathPtr;
	[Post.property.DFSNMGMTCommentPtr$[Property.DFSNMGMTDfsInfoPtrCount] = CommentPtr.ReferentID]
	NDRPTR CommentPtr;
	UINT32 State = DFSNMgmtDfsInfo2StateTable( this );
	UINT32 Timeout;
	MSRPCGuid Guid;
	UINT32 NumberOfStorages;
	[Property.DFSNMgmtStoragePtr$[Property.DFSNMGMTDfsInfoPtrCount] = StoragePtr.ReferentID]
	NDRPTR StoragePtr;
	[Property.DFSNMGMTDfsInfoPtrCount = Property.DFSNMGMTDfsInfoPtrCount + 1]
	struct {};
}

//
//	[MS-DFSNM] DFS_INFO_4 Referent Part
//	Alignment:None
//
struct DFSNMgmtDfsInfo4VariantRef
{
	switch {
		Case property.DFSNMGMTEntryPathPtr$[Property.DFSNMGMTDfsInfoRefCount] != 0:
			NdrWideString EntryPath;
	}
	switch {
		Case property.DFSNMGMTEntryPathPtr$[Property.DFSNMGMTDfsInfoRefCount] != 0:
			NdrWideString Comment;
	}
	switch{
		case Property.DFSNMgmtStoragePtr$[Property.DFSNMGMTDfsInfoRefCount] != 0:
			struct
			{
				NdrConformant NumberOfStoragesConformant;
				[Property.DFSNMGMTStorageInfoPtrCount = 0]
				DFSNMgmtDfsStorageInfoPtr StorageInfoPtr[NumberOfStoragesConformant.Maxcount];
				[Property.DFSNMGMTStorageInfoRefCount = 0]
				[MaxLoopCount = NumberOfStoragesConformant.MaxCount]
				while[Property.DFSNMGMTStorageInfoRefCount < NumberOfStoragesConformant.MaxCount]
				{
					[Post.Property.DFSNMGMTStorageInfoRefCount = Property.DFSNMGMTStorageInfoRefCount + 1]
					DFSNMgmtDfsStorageInfoRef StorageInfoRef;
				}
				
			}
		}
}

//
//	[MS-DFSNM] DFS_INFO_5 Pointer Part
//	Alignment:None
//

Struct DFSNMgmtDfsInfo5Ptr
{
	[Post.property.DFSNMGMTEntryPathPtr$[Property.DFSNMGMTDfsInfoPtrCount] = EntryPathPtr.ReferentID]
	NDRPTR EntryPathPtr;
	[Post.property.DFSNMGMTCommentPtr$[Property.DFSNMGMTDfsInfoPtrCount] = CommentPtr.ReferentID]
	NDRPTR CommentPtr;
	UINT32 State = DFSNMgmtDfsInfo2StateTable( this );
	UINT32 Timeout;
	MSRPCGuid Guid;
	DFSNMgmtDfsInfo5PropertyFlags PropertyFlags;
	UINT32 MetadataSize;
	UINT32 NumberOfStorages;
	[Property.DFSNMGMTDfsInfoPtrCount = Property.DFSNMGMTDfsInfoPtrCount + 1]
	struct {};
	switch
	{
		case Property.MSRPCNdr64: Align8 Pad;
	}
}

//
//	[MS-DFSNM] DFS_INFO_5 Referent Part
//	Alignment:None
//

struct DFSNMgmtDfsInfo5Ref
{
	Switch {
		Case property.DFSNMGMTEntryPathPtr$[Property.DFSNMGMTDfsInfoRefCount] != 0:
			NdrWideString EntryPath;
	}
	Switch {
		Case property.DFSNMGMTCommentPtr$[Property.DFSNMGMTDfsInfoRefCount] != 0:
			NdrWideString Comment;
	}
}

Struct DFSNMgmtDfsInfo5PropertyFlags
{
	UINT32 DfsInfo5PropertyFlags
	{
		UINT32 InsiteReferrals:1 = FormatString("(%s) %s", this.ToBitString, this ? "DFS in-site referral mode is enabled." : "DFS in-site referral mode isn't enabled.");
		UINT32 RootScalability:1 = FormatString("(%s) %s", this.ToBitString, this ? "DFS root scalability mode is enabled." : "DFS root scalability mode isn't enabled.");
		UINT32 SiteCosting:1 = FormatString("    (%s) %s", this.ToBitString, this ? "DFS referral site costing is enabled" : "DFS referral site costing isn't enabled");
		UINT32 TargetFailback:1 = FormatString(" (%s) %s", this.ToBitString, this ? "DFS client target failback is enabled." : "DFS client target failback isn't enabled.");
		UINT32 ClusterEnabled:1 = FormatString(" (%s) %s", this.ToBitString, this ? "Clustered DFS namespace is enabled." : "Clustered DFS namespace isn't enabled.");
		UINT32 ABDE:1 = FormatString("           (%s) %s", this.ToBitString, this ? "Enables Access Based Directory Enumeration (ABDE) mode on a domainv2-based DFS namespace or a stand-alone DFS namespace." : "Doesn't enable Access Based Directory Enumeration (ABDE) mode on a domainv2-based DFS namespace or a stand-alone DFS namespace.");
		UINT32 Unused:26 = FormatString("         (%s)", this.ToBitString);
	}
}

//
//	[MS-DFSNM] DFS_INFO_6 Pointer Part
//	Alignment:None
//

Struct DFSNMgmtDfsInfo6Ptr
{
	[Post.property.DFSNMGMTEntryPathPtr$[Property.DFSNMGMTDfsInfoPtrCount] = EntryPathPtr.ReferentID]
	NDRPTR EntryPathPtr;
	[Post.property.DFSNMGMTCommentPtr$[Property.DFSNMGMTDfsInfoPtrCount] = CommentPtr.ReferentID]
	NDRPTR CommentPtr;
	UINT32 State = DFSNMgmtDfsInfo2StateTable( this );
	UINT32 Timeout;
	MSRPCGuid Guid;
	DFSNMgmtDfsInfo5PropertyFlags PropertyFlags;
	UINT32 MetadataSize;
	UINT32 NumberOfStorages;
	[Post.property.DFSNMGMTStoragePtr$[Property.DFSNMGMTDfsInfoPtrCount] = StoragePtr.ReferentID]
	NDRPTR StoragePtr;
	[Property.DFSNMGMTDfsInfoPtrCount = Property.DFSNMGMTDfsInfoPtrCount + 1]
	struct {};
}

//
//	[MS-DFSNM] DFS_INFO_6 Referent Part
//	Alignment:None
//
struct DFSNMgmtDfsInfo6Ref
{
	Switch {
		Case property.DFSNMGMTEntryPathPtr$[Property.DFSNMGMTDfsInfoRefCount] != 0:
			NdrWideString EntryPath;
	}
	Switch {
		Case property.DFSNMGMTCommentPtr$[Property.DFSNMGMTDfsInfoRefCount] != 0:
			NdrWideString Comment;
	}
	Switch {
		Case property.DFSNMGMTStoragePtr$[Property.DFSNMGMTDfsInfoRefCount] != 0:
			struct
			{
				NdrConformant	Size;
				[Property.DFSNMGMTStorageInfoPtrCount = 0]
				DFSNMgmtDfsStorageInfo1Ptr StorageInfoPtr[Size.MaxCount];
				[Property.DFSNMGMTStorageInfoRefCount = 0]
				[MaxLoopCount = Size.MaxCount]
				while[Property.DFSNMGMTStorageInfoRefCount < Size.MaxCount]
				{
					[Post.Property.DFSNMGMTStorageInfoRefCount = Property.DFSNMGMTStorageInfoRefCount + 1]
					DFSNMgmtDfsStorageInfo1Ref StorageInfoRef;
				}
			}
	}
}
//
//	[MS-DFSNM] DFS_INFO_7
//	Alignment:4
//

Struct DFSNMgmtDfsInfo7
{
	MSRPCGuid GenerationGuid;
}

//
//	[MS-DFSNM] DFS_INFO_8 Pointer Part
//	Alignment:None
//
Struct DFSNMgmtDfsInfo8Ptr
{
	[Post.property.DFSNMGMTEntryPathPtr$[Property.DFSNMGMTDfsInfoPtrCount] = EntryPathPtr.ReferentID]
	NDRPTR EntryPathPtr;
	[Post.property.DFSNMGMTCommentPtr$[Property.DFSNMGMTDfsInfoPtrCount] = CommentPtr.ReferentID]
	NDRPTR CommentPtr;
	UINT32 State = DFSNMgmtDfsInfo2StateTable( this );
	UINT32 Timeout;
	MSRPCGuid Guid;
	DFSNMgmtDfsInfo5PropertyFlags PropertyFlags;
	UINT32 MetadataSize;
	[Property.DFSInfo8SecurityDescriptorLength]
	UINT32 SecurityDescriptorLength;
	[Post.property.DFSNMGMTSecurityDescriptorPtr$[Property.DFSNMGMTDfsInfoPtrCount] = SecurityDescriptorPtr.ReferentID]
	NDRPTR SecurityDescriptorPtr;
	UINT32 NumberOfStorages;
	[Property.DFSNMGMTDfsInfoPtrCount = Property.DFSNMGMTDfsInfoPtrCount + 1]
	struct {};
	switch
	{
		case Property.MSRPCNdr64: Align8 Pad;
	}
}

//
//	[MS-DFSNM] DFS_INFO_8 Referent Part
//	Alignment:None
//
struct DFSNMgmtDfsInfo8Ref
{
	Switch {
		Case property.DFSNMGMTEntryPathPtr$[Property.DFSNMGMTDfsInfoRefCount] != 0:
			NdrWideString EntryPath;
	}
	Switch {
		Case property.DFSNMGMTCommentPtr$[Property.DFSNMGMTDfsInfoRefCount] != 0:
			NdrWideString Comment;
	}
	Switch {
		Case property.DFSNMGMTSecurityDescriptorPtr$[Property.DFSNMGMTDfsInfoRefCount] != 0:
					Struct
					{
						NdrConformant SecurityDescriptorConf;
						Switch
						{
							case SecurityDescriptorConf.MaxCount>0:
								NdrSecurityDescriptor SecurityDescriptor;
						}
			}
	}
}
//
//	[MS-DFSNM] DFS_INFO_9 Pointer Part
//	Alignment:None
//

Struct DFSNMgmtDfsInfo9Ptr
{
	[Post.property.DFSNMGMTEntryPathPtr$[Property.DFSNMGMTDfsInfoPtrCount] = EntryPathPtr.ReferentID]
	NDRPTR EntryPathPtr;
	[Post.property.DFSNMGMTCommentPtr$[Property.DFSNMGMTDfsInfoPtrCount] = CommentPtr.ReferentID]
	NDRPTR CommentPtr;
	UINT32 State = DFSNMgmtDfsInfo2StateTable( this );
	UINT32 Timeout;
	MSRPCGuid Guid;
	DFSNMgmtDfsInfo5PropertyFlags PropertyFlags;
	UINT32 MetadataSize = MustBeSetToTable(this,"0");
	[Property.DFSInfo9SecurityDescriptorLength]
	UINT32 SecurityDescriptorLength;
	[Post.property.DFSNMGMTSecurityDescriptorPtr$[Property.DFSNMGMTDfsInfoPtrCount] = SecurityDescriptorPtr.ReferentID]
	NDRPTR SecurityDescriptorPtr;
	UINT32 NumberOfStorages;
	[Post.property.DFSNMGMTStoragePtr$[Property.DFSNMGMTDfsInfoPtrCount] = StoragePtr.ReferentID]
	NDRPTR StoragePtr;
	[Property.DFSNMGMTDfsInfoPtrCount = Property.DFSNMGMTDfsInfoPtrCount + 1]
	struct {};
}

//
//	[MS-DFSNM] DFS_INFO_9 Referent Part
//	Alignment:None
//
struct DFSNMgmtDfsInfo9Ref
{
	switch {
		Case property.DFSNMGMTEntryPathPtr$[Property.DFSNMGMTDfsInfoRefCount] != 0:
			NdrWideString EntryPath;
	}
	Switch {
		Case property.DFSNMGMTCommentPtr$[Property.DFSNMGMTDfsInfoRefCount] != 0:
			NdrWideString Comment;
	}
	Switch {
		Case property.DFSNMGMTSecurityDescriptorPtr$[Property.DFSNMGMTDfsInfoRefCount] != 0:
			Struct
			{
				NdrConformant SecurityDescriptorConf;
				Switch
				{
					case SecurityDescriptorConf.MaxCount>0:
						NdrSecurityDescriptor SecurityDescriptor;
				}
			}
	}
	Switch {
		Case property.DFSNMGMTStoragePtr$[Property.DFSNMGMTDfsInfoRefCount] != 0:
			struct
			{
				NdrConformant	Size;
				[Property.DFSNMGMTStorageInfoPtrCount = 0]
				DFSNMgmtDfsStorageInfo1Ptr StorageInfoPtr[Size.MaxCount];
				[Property.DFSNMGMTStorageInfoRefCount = 0]
				[MaxLoopCount = Size.MaxCount]
				while[Property.DFSNMGMTStorageInfoRefCount < Size.MaxCount]
				{
					[Post.Property.DFSNMGMTStorageInfoRefCount = Property.DFSNMGMTStorageInfoRefCount + 1]
					DFSNMgmtDfsStorageInfo1Ref StorageInfoRef;
				}
			}
	}
}
//
//	[MS-DFSNM] DFS_INFO_50
//	Alignment:8
//

Struct DFSNMgmtDfsInfo50
{
	UINT32 NamespaceMajorVersion;
	UINT32 NamespaceMinorVersion;
	UINT64 NamespaceCapabilities = DFSNMgmtDfsInfo50NamespaceCapabilitiesTable( this );
	switch
	{
		case Property.MSRPCNdr64: Align8 Pad;
	}
}

Table DFSNMgmtDfsInfo50NamespaceCapabilitiesTable( Value )
{
	Switch( Value )
	{
		Case 0x0000000000000001: "DFS__NAMESPACE_CAPABILITY_ABDE - The specified DFS root or DFS link supports the ABDE flag.Only  supports ABDE mode.";
		Default: "unknown";
	}
}

//
//	[MS-DFSNM] DFS_INFO_101
//
Struct DFSNMgmtDfsInfo101
{
	UINT32 State = DFSNMgmtDfsInfo101StateTable( this );
}

Table DFSNMgmtDfsInfo101StateTable( Value )
{
	Switch( Value )
	{
		Case 0x00000001: "DFS_VOLUME_STATE_OK - The specified DFS root or DFS link is in the normal state. This state MUST NOT be set to this value.";
		Case 0x00000003: "DFS_VOLUME_STATE_OFFLINE - The specified DFS root or DFS link is offline or unavailable.";
		Case 0x00000004: "DFS_VOLUME_STATE_ONLINE - The specified DFS root or DFS link is available.";
		Case 0x00000010: "DFS_VOLUME_STATE_RESYNCHRONIZE - Forces a resynchronization on the DFS root. This flag is valid only for a DFS root. This operation  is an incremental synchronization that picks up only changed objects in the metadata.";
		Case 0x00000020: "DFS_VOLUME_STATE_STANDBY - Sets a root volume to standby mode. This flag is valid only for a clustered DFS root.";
		Case 0x00000040: "FS_VOLUME_STATE_FORCE_SYNC - Forces a full resynchronization operation on the DFS root target of a specified domainv2-based DFS namespace or stand-alone DFS namespace to identify DFS links that have been added or deleted. This is not supported on a domainv1-based DFS namespace. DFS links MUST NOT be specified.";
		default: "unknown";
	}
}

//
//	[MS-DFSNM] DFS_INFO_102
//
Struct DFSNMgmtDfsInfo102
{
	UINT32 Timeout;
}

//
//	[MS-DFSNM] DFS_INFO_103
//
Struct DFSNMgmtDfsInfo103
{
	UINT32 PropertyFlagMask;
	UINT32 PropertyFlags = DFSNMgmtDfsInfo103PropertyFlagsTable( this );
}

Table DFSNMgmtDfsInfo103PropertyFlagsTable( Value )
{
	Switch( Value )
	{
		Case 0x00000001: "DFS_PROPERTY_FLAG_INSITE_REFERRALS - When set, enables DFS in-site referral mode. Valid for domain and stand-alone DFS roots and links.";
		Case 0x00000002: "DFS_PROPERTY_FLAG_ROOT_SCALABILITY - When set, enables DFS root scalability mode. This flag is valid only for the DFS root of a domain-based DFS namespace.";
		Case 0x00000004: "DFS_PROPERTY_FLAG_SITE_COSTING - When set, enables DFS referral site costing. This flag is valid only for a DFS root.";
		Case 0x00000008: "DFS_PROPERTY_FLAG_TARGET_FAILBACK - When set, enables  DFS client target failback. Valid for domain and stand-alone DFS roots and links.";
		Case 0x00000010: "DFS_PROPERTY_FLAG_CLUSTER_ENABLED - When set, indicates a clustered DFS namespace.";
		Case 0x00000020: "DFS_PROPERTY_FLAG_ABDE - When set, enables ABDE mode on a domainv2-based DFS namespace or stand-alone DFS namespace.Only  supports ABDE mode.";
		Default: "unknown";
	}
}

//
//	[MS-DFSNM] DFS_INFO_104
//	Alignment:None
//

Struct DFSNMgmtDfsInfo104
{
	DFSNMgmtDfsTargetPriority TargetPriority;
}

//
//	[MS-DFSNM] DFS_INFO_105
//	Alignment:None
//
Struct DFSNMgmtDfsInfo105
{
	NDRPTR CommentPtr;
	UINT32 State = DFSNMgmtDfsInfo105StateTable( this );
	UINT32 Timeout;
	UINT32 PropertyFlagMask;
	UINT32 PropertyFlags = DFSNMgmtDfsInfo103PropertyFlagsTable( this );
	switch
	{
		case Property.MSRPCNdr64: Align8 Pad;
	}
	Switch {
		Case CommentPtr.ReferentID:
			NdrWideString Comment;
	}
}

Table DFSNMgmtDfsInfo105StateTable( Value )
{
	Switch( Value )
	{
		Case 0x00000000: "/* no name defined */ - Indicates that the existing state MUST NOT be changed.";
		Case 0x00000001: "DFS_VOLUME_STATE_OK - The specified DFS root or DFS link is in the normal state. This state MUST NOT be set to this value.";
		Case 0x00000003: "DFS_VOLUME_STATE_OFFLINE - The specified DFS root  or link is offline or unavailable.";
		Case 0x00000004: "DFS_VOLUME_STATE_ONLINE - The specified DFS root  or link is available.";
		Default: "unknown";
	}
}

//
//	[MS-DFSNM] DFS_INFO_106
//	Alignment:4
//

Struct DFSNMgmtDfsInfo106
{
	UINT32 State = DFSNMgmtDfsInfo106StateTable( this );
	DFSNMgmtDfsTargetPriority TargetPriority;
}

Table DFSNMgmtDfsInfo106StateTable( Value )
{
	Switch( Value )
	{
		Case 0x00000001: "DFS_STORAGE_STATE_OFFLINE - This target is offline and unavailable for use.";
		Case 0x00000002: "DFS_STORAGE_STATE_ONLINE - This target is online and available for use.";
		Default: "unknown";
	}
}

//
//	[MS-DFSNM] DFS_INFO_107
//	Alignment:None
//
Struct DFSNMgmtDfsInfo107
{
	NDRPTR CommentPtr;
	UINT32 State = DFSNMgmtDfsInfo107StateTable( this );
	UINT32 Timeout;
	UINT32 PropertyFlagMask;
	UINT32 PropertyFlag = DFSNMgmtDfsInfo103PropertyFlagsTable( this );
	INT32 SecurityDescriptorLength;
	NDRPTR SecurityDescriptorPtr;
	Switch {
		Case CommentPtr.ReferentID:
			NdrWideString Comment;
	}
	Switch {
		Case SecurityDescriptorPtr.ReferentID:
			Struct
			{
				NdrConformant SecurityDescriptorConf;
				Switch
				{
					case SecurityDescriptorConf.MaxCount>0:
						NdrSecurityDescriptor SecurityDescriptor;
				}
			}
	}
}

Table DFSNMgmtDfsInfo107StateTable( Value )
{
	Switch( Value )
	{
		Case 0x00000000: "Indicates that the existing state MUST NOT be changed.";
		Case 0x00000001: "DFS_VOLUME_STATE_OK - The specified DFS root or DFS link is in the normal state. This state MUST NOT be set to this value.";
		Case 0x00000003: "DFS_VOLUME_STATE_OFFLINE - The specified DFS root or DFS link is offline or unavailable.";
		Case 0x00000004: "DFS_VOLUME_STATE_ONLINE - The specified DFS root or DFS link is available.";
		Default: "unknown";
	}
}

//
//	[MS-DFSNM] DFS_INFO_100
//	Alignment:None
//

Struct DFSNMgmtDfsInfo100
{
	NDRPTR CommentPtr;
	Switch {
		Case CommentPtr.ReferentID:
			NdrWideString Comment;
	}
}

//
//	[MS-DFSNM] DFS_INFO_150
//	Alignment:NdrAlign
//

Struct DFSNMgmtDfsInfo150
{
	UINT32 SdLengthReserved;
	NDRPTR SecurityDescriptorPtr;
	Switch {
		Case SecurityDescriptorPtr.ReferentID:
			Struct
			{
				NdrConformant SecurityDescriptorConf;
				Switch
				{
					case SecurityDescriptorConf.MaxCount>0:
						NdrSecurityDescriptor SecurityDescriptor;
				}
			}
	}
}

//
//	[MS-DFSNM] DFS_INFO_200 Pointer Part
//	Alignment:None
//
Struct DFSNMgmtDfsInfo200Ptr
{
	[property.DFSNMGMTFtDfsNamePtr$[Property.DFSNMGMTDfsInfoPtrCount] = FtDfsNamePtr.ReferentID, Post.Property.DFSNMGMTDfsInfoPtrCount = Property.DFSNMGMTDfsInfoPtrCount + 1]
	NDRPTR FtDfsNamePtr;
	
}

//
//	[MS-DFSNM] DFS_INFO_200 Referent Part
//	Alignment:None
//
struct DFSNMgmtDfsInfo200Ref
{
	Switch {
		Case property.DFSNMGMTFtDfsNamePtr$[Property.DFSNMGMTDfsInfoRefCount] != 0:
			NdrWideString FtDfsName;
	}
}
//
//	[MS-DFSNM] DFS_INFO_300 Pointer Part
//	Alignment:NdrAlign
//
Struct DFSNMgmtDfsInfo300Ptr
{
	NdrAlign Pad;
	UINT32 Flags = DFSNMgmtDfsInfo300FlagsTable( this );
	[property.DFSNMGMTDfsNamePtr$[Property.DFSNMGMTDfsInfoPtrCount] = DfsNamePtr.ReferentID]
	NDRPTR DfsNamePtr;
}

//
//	[MS-DFSNM] DFS_INFO_300 Referent Part
//	Alignment:None
//
struct DFSNMgmtDfsInfo300Ref
{
	switch {
		Case property.DFSNMGMTDfsNamePtr$[Property.DFSNMGMTDfsInfoRefCount] != 0:
			NdrWideString DfsName;
	}
}
Table DFSNMgmtDfsInfo300FlagsTable( Value )
{
	Switch( Value )
	{
		Case 0x00000100: "DFS_VOLUME_FLAVOR_STANDALONE - Stand-alone DFS namespace.";
		Case 0x00000200: "DFS_VOLUME_FLAVOR_AD_BLOB - Domain-based DFS namespace.";
		Default: "unknown";
	}
}

//
//	[MS-DFSNM] DFS_INFO_1_CONTAINER
//	Alignment:NdrAlign
//

Struct DFSNMgmtDfsInfo1Container
{
	UINT32 EntriesRead;
	NDRPTR BufferPtr;
	Switch {
		Case BufferPtr.ReferentID:
			struct
			{
				NdrConformant	Size;
				[Property.DFSNMGMTDfsInfoPtrCount = 0]
				DFSNMgmtDfsInfo1Ptr DfsInfo1Ptr[Size.MaxCount];
				[Property.DFSNMGMTDfsInfoRefCount = 0]
				[MaxLoopCount = Size.MaxCount]
				while[Property.DFSNMGMTDfsInfoRefCount < Size.MaxCount]
				{
					[Post.Property.DFSNMGMTDfsInfoRefCount = Property.DFSNMGMTDfsInfoRefCount + 1]
					DFSNMgmtDfsInfo1Ref DfsInfo1Ref;
				}
			}
	}
}

//
//	[MS-DFSNM] DFS_INFO_2_CONTAINER
//	Alignment:NdrAlign
//

Struct DFSNMgmtDfsInfo2Container
{
	UINT32 EntriesRead;
	NdrConformant Size;
	NDRPTR BufferPtr;
	Switch {
		Case BufferPtr.ReferentID:
			struct
			{
				NdrConformant	Size;
				[Property.DFSNMGMTDfsInfoPtrCount = 0]
				DFSNMgmtDfsInfo2Ptr DfsInfo2Ptr[Size.MaxCount];
				[Property.DFSNMGMTDfsInfoRefCount = 0]
				[MaxLoopCount = Size.MaxCount]
				while[Property.DFSNMGMTDfsInfoRefCount < Size.MaxCount]
				{
					[Post.Property.DFSNMGMTDfsInfoRefCount = Property.DFSNMGMTDfsInfoRefCount + 1]
					DFSNMgmtDfsInfo2Ref DfsInfo2Ref;
				}
			}
	}
}

//
//	[MS-DFSNM] DFS_INFO_3_CONTAINER
//	Alignment:NdrAlign
//

Struct DFSNMgmtDfsInfo3Container
{
	UINT32 EntriesRead;
	NDRPTR BufferPtr;
	Switch {
		Case BufferPtr.ReferentID:
		struct
		{
			NdrConformant	Size;
			[Property.DFSNMGMTDfsInfoPtrCount = 0]
			DFSNMgmtDfsInfo3Ptr DfsInfo3Ptr[Size.MaxCount];
			[Property.DFSNMGMTDfsInfoRefCount = 0]
			[MaxLoopCount = Size.MaxCount]
			while[Property.DFSNMGMTDfsInfoRefCount < Size.MaxCount]
			{
				[Post.Property.DFSNMGMTDfsInfoRefCount = Property.DFSNMGMTDfsInfoRefCount + 1]
				DFSNMgmtDfsInfo3Ref DfsInfo3Ref;
			}
		}
	}
}

//
//	[MS-DFSNM] DFS_INFO_4_CONTAINER
//	Alignment:NdrAlign
//
Struct DFSNMgmtDfsInfo4Container
{
	[DFSNMgmtEntriesRead,DFSNMgmtEntriesRead1]
	UINT32 EntriesRead;
	NDRPTR BufferPtr;
	Switch 
	{
		Case BufferPtr.ReferentID:
		struct
		{
			NdrConformant EntriesReadConformant;
			[Property.DFSNMGMTDfsInfoPtrCount = 0]
			[MaxLoopCount = EntriesReadConformant.MaxCount]
			while cond[DFSNMgmtEntriesRead>0]
			{
				[DFSNMgmtEntriesRead=DFSNMgmtEntriesRead-1]
				DFSNMgmtDfsInfo4Ptr DfsInfo4Ptr;
			}
			[MaxLoopCount = EntriesReadConformant.MaxCount]
			while cond1[DFSNMgmtEntriesRead1>0]
			{
					[DFSNMgmtEntriesRead1=DFSNMgmtEntriesRead1-1]
					DFSNMgmtDfsInfo4VariantRef DfsInfo4VariantRef;
			}
		}
	}
}

//
//	[MS-DFSNM] DFS_INFO_5_CONTAINER
//	Alignment:NdrAlign
//
Struct DFSNMgmtDfsInfo5Container
{
	UINT32 EntriesRead;
	NDRPTR BufferPtr;
	Switch {
		Case BufferPtr.ReferentID:
		struct
		{
			NdrConformant	Size;
			[Property.DFSNMGMTDfsInfoPtrCount = 0]
			DFSNMgmtDfsInfo5Ptr DfsInfo5Ptr[Size.MaxCount];
			[Property.DFSNMGMTDfsInfoRefCount = 0]
			[MaxLoopCount = Size.MaxCount]
			while[Property.DFSNMGMTDfsInfoRefCount < Size.MaxCount]
			{
				[Post.Property.DFSNMGMTDfsInfoRefCount = Property.DFSNMGMTDfsInfoRefCount + 1]
				DFSNMgmtDfsInfo5Ref DfsInfo5Ref;
			}
		}
	}
}

//
//	[MS-DFSNM] DFS_INFO_6_CONTAINER
//	Alignment:NdrAlign
//
Struct DFSNMgmtDfsInfo6Container
{
	UINT32 EntriesRead;
	NDRPTR BufferPtr;
	Switch {
		Case BufferPtr.ReferentID:
		struct
		{
			NdrConformant	Size;
			[Property.DFSNMGMTDfsInfoPtrCount = 0]
			DFSNMgmtDfsInfo6Ptr DfsInfo6Ptr[Size.MaxCount];
			[Property.DFSNMGMTDfsInfoRefCount = 0]
			[MaxLoopCount = Size.MaxCount]
			while[Property.DFSNMGMTDfsInfoRefCount < Size.MaxCount]
			{
				[Post.Property.DFSNMGMTDfsInfoRefCount = Property.DFSNMGMTDfsInfoRefCount + 1]
				DFSNMgmtDfsInfo6Ref DfsInfo6Ref;
			}
		}
	}
}

//
//	[MS-DFSNM] DFS_INFO_8_CONTAINER
//	Alignment:NdrAlign
//
Struct DFSNMgmtDfsInfo8Container
{
	UINT32 EntriesRead;
	NDRPTR BufferPtr;
	Switch {
		Case BufferPtr.ReferentID:
			struct
			{
				NdrConformant	Size;
				[Property.DFSNMGMTDfsInfoPtrCount = 0]
				DFSNMgmtDfsInfo8Ptr DfsInfo8Ptr[Size.MaxCount];
				[Property.DFSNMGMTDfsInfoRefCount = 0]
				[MaxLoopCount = Size.MaxCount]
				while[Property.DFSNMGMTDfsInfoRefCount < Size.MaxCount]
				{
					[Post.Property.DFSNMGMTDfsInfoRefCount = Property.DFSNMGMTDfsInfoRefCount + 1]
					DFSNMgmtDfsInfo8Ref DfsInfo8Ref;
				}
			}
	}
}

//
//	[MS-DFSNM] DFS_INFO_9_CONTAINER
//	Alignment:NdrAlign
//
Struct DFSNMgmtDfsInfo9Container
{
	UINT32 EntriesRead;
	NDRPTR BufferPtr;
	Switch {
		Case BufferPtr.ReferentID:
		struct
		{
			NdrConformant	Size;
			[Property.DFSNMGMTDfsInfoPtrCount = 0]
			DFSNMgmtDfsInfo9Ptr DfsInfo9Ptr[Size.MaxCount];
			[Property.DFSNMGMTDfsInfoRefCount = 0]
			[MaxLoopCount = Size.MaxCount]
			while[Property.DFSNMGMTDfsInfoRefCount < Size.MaxCount]
			{
				[Post.Property.DFSNMGMTDfsInfoRefCount = Property.DFSNMGMTDfsInfoRefCount + 1]
				DFSNMgmtDfsInfo9Ref DfsInfo9Ref;
			}
		}
	}
}

//
//	[MS-DFSNM] DFS_INFO_200_CONTAINER
//	Alignment:NdrAlign
//
Struct DFSNMgmtDfsInfo200Container
{
	UINT32 EntriesRead;
	NDRPTR BufferPtr;
	Switch {
		Case BufferPtr.ReferentID:
		struct
		{
			[Property.DFSNMGMTDfsInfoPtrCount = 0]
			NdrConformant	Size;
			DFSNMgmtDfsInfo200Ptr DfsInfo200Ptr[Size.MaxCount];
			[Property.DFSNMGMTDfsInfoRefCount = 0, MaxLoopCount = Size.MaxCount]
			while[Property.DFSNMGMTDfsInfoRefCount < Size.MaxCount]
			{
				[Post.Property.DFSNMGMTDfsInfoRefCount = Property.DFSNMGMTDfsInfoRefCount + 1]
				DFSNMgmtDfsInfo200Ref DfsInfo200Ref;
			}
		}
	}
}

//
//	[MS-DFSNM] DFS_INFO_300_CONTAINER
//	Alignment:NdrAlign
//
Struct DFSNMgmtDfsInfo300Container
{
	UINT32 EntriesRead;
	NDRPTR BufferPtr;
	Switch {
		Case BufferPtr.ReferentID:
		struct
		{
			NdrConformant	Size;
			[Property.DFSNMGMTDfsInfoPtrCount = 0]
			DFSNMgmtDfsInfo300Ptr DfsInfo300Ptr[Size.MaxCount];
			[Property.DFSNMGMTDfsInfoRefCount = 0]
			[MaxLoopCount = Size.MaxCount]
			while[Property.DFSNMGMTDfsInfoRefCount < Size.MaxCount]
			{
				[Post.Property.DFSNMGMTDfsInfoRefCount = Property.DFSNMGMTDfsInfoRefCount + 1]
				DFSNMgmtDfsInfo300Ref DfsInfo300Ref;
			}
		}
	}
}

Table DFSNMgmtMethodNameTable( Opnum )
{
	Switch( Opnum )
	{
		Case 0: "NetrDfsManagerGetVersion";
		Case 1: "NetrDfsAdd";
		Case 2: "NetrDfsRemove";
		Case 3: "NetrDfsSetInfo";
		Case 4: "NetrDfsGetInfo";
		Case 5: "NetrDfsEnum";
		Case 6: "NetrDfsMove";
		Case 7: "Opnum7NotUsedOnWire";
		Case 8: "Opnum8NotUsedOnWire";
		Case 9: "Opnum9NotUsedOnWire";
		Case 10: "NetrDfsAddFtRoot";
		Case 11: "NetrDfsRemoveFtRoot";
		Case 12: "NetrDfsAddStdRoot";
		Case 13: "NetrDfsRemoveStdRoot";
		Case 14: "NetrDfsManagerInitialize";
		Case 15: "NetrDfsAddStdRootForced";
		Case 16: "NetrDfsGetDcAddress";
		Case 17: "NetrDfsSetDcAddress";
		Case 18: "NetrDfsFlushFtTable";
		Case 19: "NetrDfsAdd2";
		Case 20: "NetrDfsRemove2";
		Case 21: "NetrDfsEnumEx";
		Case 22: "NetrDfsSetInfo2";
		Case 23: "NetrDfsAddRootTarget";
		Case 24: "NetrDfsRemoveRootTarget";
		Case 25: "NetrDfsGetSupportedNamespaceVersion";
		Default: "unknown";
	}
}


Table DFSNMgmtNetrDfsAddFlagsTable( Value )
{
	Switch( Value )
	{
		Case 0x00000000: "Create a new link or add a new target to an existing link.";
		Case 0x00000001: "DFS_ADD_VOLUME - Create a new link in the DFS namespace if it does not already exist or fail if it already exists.";
		Case 0x00000002: "DFS_RESTORE_VOLUME - Add target without verifying its existence.";
		Default: "unknown";
	}
}

Table DFSNMgmtNetrDfsSetInfoLevelTable( Value )
{
	Switch( Value )
	{
		Case 0x00000064: "100 - Sets the comment associated with the root or link specified in the DfsInfo parameter. In this case, the DfsInfo parameter MUST point to a DFS_INFO_100 structure. The ServerName and ShareName parameters MUST be null.";
		Case 0x00000065: "101 - Sets the state associated with the root, link, root target or link target specified in DfsInfo. In this case, DfsInfo MUST point to a DFS_INFO_101 structure. and  allow setting the target state of a root target or a link target to either DFS_STORAGE_STATE_ONLINE or to  DFS_STORAGE_STATE_OFFLINE.  does not allow setting the target state of a root target to DFS_STORAGE_STATE_OFFLINE.";
		Case 0x00000066: "102 - Sets the time-out value associated with the root or link specified in DfsInfo. In this case, DfsInfo MUST point to a DFS_INFO_102 structure. The ServerName and ShareName parameters MUST be null.";
		Case 0x00000067: "103 - Sets the property flags for the root or link specified in DfsInfo. In this case, DfsInfo MUST point to a DFS_INFO_103 structure. The ServerName and ShareName parameters MUST be null.";
		Case 0x00000068: "104 - Sets the target priority rank and class for the root target or link target specified in DfsInfo. In this case, DfsInfo MUST point to a DFS_INFO_104 structure.";
		Case 0x00000069: "105 - Sets the comment, state, and time-out information along with property flags for the namespace root or link specified in DfsInfo. Does not apply to the root target or link target. In this case, DfsInfo MUST point to a DFS_INFO_105 structure. The ServerName and ShareName parameters MUST be null.";
		Case 0x0000006A: "106 - Sets the target state and priority for the DFS root target or DFS link target specified in DfsInfo. allows setting the target state of a root target or a link target to either DFS_STORAGE_STATE_ONLINE or to  DFS_STORAGE_STATE_OFFLINE.  does not allow setting the target state of a root target to DFS_STORAGE_STATE_OFFLINE. This does not apply to the DFS namespace root or link. DfsInfo MUST point to a DFS_INFO_106 structure.";
		Case 0x0000006B: "107 - Sets the comment, state, time-out,  and security descriptor information along with property flags for the namespace root or link specified in DfsInfo. This does not apply to a DFS root target or DFS link target. In this case, DfsInfo MUST point to a DFS_INFO_107 structure. The ServerName and ShareName parameters MUST be null. The security descriptor MUST NOT have owner, group, or system access control lists (SACLs) in it.";
		Case 0x00000096: "150 - Sets the security descriptor associated with a DFS link. Only stand-alone DFS namespaces and domainv2-based DFS namespaces are supported. The ServerName and ShareName parameters must both be NULL. When using NetrDfsSetInfo(), the security descriptor MUST NOT have owner, group, or SACL in it.";
		Default: "unknown";
	}
}

Table DFSNMgmtNetrDfsGetInfoLevelTable( Value )
{
	Switch( Value )
	{
		Case 0x00000001: "1 - Returns the name of the DFS root or DFS link.";
		Case 0x00000002: "2 - Returns the name, comment, state, and number of targets for the DFS root or DFS link.";
		Case 0x00000003: "3 - Returns the name, comment, state, number of targets, and information about each target for the DFS root or DFS link.";
		Case 0x00000004: "4 - Returns the name, comment, state, time-out,  GUID, number of targets, and information about each target for the DFS root or DFS link.";
		Case 0x00000005: "5 - Returns the name, comment, state, time-out, GUID, property flags, metadata size, and number of targets for the DFS root or DFS link.";
		Case 0x00000006: "6 - Returns the name, comment, state, GUID, time-out, property flags, metadata size, number of targets, and a list of targets for the DFS root or DFS link.";
		Case 0x00000007: "7 - Returns the version number GUID of the DFS metadata.";
		Case 0x00000008: "8 - Returns the name, comment, state, time-out, GUID, property flags, metadata size, number of targets, and security descriptor associated with the DFS link. Only stand-alone DFS namespaces and domainv2-based DFS namespaces are supported.";
		Case 0x00000009: "9 - Returns name, comment, state, GUID, time-out, property flags, metadata size, number of targets, list of targets, and security descriptor for the DFS link. Only stand-alone DFS namespaces and domainv2-based DFS namespaces are supported.";
		Case 0x00000032: "50 - Returns DFS metadata version and capability information of an existing DFS namespace. This level is valid only for the DFS namespace root, not for DFS links. The ServerName and ShareName parameters must be NULL. This level is supported only in  and .";
		Case 0x00000064: "100 - Returns the comment associated with the root or DFS link specified in the DfsEntryPath parameter.";
		Case 0x00000096: "150 - Returns the security descriptor associated with a DFS link.Only stand-alone DFS namespaces and domainv2-based DFS namespaces are supported.";
		Default: "unknown";
	}
}

Table DFSNMgmtNetrDfsEnumLevelTable( Value )
{
	Switch( Value )
	{
		Case 0x00000001: "1 - Gets the name of the DFS root and all links beneath it. In this case, NetrDfsEnum MUST point to an array of DFS_INFO_1 structures.";
		Case 0x00000002: "2 - Gets the name, comment, state, and number of targets for the DFS root and all links under the root. In this case, NetrDfsEnum MUST point to an array of DFS_INFO_2 structures.";
		Case 0x00000003: "3 - Gets the name, comment, state, number of targets, and information about each target for the DFS root and all links under the root. In this case, NetrDfsEnum MUST point to an array of DFS_INFO_3 structures.";
		Case 0x00000004: "4 - Gets the name, comment, state, time-out, GUID, number of targets, and information  about each target for the DFS root and all links under the root. In this case, NetrDfsEnum MUST point to an array of DFS_INFO_4 structures.";
		Case 0x00000005: "5 - Gets the name, comment, state, time-out, GUID, property flags, metadata size, and number of targets for a DFS root and all links under the root. In this case, NetrDfsEnum MUST point to an array of DFS_INFO_5 structures.";
		Case 0x00000006: "6 - Gets the name, comment, state, time-out, GUID, property flags, metadata size, number of targets, and target information for a DFS root or DFS links. In this case, NetrDfsEnum MUST point to an array of DFS_INFO_6 structures.";
		Case 0x00000008: "8 - Gets the name, comment, state, time-out, GUID, property flags, metadata size, and number of targets for a DFS root and all DFS links under the root. Also returns the security descriptor associated with each of the DFS links. In this case, NetrDfsEnum MUST point to an array of DFS_INFO_8 structures.";
		Case 0x00000009: "9 - Gets the name, comment, state, time-out, GUID, property flags, metadata size, and number of targets for a DFS root and all DFS links under the root. Also returns the security descriptor associated with each of the DFS links. In this case, NetrDfsEnum MUST point to an array of DFS_INFO_9 structures.";
		Case 0x0000012C: "300 - Enumerates the stand-alone and domain-based DFS roots hosted by the specified server. In this case, NetrDfsEnum MUST point to an array of DFS_INFO_300 structures.";
		Default: "unknown";
	}
}

Struct DFSNMgmtDfsInfoEnumStructPtr
{
	NDRPTR Pointer;
	Switch {
		Case Pointer.ReferentId != 0:
			DFSNMgmtDfsInfoEnumStruct DfsEnum;
	}
}

Table DFSNMgmtNetrDfsMoveFlagsTable( Value )
{
	Switch( Value )
	{
		Case 0x00000001: "DFS_MOVE_FLAG_REPLACE_IF_EXISTS - If the destination path is an existing link, replace it as part of the move operation.";
		Default: "unknown";
	}
}

Struct DFSNMgmtDfsmRootListPtr
{
	NDRPTR Pointer;
	Switch {
		Case Pointer.ReferentId != 0:
			DFSNMgmtDfsmRootList RootList;
	}
}

Struct DFSNMgmtDfsmRootListPtrPtr
{
	NDRPTR Pointer;
	Switch {
		Case Pointer.ReferentId != 0:
			DFSNMgmtDfsmRootListPtr RootList;
	}
}

Table DFSNMgmtNetrDfsSetDcAddressFlagsTable( Value )
{
	Switch( Value )
	{
		Case 0x00000000: "NET_DFS_SETDC_FLAGS - Indicates no additional operation is requested";
		Case 0x00000001: "NET_DFS_SETDC_TIMEOUT - Sets the time-out value based on the Timeout parameter.";
		Case 0x00000002: "NET_DFS_SETDC_INIT_PKT - Instructs the called server to reload its DFS metadata from the specified DC.";
		Default: "unknown";
	}
}

Table DFSNMgmtNetrDfsAdd2FlagsTable( Value )
{
	Switch( Value )
	{
		Case 0x00000000: "Create a new link or add a new target to an existing link.";
		Case 0x00000001: "DFS_ADD_VOLUME - Create a new link in the DFS namespace if it does not exist, or fail if it exists.";
		Case 0x00000002: "DFS_RESTORE_VOLUME - Add a target without verifying its existence.";
		Default: "unknown";
	}
}

Table DFSNMgmtNetrDfsEnumExLevelTable( Value )
{
	Switch( Value )
	{
		Case 0x00000001: "1 - Gets the name of the DFS root and all links beneath it. In this case, NetrDfsEnum MUST point to an array of DFS_INFO_1 structures.";
		Case 0x00000002: "2 - Gets the name, comment, state, and number of targets for the DFS root and all links under the root. In this case, NetrDfsEnum MUST point to an array of DFS_INFO_2 structures.";
		Case 0x00000003: "3 - Gets the name, comment, state, number of targets, and information about each target for the DFS root and all links under the root. In this case, NetrDfsEnum MUST point to an array of DFS_INFO_3 structures.";
		Case 0x00000004: "4 - Gets the name, comment, state, time-out, GUID, number of targets, and information about each target for the DFS root and all links under the root. In this case, NetrDfsEnum MUST point to an array of DFS_INFO_4 structures.";
		Case 0x00000005: "5 - Gets the name, comment, state, time-out, GUID, property flags, metadata size, and number of targets for a DFS root and all links under the root. In this case, NetrDfsEnum MUST point to an array of DFS_INFO_5 structures.";
		Case 0x00000006: "6 - Gets the name, comment, state, time-out, GUID, property flags, metadata size, number of targets, and target information for a root or link. In this case, NetrDfsEnum MUST point to an array of DFS_INFO_6 structures.";
		Case 0x00000008: "8 - Gets the name, comment, state, time-out, GUID, property flags, metadata size, and number of targets for a DFS root and all links under the root. Also returns the security descriptor associated with each of the DFS links. In this case, NetrDfsEnum MUST point to an array of DFS_INFO_8 structures.";
		Case 0x00000009: "9 - Gets the name, comment, state, time-out, GUID, property flags, metadata size, and number of targets for a DFS root and all links under the root. Also returns the security descriptor associated with each of the DFS links. In this case, NetrDfsEnum MUST point to an array of DFS_INFO_9 structures.";
		Case 0x000000C8: "200 - Enumerates all of the domain-based DFS namespace in a domain. In this case, NetrDfsEnum MUST point to an array of DFS_INFO_200 structures.";
		Case 0x0000012C: "300 - Enumerates the stand-alone and domain-based DFS roots hosted by the specified server. In this case, NetrDfsEnum MUST point to an array of DFS_INFO_300 structures.";
		Default: "unknown";
	}
}

Table DFSNMgmtNetrDfsSetInfo2LevelTable( Value )
{
	Switch( Value )
	{
		Case 0x00000064: "100 - Sets the comment associated with the root or link specified in the DfsInfo parameter. In this case, the DfsInfo parameter MUST point to a DFS_INFO_100 structure.";
		Case 0x00000065: "101 - Sets the storage state associated with the root or link specified in DfsInfo. In this case, DfsInfo MUST point to a DFS_INFO_101 structure. and  allow setting the target state of a root target or a link target to either DFS_STORAGE_STATE_ONLINE or to  DFS_STORAGE_STATE_OFFLINE.  does not allow setting the target state of a root target to DFS_STORAGE_STATE_OFFLINE.";
		Case 0x00000066: "102 - Sets the time-out value associated with the root or link specified in DfsInfo. In this case, DfsInfo MUST point to a DFS_INFO_102 structure.";
		Case 0x00000067: "103 - Sets the property flags for the root or link specified in DfsInfo. In this case, DfsInfo MUST point to a DFS_INFO_103 structure.";
		Case 0x00000068: "104 - Sets the target priority rank and class for the root target or link target specified in DfsInfo. In this case, DfsInfo MUST point to a DFS_INFO_104 structure.";
		Case 0x00000069: "105 - Sets the comment, state, and time-out information along with property flags for the namespace root or link specified in DfsInfo. Does not apply to the root target or link target. In this case, DfsInfo MUST point to a DFS_INFO_105 structure.";
		Case 0x0000006A: "106 - Sets the target state and priority for the root target or link target specified in DfsInfo. This does not apply to the DFS namespace root or link. DfsInfo MUST point to a DFS_INFO_106 structure. allows setting the target state of a root target or a link target to either DFS_STORAGE_STATE_ONLINE or to  DFS_STORAGE_STATE_OFFLINE.  does not allow setting the target state of a root target to DFS_STORAGE_STATE_OFFLINE.";
		Case 0x0000006B: "107 - Sets the comment, state, time-out, and security descriptor information along with property flags for the namespace root or link specified in DfsInfo. This does not apply to the root target or link target. In this case, DfsInfo MUST point to a DFS_INFO_107 structure. The ServerName and ShareName parameters MUST be null. The security descriptor MUST NOT have owner, group, or SACL in it.";
		Case 0x00000096: "150 - Sets the security descriptor associated with a DFS link. Only stand-alone DFS namespaces and domainv2-based DFS namespaces are supported. The ServerName and ShareName parameters must both be NULL. When using NetrDfsSetInfo (), the security descriptor MUST NOT have owner, group, or SACL in it.";
		Default: "unknown";
	}
}

Table DFSNMgmtNetrDfsAddRootTargetLevelTable( Value )
{
	Switch( Value )
	{
		Case 0x00000064: "100 - Sets the comment associated with the root or link specified in the DfsInfo parameter. In this case, the DfsInfo parameter MUST point to a DFS_INFO_100 structure.";
		Case 0x00000065: "101 - Sets the storage state associated with the root or link specified in DfsInfo. In this case, DfsInfo MUST point to a DFS_INFO_101 structure. and  allow setting the target state of a root target or a link target to either DFS_STORAGE_STATE_ONLINE or to  DFS_STORAGE_STATE_OFFLINE.  does not allow setting the target state of a root target to DFS_STORAGE_STATE_OFFLINE.";
		Case 0x00000066: "102 - Sets the time-out value associated with the root or link specified in DfsInfo. In this case, DfsInfo MUST point to a DFS_INFO_102 structure.";
		Case 0x00000067: "103 - Sets the property flags for the root or link specified in DfsInfo. In this case, DfsInfo MUST point to a DFS_INFO_103 structure.";
		Case 0x00000068: "104 - Sets the target priority rank and class for the root target or link target specified in DfsInfo. In this case, DfsInfo MUST point to a DFS_INFO_104 structure.";
		Case 0x00000069: "105 - Sets the comment, state, and time-out information along with property flags for the namespace root or link specified in DfsInfo. Does not apply to the root target or link target. In this case, DfsInfo MUST point to a DFS_INFO_105 structure.";
		Case 0x0000006A: "106 - Sets the target state and priority for the root target or link target specified in DfsInfo. This does not apply to the DFS namespace root or link. DfsInfo MUST point to a DFS_INFO_106 structure. allows setting the target state of a root target or a link target to either DFS_STORAGE_STATE_ONLINE or to  DFS_STORAGE_STATE_OFFLINE.  does not allow setting the target state of a root target to DFS_STORAGE_STATE_OFFLINE.";
		Case 0x0000006B: "107 - Sets the comment, state, time-out, and security descriptor information along with property flags for the namespace root or link specified in DfsInfo. This does not apply to the root target or link target. In this case, DfsInfo MUST point to a DFS_INFO_107 structure. The ServerName and ShareName parameters MUST be null. The security descriptor MUST NOT have owner, group, or SACL in it.";
		Case 0x00000096: "150 - Sets the security descriptor associated with a DFS link. Only stand-alone DFS namespaces and domainv2-based DFS namespaces are supported. The ServerName and ShareName parameters must both be NULL. When using NetrDfsSetInfo (), the security descriptor MUST NOT have owner, group, or SACL in it.";
		Default: "unknown";
	}
}

Table DFSNMgmtNetrDfsRemoveRootTargetFlagsTable( Value )
{
	Switch( Value )
	{
		Case 0x80000000: "DFS_FORCE_REMOVE - Forcibly remove the DFS root target.";
		Default: "unknown";
	}
}

Table DFSNMgmtNetrDfsGetSupportedNamespaceVersionLevelTable( Value )
{
	Switch( Value )
	{
		Case 0x00000064: "100 - Sets the comment associated with the root or link specified in the DfsInfo parameter. In this case, the DfsInfo parameter MUST point to a DFS_INFO_100 structure.";
		Case 0x00000065: "101 - Sets the storage state associated with the root or link specified in DfsInfo. In this case, DfsInfo MUST point to a DFS_INFO_101 structure. and  allow setting the target state of a root target or a link target to either DFS_STORAGE_STATE_ONLINE or to  DFS_STORAGE_STATE_OFFLINE.  does not allow setting the target state of a root target to DFS_STORAGE_STATE_OFFLINE.";
		Case 0x00000066: "102 - Sets the time-out value associated with the root or link specified in DfsInfo. In this case, DfsInfo MUST point to a DFS_INFO_102 structure.";
		Case 0x00000067: "103 - Sets the property flags for the root or link specified in DfsInfo. In this case, DfsInfo MUST point to a DFS_INFO_103 structure.";
		Case 0x00000068: "104 - Sets the target priority rank and class for the root target or link target specified in DfsInfo. In this case, DfsInfo MUST point to a DFS_INFO_104 structure.";
		Case 0x00000069: "105 - Sets the comment, state, and time-out information along with property flags for the namespace root or link specified in DfsInfo. Does not apply to the root target or link target. In this case, DfsInfo MUST point to a DFS_INFO_105 structure.";
		Case 0x0000006A: "106 - Sets the target state and priority for the root target or link target specified in DfsInfo. This does not apply to the DFS namespace root or link. DfsInfo MUST point to a DFS_INFO_106 structure. allows setting the target state of a root target or a link target to either DFS_STORAGE_STATE_ONLINE or to  DFS_STORAGE_STATE_OFFLINE.  does not allow setting the target state of a root target to DFS_STORAGE_STATE_OFFLINE.";
		Case 0x0000006B: "107 - Sets the comment, state, time-out, and security descriptor information along with property flags for the namespace root or link specified in DfsInfo. This does not apply to the root target or link target. In this case, DfsInfo MUST point to a DFS_INFO_107 structure. The ServerName and ShareName parameters MUST be null. The security descriptor MUST NOT have owner, group, or SACL in it.";
		Case 0x00000096: "150 - Sets the security descriptor associated with a DFS link. Only stand-alone DFS namespaces and domainv2-based DFS namespaces are supported. The ServerName and ShareName parameters must both be NULL. When using NetrDfsSetInfo (), the security descriptor MUST NOT have owner, group, or SACL in it.";
		Default: "unknown";
	}
}

Table DFSNMgmtNetrDfsManagerGetVersionTable( Value )
{
	Switch( Value )
	{
		Case 0x00000001: "The server MUST support stand-alone DFS namespaces, and opnums from 0 through 5, inclusive. The server MAY support domain-based DFS namespaces and other opnums.";
		Case 0x00000002: "In addition to the preceding, the server MUST support domain-based DFS namespaces and opnums 10 through 22, inclusive. The server MAY support hosting more than one DFS namespace on the same server.";
		Case 0x00000004: "In addition to the preceding, the server MUST support hosting more than one DFS namespace on the same server and Level parameter 200 of the NetrDfsEnumEx method. It SHOULD support opnum 6.";
		Case 0x00000006: "In addition to the above, the server MUST support domainv2-based DFS namespace and opnums 23 through 25, inclusive.";
		Default: "unknown";
	}
}

Table DFSNMgmtNetrDfsAddStdRootTable( Value )
{
	Switch( Value )
	{
		Case 0x00000000: "Successful completion.";
		Case 0x00000050: "The DFS namespace specified by the ServerName and RootShare parameters already exists.";
		Case 0x00000906: "The share specified by the RootShare parameter does not already exist.";
		default: "unknown";
	}
}

Table DFSNMgmtNetrDfsEnumExTable( Value )
{
	Switch( Value )
	{
		Case 0x00000000: "Successful completion.";
		Case 0x00000103: "There is no data to return.";
		default: "unknown";
	}
}
