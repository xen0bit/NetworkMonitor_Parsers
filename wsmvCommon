//#  (c) 2009 CodePlex Foundation
//#
//#  Title:                  Web Services Management Protocol Extensions for Windows Vista
//#
//#  Details:                
//#
//#  Public References:      http://www.dmtf.org/standards/published_documents/DSP0226.pdf
//#  Microsoft References:   [MS-WSMV]: Web Services Management Protocol Extensions for Windows Vista (8.0)
//#
//#  Comments:               
//#
//#  Revision Class and Date:Major, 1/20/2009
//#                          Minor, 3/11/2010
//#
//####

[Property.SoapBodySummary = "WSMV Payload"]
[RegisterBefore(SoapBody.DefaultSoapBody, WSMV, WSMVSoapActionTable(Property.SOAPAction))]
Protocol WSMV = Property.WSMVSummary
{
	Switch(Property.SOAPAction)
	{
		case "http://schemas.microsoft.com/wbem/wsman/1/windows/shell/Command":
		case "http://schemas.microsoft.com/wbem/wsman/1/windows/shell/CommandResponse":
			[Property.WSMVSummary = this.ToString]
			WSMVCommand WSMVCommand;
		Case "http://schemas.microsoft.com/wbem/wsman/1/windows/shell/Receive":
		Case "http://schemas.microsoft.com/wbem/wsman/1/windows/shell/ReceiveResponse":
			[Property.WSMVSummary = this.ToString]
			WSMVReceive WSMVReceive;
		Case "http://schemas.microsoft.com/wbem/wsman/1/windows/shell/Send":
		Case "http://schemas.microsoft.com/wbem/wsman/1/windows/shell/SendResponse":
			[Property.WSMVSummary = this.ToString]
			WSMVSend WSMVSend;
		Case "http://schemas.microsoft.com/wbem/wsman/1/windows/shell/Signal":
		Case "http://schemas.microsoft.com/wbem/wsman/1/windows/shell/SignalResponse":
			[Property.WSMVSummary = this.ToString]
			WSMVSignal WSMVSignal;
		Default:
			While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
			{
				XmlElement(true) AnyNode;
			}
	}
	
}

struct WSMVSignal = FormatString("%s Message", Property.WSMVSignalSummary)
{
	[Post.Local.WSMVSignal_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.WSMVSignal_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "SignalResponse"):
						[Property.WSMVSignalSummary = "Signal Response"]
						WSMVSignalResponseElement SendResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Signal"):
						[Property.WSMVSignalSummary = "Signal Request"]
						WSMVSignalElement Signal;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.WSMVSignalSummary = "Fault Signal Response"]
						SoapFaultElement FaultSignalElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WSMVSignalSummary = "Encrypted Signal Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

struct WSMVSend = FormatString("%s Message", Property.WSMVSendSummary)
{
	[Post.Local.WSMVSend_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.WSMVSend_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "SendResponse"):
						[Property.WSMVSendSummary = "Send Response"]
						WSMVSendResponseElement SendResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Send"):
						[Property.WSMVSendSummary = "Send Request"]
						WSMVSendElement Send;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.WSMVSendSummary = "Fault Send Response"]
						SoapFaultElement FaultSendElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WSMVSendSummary = "Encrypted Send Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

struct WSMVReceive = FormatString("%s Message", Property.WSMVReceiveSummary)
{
	[Post.Local.WSMVReceive_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.WSMVReceive_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ReceiveResponse"):
						[Property.WSMVReceiveSummary = "Receive Response"]
						WSMVReceiveResponseElement ReceiveResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Receive"):
						[Property.WSMVReceiveSummary = "Receive Request"]
						WSMVReceiveElement Receive;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.WSMVReceiveSummary = "Fault Receive Response"]
						SoapFaultElement FaultReceiveElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WSMVReceiveSummary = "Encrypted Receive Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

struct WSMVCommand = FormatString("%s Message", Property.WSMVCommandSummary)
{
	[Post.Local.WSMVCommand_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.WSMVCommand_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "CommandLine"):
						[Property.WSMVCommandSummary = "Command Request"]
						WSMVCommandLineElement CommandLine;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "CommandResponse"):
						[Property.WSMVCommandSummary = "Command Response"]
						WSMVCommandResponseElement CommandResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.WSMVCommandSummary = "Fault Command Response"]
						SoapFaultElement FaultCommandElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WSMVCommandSummary = "Encrypted Command Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

//wsmv header ActivityID
[RegisterBefore(
    SoapHeader.SoapHeaderNodes.Node,
    WSMVActivityId,
    Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ActivityId") && Contains(Property.SoapEnvelopeAttributes, "http://schemas.microsoft.com/wbem/wsman/1/wsman.xsd"))]
Struct WSMVActivityIdElement=this.ActivityIdContent
{
	[Post.Local.WSMVActivityIdElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("ActivityId") STag;
	switch
	{
		Case !Local.WSMVActivityIdElement_IsEmpty:
			struct
			{
				StringTerm(Property.XMLEncoding, "<", true, false, false) ActivityIdContent;
				XmlTag("ActivityId") ETag;
			}
	}
}


//wmsv header DataLocale
[RegisterBefore(
    SoapHeader.SoapHeaderNodes.Node,
    WSMVDataLocale,
    Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "DataLocale") && Contains(Property.SoapEnvelopeAttributes, "http://schemas.microsoft.com/wbem/wsman/1/wsman.xsd"))]
Struct WSMVDataLocaleElement=this.DataLocaleContent
{
	[Post.Local.WSMVDataLocaleElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("DataLocale") STag;
	switch
	{
		Case !Local.WSMVDataLocaleElement_IsEmpty:
			struct
			{
				StringTerm(Property.XMLEncoding, "<", true, false, false) DataLocaleContent;
				XmlTag("DataLocale") ETag;
			}
	}
}

//
// ComplexType AuthType
//
Struct WSMVAuthType
{
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Basic") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Basic = this.STag.ToString
			{
				[Post.Local.Basic_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Basic") STag;
				switch
				{
					Case !Local.Basic_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) Basic;
							XmlTag("Basic") ETag;
						}
				}
			}
	}
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Digest") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Digest = this.STag.ToString
			{
				[Post.Local.Digest_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Digest") STag;
				switch
				{
					Case !Local.Digest_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) Digest;
							XmlTag("Digest") ETag;
						}
				}
			}
	}
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Kerberos") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Kerberos = this.STag.ToString
			{
				[Post.Local.Kerberos_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Kerberos") STag;
				switch
				{
					Case !Local.Kerberos_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) Kerberos;
							XmlTag("Kerberos") ETag;
						}
				}
			}
	}
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Negotiate") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Negotiate = this.STag.ToString
			{
				[Post.Local.Negotiate_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Negotiate") STag;
				switch
				{
					Case !Local.Negotiate_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) Negotiate;
							XmlTag("Negotiate") ETag;
						}
				}
			}
	}
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Certificate") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Certificate = this.STag.ToString
			{
				[Post.Local.Certificate_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Certificate") STag;
				switch
				{
					Case !Local.Certificate_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) Certificate;
							XmlTag("Certificate") ETag;
						}
				}
			}
	}
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "CredSSP") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct CredSSP = this.STag.ToString
			{
				[Post.Local.CredSSP_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("CredSSP") STag;
				switch
				{
					Case !Local.CredSSP_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) CredSSP;
							XmlTag("CredSSP") ETag;
						}
				}
			}
	}
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "CbtHardeningLevel") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct CbtHardeningLevel = this.STag.ToString
			{
				[Post.Local.CbtHardeningLevel_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("CbtHardeningLevel") STag;
				switch
				{
					Case !Local.CbtHardeningLevel_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) CbtHardeningLevel;
							XmlTag("CbtHardeningLevel") ETag;
						}
				}
			}
	}
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		XmlElement(true) AuthChildElement;
	}
}

[RegisterBefore(
    WSTransferPut.ElementNodes,
    WSMVAuth,
    Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Auth") && (Contains(Property.WSMVResourceURI,"http://schemas.microsoft.com/wbem/wsman/1/config/client/auth") || Contains(Property.WSMVResourceURI,"http://schemas.microsoft.com/wbem/wsman/1/config/service/auth"))),Property.WSTransferPutSummary = "Auth"]
[RegisterBefore(
    WSTransferExchangeMetadata.ElementNodes,
    WSMVAuth,
    Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Auth")  && (Contains(Property.WSMVResourceURI,"http://schemas.microsoft.com/wbem/wsman/1/config/client/auth") || Contains(Property.WSMVResourceURI,"http://schemas.microsoft.com/wbem/wsman/1/config/service/auth"))),Property.WSTransferGetSummary = "Auth"]
Struct WSMVAuthElement= this.STag.ToString
{
	[Post.Local.WSMVAuthElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Auth") STag;
	switch
	{
		Case !Local.WSMVAuthElement_IsEmpty:
			struct
			{
				WSMVAuthType AuthType;
				XmlTag("Auth") ETag;
			}
	}
}

//
// Element ResourceCreated
// Embedded ComplexType 
//
[RegisterBefore(
    WSTransferCreate.ElementNodes,
    WSMVResourceCreated,
    Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ResourceCreated")),Property.WSTransferCreateSummary = "ResourceCreated"]
struct WSMVResourceCreatedElement= this.STag.ToString
{
	[Post.Local.WSMVResourceCreatedElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("ResourceCreated") STag;
	switch
	{
		Case !Local.WSMVResourceCreatedElement_IsEmpty:
			struct
			{
				WSADDREndpointReferenceType ResourceCreatedType;
				XmlTag("ResourceCreated") ETag;
			}
	}
}

[RegisterBefore(
    WSEnumerationEnumerateElement.Filter,
    WSMVFilter,
    StringTerm(FrameData, FrameOffset, Property.XMLEncoding, ">").contains("http://schemas.dmtf.org/wbem/wsman/1/wsman/SelectorFilter") && Contains(Property.SoapEnvelopeAttributes, "http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd"))]
struct WSMVFilter = this.STag.ToString
{
	[Post.Local.Filter_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Filter") STag;
	switch
	{
		Case !Local.Filter_IsEmpty:
			struct
			{
				Switch
				{
					case String(FrameData, FrameOffset, Property.XMLEncoding, 1) != "<":
							XmlElemContent FilterContent;
					default:
						While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
						{
							XmlElement(true) OtherElement;
						}
				}
				XmlTag("Filter") ETag;
			}
	}
}

//
// Element ResourceURI
//
[RegisterBefore(
    WSADDRReferenceParametersType.OtherElement,
    WSMVResourceURI,
    Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ResourceURI") && Contains(Property.SoapEnvelopeAttributes, "http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd"))]
[RegisterBefore(
    SoapHeader.SoapHeaderNodes.Node,
    WSMVResourceURI,
    Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ResourceURI") && Contains(Property.SoapEnvelopeAttributes, "http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd"))]
struct WSMVResourceURIElement=this.ResourceURIValue
{
	[Post.Local.WSMVResourceURIElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("ResourceURI") STag;
	switch
	{
		Case !Local.WSMVResourceURIElement_IsEmpty:
			struct
			{
				[Property.WSMVResourceURI]
				StringTerm(Property.XMLEncoding, "<", true, false, false) ResourceURIValue;
				XmlTag("ResourceURI") ETag;
			}
	}
}

//
// ComplexType SelectorType
// Restricted as StringTerm(Property.XMLEncoding, "<", true, false, false)
//
Struct WSMVwsmanSelectorType
{
	Switch
	{
		Case String(FrameData, FrameOffset, Property.XMLEncoding, 1) != "<":
			XmlElemContent value;
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EndpointReference") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			WSADDREndpointReferenceElement EndpointReference;
		Case String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</":
			XmlElement(true) SelectorChildType;
	}
}

//
// Element Selector
//
struct WSMVwsmanSelectorElement= this.STag.ToString
{
	[Post.Local.WSMVwsmanSelectorElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Selector") STag;
	switch
	{
		Case !Local.WSMVwsmanSelectorElement_IsEmpty:
			struct
			{
				WSMVwsmanSelectorType SelectorType;
				XmlTag("Selector") ETag;
			}
	}
}

//
// ComplexType SelectorSetType
//
Struct WSMVwsmanSelectorSetType
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Selector") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		WSMVwsmanSelectorElement Selector;
	}
}

//
// Element SelectorSet
//
[RegisterBefore(
    WSADDRReferenceParametersType.OtherElement,
    WSMVSelectorSet,
    Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "SelectorSet") && Contains(Property.SoapEnvelopeAttributes, "http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd"))]
[RegisterBefore(
    SoapHeader.SoapHeaderNodes.Node,
    WSMVSelectorSet,
    Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "SelectorSet") && Contains(Property.SoapEnvelopeAttributes, "http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd"))]
struct WSMVSelectorSetElement= this.STag.ToString
{
	[Post.Local.WSMVSelectorSetElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("SelectorSet") STag;
	switch
	{
		Case !Local.WSMVSelectorSetElement_IsEmpty:
			struct
			{
				WSMVwsmanSelectorSetType SelectorSetType;
				XmlTag("SelectorSet") ETag;
			}
	}
}
//
// Element OperationTimeout
//
[RegisterBefore(
    SoapHeader.SoapHeaderNodes.Node,
    WSMVOperationTimeout,
    Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "OperationTimeout") && Contains(Property.SoapEnvelopeAttributes,"http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd"))]
struct WSMVOperationTimeoutElement=this.OperationTimeoutValue
{
	[Post.Local.WSMVOperationTimeoutElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("OperationTimeout") STag;
	switch
	{
		Case !Local.WSMVOperationTimeoutElement_IsEmpty:
			struct
			{
				StringTerm(Property.XMLEncoding, "<", true, false, false) OperationTimeoutValue;
				XmlTag("OperationTimeout") ETag;
			}
	}
}
//
// Element MaxEnvelopeSize
//
[RegisterBefore(
    SoapHeader.SoapHeaderNodes.Node,
    WSMVMaxEnvelopeSize,
    Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "MaxEnvelopeSize") && Contains(Property.SoapEnvelopeAttributes,"http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd"))]
struct WSMVMaxEnvelopeSizeElement=this.MaxEnvelopeSizeValue
{
	[Post.Local.WSMVMaxEnvelopeSizeElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("MaxEnvelopeSize") STag;
	switch
	{
		Case !Local.WSMVMaxEnvelopeSizeElement_IsEmpty:
			struct
			{
				StringTerm(Property.XMLEncoding, "<", true, false, false) MaxEnvelopeSizeValue;
				XmlTag("MaxEnvelopeSize") ETag;
			}
	}
}

//
// Element Locale
// Embedded ComplexType 
//
[RegisterBefore(
    SoapHeader.SoapHeaderNodes.Node,
    WSMVLocale,
    Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Locale") && Contains(Property.SoapEnvelopeAttributes,"http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd"))]
struct WSMVLocaleElement= this.STag.ToString
{
	[Post.Local.WSMVLocaleElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Locale") STag;
	switch
	{
		Case !Local.WSMVLocaleElement_IsEmpty:
			struct
			{
				XmlTag("Locale") ETag;
			}
	}
}

//
// Element Option
//
struct WSMVwsmanOptionElement=this.OptionValue
{
	[Post.Local.WSMVwsmanOptionElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Option") STag;
	switch
	{
		Case !Local.WSMVwsmanOptionElement_IsEmpty:
			struct
			{
				StringTerm(Property.XMLEncoding, "<", true, false, false) OptionValue;
				XmlTag("Option") ETag;
			}
	}
}

//
// Element OptionSet
// Embedded ComplexType 
//
[RegisterBefore(
    SoapHeader.SoapHeaderNodes.Node,
    WSMVOptionSet,
    Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "OptionSet") && Contains(Property.SoapEnvelopeAttributes,"http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd"))]
struct WSMVOptionSetElement= this.STag.ToString
{
	[Post.Local.WSMVOptionSetElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("OptionSet") STag;
	switch
	{
		Case !Local.WSMVOptionSetElement_IsEmpty:
			struct
			{
				While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Option") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
				{
					WSMVwsmanOptionElement Option;
				}
				XmlTag("OptionSet") ETag;
			}
	}
}
//
// ComplexType mixedDataType
// Restricted as StringTerm(Property.XMLEncoding, "<", true, false, false)
//
Struct WSMVwsmanMixedDataType
{
	Switch
	{
		case String(FrameData, FrameOffset, Property.XMLEncoding, 1) != "<":
				XmlElemContent value;
		default:
			While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
			{
				XmlElement(true) OtherElement;
			}
	}
}

//
// ComplexType fragmentMixedDataType
//
Struct WSMVwsmanFragmentMixedDataType
{
	WSMVwsmanMixedDataType BaseType;
}

//
// Element FragmentTransfer
//
[RegisterBefore(
    SoapHeader.SoapHeaderNodes.Node,
    WSMVFragmentTransfer,
    Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FragmentTransfer") && Contains(Property.SoapEnvelopeAttributes,"http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd"))]
struct WSMVFragmentTransferElement= this.STag.ToString
{
	[Post.Local.WSMVFragmentTransferElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("FragmentTransfer") STag;
	switch
	{
		Case !Local.WSMVFragmentTransferElement_IsEmpty:
			struct
			{
				WSMVwsmanFragmentMixedDataType FragmentMixedDataType;
				XmlTag("FragmentTransfer") ETag;
			}
	}
}

//
// Element OptimizeEnumeration
//
[RegisterBefore(
    WSEnumerationEnumerateElement.OtherElement,
    WSMVwsmanOptimizeEnumerationElement,
    Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "OptimizeEnumeration") && Contains(Property.SoapEnvelopeAttributes,"http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd"))]
struct WSMVwsmanOptimizeEnumerationElement=this.OptimizeEnumerationValue
{
	[Post.Local.WSMVwsmanOptimizeEnumerationElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("OptimizeEnumeration") STag;
	switch
	{
		Case !Local.WSMVwsmanOptimizeEnumerationElement_IsEmpty:
			struct
			{
				XmlElemContent OptimizeEnumerationValue;
				XmlTag("OptimizeEnumeration") ETag;
			}
	}
}

//
// Element EnumerationMode
//
[RegisterBefore(
    WSEnumerationEnumerateElement.OtherElement,
    WSMVwsmanEnumerationModeElement,
    Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EnumerationMode") && Contains(Property.SoapEnvelopeAttributes,"http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd"))]
struct WSMVwsmanEnumerationModeElement=this.EnumerationModeValue
{
	[Post.Local.WSMVwsmanEnumerationModeElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("EnumerationMode") STag;
	switch
	{
		Case !Local.WSMVwsmanEnumerationModeElement_IsEmpty:
			struct
			{
				StringTerm(Property.XMLEncoding, "<", true, false, false) EnumerationModeValue;
				XmlTag("EnumerationMode") ETag;
			}
	}
}

//
// Element EndOfSequence
//
[RegisterBefore(
    WSEnumerationEnumerateResponseElement.OtherElement,
    WSMVwsmanEndOfSequenceElement,
    Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EndOfSequence") && Contains(Property.SoapEnvelopeAttributes,"http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd"))]
struct WSMVwsmanEndOfSequenceElement=this.EndOfSequenceValue
{
	[Post.Local.WSMVwsmanEndOfSequenceElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("EndOfSequence") STag;
	switch
	{
		Case !Local.WSMVwsmanEndOfSequenceElement_IsEmpty:
			struct
			{
				XmlElemContent EndOfSequenceValue;
				XmlTag("EndOfSequence") ETag;
			}
	}
}

//
// Shell
//
[RegisterBefore(
    WSTransferCreate.ElementNodes,
    WSMVShell,
    Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Shell") && Contains(Property.WSMVResourceURI,"http://schemas.microsoft.com/wbem/wsman/1/windows/shell/cmd")),Property.WSTransferCreateSummary = "Shell"]
Struct WSMVShellElement= this.STag.ToString
{
	[Post.Local.WSMVShellElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Shell") STag;
	switch
	{
		Case !Local.WSMVShellElement_IsEmpty:
			struct
			{
				WSMVShellType ShellType;
				XmlTag("Shell") ETag;
			}
	}
}

//
// ComplexType Shell
//
Struct WSMVShellType
{
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Environment") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			//
			// Embedded ComplexType 
			//
			struct Environment= this.STag.ToString
			{
				[Post.Local.Environment_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Environment") STag;
				switch
				{
					Case !Local.Environment_IsEmpty:
						struct
						{
							While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
							{
								struct Variable=this.VariableValue
								{
									[Post.Local.Variable_IsEmpty = Property.IsXmlEmptyElement]
									XmlTag("Variable") STag;
									switch
									{
										Case !Local.Variable_IsEmpty:
											struct
											{
												StringTerm(Property.XMLEncoding, "<", true, false, false) VariableValue;
												XmlTag("Variable") ETag;
											}
									}
								}
								
							}
							XmlTag("Environment") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "WorkingDirectory") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct WorkingDirectory=this.WorkingDirectory
			{
				[Post.Local.WorkingDirectory_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("WorkingDirectory") STag;
				switch
				{
					Case !Local.WorkingDirectory_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) WorkingDirectory;
							XmlTag("WorkingDirectory") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Lifetime") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Lifetime=this.Lifetime
			{
				[Post.Local.Lifetime_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Lifetime") STag;
				switch
				{
					Case !Local.Lifetime_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) Lifetime;
							XmlTag("Lifetime") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "IdleTimeout") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct IdleTimeout=this.IdleTimeout
			{
				[Post.Local.IdleTimeout_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("IdleTimeout") STag;
				switch
				{
					Case !Local.IdleTimeout_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) IdleTimeout;
							XmlTag("IdleTimeout") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "InputStreams") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct InputStreams= this.STag.ToString
			{
				[Post.Local.InputStreams_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("InputStreams") STag;
				switch
				{
					Case !Local.InputStreams_IsEmpty:
						struct
						{
							WSMVshellStreamNameList InputStreams;
							XmlTag("InputStreams") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "OutputStreams") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct OutputStreams= this.STag.ToString
			{
				[Post.Local.OutputStreams_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("OutputStreams") STag;
				switch
				{
					Case !Local.OutputStreams_IsEmpty:
						struct
						{
							WSMVshellStreamNameList OutputStreams;
							XmlTag("OutputStreams") ETag;
						}
				}
			}
			
	}
	
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		Switch
		{
			Default: XmlElement(true) OtherElement;
		}
	}
}
//
// SimpleType StreamNameList
//
Struct WSMVshellStreamNameList
{
	While [String(FrameData, FrameOffset, Property.XMLEncoding, 1) != "<" && FrameOffset < FrameLength]
	{
		StringTerm(Property.XMLEncoding, "<", true, false, false) StreamNameValue;
	}
}

//
// ComplexType CommandStateType
//
Struct WSMVshellCommandStateType
{
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ExitCode") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			//
			// Embedded ComplexType 
			//
			struct ExitCode=this.Value
			{
				[Post.Local.ExitCode_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("ExitCode") STag;
				switch
				{
					Case !Local.ExitCode_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "</", true, false, false) Value;
							XmlTag("ExitCode") ETag;
						}
				}
			}
			
	}
	
}

//
// ComplexType CommandLine
//
Struct WSMVshellCommandLineType
{
	struct Command=this.Command
	{
		[Post.Local.Command_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("Command") STag;
		switch
		{
			Case !Local.Command_IsEmpty:
				struct
				{
					[ Property.WSMVshellCommandLineTypeCommand = this? this : ""]
					StringTerm(Property.XMLEncoding, "<", true, false, false) Command;
					XmlTag("Command") ETag;
				}
		}
	}
	
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Arguments") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		//
		// Embedded ComplexType 
		//
		struct Arguments= this.STag.ToString
		{
			[Post.Local.Arguments_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("Arguments") STag;
			switch
			{
				Case !Local.Arguments_IsEmpty:
					struct
					{
						Switch
						{
							Default: StringTerm(Property.XMLEncoding, "</", true, false, false) Value;
						}
						XmlTag("Arguments") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType CommandResponse
//
Struct WSMVshellCommandResponseType
{
	struct CommandId= this.STag.ToString
	{
		[Post.Local.CommandId_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("CommandId") STag;
		switch
		{
			Case !Local.CommandId_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) CommandId;
					XmlTag("CommandId") ETag;
				}
		}
	}
	
}

//
// ComplexType Signal
//
Struct WSMVshellSignalType
{
	struct Code=this.CodeValue
	{
		[Post.Local.Code_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("Code") STag;
		switch
		{
			Case !Local.Code_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) CodeValue;
					XmlTag("Code") ETag;
				}
		}
	}
	
}

//
// ComplexType Send
//
Struct WSMVshellSendType
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Stream") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct Stream=this.StreamValue
		{
			[Post.Local.Stream_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("Stream") STag;
			switch
			{
				Case !Local.Stream_IsEmpty:
					struct
					{
						Switch
						{
							Default: StringTerm(Property.XMLEncoding, "<", true, false, false) StreamValue;
						}
						XmlTag("Stream") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType SendResponse
//
Struct WSMVshellSendResponseType
{
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "DesiredStream") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct DesiredStream=this.StreamValue
			{
				[Post.Local.DesiredStream_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("DesiredStream") STag;
				switch
				{
					Case !Local.DesiredStream_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) StreamValue;
							XmlTag("DesiredStream") ETag;
						}
				}
			}
			
	}
	
}

//
// ComplexType Receive
//
Struct WSMVshellReceiveType
{
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "DesiredStream") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct DesiredStreams= this.STag.ToString
			{
				[Post.Local.DesiredStreams_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("DesiredStream") STag;
				switch
				{
					Case !Local.DesiredStreams_IsEmpty:
						struct
						{
							WSMVshellStreamNameList DesiredStreams;
							XmlTag("DesiredStream") ETag;
						}
				}
			}
			
	}
	
}

//
// ComplexType ReceiveResponse
//
Struct WSMVshellReceiveResponseType
{
	While [String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
	{
		Switch
		{
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Stream"):
			struct Stream=this.StreamValue
			{
				[Post.Local.Stream_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Stream") STag;
				switch
				{
					Case !Local.Stream_IsEmpty:
						struct
						{
							Switch
							{
								Default: StringTerm(Property.XMLEncoding, "<", true, false, false) StreamValue;
							}
							XmlTag("Stream") ETag;
						}
				}
			}
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "CommandState"):
			struct CommandState= this.STag.ToString
			{
				[Post.Local.CommandState_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("CommandState") STag;
				switch
				{
					Case !Local.CommandState_IsEmpty:
						struct
						{
							WSMVshellCommandStateType CommandState;
							XmlTag("CommandState") ETag;
						}
				}
			}
		}
	}
}

//CommandLine Element
Struct WSMVCommandLineElement= this.STag.ToString
{
	[Post.Local.WSMVCommandLineElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("CommandLine") STag;
	switch
	{
		Case !Local.WSMVCommandLineElement_IsEmpty:
			struct
			{
				WSMVshellCommandLineType CommandLineType;
				XmlTag("CommandLine") ETag;
			}
	}

}

//CommandResponse Element
Struct WSMVCommandResponseElement= this.STag.ToString
{
	[Post.Local.WSMVCommandResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("CommandResponse") STag;
	switch
	{
		Case !Local.WSMVCommandResponseElement_IsEmpty:
			struct
			{
				WSMVshellCommandResponseType CommandLineType;
				XmlTag("CommandResponse") ETag;
			}
	}
}

//ReceiveResponse Element
Struct WSMVReceiveResponseElement= this.STag.ToString
{
	[Post.Local.WSMVReceiveResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("ReceiveResponse") STag;
	switch
	{
		Case !Local.WSMVReceiveResponseElement_IsEmpty:
			struct
			{
				WSMVshellReceiveResponseType ReceiveResponseType;
				XmlTag("ReceiveResponse") ETag;
			}
	}
}

//SendElement
Struct WSMVSendElement= this.STag.ToString
{
	[Post.Local.WSMVSendElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Send") STag;
	switch
	{
		Case !Local.WSMVSendElement_IsEmpty:
			struct
			{
				WSMVshellSendType SendType;
				XmlTag("Send") ETag;
			}
	}
}

//SendResponse Element
Struct WSMVSendResponseElement= this.STag.ToString
{
	[Post.Local.WSMVSendResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("SendResponse") STag;
	switch
	{
		Case !Local.WSMVSendResponseElement_IsEmpty:
			struct
			{
				WSMVshellSendResponseType SendType;
				XmlTag("SendResponse") ETag;
			}
	}
}

//Receive Element
Struct WSMVReceiveElement= this.STag.ToString
{
	[Post.Local.WSMVReceiveElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Receive") STag;
	switch
	{
		Case !Local.WSMVReceiveElement_IsEmpty:
			struct
			{
				WSMVshellReceiveType SendType;
				XmlTag("Receive") ETag;
			}
	}
}

//SignalElement
Struct WSMVSignalElement= this.STag.ToString
{
	[Post.Local.WSMVSignalElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Signal") STag;
	switch
	{
		Case !Local.WSMVSignalElement_IsEmpty:
			struct
			{
				WSMVshellSignalType SendType;
				XmlTag("Signal") ETag;
			}
	}
}

//SignalResponse Element
Struct WSMVSignalResponseElement= this.STag.ToString
{
	[Post.Local.WSMVSignalResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("SignalResponse") STag;
	switch
	{
		Case !Local.WSMVSignalResponseElement_IsEmpty:
			struct
			{
				Struct WSMVshellSignalResponseType
				{
					Switch
					{
						case String(FrameData, FrameOffset, Property.XMLEncoding, 1) != "<":
								XmlElemContent value;
						Default:
							While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
							{
								XmlElement(true) AnyNode;
							}
					}
				}
				XmlTag("SignalResponse") ETag;
			}
	}
}

//Config Element
[RegisterBefore(
    WSTransferExchangeMetadata.ElementNodes,
    WSMVConfig,
    Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Config") && Contains(Property.WSMVResourceURI,"http://schemas.microsoft.com/wbem/wsman/1/config") && !Contains(Property.WSMVResourceURI,"http://schemas.microsoft.com/wbem/wsman/1/config/")),Property.WSTransferGetSummary = "Config"]
Struct WSMVConfigElement= this.STag.ToString
{
	[Post.Local.WSMVConfigElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Config") STag;
	switch
	{
		Case !Local.WSMVConfigElement_IsEmpty:
			struct
			{
				WSMVConfigType SendType;
				XmlTag("Config") ETag;
			}
	}
}

Struct WSMVConfigType
{
	Struct WSMVMaxEnvelopeSizekb=this.MaxEnvelopeSizekbValue
	{
		[Post.Local.WSMVMaxEnvelopeSizekbElement_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("MaxEnvelopeSizekb") STag;
		switch
		{
			Case !Local.WSMVMaxEnvelopeSizekbElement_IsEmpty:
				struct
				{
					XmlElemContent MaxEnvelopeSizekbValue;
					XmlTag("MaxEnvelopeSizekb") ETag;
				}
		}
	}
	Struct WSMVMaxTimeoutms=this.MaxTimeoutmsValue
	{
		[Post.Local.WSMVMaxTimeoutmsElement_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("MaxTimeoutms") STag;
		switch
		{
			Case !Local.WSMVMaxTimeoutmsElement_IsEmpty:
				struct
				{
					XmlElemContent MaxTimeoutmsValue;
					XmlTag("MaxTimeoutms") ETag;
				}
		}
	}
	Struct WSMVMaxBatchItems=this.MaxBatchItemsValue
	{
		[Post.Local.WSMVMaxBatchItemsElement_IsEmpty= Property.IsXmlEmptyElement]
		XmlTag("MaxBatchItems") STag;
		switch
		{
			Case !Local.WSMVMaxBatchItemsElement_IsEmpty:
				struct
				{
					XmlElemContent MaxBatchItemsValue;
					XmlTag("MaxBatchItems") ETag;
				}
		}
	}
	Struct WSMVMaxProviderRequests=this.MaxProviderRequestsValue
	{
		[Post.Local.WSMVMaxProviderRequestsElement_IsEmpty= Property.IsXmlEmptyElement]
		XmlTag("MaxProviderRequests") STag;
		switch
		{
			Case !Local.WSMVMaxProviderRequestsElement_IsEmpty:
				struct
				{
					XmlElemContent MaxProviderRequestsValue;
					XmlTag("MaxProviderRequests") ETag;
				}
		}
	}
	WSMVClientElement Client;
	WSMVServiceElement Service;
	WSMVWinrsElement Winrs;
}

//Client element
[RegisterBefore(
    WSTransferPut.ElementNodes,
    WSMVClient,
    Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Client") && Contains(Property.WSMVResourceURI,"http://schemas.microsoft.com/wbem/wsman/1/config/client") && !Contains(Property.WSMVResourceURI,"http://schemas.microsoft.com/wbem/wsman/1/config/client/")),Property.WSTransferPutSummary = "Client"]
[RegisterBefore(
    WSTransferExchangeMetadata.ElementNodes,
    WSMVClient,
    Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Client") && Contains(Property.WSMVResourceURI,"http://schemas.microsoft.com/wbem/wsman/1/config/client") && !Contains(Property.WSMVResourceURI,"http://schemas.microsoft.com/wbem/wsman/1/config/client/")),Property.WSTransferGetSummary = "Client"]
Struct WSMVClientElement= this.STag.ToString
{
	[Post.Local.WSMVClientElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Client") STag;
	switch
	{
		Case !Local.WSMVClientElement_IsEmpty:
			struct
			{
				WSMVConfigClientType ClientType;
				XmlTag("Client") ETag;
			}
	}
}

//Config Client Type
Struct WSMVConfigClientType
{
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		switch
		{
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "NetworkDelayms"):
				Struct NetworkDelayms=this.NetworkDelaymsValue
				{
					[Post.Local.WSMVNetworkDelaymsElement_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("NetworkDelayms") STag;
					switch
					{
						Case !Local.WSMVNetworkDelaymsElement_IsEmpty:
							struct
							{
								XmlElemContent NetworkDelaymsValue;
								XmlTag("NetworkDelayms") ETag;
							}
					}
				}
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "URLPrefix"):
				Struct URLPrefix=this.URLPrefixVaule
				{
					[Post.Local.WSMVURLPrefixElement_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("URLPrefix") STag;
					switch
					{
						Case !Local.WSMVURLPrefixElement_IsEmpty:
							struct
							{
								XmlElemContent URLPrefixVaule;
								XmlTag("URLPrefix") ETag;
							}
					}
				}
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "AllowUnencrypted"):
				Struct AllowUnencrypted=this.AllowUnencryptedVaule
				{
					[Post.Local.WSMVAllowUnencryptedElement_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("AllowUnencrypted") STag;
					switch
					{
						Case !Local.WSMVURLPrefixElement_IsEmpty:
							struct
							{
								XmlElemContent AllowUnencryptedVaule;
								XmlTag("AllowUnencrypted") ETag;
							}
					}
				}
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Auth"):
				Struct AuthElement= this.STag.ToString
				{
					[Post.Local.WSMVAuthElement_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("Auth") STag;
					switch
					{
						Case !Local.WSMVAuthElement_IsEmpty:
							struct
							{
								WSMVAuthType AuthType;
								XmlTag("Auth") ETag;
							}
					}
				}
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "DefaultPorts"):
				WSMVDefaultPortsElement DefaultPortsElement;
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "TrustedHosts"):
				Struct TrustedHostsElement=this.TrustedHostsValue
				{
					[Post.Local.WSMVTrustedHostsElement_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("TrustedHosts") STag;
					switch
					{
						Case !Local.WSMVTrustedHostsElement_IsEmpty:
							struct
							{
								XmlElemContent TrustedHostsValue;
								XmlTag("TrustedHosts") ETag;
							}
					}
				}
			default: XmlElement(true) XmlElement;
		}
	}
}


[RegisterBefore(
    WSTransferExchangeMetadata.ElementNodes,
    WSMVDefaultPorts,
    Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "DefaultPorts") && Contains(Property.WSMVResourceURI,"http://schemas.microsoft.com/wbem/wsman/1/config/client/defaultports")),Property.WSTransferGetSummary = "DefaultPorts"]
[RegisterBefore(
    WSTransferPut.ElementNodes,
    WSMVDefaultPorts,
    Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "DefaultPorts") && Contains(Property.WSMVResourceURI,"http://schemas.microsoft.com/wbem/wsman/1/config/client/defaultports")),Property.WSTransferPutSummary = "DefaultPorts"]
Struct WSMVDefaultPortsElement= this.STag.ToString
{
	[Post.Local.WSMVDefaultPortsElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("DefaultPorts") STag;
	switch
	{
		Case !Local.WSMVDefaultPortsElement_IsEmpty:
			struct
			{
				WSMVClientDefaultPortsType DefaultPorts;
				XmlTag("DefaultPorts") ETag;
			}
	}
}

//WSMV ClientDefaultPortsType Complex Type
Struct WSMVClientDefaultPortsType
{
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		XmlElement(true) HttpOrHttpsElement;
	}
}

//WSMV Config ServiceElement
[RegisterBefore(
    WSTransferPut.ElementNodes,
    WSMVService,
    Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Service") && Contains(Property.WSMVResourceURI,"http://schemas.microsoft.com/wbem/wsman/1/config/service") && !Contains(Property.WSMVResourceURI,"http://schemas.microsoft.com/wbem/wsman/1/config/service/")),Property.WSTransferPutSummary = "Service"]
Struct WSMVServiceElement= this.STag.ToString
{
	[Post.Local.WSMVServiceElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Service") STag;
	switch
	{
		Case !Local.WSMVServiceElement_IsEmpty:
			struct
			{
				WSMVConfigServiceType ServiceType;
				XmlTag("Service") ETag;
			}
	}
}

//WSMV Config ServiceType
Struct WSMVConfigServiceType
{
		Struct RootSDDL=this.RootSDDLValue
		{
			[Post.Local.WSMVRootSDDLElement_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("RootSDDL") STag;
			switch
			{
				Case !Local.WSMVRootSDDLElement_IsEmpty:
					struct
					{
						XmlElemContent RootSDDLValue;
						XmlTag("RootSDDL") ETag;
					}
			}
		}
		Struct MaxConcurrentOperations=this.MaxConcurrentOperationsValue
		{
			[Post.Local.WSMVMaxConcurrentOperations_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("MaxConcurrentOperations") STag;
			switch
			{
				Case !Local.WSMVMaxConcurrentOperations_IsEmpty:
					struct
					{
						XmlElemContent MaxConcurrentOperationsValue;
						XmlTag("MaxConcurrentOperations") ETag;
					}
			}
		}
		Switch
		{
			Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "MaxConcurrentOperationsPerUser"):
			Struct MaxConcurrentOperationsPerUser=this.MaxConcurrentOperationsPerUserValue
			{
				[Post.Local.WSMVMaxConcurrentOperationsPerUser_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("MaxConcurrentOperationsPerUser") STag;
				switch
				{
					Case !Local.WSMVMaxConcurrentOperationsPerUser_IsEmpty:
						struct
						{
							XmlElemContent MaxConcurrentOperationsPerUserValue;
							XmlTag("MaxConcurrentOperationsPerUser") ETag;
						}
				}
			}
		}

		Struct EnumerationTimeoutms=this.EnumerationTimeoutmsValue
		{
			[Post.Local.WSMVEnumerationTimeoutms_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("EnumerationTimeoutms") STag;
			switch
			{
				Case !Local.WSMVEnumerationTimeoutms_IsEmpty:
					struct
					{
						XmlElemContent EnumerationTimeoutmsValue;
						XmlTag("MaxConcurrentOperations") ETag;
					}
			}
		}
		Struct MaxConnections=this.MaxConnectionsValue
		{
			[Post.Local.WSMVMaxConnections_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("MaxConnections") STag;
			switch
			{
				Case !Local.WSMVMaxConnections_IsEmpty:
					struct
					{
						XmlElemContent MaxConnectionsValue;
						XmlTag("MaxConnections") ETag;
					}
			}
		}
		Switch
		{
			Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "MaxPacketRetrievalTimeSeconds") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
				Struct MaxPacketRetrievelTimeSeconds = this.MaxPacketRetrievelTimeSecondsValue
				{
					[Post.Local.WSMVMaxPacketRetrievelTimeSeconds_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("MaxPacketRetrievalTimeSeconds") STag;
					switch
					{
						Case !Local.WSMVMaxPacketRetrievelTimeSeconds_IsEmpty:
							struct
							{
								XmlElemContent MaxPacketRetrievelTimeSecondsValue;
								XmlTag("MaxPacketRetrievalTimeSeconds") ETag;
							}
					}
				}
		}
		
		Struct AllowUnencrypted=this.AllowUnencryptedValue
		{
			[Post.Local.WSMVAllowUnencrypted_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("AllowUnencrypted") STag;
			switch
			{
				Case !Local.WSMVAllowUnencrypted_IsEmpty:
					struct
					{
						XmlElemContent AllowUnencryptedValue;
						XmlTag("AllowUnencrypted") ETag;
					}
			}
		}
		Struct Auth= this.STag.ToString
		{
			[Post.Local.WSMVAuth_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("Auth") STag;
			switch
			{
				Case !Local.WSMVAuth_IsEmpty:
					struct
					{
						WSMVAuthType AllowUnencryptedValue;
						XmlTag("Auth") ETag;
					}
			}
		}
		WSMVDefaultPortsElement DefaultPortsElement;
		Struct IPv4Filter = this.IPv4Filter
		{
			[Post.Local.WSMVIPv4Filter_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("IPv4Filter") STag;
			switch
			{
				Case !Local.WSMVIPv4Filter_IsEmpty:
					struct
					{
						StringTerm(Property.XMLEncoding, "<", true, false, false) IPv4Filter;
						XmlTag("IPv4Filter") ETag;
					}
			}
		}
		Switch
		{
			Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "IPv6Filter") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
				Struct IPv6Filter = this.IPv6Filter
				{
					[Post.Local.WSMVIPv6Filter_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("IPv6Filter") STag;
					switch
					{
						Case !Local.WSMVIPv6Filter_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) IPv6Filter;
								XmlTag("IPv6Filter") ETag;
							}
					}
				}
		}
		while [(Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EnableCompatibilityHttpListener") || Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EnableCompatibilityHttpsListener")) && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
		{
			Switch
			{
				Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EnableCompatibilityHttpListener") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
					Struct EnableCompatibilityHttpListener
					{
						[Post.Local.WSMVEnableCompatibilityHttpListener_IsEmpty = Property.IsXmlEmptyElement]
						XmlTag("EnableCompatibilityHttpListener") STag;
						switch
						{
							Case !Local.WSMVEnableCompatibilityHttpListener_IsEmpty:
								struct
								{
									StringTerm(Property.XMLEncoding, "<", true, false, false) EnableCompatibilityHttpListener;
									XmlTag("EnableCompatibilityHttpListener") ETag;
								}
						}
					}
				Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EnableCompatibilityHttpsListener") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
					Struct EnableCompatibilityHttpsListener
					{
						[Post.Local.WSMVEnableCompatibilityHttpsListener_IsEmpty = Property.IsXmlEmptyElement]
						XmlTag("EnableCompatibilityHttpsListener") STag;
						switch
						{
							Case !Local.WSMVEnableCompatibilityHttpsListener_IsEmpty:
								struct
								{
									StringTerm(Property.XMLEncoding, "<", true, false, false) EnableCompatibilityHttpsListener;
									XmlTag("EnableCompatibilityHttpsListener") ETag;
								}
						}
					}
			}
		}
		Switch
		{
			Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "CertificateThumbprint") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
				Struct CertificateThumbprint = this.CertificateThumbprint
				{
					[Post.Local.WSMVCertificateThumbprint_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("CertificateThumbprint") STag;
					switch
					{
						Case !Local.WSMVCertificateThumbprint_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) CertificateThumbprint;
								XmlTag("CertificateThumbprint") ETag;
							}
					}
				}
		}
}

//WSMV Config WinrsElement
[RegisterBefore(
    WSTransferPut.ElementNodes,
    WSMVWinrs,
    Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Winrs") && Contains(Property.WSMVResourceURI,"http://schemas.microsoft.com/wbem/wsman/1/config/winrs")),Property.WSTransferPutSummary = "Winrs"]
[RegisterBefore(
    WSTransferExchangeMetadata.ElementNodes,
    WSMVWinrs,
    Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Winrs") && Contains(Property.WSMVResourceURI,"http://schemas.microsoft.com/wbem/wsman/1/config/winrs")),Property.WSTransferGetSummary = "Winrs"]
Struct WSMVWinrsElement= this.STag.ToString
{
	[Post.Local.WSMVWinrsElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Winrs") STag;
	switch
	{
		Case !Local.WSMVWinrsElement_IsEmpty:
			struct
			{
				WSMVConfigWinrsType WinrsType;
				XmlTag("Winrs") ETag;
			}
	}
}

//WSMV Config WinrsType
struct WSMVConfigWinrsType
{
	Struct AllowRemoteShellAccessElement= this.AllowRemoteShellAccessValue
	{
		[Post.Local.WSMVAllowRemoteShellAccessElement_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("AllowRemoteShellAccess") STag;
		switch
		{
			Case !Local.WSMVAllowRemoteShellAccessElement_IsEmpty:
				struct
				{
					XmlElemContent AllowRemoteShellAccessValue;
					XmlTag("AllowRemoteShellAccess") ETag;
				}
		}
	}
	Struct IdleTimeoutElementElement=this.IdleTimeoutValue
	{
		[Post.Local.WSMVIdleTimeoutElement_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("IdleTimeout") STag;
		switch
		{
			Case !Local.WSMVIdleTimeoutElement_IsEmpty:
				struct
				{
					XmlElemContent IdleTimeoutValue;
					XmlTag("IdleTimeout") ETag;
				}
		}
	}
	Struct MaxConcurrentUsersElement=this.MaxConcurrentUsersValue
	{
		[Post.Local.WSMVMaxConcurrentUsersElement_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("MaxConcurrentUsers") STag;
		switch
		{
			Case !Local.WSMVMaxConcurrentUsersElement_IsEmpty:
				struct
				{
					XmlElemContent MaxConcurrentUsersValue;
					XmlTag("MaxConcurrentUsers") ETag;
				}
		}
	}
	Struct MaxShellRunTimeElement=this.MaxShellRunTimeValue
	{
		[Post.Local.WSMVMaxShellRunTimeElement_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("MaxShellRunTime") STag;
		switch
		{
			Case !Local.WSMVMaxShellRunTimeElement_IsEmpty:
				struct
				{
					XmlElemContent MaxShellRunTimeValue;
					XmlTag("MaxShellRunTime") ETag;
				}
		}
	}
	Struct MaxProcessesPerShellElement=this.MaxShellRunTimeValue
	{
		[Post.Local.WSMVMaxProcessesPerShellElement_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("MaxProcessesPerShell") STag;
		switch
		{
			Case !Local.WSMVMaxProcessesPerShellElement_IsEmpty:
				struct
				{
					XmlElemContent MaxShellRunTimeValue;
					XmlTag("MaxProcessesPerShell") ETag;
				}
		}
	}
	Struct MaxMemoryPerShellMBElement=this.MaxMemoryPerShellMBValue
	{
		[Post.Local.WSMVMaxMemoryPerShellMBlElement_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("MaxMemoryPerShellMB") STag;
		switch
		{
			Case !Local.WSMVMaxMemoryPerShellMBlElement_IsEmpty:
				struct
				{
					XmlElemContent MaxMemoryPerShellMBValue;
					XmlTag("MaxMemoryPerShellMB") ETag;
				}
		}
	}
	Struct MaxShellsPerUserElement=this.MaxShellsPerUserValue
	{
		[Post.Local.WSMVMaxShellsPerUserElement_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("MaxShellsPerUser") STag;
		switch
		{
			Case !Local.WSMVMaxShellsPerUserElement_IsEmpty:
				struct
				{
					XmlElemContent MaxShellsPerUserValue;
					XmlTag("MaxShellsPerUser") ETag;
				}
		}
	}
}

//WSMV Listener Element
[RegisterBefore(
    WSTransferPut.ElementNodes,
    WSMVListener,
    Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Listener") && Contains(Property.WSMVResourceURI,"http://schemas.microsoft.com/wbem/wsman/1/config/listener")),Property.WSTransferPutSummary = "Listener"]
[RegisterBefore(
    WSTransferCreate.ElementNodes,
    WSMVListener,
    Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Listener") && Contains(Property.WSMVResourceURI,"http://schemas.microsoft.com/wbem/wsman/1/config/listener")),Property.WSTransferCreateSummary = "Listener"]
[RegisterBefore(
    WSTransferExchangeMetadata.ElementNodes,
    WSMVListener,
    Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Listener") && Contains(Property.WSMVResourceURI,"http://schemas.microsoft.com/wbem/wsman/1/config/listener")),Property.WSTransferGetSummary = "Listener"]
[RegisterBefore(
    WSEnumerationItemsElement.ElementNodes,
    WSMVListener,
    Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Listener") && Contains(Property.WSMVResourceURI,"http://schemas.microsoft.com/wbem/wsman/1/config/listener"))]
Struct WSMVListenerElement= this.STag.ToString
{
	[Post.Local.WSMVListenerElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Listener") STag;
	switch
	{
		Case !Local.WSMVListenerElement_IsEmpty:
			struct
			{ 
				WSMVListenerType ListenerType;
				XmlTag("Listener") ETag;
			}
	}
}

//WSMV ListenerType
Struct WSMVListenerType
{
	Struct WSMVAddress=this.AddressValue
	{
		[Post.Local.WSMVAddressElement_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("Address") STag;
		switch
		{
			Case !Local.WSMVAddressElement_IsEmpty:
				struct
				{ 
					XmlElemContent AddressValue;
					XmlTag("Address") ETag;
				}
		}
	}
	
	Struct WSMVTransport=this.TransportValue
	{
		[Post.Local.WSMVTransportElement_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("Transport") STag;
		switch
		{
			Case !Local.WSMVTransportElement_IsEmpty:
				struct
				{ 
					XmlElemContent TransportValue;
					XmlTag("Transport") ETag;
				}
		}
	}
	
	Struct WSMVPort=this.PortValue
	{
		[Post.Local.WSMVPortElement_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("Port") STag;
		switch
		{
			Case !Local.WSMVPortElement_IsEmpty:
				struct
				{ 
					XmlElemContent PortValue;
					XmlTag("Port") ETag;
				}
		}
	}
	
	Struct WSMVHostname=this.HostnameValue
	{
		[Post.Local.WSMVHostnameElement_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("Hostname") STag;
		switch
		{
			Case !Local.WSMVHostnameElement_IsEmpty:
				struct
				{ 
					XmlElemContent HostnameValue;
					XmlTag("Hostname") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Enabled"):
		Struct WSMVEnabled=this.EnabledValue
		{
			[Post.Local.WSMVEnabledElement_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("Enabled") STag;
			switch
			{
				Case !Local.WSMVEnabledElement_IsEmpty:
					struct
					{ 
						XmlElemContent EnabledValue;
						XmlTag("Enabled") ETag;
					}
			}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "URLPrefix"):
			Struct WSMVURLPrefix=this.URLPrefixValue
			{
				[Post.Local.WSMVURLPrefixElement_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("URLPrefix") STag;
				switch
				{
					Case !Local.WSMVURLPrefixElement_IsEmpty:
						struct
						{ 
							XmlElemContent URLPrefixValue;
							XmlTag("URLPrefix") ETag;
						}
				}
			}
	}
	
	Switch
	{
		Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "CertificateThumbprint"):
		Struct WSMVCertificateThumbprint=this.CertificateThumbprintValue
		{
			[Post.Local.WSMVCertificateThumbprintElement_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("CertificateThumbprint") STag;
			switch
			{
				Case !Local.WSMVCertificateThumbprintElement_IsEmpty:
					struct
					{ 
						XmlElemContent CertificateThumbprintValue;
						XmlTag("CertificateThumbprint") ETag;
					}
			}
		}
	}
	
	While[Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ListeningOn")]
	{
		Struct WSMVListeningOn=this.ListeningOnValue
		{
			[Post.Local.WSMVListeningOnElement_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("ListeningOn") STag;
			switch
			{
				Case !Local.WSMVListeningOnElement_IsEmpty:
					struct
					{ 
						XmlElemContent ListeningOnValue;
						XmlTag("ListeningOn") ETag;
					}
			}
		}
	}
}

//WSMV certmapping Element
[RegisterBefore(
    WSTransferCreate.ElementNodes,
    WSMVcertmapping,
    Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "certmapping") && Contains(Property.WSMVResourceURI,"http://schemas.microsoft.com/wbem/wsman/1/config/service/certmapping")),Property.WSTransferCreateSummary = "certmapping"]
[RegisterBefore(
    WSTransferPut.ElementNodes,
    WSMVcertmapping,
    Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "certmapping") && Contains(Property.WSMVResourceURI,"http://schemas.microsoft.com/wbem/wsman/1/config/service/certmapping")),Property.WSTransferPutSummary = "certmapping"]
[RegisterBefore(
    WSEnumerationItemsElement.ElementNodes,
    WSMVCertmappingElement,
    Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "certmapping") && Contains(Property.WSMVResourceURI,"http://schemas.microsoft.com/wbem/wsman/1/config/service/certmapping"))]
Struct WSMVCertmappingElement= this.STag.ToString
{
	[Post.Local.WSMVCertmappingElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("certmapping") STag;
	switch
	{
		Case !Local.WSMVCertmappingElement_IsEmpty:
			struct
			{ 
				WSMVcertmappingType certmappingType;
				XmlTag("certmapping") ETag;
			}
	}
}

////WSMV Body CertMappingType
Struct WSMVcertmappingType
{
		While [String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
		{
			Switch
			{
				Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Issuer"):
					Struct WSMVIssuer=this.IssuerValue
					{
						[Post.Local.WSMVIssuerElement_IsEmpty = Property.IsXmlEmptyElement]
						XmlTag("Issuer") STag;
						switch
						{
							Case !Local.WSMVIssuerElement_IsEmpty:
								struct
								{ 
									XmlElemContent IssuerValue;
									XmlTag("Issuer") ETag;
								}
						}
					}
				Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Subject"):
					Struct WSMVSubject=this.SubjectValue
					{
						[Post.Local.WSMVSubjectElement_IsEmpty = Property.IsXmlEmptyElement]
						XmlTag("Subject") STag;
						switch
						{
							Case !Local.WSMVSubjectElement_IsEmpty:
								struct
								{ 
									XmlElemContent SubjectValue;
									XmlTag("Subject") ETag;
								}
						}
					}
				Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "URI"):
						Struct WSMVURI=this.URIValue
						{
							[Post.Local.WSMVURIElement_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("URI") STag;
							switch
							{
								Case !Local.WSMVURIElement_IsEmpty:
									struct
									{ 
										XmlElemContent URIValue;
										XmlTag("URI") ETag;
									}
							}
						}
				Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "UserName"):
					Struct WSMVUserName=this.UserNameValue
					{
						[Post.Local.WSMVUserNameElement_IsEmpty = Property.IsXmlEmptyElement]
						XmlTag("UserName") STag;
						switch
						{
							Case !Local.WSMVUserNameElement_IsEmpty:
								struct
								{ 
									XmlElemContent UserNameValue;
									XmlTag("UserName") ETag;
								}
						}
					}
				Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Password"):
					Struct WSMVPassword=this.PasswordValue
					{
						[Post.Local.WSMVPasswordElement_IsEmpty = Property.IsXmlEmptyElement]
						XmlTag("Password") STag;
						switch
						{
							Case !Local.WSMVPasswordElement_IsEmpty:
								struct
								{ 
									XmlElemContent PasswordValue;
									XmlTag("Password") ETag;
								}
						}
					}	
				Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Enabled"):
					Struct WSMVEnabled=this.EnabledValue
					{
						[Post.Local.WSMVEnabledElement_IsEmpty = Property.IsXmlEmptyElement]
						XmlTag("Enabled") STag;
						switch
						{
							Case !Local.WSMVEnabledElement_IsEmpty:
								struct
								{ 
									XmlElemContent EnabledValue;
									XmlTag("Enabled") ETag;
								}
						}
					}
			}
		}
}

Table WSMVSoapActionTable(value)
{
	Switch(value)
	{
		case "http://schemas.microsoft.com/wbem/wsman/1/windows/shell/Command":
		case "http://schemas.microsoft.com/wbem/wsman/1/windows/shell/CommandResponse":
		Case "http://schemas.microsoft.com/wbem/wsman/1/windows/shell/Receive": 
		Case "http://schemas.microsoft.com/wbem/wsman/1/windows/shell/ReceiveResponse": 
		Case "http://schemas.microsoft.com/wbem/wsman/1/windows/shell/Send":
		Case "http://schemas.microsoft.com/wbem/wsman/1/windows/shell/SendResponse":
		Case "http://schemas.microsoft.com/wbem/wsman/1/windows/shell/Signal":
		Case "http://schemas.microsoft.com/wbem/wsman/1/windows/shell/SignalResponse": true;
		Default:false;
	}
}