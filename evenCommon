//#  (c) 2009 CodePlex Foundation
//#
//#  Title:                  Eventlog Remote Protocol
//#
//#  Details:                
//#
//#  Microsoft References:   [MS-EVEN]: Eventlog Remote Protocol Specification
//#
//#  Comments:               
//#
//#  Revision Class and Date:Minor, 3/2/2010
//#
//####

//******************************************************************************************
//EVEN PROTOCOL
//******************************************************************************************
[Property.EVENSummary = "", Property.EVENReturnValue = 0]
Protocol EVEN = FormatString( "%s%s%s%s%s", EVENMethodTable( Property.MSRPCIfUuid, Property.MSRPCOpnum ), Property.MSRPCPType ? " Response" : " Request", Property.EVENSummary != "" ? ", " + Property.EVENSummary : "", Property.MSRPCPType ? ", " + "Status = " + NtStatusTable( Property.EVENReturnValue ) : "", Property.ParserError ? ", " + Property.ParserErrorMessage : Property.ParserErrorMessage )
{
	Switch( Property.MSRPCIfUuid )
	{
		Case "{82273FDC-E32A-18C3-3F78-827929DC23EA}":
		_Struct Eventlog
		{
			Switch( Property.MSRPCOpnum )
			{
				Case 0x0000:
				_Struct ElfrClearELFW
				{
					Switch( Property.MSRPCPType )
					{
						Case 0x00:
						[Property.EVENSummary = "Backup File: " + BackupFileName.ToString + ", Handle: " + LogHandle.ToString]
						_Struct Request
						{
							Switch 
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										CONTEXT_HANDLE      LogHandle;
										NdrUnicodeStringPtr BackupFileName;
									}
							}

						}

						Case 0x02:
						_Struct Response
						{
							Switch 
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										[Property.EVENReturnValue = ReturnValue] UINT32 ReturnValue = NtStatusTable( this );
									}
							}

						}
					}
				}

				Case 0x0001:
				_Struct ElfrBackupELFW
				{
					Switch( Property.MSRPCPType )
					{
						Case 0x00:
						[Property.EVENSummary = "Backup File: " + BackupFileName.ToString + ", Handle: " + LogHandle.ToString]
						_Struct Request
						{
							Switch 
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										CONTEXT_HANDLE      LogHandle;
										NdrUnicodeString    BackupFileName;
									}
							}

						}

						Case 0x02:
						_Struct Response
						{
							Switch 
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										[Property.EVENReturnValue = ReturnValue] UINT32 ReturnValue = NtStatusTable( this );
									}
							}

						}
					}
				}

				Case 0x0002:
				_Struct ElfrCloseEL
				{
					Switch( Property.MSRPCPType )
					{
						Case 0x00:
						[Property.EVENSummary = "Handle: " + LogHandle.ToString]
						_Struct Request
						{
							Switch 
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										CONTEXT_HANDLE  LogHandle;
									}
							}

						}

						Case 0x02:
						[Property.EVENSummary = "Handle: " + LogHandle.ToString]
						_Struct Response
						{
							Switch 
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										CONTEXT_HANDLE LogHandle;
										[Property.EVENReturnValue = ReturnValue] UINT32 ReturnValue = NtStatusTable( this );
									}
							}

						}
					}
				}

				Case 0x0003:
				_Struct ElfrDeregisterEventSource
				{
					Switch( Property.MSRPCPType )
					{
						Case 0x00:
						[Property.EVENSummary = "Handle: " + LogHandle.ToString]
						_Struct Request
						{
							Switch 
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										CONTEXT_HANDLE  LogHandle;
									}
							}

						}

						Case 0x02:
						[Property.EVENSummary = "Handle: " + LogHandle.ToString]
						_Struct Response
						{
							Switch 
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										CONTEXT_HANDLE LogHandle;
										[Property.EVENReturnValue = ReturnValue] UINT32 ReturnValue = NtStatusTable( this );
									}
							}

						}
					}
				}

				Case 0x0004:
				_Struct ElfrNumberOfRecords
				{
					Switch( Property.MSRPCPType )
					{
						Case 0x00:
						[Property.EVENSummary = "Handle: " + LogHandle.ToString]
						_Struct Request
						{
							Switch 
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										CONTEXT_HANDLE  LogHandle;
									}
							}

						}

						Case 0x02:
						[Property.EVENSummary = "Num Records: " + FormatString( "%u", NumberOfRecords )]
						_Struct Response
						{
							Switch 
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										UINT32 NumberOfRecords;
										[Property.EVENReturnValue = ReturnValue] UINT32 ReturnValue = NtStatusTable( this );
									}
							}

						}
					}
				}

				Case 0x0005:
				_Struct ElfrOldestRecord
				{
					Switch( Property.MSRPCPType )
					{
						Case 0x00:
						[Property.EVENSummary = "Handle: " + LogHandle.ToString]
						_Struct Request
						{
							Switch 
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										CONTEXT_HANDLE  LogHandle;
									}
							}

						}

						Case 0x02:
						[Property.EVENSummary = "Oldest Record: " + FormatString( "%u", OldestRecordNumber )]
						_Struct Response
						{
							Switch 
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										UINT32 OldestRecordNumber;
										[Property.EVENReturnValue = ReturnValue] UINT32 ReturnValue = NtStatusTable( this );
									}
							}

						}
					}
				}

				Case 0x0006:
				_Struct ElfrChangeNotify 
				{
					Switch( Property.MSRPCPType )
					{
						Case 0x00:
						[Property.EVENSummary = ClientId.ToString + ", Event ID: " + FormatString( "%u", Event )]
						_Struct Request
						{
							Switch 
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
								struct
								{
									CONTEXT_HANDLE  LogHandle;
									EVENRpcClientID     ClientId;
									UINT32          Event;
								}
							}
						}

						Case 0x02:
						_Struct Response
						{
							Switch 
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										[Property.EVENReturnValue = ReturnValue] UINT32 ReturnValue = NtStatusTable( this );
									}
							}

						}
					}
				}

				Case 0x0007:
				_Struct ElfrOpenELW
				{
					Switch( Property.MSRPCPType )
					{
						Case 0x00:
						[Property.EVENSummary = "Module: " + ModuleName.ToString]
						_Struct Request
						{
							Switch 
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										WCHARPtr UNCServerName;
										NdrUnicodeString    ModuleName;
										NdrUnicodeString    RegModuleName;
										Align4 							Pad;
										UINT32              MajorVersion;
										UINT32              MinorVersion;
									}
							}

						}

						Case 0x02:
						[Property.EVENSummary = "Handle: " + LogHandle.ToString]
						_Struct Response
						{
							Switch 
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										CONTEXT_HANDLE LogHandle;
										[Property.EVENReturnValue = ReturnValue] UINT32 ReturnValue = NtStatusTable( this );
									}
							}

						}
					}
				}

				Case 0x0008:
				_Struct ElfrRegisterEventSourceW
				{
					Switch( Property.MSRPCPType )
					{
						Case 0x00:
						[Property.EVENSummary = "Module: " + ModuleName.ToString]
						_Struct Request
						{
							Switch 
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										WCHARPtr UNCServerName;
										NdrUnicodeString    ModuleName;
										NdrUnicodeString    RegModuleName;
										Align4 							Pad;
										UINT32              MajorVersion;
										UINT32              MinorVersion;
									}
							}

						}

						Case 0x02:
						[Property.EVENSummary = "Handle: " + LogHandle.ToString]
						_Struct Response
						{
							Switch 
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										CONTEXT_HANDLE LogHandle;
										[Property.EVENReturnValue = ReturnValue] UINT32 ReturnValue = NtStatusTable( this );
									}
							}

						}
					}
				}

				Case 0x0009:
				_Struct ElfrOpenBELW
				{
					Switch( Property.MSRPCPType )
					{
						Case 0x00:
						[Property.EVENSummary = "Backup: " + BackupFileName.ToString]
						_Struct Request
						{
							Switch 
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										WCHARPtr UNCServerName;
										NdrUnicodeString    BackupFileName;
										Align4 							Pad;
										UINT32              MajorVersion;
										UINT32              MinorVersion;
									}
							}

						}

						Case 0x02:
						[Property.EVENSummary = "Handle: " + LogHandle.ToString]
						_Struct Response
						{
							Switch 
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										CONTEXT_HANDLE LogHandle;
										[Property.EVENReturnValue = ReturnValue] UINT32 ReturnValue = NtStatusTable( this );
									}
							}

						}
					}
				}

				Case 0x000A:
				_Struct ElfrReadELW
				{
					Switch( Property.MSRPCPType )
					{
						Case 0x00:
						[Property.EVENSummary = "Record Offset: " + RecordOffset + ", NumBytes: " + FormatString( "%u", NumberOfBytesToRead ) + ", Flags: " + ReadFlags.ToString + ", Handle: " + LogHandle.ToString]				
						_Struct Request
						{
							Switch 
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										CONTEXT_HANDLE      LogHandle;
										EVENCommonReadFlags   ReadFlags = Property.EVENReadFlags;
										UINT32              RecordOffset;
										UINT32              NumberOfBytesToRead;
									}
							}

						}

						Case 0x02:
						[Property.EVENSummary = "Bytes Read: " + FormatString( "%d", NumberOfBytesRead ) + ", Min Bytes Needed: " + FormatString( "%d", MinNumberOfBytesNeeded )]
						_Struct Response
						{
							Switch 
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										NdrConformant NumberOfBytesToRead;
										while ReadEventlog[FrameOffset < (FrameLength - 12)]
										{
											Switch {
												Case UINT32(FrameData,FrameOffset) > 0: EVENEventlogRecord(0) eventlogRecord;
												Case UINT32(FrameData,FrameOffset) == 0: BLOB((FrameLength - 12) - FrameOffset) NoEvent; 
											}
										}
										Align4 pad;
										UINT32 NumberOfBytesRead;
										UINT32 MinNumberOfBytesNeeded;
										[Property.EVENReturnValue = ReturnValue] UINT32 ReturnValue = NtStatusTable( this );
									}
							}

						}
					}
				}

				Case 0x000B:
				_Struct ElfrReportEventW
				{
					Switch( Property.MSRPCPType )
					{
						Case 0x00:
						[Property.EVENSummary = "Type: " + EventType.ToString + ", Category: " + FormatString( "%u", EventCategory ) + ", ID: " + FormatString( "%u", EventID ) + ", Name: " + ComputerName.ToString]
						_Struct Request
						{
							Switch 
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										CONTEXT_HANDLE      LogHandle;
										UINT32              Time;
										UINT16              EventType = EVENEventTypeTable( this );
										UINT16              EventCategory;
										UINT32              EventID;
										UINT16              NumStrings;
										Align4              Pad1;
										UINT32              DataSize;
										NdrUnicodeString    ComputerName;
										SIDPtr              UserSID; 
										EventUnicodeStrings( NumStrings )        Strings;
										BinaryData          Data;
										Align2              Pad2;
										UINT16              Flags;
										UINT32Ptr RecordNumber;
										UINT32Ptr TimeWritten;
									}
							}

						}

						Case 0x02:
						_Struct Response
						{
							Switch 
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										UINT32Ptr RecordNumber;
										UINT32Ptr TimeWritten;
										[Property.EVENReturnValue = ReturnValue] UINT32 ReturnValue = NtStatusTable( this );
									}
							}

						}
					}
				}

				Case 0x000C:
				_Struct ElfrClearELFA
				{
					Switch( Property.MSRPCPType )
					{
						Case 0x00:
						[Property.EVENSummary = "Backup File: " + BackupFileName.ToString + ", Handle: " + LogHandle.ToString]
						_Struct Request
						{
							Switch 
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										CONTEXT_HANDLE  LogHandle;
										EVENRpcStringPtr      BackupFileName;
									}
							}

						}

						Case 0x02:
						_Struct Response
						{
							Switch 
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										[Property.EVENReturnValue = ReturnValue] UINT32 ReturnValue = NtStatusTable( this );
									}
							}

						}
					}
				}

				Case 0x000D:
				_Struct ElfrBackupELFA
				{
					Switch( Property.MSRPCPType )
					{
						Case 0x00:
						[Property.EVENSummary = "Backup File: " + BackupFileName.ToString + ", Handle: " + LogHandle.ToString]
						_Struct Request
						{
							Switch 
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										CONTEXT_HANDLE  LogHandle;
										NdrAlign Pad;
										EVENRpcString       BackupFileName;
									}
							}

						}

						Case 0x02:
						_Struct Response
						{
							Switch 
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										[Property.EVENReturnValue = ReturnValue] UINT32 ReturnValue = NtStatusTable( this );
									}
							}

						}
					}
				}

				Case 0x000E:
				_Struct ElfrOpenELA
				{
					Switch( Property.MSRPCPType )
					{
						Case 0x00:
						[Property.EVENSummary = "Module: " + ModuleName.ToString + ", Default File: " + RegModuleName.ToString]
						_Struct Request
						{
							Switch 
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										CHARPtr        UNCServerName;
										NdrAlign       pad1;
										EVENRpcString  ModuleName;
										NdrAlign       pad2;
										EVENRpcString  RegModuleName;
										Align4         pad3;
										UINT32         MajorVersion;
										UINT32         MinorVersion;
									}
							}

						}

						Case 0x02:
						[Property.EVENSummary = "Handle: " + LogHandle.ToString]
						_Struct Response
						{
							Switch 
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										CONTEXT_HANDLE LogHandle;
										[Property.EVENReturnValue = ReturnValue] UINT32 ReturnValue = NtStatusTable( this );
									}
							}

						}
					}
				}

				Case 0x000F:
				_Struct ElfrRegisterEventSourceA
				{
					Switch( Property.MSRPCPType )
					{
						Case 0x00:
						[Property.EVENSummary = "Module: " + ModuleName.ToString]
						_Struct Request
						{
							Switch 
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										CHARPtr UNCServerName;
										NdrAlign      pad1;
										EVENRpcString ModuleName;
										NdrAlign      pad2;
										EVENRpcString RegModuleName;
										Align4        pad3;
										UINT32        MajorVersion;
										UINT32        MinorVersion;
									}
							}

						}

						Case 0x02:
						[Property.EVENSummary = "Handle: " + LogHandle.ToString]
						_Struct Response
						{
							Switch 
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										CONTEXT_HANDLE LogHandle;
										[Property.EVENReturnValue = ReturnValue] UINT32 ReturnValue = NtStatusTable( this );
									}
							}

						}
					}
				}

				Case 0x0010:
				_Struct ElfrOpenBELA
				{
					Switch( Property.MSRPCPType )
					{
						Case 0x00:
						[Property.EVENSummary = "Backup File: " + FileName.ToString]
						_Struct Request
						{
							Switch 
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										CHARPtr UNCServerName;
										NdrAlign            Padding;
										EVENRpcString       FileName;
										Align4              pad;
										UINT32              MajorVersion;
										UINT32              MinorVersion;
									}
							}

						}

						Case 0x02:
						[Property.EVENSummary = "Handle: " + LogHandle.ToString]
						_Struct Response
						{
							Switch 
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										CONTEXT_HANDLE LogHandle;
										[Property.EVENReturnValue = ReturnValue] UINT32 ReturnValue = NtStatusTable( this );
									}
							}

						}
					}
				}

				Case 0x0011:
				_Struct ElfrReadELA
				{
					Switch( Property.MSRPCPType )
					{
						Case 0x00:
						[Property.EVENSummary = "Record Offset: " + RecordOffset + ", NumBytes: " + FormatString( "%u", NumberOfBytesToRead ) + ", Flags: " + ReadFlags.ToString + ", Handle: " + LogHandle.ToString]
						_Struct Request
						{
							Switch 
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										CONTEXT_HANDLE      LogHandle;
										EVENCommonReadFlags   ReadFlags = Property.EVENReadFlags;
										UINT32              RecordOffset;
										UINT32              NumberOfBytesToRead;
									}
							}

						}

						Case 0x02:
						[Property.EVENSummary = "Bytes Read: " + FormatString( "%d", NumberOfBytesRead ) + ", Min Bytes Needed: " + FormatString( "%d", MinNumberOfBytesNeeded )]
						_Struct Response
						{
							Switch 
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										NdrConformant NumberOfBytesToRead;
										while ReadEventlog[FrameOffset < (FrameLength - 12)]
										{
											Switch {
												Case UINT32(FrameData,FrameOffset) > 0: EVENEventlogRecord(1) eventlogRecord;
												Case UINT32(FrameData,FrameOffset) == 0: BLOB((FrameLength - 12) - FrameOffset) NoEvent; 
											}
										}
										Align4 pad;
										UINT32 NumberOfBytesRead;
										UINT32 MinNumberOfBytesNeeded;
										[Property.EVENReturnValue = ReturnValue] UINT32 ReturnValue = NtStatusTable( this );
									}
							}

						}
					}
				}

				Case 0x0012:
				_Struct ElfrReportEventA
				{
					Switch( Property.MSRPCPType )
					{
						Case 0x00:
						[Property.EVENSummary = "Type: " + EventType.ToString + ", Category: " + FormatString( "%u", EventCategory ) + ", ID: " + FormatString( "%u", EventID ) + ", Name: " + ComputerName.ToString]
						_Struct Request
						{
							Switch 
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										CONTEXT_HANDLE      LogHandle;
										UINT32              Time;
										UINT16              EventType = EVENEventTypeTable( this );
										UINT16              EventCategory;
										UINT32              EventID;
										UINT16              NumStrings;
										Align4              Pad;
										UINT32              DataSize;
										NdrAlign            Padding1;
										EVENRpcString       ComputerName;
										SIDPtr              UserSID;
										EventAsciiStrings( NumStrings )        Strings;
										NdrAlign            Padding2;
										BinaryData          Data;
										Align2              Padding3;
										UINT16              Flags;
										UINT32Ptr           RecordNumber;
										UINT32Ptr           TimeWritten;
									}
							}

						}

						Case 0x02:
						_Struct Response
						{
							Switch 
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										UINT32Ptr RecordNumber;
										UINT32Ptr TimeWritten;
										[Property.EVENReturnValue = ReturnValue] UINT32 ReturnValue = NtStatusTable( this );
									}
							}

						}
					}
				}

// opnum 19 - 21 Reserved for local use
/*				Case 0x0013:
				_Struct ElfrRegisterClusterSvc
				{
					Switch( Property.MSRPCPType )
					{
						Case 0x00:
						_Struct Request
						{
							Switch 
							{
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										WCHARPtr UNCServerName;
										Switch {
											Case CurrentProtocolOffset % 4 > 0 && FrameLength - Offset > 0: ALIGN4 Padding;
										}
									}
							}

						}

						Case 0x02:
						_Struct Response
						{
							Switch 
							{
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										UINT32 Size;
										NdrPtr Pointer;
										switch
										{
											case Pointer.ReferentID > 0:
											Struct PackedEventInfo 
											{
												NdrConformant MaxCount;
												UINT8 PackedEventInfo[ Size ];
											}
										}
										Align4 pad;
										[Property.EVENReturnValue = ReturnValue] UINT32 ReturnValue = NtStatusTable( this );
									}
							}

						}
					}
				}

				Case 0x0014:
				_Struct ElfrDeregisterClusterSvc
				{
					Switch( Property.MSRPCPType )
					{
						Case 0x00:
						_Struct Request
						{
							Switch 
							{
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										WCHARPtr UNCServerName;
										Switch {
											Case CurrentProtocolOffset % 4 > 0 && FrameLength - Offset > 0: ALIGN4 Padding;
										}
									}
							}

						}

						Case 0x02:
						_Struct Response
						{
							Switch 
							{
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										[Property.EVENReturnValue = ReturnValue] UINT32 ReturnValue = NtStatusTable( this );
									}
							}

						}
					}
				}

				Case 0x0015:
				_Struct ElfrWriteClusterEvents
				{
					Switch( Property.MSRPCPType )
					{
						Case 0x00:
						[Property.EVENSummary = "Buffer Size: " + FormatString( "%d", BufferSize )]
						_Struct Request
						{
							Switch 
							{
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										WCHARPtr UNCServerName;
										Switch {
											Case CurrentProtocolOffset % 4 > 0 && FrameLength - Offset > 0: ALIGN4 Padding;
										}
									}
							}


							UINT32              BufferSize;

							Struct Buffer 
							{
								NdrConformant       MaxCount;
								BLOB( BufferSize )  Buffer;						
							}
						}

						Case 0x02:
						_Struct Response
						{
							Switch 
							{
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										[Property.EVENReturnValue = ReturnValue] UINT32 ReturnValue = NtStatusTable( this );
									}
							}

						}
					}
				}
*/
				Case 0x0016:
				_Struct ElfrGetLogInformation
				{
					Switch( Property.MSRPCPType )
					{
						Case 0x00:
						[Property.EVENSummary = "Info Level: " + FormatString( "%u", InfoLevel ) + ", Buffer Size: " + FormatString( "%u", BufSize ) + ", Handle: " + LogHandle.ToString]
						_Struct Request
						{
							Switch 
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										CONTEXT_HANDLE  LogHandle;
										UINT32          InfoLevel;
										UINT32          BufSize;
									}
							}

						}

						Case 0x02:
						[Property.EVENSummary = "Bytes Needed: " + FormatString( "%u", BytesNeeded )]
						_Struct Response
						{
							Switch {
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:	Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										NdrConformant MaxCount;
										UINT8 Buffer[MaxCount.MaxCount];
										Align4 pad;
										UINT32 BytesNeeded;
										[Property.EVENReturnValue = ReturnValue] UINT32 ReturnValue = NtStatusTable( this );
									}
							}

						}
					}
				}

// opnum 23 Reserved for local use
/*				Case 0x0017:
				_Struct ElfrFlushEL
				{
					Switch( Property.MSRPCPType )
					{
						Case 0x00:
						[Property.EVENSummary = "Handle: " + LogHandle.ToString]
						_Struct Request
						{
							Switch {
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:	Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										CONTEXT_HANDLE  LogHandle;
									}
							}

						}

						Case 0x02:
						_Struct Response
						{
							Switch {
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:	Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										[Property.EVENReturnValue = ReturnValue] UINT32 ReturnValue = NtStatusTable( this );
									}
							}

						}
					}
				}
*/

				Case 0x0018:
				_Struct ElfrReportEventAndSourceW
				{
					Switch( Property.MSRPCPType )
					{
						Case 0x00:
						[Property.EVENSummary = "Type: " + EventType.ToString + ", Category: " + FormatString( "%u", EventCategory ) + ", ID: " + FormatString( "%u", EventID ) + ", Name: " + ComputerName.ToString]
						_Struct Request
						{
							Switch {
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:	Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										CONTEXT_HANDLE      LogHandle;
										UINT32              Time;
										UINT16              EventType = EVENEventTypeTable( this );
										UINT16              EventCategory;
										UINT32              EventID;
										NdrUnicodeString    SourceName;
										UINT16              NumStrings;
										Align4              pad1;
										UINT32              DataSize;
										NdrUnicodeString    ComputerName;
										SIDPtr              UserSID;
										EventUnicodeStrings( NumStrings )        Strings;
										BinaryData          Data;
										Align2              pad2;
										UINT16              Flags=EVENElfrReportEventAndSourceWFlagsTable( this );
										UINT32Ptr           RecordNumber;
										UINT32Ptr           TimeWritten;
									}
							}

						}

						Case 0x02:
						_Struct Response
						{
							Switch 
							{
								Case MSRPCAuthLevel == -1: Blob( FrameLength - FrameOffset ) PartialData = "May Need Reassemble";
								Case Property.MSRPCEncrypted != ConstEncTypeClearData:
									Blob( FrameLength - FrameOffset ) EncryptedData;
								Default:
									struct
									{
										UINT32Ptr RecordNumber;
										UINT32Ptr TimeWritten;
										[Property.EVENReturnValue = ReturnValue] UINT32 ReturnValue = NtStatusTable( this );
									}
							}

						}
					}
				}

				Case 19:
				Case 20:
				Case 21:
				Case 23:
				Struct NotUsedOnWire
				{
					Switch (property.MSRPCPType)
					{
						Case 0x00:// REQUEST
						[post.Description = "OPNUM:" + Property.MSRPCOpnum + " request is Not used on wire"]
						Struct Request 
						{
							ReportParserWarning("EventLog", "Invalid eventlog method, Opnum:" + Property.MSRPCOpnum) ProtocolWarning;
							Blob(FrameLength - Offset) PayloadData;
						}
						
						Case 0x02:// RESPONSE
						[post.Description = "OPNUM:" + Property.MSRPCOpnum + " response is Not used on wire"]
						Struct Response
						{
							ReportParserWarning("EventLog", "Invalid eventlog method, Opnum:" + Property.MSRPCOpnum) ProtocolWarning;
							Blob(FrameLength - Offset) PayloadData;
						}
					}
				}

				Default:
				Struct 
				{
					ReportParserError(ParserErrorProtocolClassWindows, "EventLog", "Unknown Method" ) ProtocolError;
				}
			}
		}
	}
}
//******************************************************************************************
//EVEN TABLES
//******************************************************************************************

Table EVENMethodTable( UUID, Opnum )
{
	Switch
	{
		Case UUID == "{82273FDC-E32A-18C3-3F78-827929DC23EA}" && Opnum == 0x0000: "ElfrClearELFW";
		Case UUID == "{82273FDC-E32A-18C3-3F78-827929DC23EA}" && Opnum == 0x0001: "ElfrBackupELFW";
		Case UUID == "{82273FDC-E32A-18C3-3F78-827929DC23EA}" && Opnum == 0x0002: "ElfrCloseEL";
		Case UUID == "{82273FDC-E32A-18C3-3F78-827929DC23EA}" && Opnum == 0x0003: "ElfrDeregisterEventSource";
		Case UUID == "{82273FDC-E32A-18C3-3F78-827929DC23EA}" && Opnum == 0x0004: "ElfrNumberOfRecords";
		Case UUID == "{82273FDC-E32A-18C3-3F78-827929DC23EA}" && Opnum == 0x0005: "ElfrOldestRecord";
		Case UUID == "{82273FDC-E32A-18C3-3F78-827929DC23EA}" && Opnum == 0x0006: "ElfrChangeNotify";
		Case UUID == "{82273FDC-E32A-18C3-3F78-827929DC23EA}" && Opnum == 0x0007: "ElfrOpenELW";
		Case UUID == "{82273FDC-E32A-18C3-3F78-827929DC23EA}" && Opnum == 0x0008: "ElfrRegisterEventSourceW";
		Case UUID == "{82273FDC-E32A-18C3-3F78-827929DC23EA}" && Opnum == 0x0009: "ElfrOpenBELW";
		Case UUID == "{82273FDC-E32A-18C3-3F78-827929DC23EA}" && Opnum == 0x000A: "ElfrReadELW";
		Case UUID == "{82273FDC-E32A-18C3-3F78-827929DC23EA}" && Opnum == 0x000B: "ElfrReportEventW";
		Case UUID == "{82273FDC-E32A-18C3-3F78-827929DC23EA}" && Opnum == 0x000C: "ElfrClearELFA";
		Case UUID == "{82273FDC-E32A-18C3-3F78-827929DC23EA}" && Opnum == 0x000D: "ElfrBackupELFA";
		Case UUID == "{82273FDC-E32A-18C3-3F78-827929DC23EA}" && Opnum == 0x000E: "ElfrOpenELA";
		Case UUID == "{82273FDC-E32A-18C3-3F78-827929DC23EA}" && Opnum == 0x000F: "ElfrRegisterEventSourceA";
		Case UUID == "{82273FDC-E32A-18C3-3F78-827929DC23EA}" && Opnum == 0x0010: "ElfrOpenBELA";
		Case UUID == "{82273FDC-E32A-18C3-3F78-827929DC23EA}" && Opnum == 0x0011: "ElfrReadELA";
		Case UUID == "{82273FDC-E32A-18C3-3F78-827929DC23EA}" && Opnum == 0x0012: "ElfrReportEventA";
		Case UUID == "{82273FDC-E32A-18C3-3F78-827929DC23EA}" && Opnum == 0x0013: "ElfrRegisterClusterSvc";
		Case UUID == "{82273FDC-E32A-18C3-3F78-827929DC23EA}" && Opnum == 0x0014: "ElfrDeregisterClusterSvc";
		Case UUID == "{82273FDC-E32A-18C3-3F78-827929DC23EA}" && Opnum == 0x0015: "ElfrWriteClusterEvents";
		Case UUID == "{82273FDC-E32A-18C3-3F78-827929DC23EA}" && Opnum == 0x0016: "ElfrGetLogInformation";
		Case UUID == "{82273FDC-E32A-18C3-3F78-827929DC23EA}" && Opnum == 0x0017: "ElfrFlushEL";
		Case UUID == "{82273FDC-E32A-18C3-3F78-827929DC23EA}" && Opnum == 0x0018: "ElfrReportEventAndSourceW";
	}
}

Table EVENReadFlagsTable( Value )
{
	Switch( Value )
	{
		Case 0x00000001: FormatString( "0x%08X - EventlogSequentialRead - Read operation proceeds sequentially from the last call to the ElfrReadELW or ElfrReadELA method using this handle", value);
		Case 0x00000002: FormatString( "0x%08X - EventlogSeekRead - Read operation proceeds from the record specified by the RecordOffset parameter", value);
		Case 0x00000004: FormatString( "0x%08X - EventlogForwardsRead - Log is read in chronological order", value);
		Case 0x00000008: FormatString( "0x%08X - EventlogBackwardsRead - Log is read in reverse chronological order", value);
		Default		   : FormatString( "0x%08X -  Unknown Read Flag", value );
	}
}

Table EVENEventTypeTable( Value )
{
	Switch( Value )
	{
		Case 0x00000000: FormatString( "0x%08X - Success event", value);
		Case 0x00000001: FormatString( "0x%08X - Error event", value);
		Case 0x00000002: FormatString( "0x%08X - Warning event", value);
		Case 0x00000004: FormatString( "0x%08X - Information event", value);
		Case 0x00000008: FormatString( "0x%08X - Success audit event", value);
		Case 0x00000010: FormatString( "0x%08X - Failure audit event", value);
		Default		   : FormatString( "0x%08X - Unknown Event Type", value );
	}
}

Table EVENElfrReportEventAndSourceWFlagsTable( Value )
{
	Switch( Value )
	{
		Case 0x00000000: FormatString( "0x%08X - The event is not formatted as XML", value);
		Case 0x00008000: FormatString( "0x%08X - The event is formatted as XML", value);
		Default		   : FormatString( "0x%08X - No Description Available", value );
	}
}

Table EVENRecordEventTypeTable(value)
{
	switch(value)
	{
		case 0x00000000: "SUCCESS";
		case 0x00000001: "ERROR_TYPE";
		case 0x00000002: "WARNING_TYPE";
		case 0x00000004: "INFORMATION_TYPE";
		case 0x00000008: "AUDIT_SUCCESS";
		case 0x00000010: "AUDIT_FAILURE";
		default: "Undefined Type";
	}
}

Table EVENRecordReservedFlagTable(value)
{
	switch(value)
	{
		case 	0x00000000: "The event does not contain XML.";
		case 	0x00008000: "The event contains XML.";
		default : "Undefined Flag";
	}
}

Table EVENRpcVariantTypeTable(Type)
{
	switch(Type)
	{
		case 0: "Null";
		case 1: "Boolean";
		case 2: "UInt32";
		case 3: "UInt64";
		case 4: "String";
		case 5: "Guid";
		case 6: "BooleanArray";
		case 7: "UInt32Array";
		case 8: "UInt64Array";
		case 9: "StringArray";
		case 10: "GuidArray";
		default: "undefined Type";
	}
}

//******************************************************************************************
//EVEN STRUCTURES
//******************************************************************************************

//
// _RPC_CLIENT_ID
//
Struct EVENRpcClientID = FormatString( "Unique Process: %d, Unique Thread: %d", UniqueProcess, UniqueThread ) 
{
	UINT32 UniqueProcess;
	UINT32 UniqueThread;
}

//
// _RPC_STRING
//Alignment NdrAlign
//
Struct EVENRpcString = FormatString( "%s", RPCString.ToString )
{
	UINT16 Length;
	UINT16 MaximumLength;
	NdrPtr Pointer;
	Switch
	{
		Case Pointer.ReferentID > 0: 
			Struct RPCString = String
			{
				NdrConformant ConformantArray;
				Switch {
					Case ConformantArray.MaxCount > 0: AsciiString( ConformantArray.MaxCount ) String;
				}
			}
	}
}

/*
Struct EVENCommonAsciiStringArray( Size ) {
	[Local.EventlogPointerArrayLoop = 0,Property.EVENPointerLoop = 0]
	EVENCommonPtrArray Pointer[ Size ];
	While EventlogPointerArrayWhileLoop[ Local.EventlogPointerArrayLoop < Property.EVENPointerLoop ]
	{
		[Local.EventlogPointerArrayLoop = Local.EventlogPointerArrayLoop + 1]
		Switch {
			Case Property.EVENPtr$[ Local.EventlogPointerArrayLoop - 1 ] > 0: 
			EVENRpcString NameString;
		}
	}
}*/

//
// _RPC_STRING_Ptr
//Alignment NdrAlign
//
Struct EVENRpcStringPtr 
{
	NdrPtr Pointer;
	Switch
	{
		Case Pointer.ReferentID > 0: EVENRpcString RPCString;
	}
}

//
// _Read_Flags
//Alignment None
//
Struct EVENCommonReadFlags {
	Switch( Property.MSRPCByteOrder )
	{
		Case LittleEndian:
		Struct {
			[Property.EVENReadFlags = ReadFlags.toString]
			UINT32 ReadFlags = ((this & 0x00000001) ? " Seq" : "")
			+ ((this & 0x00000002) ? " Seek": "")
			+ ((this & 0x00000004) ? " Fwd" : "")
			+ ((this & 0x00000008) ? " Back": "")
			{
				UINT32 SequentialRead:1 = FormatString("(%s) %s", this.ToBitString, this ? "Read operation proceeds sequentially from the last call" : "Read operation does not proceed sequentially from the last call");
				UINT32 SeekRead:1 = FormatString("      (%s) %s", this.ToBitString, this ? "Read operation proceeds from the record specified by the RecordOffset parameter" : "Read operation does not proceed from the record specified by the RecordOffset parameter");
				UINT32 ForwardsRead:1 = FormatString("  (%s) %s", this.ToBitString, this ? "Log is read in chronological order" : "Log is not read in chronological order");
				UINT32 BackwardsRead:1 = FormatString(" (%s) %s", this.ToBitString, this ? "Log is read in reverse chronological order" : "Log is not read in reverse chronological order");
				UINT32 Reserved:28 = FormatString("      (%s)", this.ToBitString);
			}
		};
		Default:
		Struct {
			[Property.EVENReadFlags = ReadFlags.toString]
			UINT32 ReadFlags = ((this & 0x00000001) ? " Seq" : "")
			+ ((this & 0x00000002) ? " Seek": "")
			+ ((this & 0x00000004) ? " Fwd" : "")
			+ ((this & 0x00000008) ? " Back": "")
			{ 
				UINT32 Reserved:28 = FormatString("      (%s)", this.ToBitString);
				UINT32 BackwardsRead:1 = FormatString(" (%s) %s", this.ToBitString, this ? "Log is read in reverse chronological order" : "Log is not read in reverse chronological order");
				UINT32 ForwardsRead:1 = FormatString("  (%s) %s", this.ToBitString, this ? "Log is read in chronological order" : "Log is not read in chronological order");
				UINT32 SeekRead:1 = FormatString("      (%s) %s", this.ToBitString, this ? "Read operation proceeds from the record specified by the RecordOffset parameter" : "Read operation does not proceed from the record specified by the RecordOffset parameter");
				UINT32 SequentialRead:1 = FormatString("(%s) %s", this.ToBitString, this ? "Read operation proceeds sequentially from the last call" : "Read operation does not proceed sequentially from the last call");
			}
		};
	}
}

Struct EVENCommonPtrArray {
	[Property.EVENPtr$[ Property.EVENPointerLoop ] = Pointer.ReferentID, Post.Property.EVENPointerLoop = Property.EVENPointerLoop + 1]
	NdrPtr Pointer;
}

Struct EVENCommonUnicodeStringPtrArray(size) {
	[Local.EventlogUnicodePointerArrayLoop=0,Property.EVENPointerLoop=0]
	EVENCommonPtrArray Pointer[size];
	While EventlogPointerArrayWhileLoop[Local.EventlogUnicodePointerArrayLoop < Property.EVENPointerLoop]
	{
		[Local.EventlogUnicodePointerArrayLoop = Local.EventlogUnicodePointerArrayLoop + 1]
		Switch 
		{
			Case Property.EVENPtr$[ Local.EventlogUnicodePointerArrayLoop - 1 ] > 0: NdrUnicodeString NameString;
		}
	}
}

Struct EVENCommonStringPtrArray(size) {
	[Local.EventlogPointerArrayLoop=0,Property.EVENPointerLoop=0]
	EVENCommonPtrArray Pointer[size];
	While EventlogPointerArrayWhileLoop[Local.EventlogPointerArrayLoop < Property.EVENPointerLoop]
	{
		[Local.EventlogPointerArrayLoop = Local.EventlogPointerArrayLoop + 1]
		Switch 
		{
			Case Property.EVENPtr$[ Local.EventlogPointerArrayLoop - 1 ] > 0: EVENRpcString NameString;
		}
	}
}


//
// EVENTLOGRECORD
//
Struct EVENEventlogRecord(value) = FormatString("RecordNumber : %u, EventID: %u, EventType : %s, Num of String: %u, ReservedFlags : %s", RecordNumber, EventID, EVENRecordEventTypeTable(EventType), NumStrings, EVENRecordReservedFlagTable(ReservedFlags))
{
	[Local.EventlogRecordStartOffset = FrameOffset]
	UINT32              Length;
	UINT32              Reserved;
	UINT32              RecordNumber;
	UINT32              TimeGenerated;
	UINT32              TimeWritten;
	UINT32              EventID;
	UINT16              EventType = EVENRecordEventTypeTable(this);
	UINT16              NumStrings;
	UINT16              EventCategory;
	UINT16              ReservedFlags = EVENRecordReservedFlagTable(this);
	UINT32              ClosingRecordNumber;
	UINT32              StringOffset;
	UINT32              UserSidLength;
	UINT32              UserSidOffset;
	UINT32              DataLength;
	UINT32              DataOffset;
	switch(value)
	{
		case 1:
			_struct
			{
				AsciiString SourceName;
				AsciiString ComputerName;
			}
		default:
			_struct
			{
				UnicodeString         SourceName;
				UnicodeString         ComputerName;
			}
	}
	switch
	{
		case UserSidLength > 0:
			_struct Sid
			{
				switch
				{
					case FrameOffset - Local.EventlogRecordStartOffset < UserSidOffset:
						BLob(UserSidOffset + Local.EventlogRecordStartOffset - FrameOffset) SidPad;
				}
				SID( false )         UserSid;
			}
	}
	switch
	{
		case NumStrings > 0:
			_struct Str
			{
				switch
				{
					case FrameOffset - Local.EventlogRecordStartOffset < StringOffset:
						BLob(StringOffset + Local.EventlogRecordStartOffset - FrameOffset) StrPad;
				}
				switch(value)
				{
					case 1:
							AsciiString ANSIStrings[ NumStrings ];
					default:
							UnicodeString UniStrings[ NumStrings ];
				}
			}
	}
	switch
	{
		case DataLength > 0:
			_struct Datas
			{
				switch
				{
					case FrameOffset - Local.EventlogRecordStartOffset < DataOffset:
						BLob(DataOffset + Local.EventlogRecordStartOffset - FrameOffset) DataPad;
				}
				BLOB( FrameLength - FrameOffset < DataLength ? FrameLength - FrameOffset : DataLength)  Data;
		  }
	}
	switch
	{
			case FrameOffset - Local.EventlogRecordStartOffset + 4 < Length:
			BLob(Length + Local.EventlogRecordStartOffset - 4 - FrameOffset) pad;
	}
	UINT32              Length2;
}

Struct BinaryData 
{
	NdrPtr  Pointer;
	Switch
	{
		Case Pointer.ReferentID > 0: Struct 
		{
			NdrConformant       MaxCount;
			char                Data[MaxCount.Maxcount > FrameLength - FrameOffset ? FrameLength - FrameOffset : MaxCount.Maxcount];
		}
	}
}

struct EventUnicodeStrings( NumStrings )
{
	NdrPtr  Pointer;
	switch
	{
		case Pointer.ReferentID > 0:
		struct
		{
			NdrConformant MaxCount;
			EVENCommonUnicodeStringPtrArray( NumStrings ) EventString;
		}
	}
}

struct EventAsciiStrings( NumStrings )
{
	NdrPtr  Pointer;
	switch
	{
		case Pointer.ReferentID > 0:
		struct
		{
			NdrConformant MaxCount;
			EVENCommonStringPtrArray( NumStrings ) EventString;
		}
	}
}


