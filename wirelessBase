//#  (c) 2009 CodePlex Foundation
//#
//#  Title:                  Wireless Protocols
//#
//#  Details:                
//#
//#  Public References:      
//#                          IEEE Std 802.11-2007: merged 8 amendments (802.11a,b,d,e,g,h,i,j) with the base IEEE Std 802.11-1999
//#                          IEEE Std 802.11k-2008: radio resource management. It defines and exposes radio and network information to facilitate the management and maintenance of a mobile Wireless LAN.
//#                          IEEE Std 802.11r-2008: fast BSS transition (FT), permit continuous connectivity aboard wireless devices in motion, with fast and secure handoffs from one base station to another managed in a seamless manner.
//#                          IEEE Std 802.11y-2008: enables high powered Wi-Fi equipment to operate on a co-primary basis in the 3650 to 3700 MHz band in US
//#                          IEEE Std 802.11w-2009: increase the security of its management frames
//#                          IEEE Std 802.11n-2009: improve network throughput over the two previous standards ?802.11a and 802.11g ?with a significant increase in the maximum raw data rate from 54 Mbit/s to 600 Mbit/s with the use of four spatial streams at a channel width of 40 MHz
//#                          Final_WPA_Pointer_Doc_Rev_3_1
//#                          WMM_Specification_1-1
//#
//#  Comments:               
//#
//#  Revision Class and Date:Major, 5/17/2010
//#
//####

[DataTypeByteOrder = LittleEndian]
Protocol WiFi = FormatString ("%s", WiFiDescription)
{
	// Metadata is an internal structure containing information collected by the Netmon capture engine. It's not defined by IEEE standards.
	[FCSPresent = 0]
	switch
	{
		case !NetEvent:
			WiFiMetadata MetaData;
	}
	
	// The following is defined in IEEE 802.11
	
	// Start of MAC Header
	// Exclude FCS from Packet Length if it is present	
	[WiFiPktLen = FCSPresent ? FrameLength - 4 : FrameLength]
	WiFiFrameCtrl FrameControl;
	
	[WiFiDescription = FormatString("[%s%s%s]", 
									Property.WiFiType == 2 ? ((WiFiEncrypted) ? "Encrypted " : "Unencrypted ") : "", 
									(Property.WiFiType == 2 ? "" : (" " + WiFiTypeTable(Property.WiFiType))), 
								  	WiFiSubTypeTable(Property.WiFiSubType, Property.WiFiType))]
	[WiFiDescription = FormatString("%s %s", WiFiDescription, Property.FrameControlDescription)]
	[WiFiDescription = FormatString("%s%s", WiFiDescription, (Property.WiFiType == 2 ? (Property.WiFiDS ? ", (I)" : ", (A)") : ""))]
	[WiFiDescription = FormatString("%s %s", WiFiDescription, WiFiMetadataDesc)]
	switch (Property.WiFiType) 
	{
		case 0:
			_struct Management
			{
				UINT16 Duration;
				[Pair = Address, DestinationHardwareAddress, DataFieldByteOrder = BigEndian, WiFiDestination, DestinationMacAlias = Global.AliasTable$[this], Destination = DestinationMacAlias ? DestinationMacAlias : FormatString("[%s]", this.ToString)]
				MacAddress DA = MacTable(this);
				[Pair = Address, SourceHardwareAddress, DataFieldByteOrder = BigEndian, WiFiSource, SourceMACAlias = Global.AliasTable$[this], Source = SourceMacAlias ? SourceMacAlias : FormatString("[%s]", this.ToString)]
				MacAddress SA = MacTable(this);
				[DataFieldByteOrder = BigEndian, BSSID]
				MacAddress BSSID = MacTable(this);
				WiFiSeqCtrl SequenceControl;
			}
		case 1:
			_struct Control
			{
				switch (Property.WiFiSubType)
				{
					case 7:
						_struct ControlWrapper
						{
							UINT16 Duration;
							[DataFieldByteOrder = BigEndian]
							MacAddress Address1 = MacTable(this);
							WiFiFrameCtrl CarriedFrameControl;
						}
					case 8:
						_struct BlockAckReq
						{
							UINT16 Duration;
							[Pair = Address, DestinationHardwareAddress, DataFieldByteOrder = BigEndian, WiFiDestination, DestinationMacAlias = Global.AliasTable$[this], Destination = DestinationMacAlias ? DestinationMacAlias : FormatString("[%s]", this.ToString)]
							MacAddress RA = MacTable(this);
							[Pair = Address, SourceHardwareAddress, DataFieldByteOrder = BigEndian, WiFiSource, SourceMACAlias = Global.AliasTable$[this], SourceMACAlias = Global.AliasTable$[this], Source = SourceMacAlias ? SourceMacAlias : FormatString("[%s]", this.ToString)]
							MacAddress TA = MacTable(this);
						}
					case 9:
						_struct BlockAck
						{
							UINT16 Duration;
							[Pair = Address, DestinationHardwareAddress, DataFieldByteOrder = BigEndian, WiFiDestination, DestinationMacAlias = Global.AliasTable$[this], Destination = DestinationMacAlias ? DestinationMacAlias : FormatString("[%s]", this.ToString)]
							MacAddress RA = MacTable(this);
							[Pair = Address, SourceHardwareAddress, DataFieldByteOrder = BigEndian, WiFiSource, SourceMACAlias = Global.AliasTable$[this], SourceMACAlias = Global.AliasTable$[this], Source = SourceMacAlias ? SourceMacAlias : FormatString("[%s]", this.ToString)]
							MacAddress TA = MacTable(this);
						}
					case 10:
						_struct PSPoll
						{
							WiFiAssocID AID;
							[DataFieldByteOrder = BigEndian, BSSID]
							MacAddress BSSID = MacTable(this);
							[Pair = Address, SourceHardwareAddress, DataFieldByteOrder = BigEndian, WiFiSource, SourceMACAlias = Global.AliasTable$[this], SourceMACAlias = Global.AliasTable$[this], Source = SourceMacAlias ? SourceMacAlias : FormatString("[%s]", this.ToString)]
							MacAddress TA = MacTable(this);
						}
					case 11:
						_struct RTS
						{
							UINT16 Duration;
							[Pair = Address, DestinationHardwareAddress, DataFieldByteOrder = BigEndian, WiFiDestination, DestinationMacAlias = Global.AliasTable$[this], Destination = DestinationMacAlias ? DestinationMacAlias : FormatString("[%s]", this.ToString)]
							MacAddress RA = MacTable(this);
							[Pair = Address, SourceHardwareAddress, DataFieldByteOrder = BigEndian, WiFiSource, SourceMACAlias = Global.AliasTable$[this], SourceMACAlias = Global.AliasTable$[this], Source = SourceMacAlias ? SourceMacAlias : FormatString("[%s]", this.ToString)]
							MacAddress TA = MacTable(this);
						}
					case 12:
						_struct CTS
						{
							UINT16 Duration;
							[Pair = Address, DestinationHardwareAddress, DataFieldByteOrder = BigEndian, WiFiDestination, DestinationMacAlias = Global.AliasTable$[this], Destination = DestinationMacAlias ? DestinationMacAlias : FormatString("[%s]", this.ToString)]
							MacAddress RA = MacTable(this);
						}
					case 13:
						_struct ACK
						{
							UINT16 Duration;
							[Pair = Address, DestinationHardwareAddress, DataFieldByteOrder = BigEndian, WiFiDestination, DestinationMacAlias = Global.AliasTable$[this], Destination = DestinationMacAlias ? DestinationMacAlias : FormatString("[%s]", this.ToString)]
							MacAddress RA = MacTable(this);
						}
					case 14:
						_struct CFEnd
						{
							UINT16 Duration;
							[Pair = Address, DestinationHardwareAddress, DataFieldByteOrder = BigEndian, WiFiDestination, DestinationMacAlias = Global.AliasTable$[this], Destination = DestinationMacAlias ? DestinationMacAlias : FormatString("[%s]", this.ToString)]
							MacAddress RA = MacTable(this);
							[DataFieldByteOrder = BigEndian, BSSID]
							MacAddress BSSID = MacTable(this);
						}
					case 15:
						_struct CFEnd_CFAck
						{
							UINT16 Duration;
							[Pair = Address, DestinationHardwareAddress, DataFieldByteOrder = BigEndian, WiFiDestination, DestinationMacAlias = Global.AliasTable$[this], Destination = DestinationMacAlias ? DestinationMacAlias : FormatString("[%s]", this.ToString)]
							MacAddress RA = MacTable(this);
							[DataFieldByteOrder = BigEndian, BSSID]
							MacAddress BSSID = MacTable(this);
						}
				}
			}
		case 2:
			_struct Data
			{
				UINT16 Duration;
				switch (Property.WiFiDS)
				{
					case 0:			// ToDS=0,FromDS=0
						_struct AdHoc
						{
							[Pair = Address, DestinationHardwareAddress, DataFieldByteOrder = BigEndian, WiFiDestination, DestinationMacAlias = Global.AliasTable$[this], Destination = DestinationMacAlias ? DestinationMacAlias : FormatString("[%s]", this.ToString)]
							MacAddress DA = MacTable(this);
							[Pair = Address, SourceHardwareAddress, DataFieldByteOrder = BigEndian, WiFiSource, SourceMACAlias = Global.AliasTable$[this], SourceMACAlias = Global.AliasTable$[this], Source = SourceMacAlias ? SourceMacAlias : FormatString("[%s]", this.ToString)]
							MacAddress SA = MacTable(this);
							[DataFieldByteOrder = BigEndian, BSSID]
							MacAddress BSSID = MacTable(this);
							WiFiSeqCtrl SequenceControl;
						}
					case 1:			// ToDS=1,FromDS=0
						_struct ClientToAP
						{
							[DataFieldByteOrder = BigEndian, BSSID,WiFiDestination]
							MacAddress BSSID = MacTable(this);
							[Pair = Address, SourceHardwareAddress, DataFieldByteOrder = BigEndian, WiFiSource, SourceMACAlias = Global.AliasTable$[this], SourceMACAlias = Global.AliasTable$[this], Source = SourceMacAlias ? SourceMacAlias : FormatString("[%s]", this.ToString)]
							MacAddress SA = MacTable(this);
							[Pair = Address, DestinationHardwareAddress, DataFieldByteOrder = BigEndian, DestinationMacAlias = Global.AliasTable$[this], Destination = DestinationMacAlias ? DestinationMacAlias : FormatString("[%s]", this.ToString)]
							MacAddress DA = MacTable(this);
							WiFiSeqCtrl SequenceControl;
						}
					case 2:			// ToDS=0,FromDS=1
						_struct APToClient
						{
							[Pair = Address, DestinationHardwareAddress, DataFieldByteOrder = BigEndian, WiFiDestination, DestinationMacAlias = Global.AliasTable$[this], Destination = DestinationMacAlias ? DestinationMacAlias : FormatString("[%s]", this.ToString)]
							MacAddress DA = MacTable(this);
							[DataFieldByteOrder = BigEndian, BSSID,WiFiSource]
							MacAddress BSSID = MacTable(this);
							[Pair = Address, SourceHardwareAddress, DataFieldByteOrder = BigEndian, SourceMACAlias = Global.AliasTable$[this], SourceMACAlias = Global.AliasTable$[this], Source = SourceMacAlias ? SourceMacAlias : FormatString("[%s]", this.ToString)]
							MacAddress SA = MacTable(this);
							WiFiSeqCtrl SequenceControl;
						}
					case 3:			// ToDS=1,FromDS=1
						_struct APToAP
						{
							[DataFieldByteOrder = BigEndian, WiFiDestination]
							MacAddress RA = MacTable(this);
							[DataFieldByteOrder = BigEndian, WiFiSource]
							MacAddress TA = MacTable(this);
							[Pair = Address, DestinationHardwareAddress, DataFieldByteOrder = BigEndian, DestinationMacAlias = Global.AliasTable$[this], Destination = DestinationMacAlias ? DestinationMacAlias : FormatString("[%s]", this.ToString)]
							MacAddress DA = MacTable(this);
							WiFiSeqCtrl SequenceControl;
							[Pair = Address, SourceHardwareAddress, DataFieldByteOrder = BigEndian, SourceMACAlias = Global.AliasTable$[this], SourceMACAlias = Global.AliasTable$[this], Source = SourceMacAlias ? SourceMacAlias : FormatString("[%s]", this.ToString)]
							MacAddress SA = MacTable(this);
						}
				}
				// QoS
				switch
				{
					case Property.WiFiSubType & 0x8:
						struct QoSControl
						{
							switch 
							{
								// WMM_Specification_1-1. QoS field present without setting WiFiCapability.QoS bit.
								case !Property.WiFiSupportQos:
									UINT16 QosControlWMM = WiFiPriorityTable(Priority)
									{
										UINT16 Priority:3 = FormatString("  (%s) %s", this.ToBitString, WiFiPriorityTable(this));
										UINT16 Reserved2:1 = FormatString(" (%s)", this.ToBitString);
										UINT16 EOSP:1 = FormatString("      (%s) %s", this.ToBitString, this ? "End of USP" : "NA");
										UINT16 AckPolicy:2 = FormatString(" (%s) %s", this.ToBitString, WiFiAckPolicyTable(this));
										UINT16 Reserved1:9 = FormatString(" (%s)", this.ToBitString);
									};
								default:
									switch (WiFiDS)
									{
										case 1:
											switch 
											{
												case UINT16(FrameData, FrameOffset) & 0x8:
													UINT16 QosControlWithQueueSize
													{
														UINT16 TID:4 = FormatString("      (%s) %u", this.ToBitString, this);
														UINT16 BIT4:1 = FormatString("     (%s) %s", this.ToBitString, this ? "QueueSize" : "TXOPDurationRequested");
														UINT16 AckPolicy:2 = FormatString("(%s) %s", this.ToBitString, WiFiAckPolicyTable(this));
														UINT16 Reserved:1 = FormatString(" (%s)", this.ToBitString);
														UINT16 QueueSize:8 = FormatString("(%s) %u octet(s)", this.ToBitString, this * 256);
													};
												default:
													UINT16 QosControlWithTXOPDurationRequested
													{
														UINT16 TID:4 = FormatString("                  (%s) %u", this.ToBitString, this);
														UINT16 BIT4:1 = FormatString("                 (%s) %s", this.ToBitString, this ? "QueueSize" : "TXOPDurationRequested");
														UINT16 AckPolicy:2 = FormatString("            (%s) %s", this.ToBitString, WiFiAckPolicyTable(this));
														UINT16 Reserved:1 = FormatString("             (%s)", this.ToBitString);
														UINT16 TXOPDurationRequested:8 = FormatString("(%s) %s", this.ToBitString, this ? FormatString("%u microsecond(s)", this * 32) : "No TXOP is requested for the MSDUs for the specified TID in the current SP");
													};
											}
										case 2:
											switch (Property.WiFiSubType)
											{
												case 0xA:
												case 0xB:
												case 0xE:
												case 0xF:
													UINT16 QosControlWithTXOPLimit
													{
														UINT16 TID:4 = FormatString("      (%s) %u", this.ToBitString, this);
														UINT16 EOSP:1 = FormatString("     (%s) %s", this.ToBitString, this ? "End of Service Period" : "Not End of Service Period");
														UINT16 AckPolicy:2 = FormatString("(%s) %s", this.ToBitString, WiFiAckPolicyTable(this));
														UINT16 Reserved:1 = FormatString(" (%s)", this.ToBitString);
														UINT16 TXOPLimit:8 = FormatString("(%s) %s", this.ToBitString, this ? FormatString("%u microsecond(s)", this * 32) : "One MPDU or one QoS Null frame is to be transmitted immediately following the QoS (+)CF-Poll frame");
														
													};
												case 0x8: 
												case 0x9: 
												case 0xC: 
													UINT16 QosControlWithQAPPSBufferState
													{
														UINT16 TID:4 = FormatString("                      (%s) %u", this.ToBitString, this);
														UINT16 EOSP:1 = FormatString("                     (%s) %s", this.ToBitString, this ? "End of Service Period" : "Not End of Service Period");
														UINT16 AckPolicy:2 = FormatString("                (%s) %s", WiFiAckPolicyTable(this));
														UINT16 Reserved1:1 = FormatString("                (%s)", this.ToBitString);
														UINT16 Reserved2:1 = FormatString("                (%s)", this.ToBitString);
														UINT16 BufferedStateIndicated:1 = FormatString("   (%s) %s", this.ToBitString, this ? "QAP PS buffer state is specified" : "QAP PS buffer state is NOT specified");
														UINT16 HighestPriorityBufferedAC:2 = BufferedStateIndicated ? 
																							 FormatString("(%s) %u", this.ToBitString, this) : 
																							 FormatString("(%s) Reserved", this.ToBitString);
														UINT16 QAPBufferedLoad:4 = BufferedStateIndicated ? 
																				   FormatString("          (%s) %s", this.ToBitString, this ? FormatString("%u octet(s)", this * 4096) : "Buffered traffic for the indicated highest priority buffered AC is absent") : 
																				   FormatString("          (%s) Reserved", this.ToBitString);
													};
											}
									}
							}
						}
				}
			}
	}
	Switch
	{
		case (Property.WiFiType == 0 || (Property.WiFiType == 2 && (Property.WiFiSubType & 0x8))) && Property.WiFiOrder == 1:
		case Property.WiFiType == 1 && Property.WiFiSubType == 0x7:
			//802.11N: 7.1.3.5a HT Control field
			_struct HTControl
			{
				switch
				{
					case UINT16(Framedata, Offset) & 0x38 == 0x38:
						struct LinkAdaptationControl0
						{
							UINT16 Reserved:1 = FormatString("   (%s)", this.ToBitString);
							UINT16 TRQ:1 = FormatString("        (%s) %s", this.ToBitString, this? "Request the responder to transmit a sounding PPDU" : "The responder is not requested to transmit a sounding PPDU");
							UINT16 MAI:4 = FormatString("        (%s) %s", this.ToBitString, "ASELI" );
							UINT16 MFSI:3 = FormatString("       (%s) %s", this.ToBitString, this == 7 ? "Unsolicited MFB" : "The received value of MSI contained in the frame to which the MFB information refers");
							[Property.WiFiASELCommand]
							UINT16 ASELCommand:3 = FormatString("(%s) %s",  this.ToBitString, WiFiASELCommandTable(this));
							UINT16 ASELData:4 = FormatString("   (%s) %s", this.ToBitString, WiFiASELDataTable(Property.WiFiASELCommand));
						}
					default:
						struct LinkAdaptationControl1
						{
							UINT16 Reserved:1 = FormatString("  (%s)", this.ToBitString);
							UINT16 TRQ:1 = FormatString("       (%s) %s", this.ToBitString, this? "Request the responder to transmit a sounding PPDU" : "The responder is not requested to transmit a sounding PPDU");
							[Property.WiFiMRQ]
							UINT16 MRQ:1 = FormatString("       (%s) %s", this.ToBitString, this? "MFB is requested" : "No MFB is requested");
							UINT16 MSI:3 = FormatString("       (%s) %s", this.ToBitString, Property.WiFiMRQ ? "The sequence number in the range 0 to 6 that identifies the specific request" : "Reserved" );
							UINT16 MFSI:3 = FormatString("      (%s) %s", this.ToBitString, this == 7 ? "Unsolicited MFB" : "The received value of MSI contained in the frame to which the MFB information refers");
							UINT16 MFB:7 = FormatString("       (%s) %s", this.ToBitString, this == 127 ? "No feedback is present" : "MCS feedback");
						}
				}
				_struct
				{
					UINT16 CalibrationPosition:2 = FormatString("(%s)", this.ToBitString, WiFiCalibrationPositionTable(this));
					UINT16 CalibrationSequence:2 = FormatString("(%s) %s", this.ToBitString, "Calibration sequence identifier");
					UINT16 Reserved1:2 = FormatString("          (%s)", this.ToBitString);
					UINT16 CSIOrSteering:2 = FormatString("      (%s) %s", this.ToBitString, WiFiCSIOrSteeringTable(this));
					UINT16 NDPAnnouncement:1 = FormatString("    (%s) %s", this.ToBitString, this ? "NDP will follow" : "NDP will NOT follow");
					UINT16 Reserved2:5 = FormatString("          (%s)", this.ToBitString);
					UINT16 ACConstraint:1 = FormatString("       (%s)", this.ToBitString, this ? "The response to an RDG may contain data frames only from the same AC as the last data frame received from the RD initiator" : "The response to a reverse direction grant (RDG) may contain data frames from any TID");
					UINT16 RDGMorePPDU:1 = FormatString("        (%s)", this.ToBitString, this ? "RD initiator: An RDG is present, as defined by the Duration/ID field; RD responder:The PPDU carrying the frame is followed by another PPDU" : "RD initiator: No reverse grant; RD responder: The PPDU carrying the frame is the last transmission by the RD responder");
				}
			}
	}
	// End of MAC Header
	
	// Frame Body Start here
	[
		BuildConversation(Property.WiFiMonitorMode ? (WiFiSource < WiFiDestination ?
												MakeByteArray(WiFiSource, WiFiDestination): 
												MakeByteArray(WiFiDestination, WiFiSource)
											): -1), /* only build for monitor mode */
					
			  Conversation.ConversationDescription = FormatString("(%s - %s) ConvID = %d", WiFiSource,WiFiDestination,ConvID),
		WiFiDirection = (WiFiSource > WiFiDestination) ? 1 : (WiFiSource == WiFiDestination) ? 0 : 2,
		DataFieldFrameLength = FCSPresent ? FrameLength - 4 : FrameLength,
		PayloadStart(
					WiFiDirection, /* direction */
					WiFiSequenceNumber, /* id */
					WiFiFragmentNumber, /* sequence token */
					WiFiFragmentNumber + 1, /* next sequence token */
					0, /* total payload length */
					WiFiFragmentNumber == 0, /* is first */
					Property.WiFiMoreFrag == 0, /* is last */
					RssmblyIndStartBit+RssmblyIndEndBit+RssmblySequenceBit, 
					0x0000, /* Properties... */
					Property.WiFiSupportQos,
					0x0000,
					Property.WiFiDS,
					0x0000,
					Property.WiFiType,
					0x0000,
					Property.WiFiSubType,
					0x0000,
					Property.WiFiEncrypted
			)
	]
	_struct Payload
	{
		switch
		{
			case WiFiFragmentNumber > 0:
				BLOB(FrameLength - FrameOffset) Continuation;
			default:
				// Payload
				switch (Property.WiFiType)
				{
					case 0:
						switch (Property.WiFiSubType)
						{
							case 0: WiFiAssReq AssociationRequest;
							case 1: WiFiAssRes AssociationResponse;
							case 2: WiFiReAssReq ReassociationRequest;
							case 3: WiFiAssRes ReassociationResponse;
							case 4: WiFiPrbReq ProbeRequest;
							case 5: WiFiBeacon ProbeResponse;
							case 8: WiFiBeacon Beacon;
							case 10:WiFiDisAssoc WiFiDisAssoc;
							case 11:WiFiAuth Authentication;
							case 12:WiFiDisAssoc Deauthentication;
							case 13:WiFiAction Action;
							case 14:WiFiAction ActionNoAck;
						}
					case 1:
						switch (Property.WiFiSubType)
						{
							case 7:
								WiFiControlWrapper ControlWrapper;
							case 8:
								WiFiBlockAckReq BlockAckReq;
							case 9:
								WiFiBlockAck BlockAck;
						}
					case 2:
						switch
						{
							// Only Data Pkts with subtype <= 3 have a Payload
							case (Property.WiFiSubType & 0x07) <= 3 :
								switch 
								{
									case !Property.WiFiEncrypted:
										[DataFieldByteOrder = BigEndian]
										LLC LLC;
									case (UINT8( Framedata, Offset + 3 ) & 0x3F) == 0x0:
										WiFiWEPPayload WPayload = "WEP MPDU";
									// WEPSeed is set to (TSC1 | 0x20) & 0x7f
									case UINT8( Framedata, Offset + 1 ) == ((UINT8( Framedata, Offset ) | 0x20) & 0x7f):
										WiFiTKIP TPayload = "TKIP MPDU";
									default:
										WiFiCCMP CPayload = "CCMP MPDU";
								}
						}
				}
		}
	}
	
	switch
	{
		case FCSPresent || FrameLength - FrameOffset == 4:
			[DataFieldByteOrder = BigEndian]
			UINT32 FCS = FormatString("0x%X", this);
	}
}
UnsignedNumber OUI
{
	Size = 3;
	DisplayFormat = FormatString( "%02X-%02X-%02X(%s)", this[2], this[1], this[0], OUITable(this) );
	ByteOrder = BigEndian;
}

UnsignedNumber WTimeStamp
{
	Size = 8;
	DisplayFormat = FormatString( "%I64u microsecond(s)", this );
}

Table WiFiSTACFPollTable(CFValue, WiFiSupportQosValue)
{
	switch
	{
		case WiFiSupportQosValue == 0 && CFValue == 0: "STA is not CF pollable";
		case WiFiSupportQosValue == 0 && CFValue == 1: "STA is CF-Pollable, not requesting to be placed on the CF-Polling list";
		case WiFiSupportQosValue == 0 && CFValue == 2: "STA is CF-Pollable, requesting to be placed on the CF-Polling list";
		case WiFiSupportQosValue == 0 && CFValue == 3: "STA is CF-Pollable, requesting never to be polled";
		case WiFiSupportQosValue == 0x0200 && CFValue == 0: "QoS STA requesting association in a QoS BSS";
		case WiFiSupportQosValue == 0x0200 && CFValue == 1:
		case WiFiSupportQosValue == 0x0200 && CFValue == 2:
		case WiFiSupportQosValue == 0x0200 && CFValue == 3: "Reserved";
		default: FormatString("Undefined Value (%d, %d)", CFValue, WiFiSupportQosValue);
	}
}

Table WiFiPrintRate(value)
{
	switch (value)
	{
		default: FormatString("%u.%u", value / 2, value % 2 > 0 ? 5 : 0);
	}
}
  

Table WiFiAPCFPollTable(CFValue, WiFiSupportQosValue)
{
	switch
	{
		case WiFiSupportQosValue == 0 && CFValue == 0: "No PC at non-QoS AP";
		case WiFiSupportQosValue == 0 && CFValue == 1: "PC at non-QoS AP for delivery only (no polling)";
		case WiFiSupportQosValue == 0 && CFValue == 2: "PC at non-QoS AP for delivery and polling";
		case WiFiSupportQosValue == 0 && CFValue == 3: "Reserved";
		case WiFiSupportQosValue == 1 && CFValue == 0: "QoS AP (HC) does not use CFP for delivery of unicast data frames";
		case WiFiSupportQosValue == 1 && CFValue == 1: "QoS AP (HC) uses CFP for delivery, but does not send CF-Polls to non-QoS STAs";
		case WiFiSupportQosValue == 1 && CFValue == 2: "QoS AP (HC) uses CFP for delivery, and sends CF-Polls to non-QoS STAs";
		case WiFiSupportQosValue == 1 && CFValue == 3: "Reserved";
		default: FormatString("Undefined Value (%d, %d)", CFValue, WiFiSupportQosValue);
	}
}

Table WifiOpMode(value)
{
	switch (value)
	{
		case 0x00000001: "Station Mode";
		case 0x00000002: "AP Mode";
		case 0x00000004: "Extensible Station Mode";
		case 0x80000000: "Monitor Mode";
		default: FormatString("Unknown operation mode(%u)", value);
	}
}

Table WiFiDSTable(DSvalue,type)
{
	switch (DSvalue)
	{
		case 0: "Ad hoc network";			  // ToDS=0,FromDS=0
		case 1: "STA to DS via AP";           // ToDS=1,FromDS=0
		case 2: "DS to STA via AP";           // ToDS=0,FromDS=1
		case 3: "AP to AP";                   // ToDS=1,FromDS=1
		default: FormatString("Undefined Value (DSvalue = %u, type = %u)", DSvalue, type);
	}
}

Table WiFiDSDescriptionTable(DS)
{
	switch (DS)
	{
		case 0: "..";
		case 1: ".T";
		case 2: "F.";
		case 3: "FT";
	}
}

Table WiFiPhyType (value)
{
	switch (value)
	{
		case 4: "802.11a";
		case 5: "802.11b";
		case 6: "802.11g";
		case 7: "802.11n";
		default: FormatString("Undefined Value (%d)", value);
	}
}

Table WiFiTypeTable(value)
{
	switch(value)
	{
		case 0: "Management";
		case 1: "Control";
		case 2: "Data";
		case 3: "Reserved";
		default: FormatString("Undefined Value (%d)", value);
	}
}

Table WiFiMgmtSubTypeTable(value)
{
	switch (value)
	{
		case 0x0: "Association request";
		case 0x1: "Association response";
		case 0x2: "Reassociation request";
		case 0x3: "Reassociation response";
		case 0x4: "Probe request";
		case 0x5: "Probe response";
		case 0x8: "Beacon";
		case 0x9: "ATIM";
		case 0xA: "Disassociation";
		case 0xB: "Authentication";
		case 0xC: "Deauthentication";
		case 0xD: "Action";
		case 0xE: "Action No Ack";
		default: "Reserved";
	};
}

Table WiFiCtrlSubTypeTable(value)
{
	switch (value)
	{
		case 0x7: "Control Wrapper";
		case 0x8: "BlockAckReq";
		case 0x9: "BlockAck";
		case 0xA: "PS-Poll";
		case 0xB: "RTS";
		case 0xC: "CTS";
		case 0xD: "ACK";
		case 0xE: "CF-End";
		case 0xF: "CF-End + CF-Ack";
		default: "Reserved";
	};
}

Table WiFiDataSubTypeTable(value)
{
	switch (value)
	{
		case 0x0: "Data";
		case 0x1: "Data + CF-Ack";
		case 0x2: "Data + CF-Poll";
		case 0x3: "Data + CF-Ack + CF-Poll";
		case 0x4: "Null (no data)";
		case 0x5: "CF-Ack (no data)";
		case 0x6: "CF-Poll (no data)";
		case 0x7: "CF-Ack + CF-Poll (no data)";
		case 0x8: "QoS Data";
		case 0x9: "QoS Data + CF-Ack";
		case 0xA: "QoS Data + CF-Poll";
		case 0xB: "QoS Data + CF-Ack + CF-Poll";
		case 0xC: "QoS Null (no data)";
		case 0xE: "QoS CF-Poll (no data)";
		case 0xF: "QoS CF-Ack + CF-Poll (no data)";
		default: "Reserved";
	};
}

Table WiFiSubTypeTable(value,type)
{
	switch(type)
	{
		case 0: WifiMgmtSubTypeTable(value);
		case 1: WiFiCtrlSubTypeTable(value);
		case 2: WiFiDataSubTypeTable(value);
		default: FormatString("Reserved (%d)", type);
	}
}

Table WiFiAuthenticationAlgoTable(value)
{
	switch (value)
	{
		case 0: "Open System (0)";
		case 1: "Shared Key (1)";
		//802.11r
		case 2: "Fast BSS Transition (2)";
		default: FormatString("Reserved (%d)", value);
	}
}

Table WiFiStatusTable(value)
{
	switch (value)
	{
		// 802.11
		case 0: "Successful";
		case 1: "Unspecified failure";
		case 10: "Cannot support all requested capabilities in the Capability Information field";
		case 11: "Reassociation denied due to inability to confirm that association exists";
		case 12: "Association denied due to reason outside the scope of this standard";
		case 13: "Responding station does not support the specified authentication algorithm";
		case 14: "Received an Authentication frame with authentication transaction sequence number out of expected sequence";
		case 15: "Authentication rejected because of challenge failure";
		case 16: "Authentication rejected due to timeout waiting for next frame in sequence";
		case 17: "Association denied because AP is unable to handle additional associated stations";
		case 18: "Association denied due to requesting station not supporting all of the data rates in the BSSBasicRateSet parameter";
		case 19: "Association denied due to requesting station not supporting the short preamble option";
		case 20: "Association denied due to requesting station not supporting the PBCC modulation option";
		case 21: "Association denied due to requesting station not supporting the channel agility option";
		case 22: "Association request rejected because Spectrum Management capability is required";
		case 23: "Association request rejected because the information in the Power Capability element is unacceptable";
		case 24: "Association request rejected because the information in the Supported Channels element is unacceptable";
		case 25: "Association denied due to requesting station not supporting the Short Slot Time option";
		case 26: "Association denied due to requesting station not supporting the DSSS-OFDM option";
		case 32: "Unspecified, QoS-related failure";
		case 33: "Association denied because QAP has insufficient bandwidth to handle another QSTA";
		case 34: "Association denied due to excessive frame loss rates and/or poor conditions on current operating channel";
		case 35: "Association (with QBSS) denied because the requesting STA does not support the QoS facility";
		case 37: "The request has been declined";
		case 38: "The request has not been successful as one or more parameters have invalid values";
		case 39: "The TS has not been created because the request cannot be honored; however, a suggested TSPEC is provided so that the initiating QSTA may attempt to set another TS with the suggested changes to the TSPEC";
		case 40: "Invalid information element";
		case 41: "Invalid group cipher";
		case 42: "Invalid pairwise cipher";
		case 43: "Invalid AKMP";
		case 44: "Unsupported RSN information element version";
		case 45: "Invalid RSN information element capabilities";
		case 46: "Cipher suite rejected per security policy";
		case 47: "The TS has not been created; however, the HC may be capable of creating a TS, in response to a request, after the time indicated in the TS Delay element";
		case 48: "Direct link is not allowed in the BSS by policy";
		case 49: "The Destination STA is not present within this QBSS";
		case 50: "The Destination STA is not a QSTA";
		case 51: "Association denied because Listen Interval is too large";
		
		//802.11r
		case 28: "R0KH unreachable";
		case 52: "Invalid FT Action frame count";
		case 53: "Invalid pairwise master key identifier (PMKID)";
		case 54: "Invalid MDIE";
		case 55: "Invalid FTIE";
		
		//802.11n
		case 27: "Association denied because the requesting STA does not support HT features";
		case 29: "Association denied because the requesting STA does not support the phased coexistence operation (PCO) transition time required by the AP";
		
		//802.11w
		case 30: "Association request rejected temporarily; try again later";
		case 31: "Robust Management frame policy violation";
		default: FormatString("Reserved Value(%d)", value);
	}
}

Table WiFiReasonTable(value)
{
	switch (value)
	{
		//802.11
		case 0: "Reserved";
		case 1: "Unspecified reason";
		case 2: "Previous authentication no longer valid";
		case 3: "Deauthenticated because sending station is leaving (or has left) IBSS or ESS";
		case 4: "Disassociated due to inactivity";
		case 5: "Disassociated because AP is unable to handle all currently associated stations";
		case 6: "Class 2 frame received from nonauthenticated station";
		case 7: "Class 3 frame received from nonassociated station";
		case 8: "Disassociated because sending station is leaving (or has left) BSS";
		case 9: "Station requesting (re)association is not authenticated with responding station";
		case 10: "Disassociated because the information in the Power Capability element is unacceptable";
		case 11: "Disassociated because the information in the Supported Channels element is unacceptable";
		case 13: "Invalid information element";
		case 14: "Message integrity code (MIC) failure";
		case 15: "4-Way Handshake timeout";
		case 16: "Group Key Handshake timeout";
		case 17: "Information element in 4-Way Handshake different from (Re)Association Request/Probe Response/Beacon frame";
		case 18: "Invalid group cipher";
		case 19: "Invalid pairwise cipher";
		case 20: "Invalid AKMP";
		case 21: "Unsupported RSN information element version";
		case 22: "Invalid RSN information element capabilities";
		case 23: "IEEE  802.1X authentication failed";
		case 24: "Cipher suite rejected per security policy";
		case 32: "Disassociated for unspecified, QoS-related reason";
		case 33: "Disassociated because QAP lacks sufficient bandwidth for this QSTA";
		case 34: "Disassociated because excessive number of frames need to be acknowledged, but are not acknowledged due to AP transmissions and/or poor channel conditions";
		case 35: "Disassociated because QSTA is transmitting outside the limits of its TXOPs";
		case 36: "Requested from peer QSTA as the QSTA is leaving the QBSS (or resetting)";
		case 37: "Requested from peer QSTA as it does not want to use the mechanism";
		case 38: "Requested from peer QSTA as the QSTA received frames using the mechanism for which a setup is required";
		case 39: "Requested from peer QSTA due to timeout";
		case 45: "Peer QSTA does not support the requested cipher suite";
		
		//802.11n
		case 31: "TS deleted because QoS AP lacks sufficient bandwidth for this QoS STA due to a change in BSS service characteristics or operational mode (e.g., an HT BSS change from 40 MHz channel to 20 MHz channel)";
		
		//Not appear in 802.11 /802.11r /802.11e /802.11y /802.11k /802.11n
		case 40: "Requested from peer QSTA as the QSTA is leaving the QBSS (or resetting)";
		case 41: "Requested from peer QSTA as it does not want to receive frames directly from the QSTA";
		case 42: "Requested from peer QSTA as the QSTA received DLP frames for which it has not set up";
		case 43: "Requested from peer QSTA as it does not want to use Block Ack";
		case 44: "Requested from peer QSTA as the QSTA received frames indicated Block Acknowledgement policy for which it has not set up";
		
		default: "Reserved";
	}
}

Table WiFiDefaultCipherTable(type)
{
	switch (type)
	{
		case 0: "Use group cipher suite";
		case 1: "WEP-40";
		case 2: "TKIP";
		case 4: "CCMP (default)";
		case 5: "WEP-104";
		case 6: "BIP (default)";
		default: "Reserved";
	}
}	

Table WiFiCipherSuiteTable(ouivalue,type)
{
	switch (ouivalue)
	{
		case 0x000FAC:  WiFiDefaultCipherTable (type);
		case 0x0050F2:  WiFiDefaultCipherTable (type);
		default: "Vendor Specific Cipher";
	}
}

Table WiFiDefaultAKMTable(type)
{
	switch (type)
	{
		case 1: "Auth = 802.1x or PMKSA caching (default) / Key Mgmt = RSNA or PMKSA caching";
		case 2: "Auth = PSK / Key Mgmt = RSNA using PSK";
		//From 802.11r: Table 7-34
		case 3: "FT authentication negotiated over IEEE 802.1X / FT key management";
		case 4: "FT authentication using PSK / FT key management";
		default: "Reserved";
	}
}	

Table WiFiWPADefaultAKMTable(type)
{
	switch (type)
	{
		case 1: "(Authentication negotiated over IEEE 802.1X) with (RSNA key management or using PMKSA caching)";
		case 2: "PSK is used with RSNA key management";
		default: "Reserved";
	}
}

Table WiFiAKMSuiteTable(ouivalue,type)
{
	switch (ouivalue)
	{
		case 0x0FAC: WiFiDefaultAKMTable (type);
		case 0x050F2: WiFiWPADefaultAKMTable (type);
		default: "Vendor Specific AKM Suite";
	}
}

Table WiFiACItoACTable(value)
{
	switch (value)
	{
		case 0: "Best Effort (AC_BE)";
		case 1: "Background (AC_BK)";
		case 2: "Video (AC_VI)";
		case 3: "Voice (AC_VO)";
		default: FormatString("Undefined Value (%d)", value);
	}
}

Table WiFiPriorityTable(value)
{
	switch 
	{
		case (value == 0 || value == 3): "Best Effort (AC_BE)";
		case (value == 1 || value == 2): "Background (AC_BK)";
		case (value == 4 || value == 5): "Video (AC_VI)";
		case (value == 6 || value == 7): "Voice (AC_VO)";
		default: FormatString("Undefined Value (%d)", value);
	}
}

Table WiFiReplayCntTable(value)
{
	switch (value)
	{
		case 0x0:"1 replay counter per PTKSA/GTKSA/STAKeySA";
		case 0x1:"2 replay counters per PTKSA/GTKSA/STAKeySA";
		case 0x2:"4 replay counters per PTKSA/GTKSA/STAKeySA";
		case 0x3:"16 replay counters per PTKSA/GTKSA/STAKeySA";
		default: FormatString("Undefined Value (%d)", value);
	}
}

Table WiFiInformationFieldsTypeTable(value)
{
	switch (value)
	{
		//802.11
		case 0: "SSID";
		case 1: "Supported Rates";
		case 2: "FHParams";
		case 3: "Channel";
		case 4: "CFParams";
		case 5: "ATIM";
		case 6: "IBSSParams";
		case 7: "Country";
		case 8: "Hopping Pattern Parameters";
		case 9: "Hopping Pattern Table";
		case 10: "Request";
		case 11: "QBSS Load";
		case 12: "EDCA Parameter Set";
		case 13: "TSPEC";
		case 14: "TCLAS";
		case 15: "Schedule";
		case 16: "Challenge Text";
		case 32: "Power Constraint";
		case 33: "Power Capability";
		case 34: "TPC Request";
		case 35: "TPC Report";
		case 36: "Supported Channels";
		case 37: "Channel Switch Announcement";
		case 38: "Measurement Request";
		case 39: "Measurement Report";
		case 40: "Quiet";
		case 41: "IBSS DFS";
		case 42: "ERP";
		case 43: "TS Delay";
		case 44: "TCLAS Processing";
		case 46: "QoS Capability";
		case 48: "RSN";
		case 50: "Extended supported rates";
		case 127: "Extended Capability";
		case 221: "Vendor Specific Information";

		//802.11k
		case 51: "AP Channel Report";
		case 52: "Neighbor Report";
		case 53: "RCPI";
		case 63: "BSS Average Access Delay";
		case 64: "Antenna Information";
		case 65: "RSNI";
		case 66: "Measurement Pilot Transmission Information";
		case 67: "BSS Available Admission Capacity";
		case 68: "BSS AC Access Delay";
		case 70: "RRM Enabled Capabilities";
		case 71: "Multiple BSSID";
		
		//802.11n
		case 45: "HT Capabilities";
		case 61: "HT Operation";
		case 62: "Secondary Channel Offset";
		case 72: "20/40 BSS Coexistence";
		case 73: "20/40 BSS Intolerant Channel Report";
		case 74: "Overlapping BSS Scan Parameters";
		
		//802.11r
		case 54: "Mobility Domain (MDIE)";
		case 55: "Fast BSS Transition (FTIE)";
		case 56: "Timeout Interval";
		case 57: "RIC Data (RDIE)";
		case 75: "RIC Descriptor";
		
		//802.11y
		case 58: "DSE Registered Location";
		case 59: "Supported Regulatory Classes";
		case 60: "Extended Channel Switch Announcement";
		
		//802.11w
		case 76: "Management MIC information element";
		
		case 47: "Broadcom Proprietary"; //Not Implemented
		case 49: "802.15 Coexistence"; //Not Implemented
		case 128: "Agere proprietary"; //Not Implemented
		case 129: "Agere proprietary"; //Not Implemented
		case 133: "Cisco proprietary"; //Not Implemented
		case 134: "Cisco proprietary"; //Not Implemented
		case 135: "Cisco proprietary"; //Not Implemented
		case 136: "Cisco proprietary"; //Not Implemented
		case 149: "Cisco proprietary"; //Not Implemented
		case 150: "Cisco proprietary"; //Not Implemented
		case 155: "Cisco proprietary"; //Not Implemented
		case 156: "Cisco proprietary"; //Not Implemented
		case 173: "Symbol proprietary"; //Not Implemented
		case 176: "Symbol proprietary"; //Not Implemented
		case 178: "Symbol proprietary"; //Not Implemented
		case 179: "Symbol proprietary"; //Not Implemented
		case 219: "Philips proprietary"; //Not Implemented
		case 255: "Escape"; //Not Implemented
		default: FormatString("Reserved (%d)", value);
	}
}

Table WiFiAckPolicyTable(value)
{
	switch (value)
	{
		case 0:"Normal Ack or Implicit Block Ack Request";
		case 1:"No Ack";
		case 2:"No Explicit Acknowledgment or PSMP Ack";
		case 3:"Block Ack";
		default: FormatString("Undefined Value (%d)", value);
	}
}

Table WiFiASELCommandTable(value)
{
	switch (value)
	{
		case 0: "Transmit Antenna Selection Sounding Indication (TXASSI)";
		case 1: "Transmit Antenna Selection Sounding Request (TXASSR) or Transmit ASEL Sounding Resumption";
		case 2: "Receive Antenna Selection Sounding Indication (RXASSI)";
		case 3: "Receive Antenna Selection Sounding Request (RXASSR)";
		case 4: "Sounding Label";
		case 5: "No Feedback Due to ASEL Training Failure or Stale Feedback";
		case 6: "Transmit Antenna Selection Sounding Indication requesting feedback of explicit CSI (TXASSI-CSI)";
		default: FormatString("Undefined Value (%d)", value);
	}
}

Table WiFiCalibrationPositionTable(value)
{
	switch (value)
	{
		case 0: "This is not a calibration frame";
		case 1: "Calibration start";
		case 2: "Sounding response";
		case 3: "Sounding complete";
		default: FormatString("Undefined Value (%d)", value);
	}
}

Table WiFiCSIOrSteeringTable(value)
{
	switch (value)
	{
		case 0: "No feedback required";
		case 1: "CSI";
		case 2: "Noncompressed beamforming";
		case 3: "Compressed beamforming";
		default: FormatString("Undefined Value (%d)", value);
	}
}

Table WiFiASELDataTable(value)
{
	switch (value)
	{
		case 0: "Number of remaining sounding PPDUs to be transmitted";
		case 1: "Number of the first sounding PPDU to be transmitted when the command is Transmit ASEL Sounding Resumption";
		case 2: "Number of remaining sounding PPDUs to be received";
		case 3: "Number of sounding PPDUs required";
		case 4: "Sequence number of the sounding PPDU corresponding to a channel state information (CSI) frame in ASEL feedback";
		case 5: "Number of the first sounding PPDU that was not received properly";
		case 6: "Number of remaining sounding PPDUs to be transmitted";
		default: FormatString("Undefined Value (%d)", value);
	}
}

struct WiFiFrameCtrl = FormatString ("Version %d,%s, %s, %s(0x%X)", Version, WifiTypeTable(Type), WiFiSubTypeTable(SubType, Type), Property.FrameControlDescription, UINT16(FrameData, FrameOffset))
{
	UINT16 Version:2 = FormatString("       (%s) %d", this.ToBitString, this);
	[Property.WiFiType]
	UINT16 Type:2 = FormatString("          (%s) %s", this.ToBitString, WifiTypeTable(this));
	[Property.WiFiSubType]
	UINT16 SubType:4 = FormatString("       (%s) %s", this.ToBitString, WiFiSubTypeTable(this, Type));
	[Property.WiFiDS]
	UINT16 DS:2 = FormatString("            (%s) %s", this.ToBitString, WiFiDSTable(this,Type));
	[Property.WiFiMoreFrag]
	UINT16 MoreFrag:1 = FormatString("      (%s) %s", this.ToBitString, this? "Yes" : "No");
	UINT16 Retry:1 = FormatString("         (%s) %s", this.ToBitString, this? "Yes" : "No");
	UINT16 PowerMgt:1 = FormatString("      (%s) %s", this.ToBitString, this? "Power Save Mode" : "Active Mode");
	[Property.WiFiMoreData]
	UINT16 MoreData:1 = FormatString("      (%s) %s", this.ToBitString, this? "Yes" : "No");
	[Property.WiFiEncrypted = Property.WiFiMonitorMode & this]
	UINT16 ProtectedFrame:1 = FormatString("(%s) %s", this.ToBitString, this? "Yes" : "No");
	[Property.FrameControlDescription = FormatString("%s%s%s%s%s%s",
											WiFiDSDescriptionTable(DS),
											MoreFrag ? "M" : ".",
											Retry ? "R" : ".",
											PowerMgt ? "P" : ".",
											MoreData ? "D" : ".",
											ProtectedFrame ? "P" : ".",
											Order ? "O" : ".")]
	[Property.WiFiOrder]
	UINT16 Order:1 = FormatString("         (%s) %s", this.ToBitString, this? "Ordered" : "Unordered");
}

//From 802.11: 7.3.1.4 Capability Information field
[ Property.WiFiCapability ]
struct WiFiCapability = FormatString("0x%02X%02X", UINT8(FrameData, FrameOffset), UINT8(FrameData, FrameOffset + 1))
{
	UINT16 ESS:1 = FormatString("               (%s) %s", this.ToBitString, this ? "Extended service set used" : "Extended service set Not used");
	UINT16 IBSS:1 = FormatString("              (%s) %s", this.ToBitString, this ? "Independent basic service set used" : "Independent basic service set Not used");
	UINT16 CF:2 = FormatString("                (%s) %s", 
											this.ToBitString, 
											(Property.WiFiSubType == 0 || Property.WiFiSubType == 2) ? 
													 WiFiSTACFPollTable(this, Property.WiFiCapability & 0x0200) :
													 ((Property.WiFiSubType == 0 || Property.WiFiSubType == 2 || Property.WiFiSubType == 5 || Property.WiFiSubType == 8) ?
													 WiFiAPCFPollTable(this, Property.WiFiCapability & 0x0200) : "Invalid")
										  );
	UINT16 Privacy:1 = FormatString("           (%s) %s", this.ToBitString, this ? "Required" : "Not required");
	UINT16 ShortPreamble:1 = FormatString("     (%s) %s", this.ToBitString, this ? "Allowed" : "Not Allowed");
	UINT16 PBCCModulation:1 = FormatString("    (%s) %s", this.ToBitString, this ? "Allowed" : "Not Allowed");
	UINT16 ChannelAgility:1 = FormatString("    (%s) %s", this.ToBitString, this ? "In Use" : "No");
	UINT16 SpectrumManagement:1 = FormatString("(%s) %s", this.ToBitString, this ? "Required" : "Not Required");
	[Property.WiFiSupportQos]
	UINT16 QoS:1 = FormatString("               (%s) %s", this.ToBitString, this ? "Implemented" : "Not Implemented");
	UINT16 ShortSlotTime:1 = FormatString("     (%s) %s", this.ToBitString, this ? "Enabled" : "Disabled");
	UINT16 APSD:1 = FormatString("              (%s) %s", this.ToBitString, this ? "Implemented" : "Not Implemented");
	UINT16 RadioMeasurement:1 = FormatString("  (%s) %s", this.ToBitString, this ? "Enabled" : "Disabled");
	UINT16 DSSSOFDM:1 = FormatString("          (%s) %s", this.ToBitString, this ? "Allowed" : "Not Allowed");
	UINT16 DelayedBlockAck:1 = FormatString("   (%s) %s", this.ToBitString, this ? "Implemented" : "Not Implemented");
	UINT16 ImmediateBlockAck:1 = FormatString(" (%s) %s", this.ToBitString, this ? "Implemented" : "Not Implemented");
}

//From 802.11-2007:7.1.3.4 Sequence Control field
struct WiFiSeqCtrl = FormatString ("Sequence Number = %d", SequenceNumber)
{
	[WiFiFragmentNumber]
	UINT16 FragmentNumber:4 = FormatString("(%s) %d", this.ToBitString, this);
	[WiFiSequenceNumber]
	UINT16 SequenceNumber:12 = FormatString("(%s) %d", this.ToBitString, this);
}

// Information Elements
//From 802.11: 7.3.2.9 Country information element
struct WiFiCountry = CountryString
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	[ChannelStart = FrameOffset]
	AsciiString(3) CountryString;
	while [FrameOffset - ChannelStart < Length - 1]
	{
		UINT8 FirstChannelNumber;
		UINT8 NumChannels;
		UINT8 MaxTransmitPowerLevel = FormatString("%u dBm", this);
	}
	switch 
	{
		case FrameOffset - ChannelStart < Length:
			UINT8 Pad;
	}
}

//From 802.11: 7.3.2.10 Hopping Pattern Parameters information element
struct WiFiHoppingPatternParameters
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	UINT8 PrimeRadix;
	UINT8 NumChannels;
}

//From 802.11: 7.3.2.11 Hopping Pattern Table information element
struct WiFiHoppingPatternTable
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	UINT8 Flag = this ? "Random Table is present" : "Random Table is NOT present and hop index method is to be used";
	UINT8 NumSets;
	UINT8 Modulus;
	UINT8 Offset;
	switch 
	{
		case Flag:
			UINT8 RandomTable[Length - 4];
	}
}

//From 802.11: 7.3.2.12 Request information element
struct WiFiRequest
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	switch
	{
		case Length > 0:
			UINT8 RequestedElementID[Length];
	}
}

//From 802.11: 7.3.2.8 Challenge Text element
struct WiFiChallengeText
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	BLOB(Length) ChallengeText;
	
}

//From 802.11: 7.3.2.28 BSS Load element
struct WiFiBSSLoad
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	UINT16 STACount;
	UINT8 ChannelUtilization;
	UINT16 AvailableAdmissionCapacity = FormatString("%u microsecond(s)/s", this * 32);
}

Table WiFiEDCAACITable(code)
{
	switch (code)
	{
		case 0: "Best effort";
		case 1: "Background";
		case 2: "Video";
		case 3: "Voice";
	}
}

struct WiFiEDCAParameterAC = "ACI = " + WiFiEDCAACITable(ACI)
{
	UINT8 AIFSN:4 = FormatString("   (%s) %u", this.ToBitString, this);
	UINT8 ACM:1 = FormatString("     (%s) %s", this.ToBitString, this ? "Admission Control Required" : "Admission Control not required");
	UINT8 ACI:2 = FormatString("     (%s) %s", this.ToBitString, WiFiEDCAACITable(this));
	UINT8 Reserved:1 = FormatString("(%s)", this.ToBitString);
	UINT8 ECWmin:4 = FormatString("  (%s) %u", this.ToBitString, this);
	UINT8 ECWmax:4 = FormatString("  (%s) %u", this.ToBitString, this);
	UINT16 TXOPLimit = FormatString("%u microsecond(s)", this * 32);
}

//From 802.11: 7.3.2.29 EDCA Parameter Set element
struct WiFiEDCAParameterSet
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	WiFiQosInfoField QoSInfo;
	UINT8 Reserved;
	WiFiEDCAParameterAC ACBE;
	WiFiEDCAParameterAC ACBK;
	WiFiEDCAParameterAC ACVI;
	WiFiEDCAParameterAC ACVO;
}

Table WiFiDirectionTable(value)
{
	switch(value)
	{
		case 0: "Uplink";
		case 1: "Downlink";
		case 2: "Directlink";
		case 3: "Bidirectional link";
	}
}

Table WiFiTSPECTsInfoAccessPolicyTable(value)
{
	switch(value)
	{
		case 0: "Reserved";
		case 1: "Contention-based channel access (EDCA)";
		case 2: "Controlled channel access (HCCA)";
		case 3: "HCCA, EDCA mixed mode (HEMM)";
	}
}

Table WiFiTSPECTsInfoAckPolicyTable(value)
{
	switch(value)
	{
		case 0: "Normal IEEE 802.11 acknowledgment";
		case 1: "No Ack";
		case 2: "Reserved";
		case 3: "Block Ack";
	}
}

//From 802.11: 7.3.2.30 TSPEC element
struct WiFiTSPEC
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	UINT24 TSInfo
	{
		UINT24 TrafficType:1 = FormatString("    (%s) %s", this.ToBitString, this ? "Periodic traffic pattern" : "Aperiodic or unspecified traffic pattern");
		UINT24 TSID:4 = FormatString("           (%s) %u", this.ToBitString, this);
		UINT24 Direction:2 = FormatString("      (%s) %s", this.ToBitString, WiFiDirectionTable(this));
		UINT24 AccessPolicy:2 = FormatString("   (%s) %s", this.ToBitString, WiFiTSPECTsInfoAccessPolicyTable(this));
		switch 
		{
			case (AccessPolicy == 2) || (AccessPolicy == 1 && (TSInfo & 0x100)):
				UINT24 Aggregation:1 = FormatString("    (%s) %s", this.ToBitString, this ? "Aggregate schedule is required" : "Aggregate schedule is NOT required");
			default:
				UINT24 Reserved1:1 = FormatString("      (%s)", this.ToBitString);
		}
		UINT24 APSD:1 = FormatString("           (%s) %s", this.ToBitString, this ? "Automatic PS delivery is to be used for the traffic associated with the TSPEC" : "Automatic PS delivery is NOT to be used for the traffic associated with the TSPEC");
		UINT24 UserPriority:3 = FormatString("   (%s) %u", this.ToBitString, this);
		UINT24 TSInfoAckPolicy:2 = FormatString("(%s) %s", this.ToBitString, WiFiTSPECTsInfoAckPolicyTable(this));
		switch 
		{
			case AccessPolicy == 2:
				UINT24 Schedule:1 = FormatString("       (%s) %s", this.ToBitString, this ? ( APSD ? "Scheduled APSD" : "Reserved") : ( APSD ? "Unscheduled APSD" : "No Schedule"));
			default:
				UINT24 Reserved2:1 = FormatString("      (%s)", this.ToBitString);
		}
		UINT24 Reserved3:7 = FormatString("      (%s)", this.ToBitString);
	};
	switch 
	{
		case UINT16(FrameData, FrameOffset):
			UINT16 NominalMSDUSize
			{
				UINT16 Size:15 = FormatString(" (%s) %u octet(s)", this.ToBitString, this);
				UINT16 Fixed:1 = FormatString("(%s) %s", this.ToBitString, this ? "Fixed" : "Not fixed");
			};
		default:
			UINT16 UnspecifiedNominalMSDUSize;
	}
	UINT16 MaximumMSDUSize = FormatString("%u octet(s)", this);
	UINT32 MinimumServiceInterval = FormatString("%u microsecond(s)", this);
	UINT32 MaximumServiceInterval = FormatString("%u microsecond(s)", this);
	UINT32 InactivityInterval = FormatString("%u microsecond(s)", this);
	UINT32 SuspensionInterval = FormatString("%u microsecond(s)", this);
	UINT32 ServiceStartTime = FormatString("%u microsecond(s)", this);
	UINT32 MinimumDataRate = FormatString("%u bps", this);
	UINT32 MeanDataRate = FormatString("%u bps", this);
	UINT32 PeakDataRate = FormatString("%u bps", this);
	UINT32 BurstSize = FormatString("%u octet(s)", this);
	UINT32 DelayBound = FormatString("%u microsecond(s)", this);
	UINT32 MinimumPHYRate = FormatString("%u bps", this);
	struct SurplusBandwidthAllowancefield
	{
		UINT16 IntegerPart:13 = FormatString("(%s) %u", this.ToBitString, this);
		UINT16 DecimalPart:3 = FormatString("(%s)", this.ToBitString);
	};
	UINT16 MediumTime = FormatString("%u microsecond(s)/s", this * 32);
}

Table WiFiTCLASFrameClassifierTypeTable(value)
{
	switch (value)
	{
		case 0: "Ethernet parameters";
		case 1: "TCP/UDP IP parameters";
		case 2: "IEEE 802.1D/Q parameters";
		default: FormatString("Reserved (%d)", value);
	}
}

//From 802.11: 7.3.2.31 TCLAS element
struct WiFiTCLAS
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	UINT8 UserPriority;
	UINT8 ClassifierType = WiFiTCLASFrameClassifierTypeTable(this);
	UINT8 ClassifierMask;
	switch (ClassifierType)
	{
		case 0:
			_struct Ethernet
			{
				[DataFieldByteOrder = BigEndian]
				MacAddress SourceAddress = MacTable(this);
				[DataFieldByteOrder = BigEndian]
				MacAddress DestinationAddress = MacTable(this);
				UINT16 Type = ProtocolTable(this);
			}
		case 1: 
			_struct TCPUDPIP
			{
				UINT8 Version;
				switch (Version)
				{
					case 4:
						_struct IPv4
						{
							[DataFieldByteOrder = BigEndian]
							IPv4Address SourceIPAddress;
							[DataFieldByteOrder = BigEndian]
							IPv4Address DestinationIPAddress;
							UINT16 SourcePort = PortNameTable(this);
							UINT16 DestinationPort = PortNameTable(this);
							UINT8 DSCP = FormatString("%u", this & 0x3F);
							UINT8 Protocol = ProtocolTypeTable(this);
							UINT8 Reserved;
						}
					case 6:
						_struct IPv6
						{
							[DataFieldByteOrder = BigEndian]
							IPv6Address SourceIPAddress;
							[DataFieldByteOrder = BigEndian]
							IPv6Address DestinationIPAddress;
							UINT16 SourcePort = PortNameTable(this);
							UINT16 DestinationPort = PortNameTable(this);
							UINT24 FlowLabel;
						}
				}
				
			}
		case 2: 
			_struct IEEE8021Q
			{
				UINT16 TagType = ProtocolTable(this);
			}
	}
}

//From 802.11: 7.3.2.34 Schedule element
struct WiFiSchedule
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	UINT16 ScheduleInfo
	{
		switch 
		{
			case UINT16(FrameData, FrameOffset) & 0x1:
				_struct Aggregation
				{
					UINT16 Aggregation:1 = FormatString("(%s) %s", this.ToBitString, this ? "Aggregate schedule for all TSIDs associated with the non-AP QSTA to which the frame is directed" : "Not aggregate schedule for all TSIDs associated with the non-AP QSTA to which the frame is directed");
					UINT16 Reserved:15 = FormatString("   (%s)", this.ToBitString);
				}
			default:
				_struct NonAgregation
				{
					UINT16 Aggregation:1 = FormatString("(%s) %s", this.ToBitString, this ? "Aggregate schedule for all TSIDs associated with the non-AP QSTA to which the frame is directed" : "Not aggregate schedule for all TSIDs associated with the non-AP QSTA to which the frame is directed");
					UINT16 TSID:4 = FormatString("       (%s) %u", this.ToBitString, this);
					UINT16 Direction:2 = FormatString("  (%s) %s", this.ToBitString, WiFiDirectionTable(this));
					UINT16 Reserved:9 = FormatString("   (%s)", this.ToBitString);
				}
		}
	};
	UINT32 ServiceStartTime = FormatString("%u microsecond(s)", this);
	UINT32 ServiceInterval = FormatString("%u microsecond(s)", this);
	UINT16 SpecificationInterval = FormatString("%u ms", this);
}

//From 802.11: 7.3.2.15 Power Constraint element
struct WiFiPowerConstraint
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	UINT8 PowerConstraint;
}

//From 802.11: 7.3.2.16 Power Capability element
struct WiFiPowerCapability
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	INT8 MinimumTransmitPowerCapability = FormatString("%d dBm", this);
	INT8 MaximumTransmitPowerCapability = FormatString("%d dBm", this);
}

//From 802.11: 7.3.2.17 TPC Request element
struct WiFiTPCRequest
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
}

//From 802.11: 7.3.2.18 TPC Report element
struct WiFiTPCReport
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	UINT8 TransmitPower = FormatString("%u dBm", this);
	UINT8 LinkMargin = FormatString("%u dB", this);
}

//From 802.11: 7.3.2.19 Supported Channels element
struct WiFiSupportedChannels
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	[ChannelStart = FrameOffset]
	while [FrameOffset - ChannelStart < Length]
	{
		UINT8 FirstChannelNumber;
		UINT8 NumChannels;
	}
}

Table WiFiChannelSwitchAnnouncementCountMeaningTable(value)
{
	switch (value)
	{
		case 0: "The switch shall occur at any time after the frame containing the element is transmitted";
		case 1: "The switch shall occur immediately before the next TBTT";
		default: FormatString("%u", value);
	}
}

//From 802.11: 7.3.2.20 Channel Switch Announcement element
struct WiFiChannelSwitchAnnouncement
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	UINT8 ChannelSwitchMode = this ? "Shall transmit no further frames within the BSS until the scheduled channel switch" : "No requirement imposed on the receiving STA";
	UINT8 NewChannelNumber;
	UINT8 ChannelSwitchCount = WiFiChannelSwitchAnnouncementCountMeaningTable(this);
}

Table WiFiMeasurementRequestTypeTable(value)
{
	switch (value)
	{
		// Spectrum Management
		case 0: "Basic request";
		case 1: "Clear channel assessment (CCA) request";
		case 2: "Receive power indication (RPI) histogram request";
		// Radio Resource Measurement, 802.11k-2008, not implemented
		case 3: "Channel load request";
		case 4: "Noise histogram request";
		case 5: "Beacon request";
		case 6: "Frame request";
		case 7: "STA statistics request";
		case 8: "LCI request";
		case 9: "Transmit stream/category measurement request";
		case 255: "Measurement Pause request";
		// Reserved
		default: FormatString("Reserved (%d)", value);
	}
}

table WiFiMeasurementReportTypeTable
{
	switch (value)
	{
		// Spectrum Management
		case 0: "Basic report";
		case 1: "CCA report";
		case 2: "RPI histogram report";
		case 3: "Channel load report";
		case 4: "Noise histogram report";
		case 5: "Beacon report";
		case 6: "Frame report";
		case 7: "STA statistics report";
		case 8: "LCI report";
		case 9: "Transmit stream/category measurement report";
		// Reserved
		default: FormatString("Reserved (%d)", value);
	}
}

//From 802.11k: 7.3.2.21 Measurement Request element
struct WiFiMeasurementRequest
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	UINT8 MeasurementToken;
	UINT8 MeasurementRequestMode
	{
		UINT8 Parallel:1 = FormatString("         (%s) %s", this.ToBitString, MeasurementRequestMode & 0x02 == 0x02 ? "Reserved" : ( this ? "Request that the measurement is to start at the same time as the measurement described by the next Measurement Request element in the same Measurement Request frame" : "The measurements are to be performed in sequence" ));
		UINT8 Enable:1 = FormatString("           (%s) %s", this.ToBitString, this ? "Enable the sending of measurement requests and autonomous measurement reports" : "Disable the sending of measurement requests and autonomous measurement reports");
		UINT8 Request:1 = FormatString("          (%s) %s", this.ToBitString, this ? "Enable measurement requests" : "Disable measurement requests");
		UINT8 Report:1 = FormatString("           (%s) %s", this.ToBitString, this ? "Enable autonomous measurement reports" : "Disable autonomous measurement reports");
		UINT8 DurationMandatory:1 = FormatString("(%s) %s", this.ToBitString, this ? "The duration requested is a mandatory duration" : "The duration requested is a maximum duration");
		UINT8 Reserved:3 = FormatString("         (%s) Reserved", this.ToBitString);
	};
	UINT8 MeasurementType = WiFiMeasurementRequestTypeTable(this);
	switch
	{
		case MeasurementRequestMode.Enable == 0 && MeasurementType == 0:
			_struct BasicRequest
			{
				UINT8 ChannelNumber;
				UINT64 MeasurementStartTime = FormatString("%u microsecond(s)", this);
				UINT16 MeasurementDuration = FormatString("%u ms", this);
			}
		case MeasurementRequestMode.Enable == 0 && MeasurementType == 1:
			_struct CCARequest
			{
				UINT8 ChannelNumber;
				UINT64 MeasurementStartTime = FormatString("%u microsecond(s)", this);
				UINT16 MeasurementDuration = FormatString("%u ms", this);
			}
		case MeasurementRequestMode.Enable == 0 && MeasurementType == 2:
			_struct RPIHistogramRequest
			{
				UINT8 ChannelNumber;
				UINT64 MeasurementStartTime = FormatString("%u microsecond(s)", this);
				UINT16 MeasurementDuration = FormatString("%u ms", this);
			}
		case MeasurementRequestMode.Enable == 0 && MeasurementType == 3:
			_struct ChannelLoadRequest
			{
				UINT8 RegulatoryClass;
				UINT8 ChannelNumber;
				UINT16 RandomizationInterval;
				UINT16 MeasurementDuration = FormatString("%u ms", this);
				while OptionalSubElemnts[UINT8( Framedata, Offset + 1 ) + FrameOffset + 2 <= WiFiPktLen]
				{
					WiFiChannelLoadRequestSubelement Subelement;
				}
			}
		case MeasurementRequestMode.Enable == 0 && MeasurementType == 4:
			_struct NoiseHistogramRequest
			{
				UINT8 RegulatoryClass;
				UINT8 ChannelNumber;
				UINT16 RandomizationInterval;
				UINT16 MeasurementDuration = FormatString("%u ms", this);
				while OptionalSubElemnts[UINT8( Framedata, Offset + 1 ) + FrameOffset + 2 <= WiFiPktLen]
				{
					WiFiNoiseHistogramRequestSubelement Subelement;
				}
			}
		case MeasurementRequestMode.Enable == 0 && MeasurementType == 5:
			_struct BeaconRequest
			{
				UINT8 RegulatoryClass;
				UINT8 ChannelNumber;
				UINT16 RandomizationInterval;
				UINT16 MeasurementDuration = FormatString("%u ms", this);
				UINT8 MeasurementMode = WiFiMeasurementModeTable(this);
				UINT48 BSSID;
				while OptionalSubElemnts[UINT8( Framedata, Offset + 1 ) + FrameOffset + 2 <= WiFiPktLen]
				{
					WiFiBeaconRequestSubelement Subelement;
				}
			}
		case MeasurementRequestMode.Enable == 0 && MeasurementType == 6:
			_struct FrameRequest
			{
				UINT8 RegulatoryClass;
				UINT8 ChannelNumber;
				UINT16 RandomizationInterval;
				UINT16 MeasurementDuration = FormatString("%u ms", this);
				UINT8 FrameRequestType = WiFiFrameRequestTypeTable(this);
				[DataFieldByteOrder = BigEndian]
				MacAddress MacAddress = MacTable(this);
				while OptionalSubElemnts[UINT8( Framedata, Offset + 1 ) + FrameOffset + 2 <= WiFiPktLen]
				{
					WiFiFrameRequestSubelement Subelement;
				}
			}
		case MeasurementRequestMode.Enable == 0 && MeasurementType == 7:
			_struct STAStatisticsRequest
			{
				[DataFieldByteOrder = BigEndian]
				MacAddress PeerMacAddress;
				UINT16 RandomizationInterval;
				UINT16 MeasurementDuration = FormatString("%u ms", this);
				UINT8 GroupIdentity = WiFiGroupIdentityTable(this);
				while OptionalSubElemnts[UINT8( Framedata, Offset + 1 ) + FrameOffset + 2 <= WiFiPktLen]
				{
					WiFiFrameRequestSubelement Subelement;
				}
			}
		case MeasurementRequestMode.Enable == 0 && MeasurementType == 8:
			_struct LCIRequest
			{
				UINT8 LocationSubject = WiFiLocationSubjectTable(this);
				UINT8 LatitudeRequestedResolution;
				UINT8 LongitudeRequestedResolution;
				UINT8 AltitudeRequestedResolution;
				while OptionalSubElemnts[UINT8( Framedata, Offset + 1 ) + FrameOffset + 2 <= WiFiPktLen]
				{
					WiFiLocationConfigurationInformationRequestSubelement Subelement;
				}
			}
		case MeasurementRequestMode.Enable == 0 && MeasurementType == 9:
			_struct TransmitStreamOrCategoryMeasurementRequest
			{
				UINT16 RandomizationInterval;
				UINT16 MeasurementDuration = FormatString("%u ms", this);
				[DataFieldByteOrder = BigEndian]
				MacAddress PeerSTAAddress;
				UINT8 TrafficIdentifier
				{
					UINT8 Reserved:4 = FormatString("(%s)", this.ToBitString);
					UINT8 TID:4 = FormatString("     (%s) %d", this.ToBitString, this);
				};
				UINT8 Bin0Range = WiFiBin0RangeTable(this);
				while OptionalSubElemnts[UINT8( Framedata, Offset + 1 ) + FrameOffset + 2 <= WiFiPktLen]
				{
					WiFiTransmitStreamOrCategoryMeasurementRequestSubelement Subelement;
				}
			}
		case MeasurementRequestMode.Enable == 0 && MeasurementType == 255:
			_struct MeasurementPauseRequest
			{
				UINT16 PauseTime = FormatString("%u (10 TU)", this);
				while OptionalSubElemnts[UINT8( Framedata, Offset + 1 ) + FrameOffset + 2 <= WiFiPktLen]
				{
					WiFiFrameRequestSubelement Subelement;
				}
			}
	}
}

struct WiFiTransmitStreamOrCategoryMeasurementRequestSubelement
{
	switch ( UINT8(Framedata, Offset) )
	{
		case 1:
			_struct TriggeredReporting
			{
				UINT8 SubelementID = WiFiTriggeredReportingTable(this);
				UINT8 Length;
				UINT8 TriggerConditions
				{
					UINT8 Average:1 = FormatString("    (%s) %s", this.ToBitString, this ?"A Transmit Stream/Category Measurement Report be generated when the number of MSDUs for the TC or TS given by the TID that are discarded out of the number of preceding MSDUs specified in Measurement Count is greater than or equal to the value given in Average Error Threshold" : "A Transmit Stream/Category Measurement Report be generated when the number of MSDUs for the TC or TS given by the TID that are discarded out of the number of preceding MSDUs specified in Measurement Count is NOT greater than or equal to the value given in Average Error Threshold");
					UINT8 Consecutive:1 = FormatString("(%s) %s", this.ToBitString, this ?"A Transmit Stream/Category Measurement Report be generated when the number of MSDUs for the TC or TS given by the TID that are discarded in succession is greater than or equal to the value given in Consecutive Error Threshold" : "A Transmit Stream/Category Measurement Report be generated when the number of MSDUs for the TC or TS given by the TID that are discarded outin succession is greater than or equal to the value given in Consecutive Error Threshold");
					UINT8 Delay:1 = FormatString("      (%s) %s", this.ToBitString, this ?"A Transmit Stream/Category Measurement Report be generated when the number of MSDUs for the TC or TS given by the TID that experience a transmit delay greater than or equal to the value specified in the Delay Threshold subfield, is greater than or equal to the value given in Delayed MSDU Count" : "A Transmit Stream/Category Measurement Report be generated when the number of MSDUs for the TC or TS given by the TID that experience a transmit delay greater than or equal to the value specified in the Delay Threshold subfield, is greater than or equal to the value given in Delayed MSDU Count");
					UINT8 Reserved:5 = FormatString("(%s)", this.ToBitString);
				};
				UINT8 AverageErrorThreshold;
				UINT8 ConsecutiveErrorThreshold;
				UINT8 DelayThreshold
				{
					UINT8 DelayedMSDURange:2 = FormatString("          (%s) %s", this.ToBitString, WiFiDelayedMSDURangeTable(this));
					UINT8 DelayedMSDUCount:6 = FormatString("(%s) %d", this.ToBitString, this);
				};
				UINT8 MeasurementCount;
				UINT8 TriggerTimeout = FormatString("%u (100 TU)", this);
			}
		case 221: WiFiVendorSpecificInfo VendorSpecificInfo;
		default:
			_struct
			{
				UINT8 SubelementID = WiFiTriggeredReportingTable(this);
				UINT8 Length;
				Blob( Length ) Data;
			}
	}
}

table WiFiTriggeredReportingTable
{
	switch(value)
	{
		case 1: "Triggered Reporting";
		case 2: "Vendor Specific";
		default: FormatString("Reserved (%d)", value);
	}
}

table WiFiDelayedMSDURangeTable(value)
{
	switch(value)
	{
		case 0: "Transmit Delay = Lower Bound of Bin 2";
		case 1: "Transmit Delay = Lower Bound of Bin 3";
		case 2: "Transmit Delay = Lower Bound of Bin 4";
		case 3: "Transmit Delay = Lower Bound of Bin 5";
		default: FormatString("Reserved (%d)", value);
	}
}

struct WiFiLocationConfigurationInformationRequestSubelement
{
	switch ( UINT8(Framedata, Offset) )
	{
		case 1:
			_struct AzimuthRequest
			{
				UINT8 SubelementID = WiFiLCIRequestTable(this);
				UINT8 Length;
				UINT8 AzimuthRequest
				{
					UINT8 AzimuthResolutionRequested:4 = FormatString("(%s) %d", this.ToBitString, this);
					UINT8 AzimuthType:1 = FormatString("               (%s) %s", this.ToBitString, this ? "Request a report of the Azimuth of radio reception" : "Request a report of the Azimuth of front surface of the reporting STA");
					UINT8 Reserved:3 = FormatString("                  (%s)", this.ToBitString);
				};
			}
		case 221: WiFiVendorSpecificInfo VendorSpecificInfo;
		default:
			_struct
			{
				UINT8 SubelementID = WiFiLCIRequestTable(this);
				UINT8 Length;
				Blob( Length ) Data;
			}
	}
}

table WiFiLCIRequestTable
{
	switch(value)
	{
		case 1: "Azimuth Request";
		case 221: "Vendor Specific";
		default: FormatString("Reserved (%d)", value);
	}
}

table WiFiLocationSubjectTable
{
	switch(value)
	{
		case 0: "LCI Subject Local";
		case 1: "LCI Subject Remote";
		default: FormatString("Reserved (%d)", value);
	}
}

struct WiFiFrameRequestSubelement
{
	switch ( UINT8(Framedata, Offset) )
	{
		case 221: WiFiVendorSpecificInfo VendorSpecificInfo;
		default:
			_struct
			{
				UINT8 SubelementID = WiFiFrameRequestTypeTable(this);
				UINT8 Length;
				Blob( Length ) Data;
			}
	}
}

table WiFiFrameRequestTypeTable
{
	switch(value)
	{
		case 221: "Vendor Specific";
		default: FormatString("Reserved (%d)", value);
	}
}

table WiFiMeasurementModeTable
{
	switch(value)
	{
		case 0: "Passive";
		case 1: "Active";
		case 2: "Beacon Table";
		default: FormatString("Reserved (%d)", value);
	}
}

struct WiFiBeaconRequestSubelement
{
	switch ( UINT8(Framedata, Offset) )
	{
		case 0: WiFiSSID SSID;
		case 1:
			_struct BeaconReportingInformation
			{
				UINT8 SubelementID = WiFiBeaconRequestSubElementIDTable(this);
				UINT8 Length;
				UINT8 ReportingCondition = WiFiBeaconReportingConditionTable(this);
				UINT8 ThresholdOrOffsetReferenceValue;
			}
		case 2:
			_struct ReportingDetail
			{
				UINT8 SubelementID = WiFiBeaconRequestSubElementIDTable(this);
				UINT8 Length;
				UINT8 ReportingDetail = WiFiReprotingDetailTable(this);
			}
		case 10: WiFiRequest Request;
		case 51: WiFiAPChannelReport APChannelReport;
		case 221: WiFiVendorSpecificInfo VendorSpecificInfo;
		default:
			_struct
			{
				UINT8 SubelementID = WiFiBeaconRequestSubElementIDTable(this);
				UINT8 Length;
				Blob( Length ) Data;
			}
	}
}

table WiFiReprotingDetailTable(value)
{
	switch(value)
	{
		case 0: "No fixed length fields or elements";
		case 1: "All fixed length fields and any requested elements in the Request information element if present";
		case 2: "All fixed length fields and elements";
		default: FormatString("Reserved (%d)", value);
	}
}

table WiFiBeaconRequestSubElementIDTable(value)
{
	switch(value)
	{
		case 0: "SSID";
		case 1: "Beacon Reporting Information";
		case 2: "Reporting Detail";
		case 10: "Request";
		case 51: "AP Channel Report";
		case 221: "Vendor Specific";
		default: FormatString("Reserved (%d)", value);
	}
}

table WiFiBeaconReportSubElementIDTable(value)
{
	switch(value)
	{
		case 1: "Reported Frame Body";
		case 221: "Vendor Specific";
		default: FormatString("Reserved (%d)", value);
	}
}

table WiFiBeaconReportingConditionTable(value)
{
	switch(value)
	{
		case 0: "Report to be issued after each measurement";
		case 1: "The measured RCPI level is greater than the threshold indicated in the Threshold/Offset Reference Value";
		case 2: "The measured RCPI level is less the threshold indicated in the Threshold/Offset Reference Value";
		case 3: "The measured RSNI level is greater than the threshold indicated in the Threshold/Offset Reference Value";
		case 4: "The measured RSNI level is less than the threshold indicated in the Threshold/Offset Reference Value";
		case 5: "The measured RCPI level is greater than a threshold defined by an offset from the serving APs reference RCPI, where the offset is indicated in the Threshold/Offset Reference Value";
		case 6: "The measured RCPI level is less than a threshold defined by an offset from the serving APs reference RCPI, where the offset is indicated in the Threshold/Offset Reference Value";
		case 7: "The measured RSNI level is greater than a threshold defined by an offset from the serving APs reference RSNI, where the offset is indicated in the Threshold/Offset Reference Value";
		case 8: "The measured RSNI level is less than a threshold defined by an offset from the serving APs reference RSNI, where the offset is indicated in the Threshold/Offset Reference Value";
		case 9: "The measured RCPI level is in a range bound by the serving APs reference RCPI and an offset from the serving APs reference RCPI, where the offset is indicated in the Threshold/Offset Reference Value";
		case 10: "The measured RSNI level is in a range bound by the serving APs reference RSNI and an offset from the serving APs reference RSNI, where the offset is indicated in the Threshold/Offset Reference Value";
		default: FormatString("Reserved (%d)", value);
	}
}

struct WiFiNoiseHistogramRequestSubelement
{
	switch( UINT8(Framedata, Offset) )
	{
		case 1:
			_struct NoiseHistogramReportingInformation
			{
				UINT8 SubelementID = WiFiNoiseHistogramRequestSubElementIDTable(this);
				UINT8 Length;
				UINT8 ReportingCondition = WiFiNoiseHistogramReportingConditionTable(this);
				UINT8 ANPIReferenceValue;
			}
		case 221: WiFiVendorSpecificInfo VendorSpecificInfo;
		default:
			_struct
			{
				UINT8 SubelementID = WiFiNoiseHistogramRequestSubElementIDTable(this);
				UINT8 Length;
				Blob( Length ) Data;
			}
	}
}

table WiFiNoiseHistogramRequestSubElementIDTable(value)
{
	switch(value)
	{
		case 1: "Noise Histogram Reporting Information";
		case 221: "Vendor Specific";
		default: FormatString("Reserved (%d)", value);
	}
}

table WiFiNoiseHistogramReportingConditionTable(value)
{
	switch(value)
	{
		case 0: "Report to be issued after each measurement";
		case 1: "Noise Histogram Report to be issued when measured ANPI is equal to or greater than the reference value";
		case 2: "Noise Histogram Report to be issued when measured ANPI is equal to or less than the reference value";
		default: FormatString("Reserved (%d)", value);
	}
}

struct WiFiChannelLoadRequestSubelement
{
	switch( UINT8(Framedata, Offset) )
	{
		case 1:
			_struct ChannelLoadReportingInformation
			{
				UINT8 SubelementID = WiFiChannelLoadRequestSubElementIDTable(this);
				UINT8 Length;
				UINT8 ReportingCondition = WiFiChannelLoadReportingConditionTable(this);
				UINT8 ChannelLoadReferenceValue;
			}
		default:
			_struct
			{
				UINT8 SubelementID = WiFiChannelLoadRequestSubElementIDTable(this);
				UINT8 Length;
				Blob( Length ) Data;
			}
	}
}

table WiFiChannelLoadRequestSubElementIDTable(value)
{
	switch(value)
	{
		case 1: "Channel Load Reporting Information";
		case 221: "Vendor Specific";
		default: FormatString("Reserved (%d)", value);
	}
}

table WiFiChannelLoadReportingConditionTable(value)
{
	switch(value)
	{
		case 0: "Report to be issued after each measurement";
		case 1: "Report to be issued when measured Channel Load is equal to or greater than the reference value";
		case 2: "Report to be issued when measured Channel Load is equal to or less than the reference value";
		default: FormatString("Reserved (%d)", value);
	}
}

//From 802.11: 7.3.2.22 Measurement Report element
struct WiFiMeasurementReport
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	UINT8 MeasurementToken;
	UINT8 MeasurementReportMode
	{
		UINT8 Late:1 = FormatString("     (%s) %s", this.ToBitString, this ? "Request was too late" : "Received in time");
		UINT8 Incapable:1 = FormatString("(%s) %s", this.ToBitString, this ? "Incapable." : "Capable or the report is autonomous.");
		UINT8 Refused:1 = FormatString("  (%s) %s", this.ToBitString, this ? "Refusing." : "NOT refusing or the report is autonomous");
		UINT8 Reserved:5 = FormatString(" (%s)", this.ToBitString);
	};
	UINT8 MeasurementType = WiFiMeasurementReportTypeTable(this);
	switch
	{
		case MeasurementReportMode == 0:
			switch (MeasurementType)
			{
				case 0: 
					_struct Basic
					{
						UINT8 ChannelNumber;
						UINT64 MeasurementStartTime = FormatString("%u microsecond(s)", this);
						UINT16 MeasurementDuration = FormatString("%u ms", this);
						UINT8 Map
						{
							UINT8 BSS:1 = FormatString("               (%s) %s", this.ToBitString, this ? "MPDU was received from another BSS or IBSS" : "MPDU was NOT received from another BSS or IBSS");
							UINT8 OFDMPreamble:1 = FormatString("      (%s) %s", this.ToBitString, this ? "At least one sequence of short training symbols was detected" : "None sequence of short training symbols was detected");
							UINT8 UnidentifiedSignal:1 = FormatString("(%s) %s", this.ToBitString, this ? "Significant power is detected" : "Significant power is NOT detected");
							UINT8 Radar:1 = FormatString("             (%s) %s", this.ToBitString, this ? "Radar was detected operating" : "Radar was NOT detected operating");
							UINT8 Unmeasured:1 = FormatString("        (%s) %s", this.ToBitString, this ? "Channel has not been measured" : "Channel has been measured");
							UINT8 Reserved:3 = FormatString("          (%s)", this.ToBitString);
						};
					}
				case 1: 
					_struct CCA
					{
						UINT8 ChannelNumber;
						UINT64 MeasurementStartTime = FormatString("%u microsecond(s)", this);
						UINT16 MeasurementDuration = FormatString("%u ms", this);
						UINT8 CCABusyFraction = FormatString("%u microsecond(s)", this);
					}
				case 2: 
					_struct RPI
					{
						UINT8 ChannelNumber;
						UINT64 MeasurementStartTime = FormatString("%u microsecond(s)", this);
						UINT16 MeasurementDuration = FormatString("%u ms", this);
						UINT8 RPI0Density = FormatString("%u dBm", this);
						UINT8 RPI1Density = FormatString("%u dBm", this);
						UINT8 RPI2Density = FormatString("%u dBm", this);
						UINT8 RPI3Density = FormatString("%u dBm", this);
						UINT8 RPI4Density = FormatString("%u dBm", this);
						UINT8 RPI5Density = FormatString("%u dBm", this);
						UINT8 RPI6Density = FormatString("%u dBm", this);
						UINT8 RPI7Density = FormatString("%u dBm", this);
					}
				case 3:
					//From 802.11k: 7.3.2.22.4 Channel Load Report
					_struct ChannelLoad
					{
						UINT8 RegulatoryClass;
						UINT8 ChannelNumber;
						UINT64 MeasurementStartTime = FormatString("%u microsecond(s)", this);
						UINT16 MeasurementDuration = FormatString("%u ms", this);
						UINT8 ChannelLoad;
						while OptionalSubElemnts[UINT8( Framedata, Offset + 1 ) + FrameOffset + 2 <= WiFiPktLen]
						{
							WiFiFrameRequestSubelement Subelement;
						}
					}
				case 4:
					//From 802.11k: 7.3.2.22.5 Noise Histogram Report
					_struct NoiseHistogram
					{
						UINT8 RegulatoryClass;
						UINT8 ChannelNumber;
						UINT64 ActualMeasurementStartTime = FormatString("%u microsecond(s)", this);
						UINT16 MeasurementDuration = FormatString("%u ms", this);
						UINT8 AntennaID;
						UINT8 ANPI;
						UINT8 IPI0Density = WiFiIPIDefinitionsTable(this);
						UINT8 IPI1Density = WiFiIPIDefinitionsTable(this);
						UINT8 IPI2Density = WiFiIPIDefinitionsTable(this);
						UINT8 IPI3Density = WiFiIPIDefinitionsTable(this);
						UINT8 IPI4Density = WiFiIPIDefinitionsTable(this);
						UINT8 IPI5Density = WiFiIPIDefinitionsTable(this);
						UINT8 IPI6Density = WiFiIPIDefinitionsTable(this);
						UINT8 IPI7Density = WiFiIPIDefinitionsTable(this);
						UINT8 IPI8Density = WiFiIPIDefinitionsTable(this);
						UINT8 IPI9Density = WiFiIPIDefinitionsTable(this);
						UINT8 IPI10Density = WiFiIPIDefinitionsTable(this);
						while OptionalSubElemnts[UINT8( Framedata, Offset + 1 ) + FrameOffset + 2 <= WiFiPktLen]
						{
							WiFiFrameRequestSubelement Subelement;
						}
					}
				case 5:
					//From 802.11k: 7.3.2.22.6 Beacon Report
					_struct Beacon
					{
						UINT8 RegulatoryClass;
						UINT8 ChannelNumber;
						UINT64 ActualMeasurementStartTime = FormatString("%u microsecond(s)", this);
						UINT16 MeasurementDuration = FormatString("%u ms", this);
						UINT8 ReportedFrameInformation
						{
							UINT8 CondensedPHYType:7 = FormatString(" (%s) %d", this.ToBitString, this);
							[Property.ReportedFrameType]
							UINT8 ReportedFrameType:1 = FormatString("(%s) %s", this.ToBitString, this ? "Measurement Pilot frame" : "Beacon or Probe Response frame");
						};
						UINT8 RCPI;
						UINT8 RSNI;
						UINT48 BSSID;
						UINT8 AntennaID;
						UINT32 ParentTSF;
						while OptionalSubElemnts[UINT8( Framedata, Offset + 1 ) + FrameOffset + 2 <= WiFiPktLen]
						{
							WiFiBeaconReportSubelement Subelement;
						}
					}
				case 6:
					//From 802.11k: 7.3.2.22.7 Frame Report
					_struct Frame
					{
						UINT8 RegulatoryClass;
						UINT8 ChannelNumber;
						UINT64 ActualMeasurementStartTime = FormatString("%u microsecond(s)", this);
						UINT16 MeasurementDuration = FormatString("%u ms", this);
						while OptionalSubElemnts[UINT8( Framedata, Offset + 1 ) + FrameOffset + 2 <= WiFiPktLen]
						{
							WiFiFrameReportSubelement Subelement;
						}
					}
				case 7:
					//From 802.11k: 7.3.2.22.8 STA Statistics Report
					_struct STAStatistics
					{
						UINT16 MeasurementDuration = FormatString("%u ms", this);
						UINT8 GroupIdentity = WiFiGroupIdentityTable(this);
						switch(GroupIdentity)
						{
							case 1:
								_struct dot11MACStatisticsGroup
								{
									UINT32 dot11RetryCount;
									UINT32 dot11MultipleRetryCount;
									UINT32 dot11FrameDuplicateCount;
									UINT32 dot11RTSSuccessCount;
									UINT32 dot11RTSFailureCount;
									UINT32 dot11ACKFailureCount;
								}
							case 2:
							case 3:
							case 4:
							case 5:
							case 6:
							case 7:
							case 8:
							case 9:
								_struct dot11QosCountersGroup
								{
									UINT32 dot11QosTransmittedFragmentCount;
									UINT32 dot11QosFailedCount;
									UINT32 dot11QosRetryCount;
									UINT32 dot11QosMultipleRetryCount;
									UINT32 dot11QosFrameDuplicateCount;
									UINT32 dot11QosRTSSuccessCount;
									UINT32 dot11QosRTSFailureCount;
									UINT32 dot11QosACKFailureCount;
									UINT32 dot11QosReceivedFragmentCount;
									UINT32 dot11QosTransmittedFrameCount;
									UINT32 dot11QosDiscardedFrameCount;
									UINT32 dot11QosMPDUsReceivedCount;
									UINT32 dot11QosRetriesReceivedCount;
								}
							case 10:
								_struct dot11BSSAverageAccessDelayGroup
								{
									UINT8 dot11STAStatisticsAPAverageAccessDelay;
									UINT8 dot11STAStatisticsAverageAccessDelayBestEffort;
									UINT8 dot11STAStatisticsAverageAccessDelayBackGround;
									UINT8 dot11STAStatisticsAverageAccessDelayVideo;
									UINT8 dot11STAStatisticsAverageAccessDelayVoice;
									UINT8 dot11STAStatisticsStationCount;
									UINT8 dot11STAStatisticsChannelUtilization;
								}
						}
						while OptionalSubElemnts[UINT8( Framedata, Offset + 1 ) + FrameOffset + 2 <= WiFiPktLen]
						{
							WiFiFrameRequestSubelement Subelement;
						}
					}
				case 8:
					//From 802.11k: 7.3.2.22.9 Location Configuration Information Report
					_struct LocationConfigurationInfo
					{
						Struct
						{
							UINT128 LaRes:6 = FormatString("     (%s) Latitude resolution",this.ToBitString);
							UINT128 Latitude:34 = FormatString("  (%s) SHOULD be normalized to within +/- 90 degrees.",this.ToBitString);
							UINT128 LoRes:6 = FormatString("     (%s) Longitude resolution",this.ToBitString);
							UINT128 Longitude:34 = FormatString(" (%s) SHOULD be normalized to within +/- 180 degrees.",this.ToBitString);
							UINT128 AT:4 = FormatString("        (%s) Altitude Type for altitude.",this.ToBitString);
							UINT128 AltRes:6 = FormatString("    (%s) Altitude resolution.",this.ToBitString);
							UINT128 Altitude:30 = FormatString("  (%s) A 30 bit value defined by the AT field.",this.ToBitString);
							UINT128 Datum:8 = FormatString("     (%s) The Map Datum used for the coordinates given in this Option.",this.ToBitString);
						};
						while OptionalSubElemnts[UINT8( Framedata, Offset + 1 ) + FrameOffset + 2 <= WiFiPktLen]
						{
							WiFiLocationConfigurationInfoSubelement Subelement;
						}
					}
				case 9:
					////From 802.11k: 7.3.2.22.10 Transmit Stream/Category Measurement Report
					_struct TransmitStreamOrCategoryMeasurement
					{
						UINT64 ActualMeasurementStartTime = FormatString("%u microsecond(s)", this);
						UINT16 MeasurementDuration = FormatString("%u ms", this);
						[DataFieldByteOrder = BigEndian]
						MacAddress PeerSTAAddress;
						UINT8 TrafficIdentifier
						{
							UINT8 Reserved:4 = FormatString("(%s)", this.ToBitString);
							UINT8 TID:4 = FormatString("     (%s) %d", this.ToBitString, this);
						};
						UINT8 ReportingReason
						{
							UINT8 AverageTrigger:1 = FormatString("    (%s) %s", this.ToBitString, this ? "Transmit Stream/Category Measurement Report was generated as a triggered report due to the Average Error trigger" : "Transmit Stream/Category Measurement Report was NOT generated as a triggered report due to the Average Error trigger");
							UINT8 ConsecutiveTrigger:1 = FormatString("(%s) %s", this.ToBitString, this ? "Transmit Stream/Category Measurement Report was generated as a triggered report due to the Consecutive Error trigger" : "Transmit Stream/Category Measurement Report was NOT generated as a triggered report due to the Consecutive Error trigger");
							UINT8 CDelayTrigger:1 = FormatString("     (%s) %s", this.ToBitString, this ? "Transmit Stream/Category Measurement Report was generated as a triggered report due to the delay exceeding the Delay Threshold" : "Transmit Stream/Category Measurement Report was NOT generated as a triggered report due to the delay exceeding the Delay Threshold");
							UINT8 Reserved:5 = FormatString("          (%s)", this.ToBitString);
						};
						UINT32 TransmittedMSDUCount;
						UINT32 MSDUDiscardedCount;
						UINT32 MSDUFailedCount;
						UINT32 MSDUMultipleRetryCount;
						UINT32 QoSCFPollsLostCount;
						UINT32 AverageQueueDelay;
						UINT32 AverageTransmitDelay;
						UINT8 Bin0Range = WiFiBin0RangeTable(this);
						UINT32 Bin0;
						UINT32 Bin1;
						UINT32 Bin2;
						UINT32 Bin3;
						UINT32 Bin4;
						UINT32 Bin5;
						while OptionalSubElemnts[UINT8( Framedata, Offset + 1 ) + FrameOffset + 2 <= WiFiPktLen]
						{
							WiFiFrameRequestSubelement Subelement;
						}
					}
			}
	}
}

table WiFiBin0RangeTable(value)
{
	switch(value)
	{
		case 0: "Delay < 10";
		case 1: "10  Delay < 20";
		case 2: "20  Delay < 40";
		case 3: "40  Delay < 80";
		case 4: "80  Delay < 160";
		case 5: "160  Delay";
	}
}

struct WiFiLocationConfigurationInfoSubelement
{
	switch ( UINT8(Framedata, Offset) )
	{
		case 1:
			_struct AzimuthReport
			{
				UINT8 SubelementID = WiFiLocationConfigurationInfoSubelementIDTable(this);
				UINT8 Length;
				_struct AzimuthReport
				{
					UINT16 Reserved:2 = FormatString("         (%s)", this.ToBitString);
					UINT16 AzimuthType:1 = FormatString("      (%s) %s", this.ToBitString, this ? "Report the Azimuth of the bearing of the requestor with respect to the responder" : "Report the Azimuth of front surface of the reporting STA");
					UINT16 AzimuthResolution:4 = FormatString("(%s) %s", this.ToBitString, this);
					UINT16 Azimuth:9 = FormatString("          (%s) %s", this.ToBitString, this);
				}
			}
		case 221: WiFiVendorSpecificInfo VendorSpecificInfo;
		default:
			_struct
			{
				UINT8 SubelementID = WiFiFrameReportSubelementIDTable(this);
				UINT8 Length;
				Blob( Length ) Data;
			}
	}
}

table WiFiLocationConfigurationInfoSubelementIDTable(value)
{
	switch(value)
	{
		case 1: "Azimuth Report";
		case 221: "Vendor Specific";
		default: FormatString("Reserved (%d)", value);
	}
}

table WiFiGroupIdentityTable(value)
{
	switch(value)
	{
		case 1: "dot11MACStatistics Group for the Interface on which the STA Statistics Request was received";
		case 2: "dot11QosCounters Group for UP0 for the Interface on which the STA Statistics Request was received";
		case 3: "dot11QosCounters Group for UP1 for the Interface on which the STA Statistics Request was received";
		case 4: "dot11QosCounters Group for UP2 for the Interface on which the STA Statistics Request was received";
		case 5: "dot11QosCounters Group for UP3 for the Interface on which the STA Statistics Request was received";
		case 6: "dot11QosCounters Group for UP4 for the Interface on which the STA Statistics Request was received";
		case 7: "dot11QosCounters Group for UP5 for the Interface on which the STA Statistics Request was received";
		case 8: "dot11QosCounters Group for UP6 for the Interface on which the STA Statistics Request was received";
		case 9: "dot11QosCounters Group for UP7 for the Interface on which the STA Statistics Request was received";
		case 10: "dot11BSSAverageAccessDelay Group";
		default: FormatString("Reserved (%d)", value);
	}
}

struct WiFiFrameReportSubelement
{
	switch ( UINT8(Framedata, Offset) )
	{
		case 1:
			_struct FrameCountReport
			{
				UINT8 SubelementID = WiFiFrameReportSubelementIDTable(this);
				UINT8 Length;
				while FrameReportEntries[UINT8( Framedata, Offset + 1 ) + FrameOffset + 2 <= WiFiPktLen]
				{
					struct FrameReportEntry
					{
						[DataFieldByteOrder = BigEndian]
						MacAddress TransmitAddress = MacTable(this);
						UINT48 BSSID;
						UINT8 PHYType;
						UINT8 AverageRCPI;
						UINT8 LastRSNI;
						UINT8 LastRCPI;
						UINT8 AntennaID;
						UINT16 FrameCount;
					}
				}
			}
		case 221: WiFiVendorSpecificInfo VendorSpecificInfo;
		default:
			_struct
			{
				UINT8 SubelementID = WiFiFrameReportSubelementIDTable(this);
				UINT8 Length;
				Blob( Length ) Data;
			}
	}
}

table WiFiFrameReportSubelementIDTable(value)
{
	switch(value)
	{
		case 1: "Frame Count Report";
		case 221: "Vendor Specific";
		default: FormatString("Reserved (%d)", value);
	}
}

struct WiFiBeaconReportSubelement
{
	switch ( UINT8(Framedata, Offset) )
	{
		case 1:
			_struct ReportedFrameBody
			{
				Switch(Property.ReportedFrameType)
				{
					case 0: WiFiBeacon BeaconFrameBody;
					case 1: WiFiMeasurementPilot MeasurementPilotFrameBody;
				}
			}
		case 221: WiFiVendorSpecificInfo VendorSpecificInfo;
		default:
			_struct
			{
				UINT8 SubelementID = WiFiBeaconReportSubElementIDTable(this);
				UINT8 Length;
				Blob( Length ) Data;
			}
	}
}

table WiFiIPIDefinitionsTable(value)
{
	switch(value)
	{
		case 0: "IPI   92 (IPI Measured Power (dBm))";
		case 1: "92 < IPI  89 (IPI Measured Power (dBm))";
		case 2: "89 < IPI  86 (IPI Measured Power (dBm))";
		case 3: "86 < IPI  83 (IPI Measured Power (dBm))";
		case 4: "83 < IPI  80 (IPI Measured Power (dBm))";
		case 5: "80 < IPI  75 (IPI Measured Power (dBm))";
		case 6: "75 < IPI  70 (IPI Measured Power (dBm))";
		case 7: "70 < IPI  65 (IPI Measured Power (dBm))";
		case 8: "65 < IPI  60 (IPI Measured Power (dBm))";
		case 9: "60 < IPI  55 (IPI Measured Power (dBm))";
		case 10: "55 < IPI (IPI Measured Power (dBm))";
		default: FormatString("Reserved (%d)", value);
	}
}

Table WiFiQuietCountTable(value)
{
	switch (value)
	{
		case 0: "Reserved";
		case 1: "The quiet interval will start during the beacon interval starting at the next TBTT";
		default: FormatString("%u", value);
	}
}

//From 802.11: 7.3.2.23 Quiet element
struct WiFiQuiet
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	UINT8 QuietCount = WiFiQuietCountTable(this);
	UINT8 QuietPeriod = this ? FormatString("%u", this) : "No periodic quiet interval is defined";
	UINT16 QuietDuration = FormatString("%u ms", this);
	UINT16 QuietOffset = FormatString("%u ms", this);
}

//From 802.11: 7.3.2.24 IBSS DFS element
struct WiFiIBSSDFS
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	[DataFieldByteOrder = BigEndian]
	MacAddress DFSOwner = MacTable(this);
	UINT8 DFSRecoveryInterval = FormatString("%u Beacon interval(s)", this);
	[ChannelMapStart = FrameOffset]
	while [FrameOffset - ChannelMapStart < Length - 7]
	{
		UINT8 ChannelNumber;
		UINT8 Map
		{
			UINT8 BSS:1 = FormatString("               (%s) %s", this.ToBitString, this ? "MPDU was received from another BSS or IBSS" : "MPDU was NOT received from another BSS or IBSS");
			UINT8 OFDMPreamble:1 = FormatString("      (%s) %s", this.ToBitString, this ? "At least one sequence of short training symbols was detected" : "None sequence of short training symbols was detected");
			UINT8 UnidentifiedSignal:1 = FormatString("(%s) %s", this.ToBitString, this ? "Significant power is detected" : "Significant power is NOT detected");
			UINT8 Radar:1 = FormatString("             (%s) %s", this.ToBitString, this ? "Radar was detected operating" : "Radar was NOT detected operating");
			UINT8 Unmeasured:1 = FormatString("        (%s) %s", this.ToBitString, this ? "Channel has not been measured" : "Channel has been measured");
			UINT8 Reserved:3 = FormatString("          (%s)", this.ToBitString);
		};
	}
}

//From 802.11: 7.3.2.32 TS Delay element
struct WiFiTSDelay
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	UINT32 Delay = FormatString("%u ms", this);
}

Table WiFiTCLASProcessingProcessingTable(value)
{
	switch (value)
	{
		case 0: "Incoming MSDU's higher layer parameters have to match to the parameters in all the associated TCLAS elements";
		case 1: "Incoming MSDU's higher layer parameters have to match to at least one of the associated TCLAS elements.";
		case 2: "Incoming MSDU's that do not belong to any other TS are classified to the TS for which this TCLAS Processing element is used";
		default: FormatString("Reserved (%d)", value);
	}
}

//From 802.11: 7.3.2.33 TCLAS Processing element
struct WiFiTCLASProcessing
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	UINT8 Processing = WiFiTCLASProcessingProcessingTable(this);
}

//From 802.11: 7.3.2.35 QoS Capability element
struct WiFiQoSCapability
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	WiFiQoSInfoField QoSInfo;
}

//From 802.11: 7.3.2.1 SSID element
struct WiFiSSID = WiFiSSIDValue
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	[WiFiSSIDValue = "BroadCast SSID", 
	Post.WiFiDescription = FormatString("%s, SSID = %s", WiFiDescription, WiFiSSIDValue)]
	switch
	{
		case Length > 0:
			[Post.WiFiSSIDValue = SSID]
			MbcString(Length) SSID;
	}
}

struct WiFiRate = FormatString ("%s BitRate = %s Mbps", Type ? "Mandatory" : "Optional", WiFiPrintRate(Rate))
{
	[WiFiRateValue]
	UINT8 Rate:7 = FormatString("(%s) %s Mbps", this.ToBitString, WiFiPrintRate(this));
	UINT8 Type:1 = FormatString("(%s) %s", this.ToBitString, this ? "Rate contained in the BSSBasicRateSet parameter" : "Rate NOT contained in the BSSBasicRateSet parameter");
}

//From 802.11: 7.3.2.2 Supported Rates element
struct WiFiSupportedRates = AllRates
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	[ratestart = FrameOffset, AllRates = ""]
	while [FrameOffset - ratestart < Length]
	{
		[Post.AllRates = (AllRates == "" ? FormatString("%s", WiFiPrintRate(WiFiRateValue)) : FormatString("%s, %s", AllRates, WiFiPrintRate(WiFiRateValue)))]
		WiFiRate Rate;
	}
}

//From 802.11: 7.3.2.4 DS Parameter Set element
struct WiFiDSParameterSet = FormatString ("%u", CurrentChannel)
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	[WiFiDescription = FormatString("%s, Channel = %u", WiFiDescription, CurrentChannel)]
	UINT8 CurrentChannel;
}
	
struct WiFiUnknownInfField
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	BLOB(Length) Data;
}

struct WiFiWPACapability = FormatString ("%s : %s", 
									 Unicast ? "Unicast uses Group key" : "Unicast does NOT use Group key", 
									 WiFiReplayCntTable(ReplayCntr))
{
	UINT16 Reserved1:1 = FormatString(" (%s)", this.ToBitString);
	UINT16 Unicast:1 = FormatString("   (%s) %s", this.ToBitString, this ?"Unicast uses Group key" : "Unicast does NOT use Group key");
	UINT16 ReplayCntr:2 = FormatString("(%s) %s", this.ToBitString, WiFiReplayCntTable(this));
	UINT16 Reserved2:12 = FormatString(" (%s)", this.ToBitString);
}

//From 802.11w: 7.3.2.25.3 RSN capabilities
struct WiFiRSNCapability
{
	UINT16 PreAuth:1 = FormatString("           (%s) Pre-Auth is %ssupported", this.ToBitString, this ? "" : "NOT ");
	UINT16 NoPairwise:1 = FormatString("        (%s) STA CAN%s support WEP default key 0 simultaneously with a pairwise key", this.ToBitString, this ? "NOT" : "");
	UINT16 PTKSAReplayCounter:2 = FormatString("(%s) %s", this.ToBitString, WiFiReplayCntTable(this));
	UINT16 GTKSAReplayCounter:2 = FormatString("(%s) %s", this.ToBitString, WiFiReplayCntTable(this));
	UINT16 MFPR:1 = FormatString("              (%s) Management Frame Protection is %srequired", this.ToBitString, this ? "" : "NOT ");
	UINT16 MFPC:1 = FormatString("              (%s) Management Frame Protection is %ssupported", this.ToBitString, this ? "" : "NOT ");
	UINT16 Reserved1:1 = FormatString("         (%s) Reserved", this.ToBitString);
	UINT16 PeerkeyEnabled:1 = FormatString("    (%s) Peerkey is %senabled", this.ToBitString, this ? "" : "NOT ");
	UINT16 Reserved2:6 = FormatString("         (%s) Reserved", this.ToBitString);
}

//From 802.11r: 7.3.2.47 Mobility domain information element (MDIE)
struct WiFiMobilityDomain
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	UINT16 MDID;
	UINT8 FTCapabilityandPolicy
	{
		UINT8 FastBSSTransitionoverDS:1 = FormatString("          (%s) %s", this.ToBitString, this ? "Enabled" : "Disabled");
		UINT8 ResourceRequestProtocolCapability:1 = FormatString("(%s) %s", this.ToBitString, this ? "Enabled" : "Disabled");
		UINT8 Reserved:6 = FormatString("                         (%s) Reserved", this.ToBitString);
	};
}

//From 802.11r: 7.3.2.48 Fast BSS transition information element (FTIE)
struct WiFiFastBSSTransition
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	UINT16 MICControl
	{
		UINT16 Reserved:8 = FormatString("                         (%s) Reserved", this.ToBitString);
		UINT16 InformationelementCount:8 = FormatString("(%s) %d", this.ToBitString, this);
	};
	Blob(16) MIC;
	Blob(32) ANonce;
	Blob(32) Snonce;
	while OptionalParameters[UINT8( Framedata, Offset + 1 ) + FrameOffset + 2 <= WiFiPktLen]
	{
		WiFiFastBSSTransitionParameter Parameter;
	}
}

struct WiFiFastBSSTransitionParameter
{
	switch ( UINT8(Framedata, Offset) )
	{
		case 1:
			_struct R1KHID
			{
				UINT8 SubelementID = WiFiFastBSSTransitionParameterTable(this);
				UINT8 Length;
				Blob(Length) R1KHID;
			}
		case 2:
			_struct GTK
			{
				UINT8 SubelementID = WiFiFastBSSTransitionParameterTable(this);
				UINT8 Length;
				UINT16 KeyInfo
				{
					UINT16 KeyID:2 = FormatString("   (%s) %d", this.ToBitString, this);
					UINT16 Reserved:14 = FormatString("(%s) Reserved", this.ToBitString);
				};
				UINT8 KeyLength;
				UINT64 RSC;
				Blob(Length - 11) Key;
			}
		case 3:
			_struct R0KHID
			{
				UINT8 SubelementID = WiFiFastBSSTransitionParameterTable(this);
				UINT8 Length;
				Blob(Length) R0KHID;
			}
		//From 802.11w: 7.3.2.48 Fast BSS transition information element (FTIE)
		case 4:
			_struct IGTK
			{
				UINT8 SubelementID = WiFiFastBSSTransitionParameterTable(this);
				UINT8 Length;
				UINT16 KeyID;
				UINT48 IPN;
				UINT8 KeyLength;
				Blob(24) Key;
			}
	}
}

table WiFiFastBSSTransitionParameterTable(value)
{
	switch(value)
	{
		case 1: "PMK-R1 key holder identifier (R1KH-ID)";
		case 2: "GTK";
		case 3: "PMK-R0 key holder identifier (R0KH-ID)";
		case 4: "IGTK";
		default: FormatString("Reserved (%d)", value);
	}
}

//From 802.11r: 7.3.2.49 Timeout Interval information element (TIE)
struct WiFiTimeoutInterval
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	UINT8 TimeoutIntervalType = WiFiTimeoutIntervalTypeTable(this);
	UINT32 TimeoutIntervalValue;
}

table WiFiTimeoutIntervalTypeTable(value)
{
	switch(value)
	{
		case 1: "Reassociation deadline interval(Units: Time units (TUs))";
		case 2: "Key lifetime interval(Units: Seconds)";
		case 3: "Association Comeback time(Units: Time units (TUs))";
		default: FormatString("Reserved (%d)", value);
	}
}

//From 802.11r: 7.3.2.50 RIC Data information element (RDIE)
struct WiFiRICDataInfo
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	UINT8 RDIEIdentifier;
	UINT8 ResourceDescriptorCount;
	UINT16 StatusCode = WiFiStatusTable(this);
}

//From 802.11r: 7.3.2.51 RIC Descriptor information element
struct WiFiRICDescriptorInfo
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	UINT8 ResourceType = WiFiRICDescriptorInfoResourceTypeTable(this);
	switch(ResourceType)
	{
		case 1:
			_struct BlockAckParameters
			{
				WiFiBlockAckParameterSet BlockAckParameterSet;
				UINT16 BlockAckTimeoutValue;
				UINT16 BlockAckStartingSequenceControl
				{
					UINT16 FragmentNumber:4 = FormatString("        ($s) %d", this.ToBitString, this);
					UINT16 StartingSequenceNumber:12 = FormatString("($s) %d", this.ToBitString, this);
				};
			}
		default:
			Blob(Length - 1) Variableparameters;
	}
}

//From 802.11w: 7.3.2.55 Management MIC information element
struct WiFiMMIE
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	UINT16 KeyID;
	UINT48 IPN;
	UINT64 MIC;
}

table WiFiRICDescriptorInfoResourceTypeTable(value)
{
	switch(value)
	{
		case 1: "Block Ack";
		default: FormatString("Reserved (%d)", value);
	}
}

//From 802.11y: 7.3.2.52 DSE Registered Location element
struct WiFiDSERegisteredLocation
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	Struct
	{
		UINT128 LaRes:6 = FormatString("          (%s) Latitude resolution",this.ToBitString);
		UINT128 Latitude:34 = FormatString("       (%s) SHOULD be normalized to within +/- 90 degrees.",this.ToBitString);
		UINT128 LoRes:6 = FormatString("          (%s) Longitude resolution",this.ToBitString);
		UINT128 Longitude:34 = FormatString("      (%s) SHOULD be normalized to within +/- 180 degrees.",this.ToBitString);
		UINT128 AT:4 = FormatString("             (%s) Altitude Type for altitude.",this.ToBitString);
		UINT128 AltRes:6 = FormatString("         (%s) Altitude resolution.",this.ToBitString);
		UINT128 Altitude:30 = FormatString("       (%s) A 30 bit value defined by the AT field.",this.ToBitString);
		UINT128 Datum:3 = FormatString("          (%s) The Map Datum used for the coordinates given in this Option.",this.ToBitString);
		UINT128 RegLocAgreement:1 = FormatString("(%s) %s", this.ToBitString, this ? "The STA is operating within a national policy area or an international agreement area near a national border" : "The STA is NOT operating within a national policy area or an international agreement area near a national border");
		UINT128 RegLocDSE:1 = FormatString("      (%s) %s", this.ToBitString, this ? "The enabling STA is enabling the operation of STAs with DSE" : "The enabling STA is NOT enabling the operation of STAs with DSE");
		UINT128 DependentSTA:1 = FormatString("   (%s) %s", this.ToBitString, this ? "The STA is operating with the enablement of the enabling STA whose LCI is being reported" : "The STA is NOT operating with the enablement of the enabling STA whose LCI is being reported");
		UINT128 Reserved:2 = FormatString ("      (%s)", this.ToBitString);
	};
	UINT16 DependentEnablementIdentifier;
	UINT8 RegulatoryClass;
	UINT8 ChannelNumber;
}

//From 802.11y: 7.3.2.53 Extended Channel Switch Announcement element
struct WiFiExtendedChannelSwitchAnnouncementElement
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	UINT8 ChannelSwitchMode = this ? "Shall transmit no further frames within the BSS until the scheduled channel switch" : "No requirement imposed on the receiving STA";
	UINT8 NewRegulatoryClass;
	UINT8 NewChannelNumber;
	UINT8 ChannelSwitchCount = WiFiChannelSwitchAnnouncementCountMeaningTable(this);
}

//From 802.11y: 7.3.2.54 Supported Regulatory Classes element
struct WiFiSupportedRegulatoryClasses
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	UINT8 CurrentRegulatoryClass;
	_struct ListOfRegulatoryClasses
	{
		UINT8 RegulatoryClasses[Length - 1];
	}
}

struct WiFiExtCap = FormatString ("Legacy1x:%s ; WPS:%s", Legacy1x ? "Enabled" : "Disabled", WPS ? "Enabled" : "Disabled")
{
	UINT8 Legacy1x:1 = FormatString(" (%s) %s", this.ToBitString, this ? "Enabled" : "Disabled");
	UINT8 WPS:1 = FormatString("      (%s) %s", this.ToBitString, this ? "Enabled" : "Disabled");
	UINT8 Reserved:6 = FormatString ("(%s)", this.ToBitString);
}

Table WPSMultCipherTbl(value)
{
	switch (value)
	{
		case 0: "None";
		case 1: "WEP40";
		case 2: "WEP104";
		case 3: "TKIP";
		case 4: "CCMP";
		case 5: "CKIP_CMIC";
		case 6: "CKIP";
		case 7: "CMIC";
		default: FormatString("Undefined Value(%u)", value);
	}
}

struct WiFiSSIDCap
{
	UINT32 MulticastCipher:4 = FormatString("     (%s) %s", this.ToBitString, WPSMultCipherTbl(this));
	UINT32 UCCipherNone:1 = FormatString("        (%s) %s", this.ToBitString, this ? "Not Support Pairwise encryption keys" : "Support Pairwise encryption keys");
	UINT32 UCCipherWep40:1 = FormatString("       (%s) %s", this.ToBitString, this ? "Support Wep40" : "Not Support Wep40");
	UINT32 UCCipherWep104:1 = FormatString("      (%s) %s", this.ToBitString, this ? "Support Wep104" : "Not Support Wep104");
	UINT32 UCCipherTkip:1 = FormatString("        (%s) %s", this.ToBitString, this ? "Support Tkip" : "Not Support Tkip");
	UINT32 UCCipherCcmp:1 = FormatString("        (%s) %s", this.ToBitString, this ? "Support Ccmp" : "Not Support Ccmp");
	UINT32 UCCipherCkipCmic:1 = FormatString("    (%s) %s", this.ToBitString, this ? "Support CkipCmic" : "Not Support CkipCmic");
	UINT32 UCCipherCkip:1 = FormatString("        (%s) %s", this.ToBitString, this ? "Support Ckip" : "Not Support Ckip");
	UINT32 UCCipherCmic:1 = FormatString("        (%s) %s", this.ToBitString, this ? "Support Cmic" : "Not Support Cmic");
	UINT32 UCCipherWpa2Wep40:1 = FormatString("   (%s) %s", this.ToBitString, this ? "Support Wpa2Wep40" : "Not Support Wpa2Wep40");
	UINT32 UCCipherWpa2Wep104:1 = FormatString("  (%s) %s", this.ToBitString, this ? "Support Wpa2Wep104" : "Not Support Wpa2Wep104");
	UINT32 UCCipherWpa2Tkip:1 = FormatString("    (%s) %s", this.ToBitString, this ? "Support Wpa2Tkip" : "Not Support Wpa2Tkip");
	UINT32 UCCipherWpa2Ccmp:1 = FormatString("    (%s) %s", this.ToBitString, this ? "Support Wpa2Ccmp" : "Not Support Wpa2Ccmp");
	UINT32 UCCipherWpa2CkipCmic:1 = FormatString("(%s) %s", this.ToBitString, this ? "Support Wpa2CkipCmic" : "Not Support Wpa2CkipCmic");
	UINT32 UCCipherWpa2Ckip:1 = FormatString("    (%s) %s", this.ToBitString, this ? "Support Wpa2Ckip" : "Not Support Wpa2Ckip");
	UINT32 UCCipherWpa2Cmic:1 = FormatString("    (%s) %s", this.ToBitString, this ? "Support Wpa2Cmic" : "Not Support Wpa2Cmic");
	UINT32 Reserved1:5 = FormatString("           (%s)", this.ToBitString);
	UINT32 AKMUnused:1 = FormatString("           (%s)", this.ToBitString);
	UINT32 AKMWpa11X:1 = FormatString("           (%s) %s", this.ToBitString, this ? "Support Wpa11X" : "Not Support Wpa11X");
	UINT32 AKMWpa1Psk:1 = FormatString("          (%s) %s", this.ToBitString, this ? "Support Wpa1Psk" : "Not Support Wpa1Psk");
	UINT32 AKMWpa21X:1 = FormatString("           (%s) %s", this.ToBitString, this ? "Support Wpa21X" : "Not Support Wpa21X");
	UINT32 AKMWpa2Psk:1 = FormatString("          (%s) %s", this.ToBitString, this ? "Support Wpa2Psk" : "Not Support Wpa2Psk");
	UINT32 AKMWpa1Cckm:1 = FormatString("         (%s) %s", this.ToBitString, this ? "Support Wpa1Cckm" : "Not Support Wpa1Cckm");
	UINT32 AKMWpa2Cckm:1 = FormatString("         (%s) %s", this.ToBitString, this ? "Support Wpa2Cckm" : "Not Support Wpa2Cckm");
	UINT32 Reserved2:1 = FormatString("           (%s)", this.ToBitString);
}

struct WiFiWPSSSID = SSID
{
	WiFiExtCap ExtendedCapability;
	WiFiSSIDCap SSIDCapability;
	UINT8 SSIDlen;
	MbcString(SSIDlen) SSID;
}
	
struct WiFiWPS(len)
{
	UINT8 OUIType = "WPS";
	WiFiExtCap PrSSIDExtCapab;
	switch
	{
		case (len > 2):
			struct SSID
			{
				UINT8 SSIDCount;
				WiFiWPSSSID HiddenSSID[SSIDCount];
			}
	}
}

Table WiFiMaxSPLengthTable(value)
{
	switch (value)
	{
		case 0: "AP may deliver all buffered MSDUs and MMPDUs";
		case 1: "AP may deliver a maximum of two MSDUs and MMPDUs per SP";
		case 2: "AP may deliver a maximum of four MSDUs and MMPDUs per SP";
		case 3: "AP may deliver a maximum of six MSDUs and MMPDUs per SP";
		default: FormatString("Unknown operation mode(%u)", value);
	}
}

//From 802.11: 7.3.1.17 QoS Info field
struct WiFiQosInfoField
{
	switch
	{
		case (Property.WiFiDS == 0):
			_struct SubType02
			{
				UINT8 ACVO:1 = FormatString("       (%s) %s", this.ToBitString, this == 1 ? "Enabled" : "Disabled");
				UINT8 ACVI:1 = FormatString("       (%s) %s", this.ToBitString, this == 1 ? "Enabled" : "Disabled");
				UINT8 ACBK:1 = FormatString("       (%s) %s", this.ToBitString, this == 1 ? "Enabled" : "Disabled");
				UINT8 ACBE:1 = FormatString("       (%s) %s", this.ToBitString, this == 1 ? "Enabled" : "Disabled");
				UINT8 QAck:1 = FormatString("       (%s) %s", this.ToBitString, this ? "MIB attribute dot11QAckOptionImplemented is true" : "MIB attribute dot11QAckOptionImplemented is false");
				UINT8 MaxSPLength:2 = FormatString("(%s) %d", this.ToBitString, WiFiMaxSPLengthTable(this));
				UINT8 MoreDataAck:1 = FormatString("(%s) %s", this.ToBitString, this ? "Can process Ack frames with the More Data bit set to 1" : "Can NOT process Ack frames with the More Data bit set to 1");
			}
		default:
			_struct SubTypeOther
			{
				switch
				{
					case Property.WiFiSupportQos:
						_struct IEEE80211E
						{
							UINT8 EDCAParameterSetUpdateCount:4 = FormatString("(%s) %d", this.ToBitString, this);
							UINT8 QAck:1 = FormatString("                       (%s) %s", this.ToBitString, this ? "MIB attribute dot11QAckOptionImplemented is true" : "MIB attribute dot11QAckOptionImplemented is false");
							UINT8 QueueRequest:1 = FormatString("               (%s) %s", this.ToBitString, this ? "Can process a nonzero Queue Size" : "Can NOT process a nonzero Queue Size");
							UINT8 TXOP:1 = FormatString("                       (%s) %s", this.ToBitString, this ? "can process a nonzero TXOP Duration Requested" : "can NOT process a nonzero TXOP Duration Requested");
							UINT8 Reserved:1 = FormatString("                   (%s) %s", this.ToBitString, "Reserved");
						}
					default:
						_struct WMM
						{
							UINT8 ParameterSetCount:4 = FormatString ("(%s) %d", this.ToBitString, this);
							UINT8 QAck:1 = FormatString("              (%s) %s", this.ToBitString, this ? "MIB attribute dot11QAckOptionImplemented is true" : "MIB attribute dot11QAckOptionImplemented is false");
							UINT8 QueueRequest:1 = FormatString("      (%s) %s", this.ToBitString, this ? "Can process a nonzero Queue Size" : "Can NOT process a nonzero Queue Size");
							UINT8 TXOP:1 = FormatString("              (%s) %s", this.ToBitString, this ? "can process a nonzero TXOP Duration Requested" : "can NOT process a nonzero TXOP Duration Requested");
							UINT8 Reserved:1 = FormatString("             (%s) %s", this.ToBitString, this == 1 ? "AP Supports Unscheduled Power Save Delivery" : "Disabled");
						}
				}
			}
	}
}

Table WiFiWMMOUISubTypeTable(code)
{
	switch (code)
	{
		case 0: "WMM Information Element";
		case 1: "WMM Parameter Element";
		case 2: "WMM TSPEC Element";
	}
}

Table WiFiWMMDirectionTable(code)
{
	switch(code)
	{
		case 0: "Uplink";
		case 1: "Downlink";
		case 2: "Reserved";
		case 3: "Bi-directional";
	}
}

struct WiFiWMM(len) = OUISubType.ToString
{
	UINT8 OUIType = "WMM";
	UINT8 OUISubType = WiFiWMMOUISubTypeTable(this);
	UINT8 Version;
	switch (OUISubType)
	{
		case 0:
			struct WMMIE
			{
				WiFiQosInfoField QosInfo;
			}
		case 1:
			struct ACParam
			{
				WiFiQosInfoField QosInfo;
				UINT8 Reserved;
				WiFiEDCAParameterAC EDCAParameterAC[4];
			}
		case 2:
			struct TSPEC
			{
				UINT24 TSInfo
				{
					UINT24 Reserved1:1 = FormatString("(%s)", this.ToBitString);
					UINT24 TID:4 = FormatString("      (%s) %u", this.ToBitString, this);
					UINT24 Direction:2 = FormatString("(%s) %s", this.ToBitString, WiFiWMMDirectionTable(this));
					UINT24 Unused1:1 = FormatString("  (%s) Set to 1", this.ToBitString);
					UINT24 Unused2:1 = FormatString("  (%s) Set to 0", this.ToBitString);
					UINT24 Reserved2:1 = FormatString("(%s)", this.ToBitString);
					UINT24 PSB:1 = FormatString("      (%s) %s", this.ToBitString, this ? "U-APSD" : "Legacy");
					UINT24 UP:3 = FormatString("       (%s) %u", this.ToBitString, this);
					UINT24 Reserved3:10 = FormatString("(%s)", this.ToBitString);
				};
				UINT16 NominalMSDUSize
				{
					UINT16 Size:15 = FormatString(" (%s) %u octet(s)", this.ToBitString, this);
					UINT16 Fixed:1 = FormatString("(%s) %s", this.ToBitString, this ? "Fixed" : "Not fixed");
				};
				UINT16 MaximumMSDUSize = FormatString("%u octet(s)", this);
				UINT32 MinimumServiceInterval = FormatString("%u microsecond(s)", this);
				UINT32 MaximumServiceInterval = FormatString("%u microsecond(s)", this);
				UINT32 InactivityInterval = FormatString("%u microsecond(s)", this);
				UINT32 SuspensionInterval = FormatString("%u microsecond(s)", this);
				UINT32 ServiceStartTime = FormatString("%u microsecond(s)", this);
				UINT32 MinimumDataRate = FormatString("%u bps", this);
				UINT32 MeanDataRate = FormatString("%u bps", this);
				UINT32 PeakDataRate = FormatString("%u bps", this);
				UINT32 MaximumBurstSize = FormatString("%u octet(s)", this);
				UINT32 DelayBound = FormatString("%u microsecond(s)", this);
				UINT32 MinimumPHYRate = FormatString("%u bps", this);
				struct SurplusBandwidthAllowancefield
				{
					UINT16 IntegerPart:13 = FormatString("(%s) %u", this.ToBitString, this);
					UINT16 DecimalPart:3 = FormatString("(%s)", this.ToBitString);
				};
				UINT16 MediumTime = FormatString("%u microsecond(s)/s", this * 32);
			}
	}
}

struct WiFiWPA(len)
{
	UINT8 OUIType;
	UINT16 Version;
	switch
	{
		case (len >= 7):
			WiFiCipherSuiteSelector GroupCipher;
	}
	switch
	{
		case (len >= 9):
		struct PareClipher
		{
			UINT16 NumPairCipher;
			switch 
			{
				case NumPairCipher > 0:
					WiFiCipherSuiteSelector PairCipher[NumPairCipher];
			}
		}
	}
	switch
	{
		case (len >= 11 + PareClipher.NumPairCipher * 4):
		struct AKM
		{
			UINT16 AKMSuiteCount;
			switch
			{
				case AKMSuiteCount > 0:
					WiFiAKM AKMSuite[AKMSuiteCount];
			}
		}
	}
	switch
	{
		case (len >= 13 + PareClipher.NumPairCipher*4 + AKM.AKMSuiteCount*4):
			WiFiWPACapability Capability;
	}
}

//From 802.11: 7.3.2.26 Vendor Specific information element
struct WiFiVendorSpecificInfo = FormatString("OUI=%s, FieldType=%s", OUITable(OUI), FieldType)
{
	[FieldType = "Unknown"]
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	OUI OUI;
	switch ( OUI )
	{
		case 0x0050F2:
			switch(UINT8( Framedata, Offset ))
			{
				case 1:
					[FieldType="WPA"]
					WiFiWPA(Length - 3) WPA;
				case 2:
					[FieldType="WMM"]
					WiFiWMM(Length - 3) WMM;
				case 5:
					[FieldType="WPS"]
					WiFiWPS(Length-3) WPS;
				case 6:
					[FieldType="PSDP"]
					PSDP(Length - 3) PSDP;
				default:
					BLOB(Length - 3) Data;
			}
		default:
			struct
			{
				BLOB(Length - 3) Data;
			}
	}
}

//From 802.11: 7.3.2.3 FH Parameter Set element
struct WiFiFHParameterSet
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	UINT16 DwellTime = FormatString("%u ms", this);
	UINT8 HopSet;
	UINT8 HopPattern;
	UINT8 HopIndex;
}

//From 802.11: 7.3.2.5 CF Parameter Set element
struct WiFiCFParameterSet
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	UINT8 CFPCount;
	UINT8 CFPPeriod;
	UINT16 CFPMaxDuration = FormatString("%u ms", this);
	UINT16 CFPDurRemaining = FormatString("%u ms", this);
}

//From 802.11: 7.3.2.7 IBSS Parameter Set element
struct WiFiIBSSParameterSet
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	UINT16 ATIMWindow = FormatString("%u ms", this);
}

Table WiFiTIMDTIMPeriodTable(code)
{
	switch (code)
	{
		case 0: "Reserved";
		case 1: "All TIMs are DTIMs";
		default: FormatString("%u", code);
	}
}

//From 802.11: 7.3.2.6 TIM
struct WiFiTIM = FormatString ("DTIMCount = %d, DTIMPeriod = %d", DTIMCount, DTIMPeriod)
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	UINT8 DTIMCount = this ? FormatString("%u", DTIMCount) : "The current TIM is a DTIM";
	UINT8 DTIMPeriod = WiFiTIMDTIMPeriodTable(this);
	UINT8 BitmapControl
	{
		UINT8 TrafficIndicator:1 = FormatString("(%s) %s", this.ToBitString, this ? "One or more broadcast or multicast frames are buffered at the AP" : "None broadcast or multicast frames are buffered at the AP");
		UINT8 BitmapOffset:7 = FormatString("    (%s) %u", this.ToBitString, this);
	};
	UINT8 VirtualBitmap[Length-3];
}

struct WiFiERP = Flags.NonERPPresent? "Non-802.11g STA present" : "No Non-802.11g STA present"
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	struct Flags
	{
		UINT8 NonERPPresent:1 = FormatString("  (%s) %s", this.ToBitString, this ? "There are NonERP STAs associated with the BSS" : "There are no NonERP STAs associated with the BSS");
		UINT8 Protection:1 = FormatString("     (%s) %s", this.ToBitString, this? "Use Protection" : "Protection not required");
		UINT8 Preamble:1 = FormatString("       (%s) %s", this.ToBitString, this? "One or more associated NonERP STAs are long preamble capable" : "Preamble type not advocated");
		UINT8 Reserved:5 = FormatString("       (%s)", this.ToBitString);
	}
}

//From 802.11: 7.3.2.25.2 AKM suites
struct WiFiAKM = WiFiAKMSuiteTable(CipherOUI,SuiteType)
{
	OUI CipherOUI;
	UINT8 SuiteType;
}

//From 802.11: 7.3.2.25.1 Cipher suites
struct WiFiCipherSuiteSelector = WiFiCipherSuiteTable(CipherOUI,SuiteType)
{
	OUI CipherOUI;
	UINT8 SuiteType;
}

//From 802.11: 7.3.2.25 RSN information element
struct WiFiRSN
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	UINT16 Version;
	
	// Rest of the fields are optional, have to check the length
	switch
	{
		case (Length >= 6):
			WiFiCipherSuiteSelector GroupCipher;
	}
	
	switch
	{
		case (Length >= 8):
			UINT16 NumPairCipher;
	}
	
	switch
	{
		case (Length >= 8 + NumPairCipher*4):
			WiFiCipherSuiteSelector PairCipher[NumPairCipher];
	}
	
	switch
	{
		case (Length >= 10 + NumPairCipher*4):
			UINT16 AKMSuiteCount;
	}
	
	switch
	{
		case (Length >= 10 + NumPairCipher*4 + AKMSuiteCount*4):
			WiFiAKM AKMSuite[AKMSuiteCount];
	}
	
	switch
	{
		case (Length >= 12 + NumPairCipher*4 + AKMSuiteCount*4):
			WiFiRSNCapability Capability;
	}
	
	switch
	{
		case (Length >= 14 + NumPairCipher*4 + AKMSuiteCount*4):
			UINT16 PMKIDCount;
	}
	
	switch
	{
		case (Length >= 14 + NumPairCipher*4 + AKMSuiteCount*4 + PMKIDCount*16):
			BLOB(16) PMKID[PMKIDCount];
	}
}

struct WiFiInformationFields
{
	//check if the length of the remain data is enough to parse the option data
	while [UINT8( Framedata, Offset + 1 ) + FrameOffset + 2 <= WiFiPktLen]
	{
		switch(UINT8( Framedata, Offset ))
		{
			//802.11
			case 0x00: WiFiSSID ssid;
			case 0x01: WiFiSupportedRates rates;
			case 0x02: WiFiFHParameterSet FHParams;
			case 0x03: WiFiDSParameterSet Channel;
			case 0x04: WiFiCFParameterSet CFParams;
			case 0x05: WiFiTIM TIM;
			case 0x06: WiFiIBSSParameterSet IBSSParams;
			case 0x07: WiFiCountry Country;
			case 0x08: WiFiHoppingPatternParameters PatternParameters;
			case 0x09: WiFiHoppingPatternTable HoppingPatternTable;
			case 0x0A: WiFiRequest Request;
			case 0x0B: WiFiBSSLoad BSSLoad;
			case 0x0C: WiFiEDCAParameterSet EDCAParameterSet;
			case 0x0D: WiFiTSPEC TSPEC;
			case 0x0E: WiFiTCLAS TCLAS;
			case 0x0F: WiFiSchedule Schedule;
			case 0x10: WiFiChallengeText ChallengeText;
			case 0x20: WiFiPowerConstraint PowerConstraint;
			case 0x21: WiFiPowerCapability PowerCapability;
			case 0x22: WiFiTPCRequest TPCRequest;
			case 0x23: WiFiTPCReport TPCReport;
			case 0x24: WiFiSupportedChannels SupportedChannels;
			case 0x25: WiFiChannelSwitchAnnouncement ChannelSwitchAnnouncement;
			case 0x26: WiFiMeasurementRequest MeasurementRequest;
			case 0x27: WiFiMeasurementReport MeasurementReport;
			case 0x28: WiFiQuiet Quiet;
			case 0x29: WiFiIBSSDFS IBSSDFS;
			case 0x2A: WiFiERP ERP;
			case 0x2B: WiFiTSDelay TSDelay;
			case 0x2C: WiFiTCLASProcessing TCLASProcessing;
			case 0x2E: WiFiQoSCapability QoSCapability;
			case 0x30: WiFiRSN RSN;
			case 0x32: WiFiSupportedRates ExtendedRates;
			
			//802.11k
			case 0x33: WiFiAPChannelReport APChannelReport;
			case 0x34: WiFiNeighborReport NeighborReport;
			case 0x35: WiFiRCPI RCPI;
			case 0x3F: WiFiBSSAverageAccessDelay BSSAverageAccessDelay;
			case 0x40: WiFiAntennaInformation AntennaInformation;
			case 0x41: WiFiRSNI RSNI;
			case 0x42: WiFiMeasurementPilotTransInfo MeasurementPilotTransInfo;
			case 0x43: WiFiBSSAvailableAdmissionCapacity BSSAvailableAdmissionCapacity;
			case 0x44: WiFiBSSACAccessDelay BSSACAccessDelay;
			case 0x46: WiFiRRMEnabledCapabilities RRMEnabledCapabilities;
			case 0x47: WiFiMultipleBSSID MultipleBSSID;
			
			//802.11r
			case 0x36: WiFiMobilityDomain MobilityDoman;
			case 0x37: WiFiFastBSSTransition FastBSSTransition;
			case 0x38: WiFiTimeoutInterval TimeoutInterval;
			case 0x39: WiFiRICDataInfo RICDataInfo;
			case 0x4B: WiFiRICDescriptorInfo RICDescriptorInfo;
			
			//802.11y
			case 0x3A: WiFiDSERegisteredLocation DSERegisteredLocation;
			case 0x3B: WiFiSupportedRegulatoryClasses SupportedRegulatoryClasses;
			case 0x3C: WiFiExtendedChannelSwitchAnnouncementElement ExtendedChannelSwitchAnnouncement;
			
			//802.11n
			case 0x2D: WiFiHTCapabilities HTCapabilities;
			case 0x3D: WiFiHTOperation HTOperation;
			case 0x3E: WiFiSecondaryChannelOffset SecondaryChannelOffset;
			case 0x48: WiFi20and40BSSCoexistence BSSCoexistence;
			case 0x49: WiFi20and40BSSIntolerantChannelReport BSSIntolerantChannelReport;
			case 0x4A: WiFiOverlappingBSSScanParameters OverlappingBSSScanParameters;
			
			//802.11w
			case 0x4C: WiFiMMIE MMIE;
			
			case 0x7F: WiFiExtendedCapabilities ExtendedCapabilities;
			case 0xDD: WiFiVendorSpecificInfo VendorSpecificInfo;
			
			default: WiFiUnknownInfField UnknownIE;
		}
	}
}

//From 802.11-2007:7.3.1.8 AID field
struct WiFiAssocID = FormatString("%d", AssociationIDValue)
{
	UINT16 AssociationIDValue:14 = FormatString("(%s) %d", this.ToBitString, this);
	UINT16 ReservedBits:2 = FormatString("      (%s)", this.ToBitString);
}

//From 802.11-2007:7.2.3.1 Beacon frame format
struct WiFiBeacon = FormatString("%s with SSID [%s]",(Property.WiFiSubType == 8)? "Beacon" : "Probe Response", WiFiSSIDValue)
{
	WTimeStamp TimeStamp;
	UINT16 BeaconInterval = FormatString("%d ms", this);
	WiFiCapability Capability;
	WiFiInformationFields InformationElements;
}

//From 802.11: 7.2.3.8 Probe Request frame format
struct WiFiPrbReq
{
	WiFiInformationFields InformationElements;
}

//From 802.11: 7.2.3.10 Authentication frame format
struct WiFiAuth
{
	switch
	{
		//Shared Key Step3
		case UINT16(FrameData, FrameOffset) == 1 && WiFiEncrypted:
			WiFiWEPPayload WPayload = "WEP MPDU";
		default:
			_struct others
			{	
				UINT16 AuthAlgo = WiFiAuthenticationAlgoTable(this);
				[AuthSeq]
				UINT16 AuthSequence;
				switch(AuthAlgo)
				{
					//Open System
					case 0:
						switch(property.AuthSeq)
						{
							case 1:					
								_struct OpenSystemStep1
								{
									UINT16 Reserved;
								}
							case 2:
								_struct OpenSystemStep2
								{
									UINT16 Status = WiFiStatusTable(this);
								}
						}
					//Shared Key
					case 1:
						switch(property.AuthSeq)
						{
							case 1:
								struct SharedKeyStep1
								{
									UINT16 Reserved;						
								}
							case 2:
								struct SharedKetStep2
								{
									UINT16 Status = WiFiStatusTable(this);
									WiFiChallengeText ChallengeText;
								}
							case 3:
								//#? encrypted, will not be captured?
								struct SharedKeyStep3
								{
									UINT16 Reserved;
									WiFiChallengeText ChallengeText;
								}
							case 4:
								struct SharedKeyStep4
								{
									UINT16 Status = WiFiStatusTable(this);
								}
						}
				}
			}
	}
}

//From 802.11: 7.2.3.4 Association Request frame format
struct WiFiAssReq
{
	WiFiCapability Capability;
	UINT16 ListenInterval = FormatString("%u BeaconInterval(s)", this);
	WiFiInformationFields InformationElements;
}

//Fro, 802.11: 7.2.3.6 Reassociation Request frame format
struct WiFiReAssReq
{
	WiFiCapability Capability;
	UINT16 ListenInterval = FormatString("%u BeaconInterval(s)", this);
	[DataFieldByteOrder = BigEndian]
	MacAddress CurrentAP = MacTable(this);
	WiFiInformationFields InformationElements;
}

//From 802.11:7.2.3.5 Association Response frame format
struct WiFiAssRes
{
	WiFiCapability Capability;
	UINT16 Status = WiFiStatusTable(this);
	WiFiAssocID AssociationID;
	WiFiInformationFields InformationElements;
}

//From 802.11:7.2.3.3 Disassociation frame format
struct WiFiDisAssoc = Reason.ToString
{
	UINT16 Reason = WiFiReasonTable(this);
	WiFiInformationFields InformationElements;
}

Table WiFiActionCategoryTable(value)
{
	switch 
	{
		case value == 0: "Spectrum management";
		case value == 1: "Qos";
		case value == 2: "DLS";
		case value == 3: "Block Ack";
		case value == 4: "Public";
		case value == 5: "Radio measurement";
		case value == 6: "Fast BSS Transition";
		case value == 7: "HT";
		case value == 8: "SA Query";
		case value == 9: "Protected Dual of Public Action";
		case value == 126: "Vendor specific Protected";
		case value == 127: "Vendor-specific";
		case value <= 127: FormatString("Reserved (%d)", value);
		default: FormatString("Error (%d)", value);
	}
}

Table WiFiActionSpectrumActionTable(value)
{
	switch (value)
	{
		case 0: "Measurement Request";
		case 1: "Measurement Report";
		case 2: "TPC Request";
		case 3: "TPC Report";
		case 4: "Channel Switch Announcement";
		default: FormatString("Reserved (%d)", value);
	}
}

Table WiFiActionQoSActionTable(value)
{
	switch (value)
	{
		case 0: "ADDTS Request";
		case 1: "ADDTS Response";
		case 2: "DELTS";
		case 3: "Schedule";
		default: FormatString("Reserved (%d)", value);
	}
}

Table WiFiActionDLSActionTable(value)
{
	switch (value)
	{
		case 0: "DLS Request";
		case 1: "DLS Response";
		case 2: "DLS Teardown";
		default: FormatString("Reserved (%d)", value);
	}
}

Table WiFiActionBlockAckActionTable(value)
{
	switch (value)
	{
		case 0: "ADDBA Request";
		case 1: "ADDBA Response";
		case 2: "DELBA";
		default: FormatString("Reserved (%d)", value);
	}
}

Table WiFiRadioMeasurementActionTable(value)
{
	switch (value)
	{
		case 0: "Radio Measurement Request";
		case 1: "Radio Measurement Report";
		case 2: "Link Measurement Request";
		case 3: "Link Measurement Report";
		case 4: "Neighbor Report Request";
		case 5: "Neighbor Report Response";
		default: FormatString("Reserved (%d)", value);
	}
}

//From 802.11: 7.3.1.11 Action field
struct WiFiAction
{
	UINT8 Category = WiFiActionCategoryTable(this);
	switch (Category)
	{
		case 0: WiFiSpectrumManagementAction Spectrum;
		case 1: WiFiQoSAction QoS;
		case 2: WiFiDLSAction DLS;
		case 3: WiFiBlockAckAction BlockAck;
		case 4: WiFiPublicAction Public;
		case 5: WiFiRadioMeasurementAction RadioMeasurement;
		case 6: WiFiFastBSSTransitionAction FastBSSTransition;
		case 7: WiFiHTAction HTAction;
		case 8: WiFiSAQueryActionFrameDetails SAQueryActionFrameDetails;
		case 9: WiFiProtectedDualOfPublicAction ProtectedDualOfPublicAction;
		case 127: WiFiVendorSpecificInfo VendorSpecificInfo;
		default:_struct Error{}
	}
}

//From 802.11: 7.4.1 Spectrum management action details
struct WiFiSpectrumManagementAction
{
	UINT8 Action = WiFiActionSpectrumActionTable(this);
	switch (Action)
	{
		case 0: 
			_struct MsrmtRequest
			{
				UINT8 DialogToken;
				while [FrameOffset < WiFiPktLen]
				{
					WiFiMeasurementRequest MsrmtRequest;
				}
			}
		case 1: 
			_struct MsrmtReport
			{
				UINT8 DialogToken;
				while [FrameOffset < WiFiPktLen]
				{
					WiFiMeasurementReport MsrmtReport;
				}
			}
		case 2: 
			_struct TPCRequest
			{
				UINT8 DialogToken;
				WiFiTPCRequest TPCRequest;
			}
		case 3: 
			_struct TPCReport
			{
				UINT8 DialogToken;
				WiFiTPCReport TPCReport;
			}
		case 4: 
			_struct ChannelSwitch
			{
				WiFiInformationFields ChannelSwitchInfo;
			}
	}
}

//From 802.11: 7.4.2 QoS Action frame details
struct WiFiQoSAction
{
	UINT8 Action = WiFiActionQoSActionTable(this);
	switch (Action)
	{
		case 0:
			_struct ADDTSRequest
			{
				UINT8 DialogToken;
				WiFiInformationFields InformationFields;
			}
		case 1:
			_struct ADDTSResponse
			{
				UINT8 DialogToken;
				UINT16 Status = WiFiStatusTable(this);
				WiFiInformationFields InformationFields;
			}
		case 2:
			_struct DELTS
			{
				WiFiTSPEC TSInfo;
				UINT16 Reason = WiFiReasonTable(this);
			}
		case 3:
			_struct Schedule
			{
				WiFiSchedule Schedule;
			}
	}
}

//From 802.11: 7.4.3 DLS Action frame details
struct WiFiDLSAction
{
	UINT8 Action = WiFiActionDLSActionTable(this);
	switch (Action)
	{
		case 0:
			_struct DLSRequest
			{
				[DataFieldByteOrder = BigEndian]
				MacAddress Destination = MacTable(this);
				[DataFieldByteOrder = BigEndian]
				MacAddress Source = MacTable(this);
				WiFiCapability CapabilityInformation;
				UINT16 DLSTimeoutValue;
				WiFiInformationFields InformationFields;
			}
		case 1:
			_struct DLSResponse
			{
				UINT16 Status = WiFiStatusTable(this);
				[DataFieldByteOrder = BigEndian]
				MacAddress Destination = MacTable(this);
				[DataFieldByteOrder = BigEndian]
				MacAddress Source = MacTable(this);
				WiFiCapability CapabilityInformation;
				WiFiInformationFields InformationFields;
			}
		case 2:
			_struct DLSTeardown
			{
				[DataFieldByteOrder = BigEndian]
				MacAddress Destination = MacTable(this);
				[DataFieldByteOrder = BigEndian]
				MacAddress Source = MacTable(this);
				UINT16 Reason = WiFiReasonTable(this);
			}
	}
}

//From 802.11: 7.4.4 Block Ack Action frame details
struct WiFiBlockAckAction
{
	UINT8 Action = WiFiActionBlockAckActionTable(this);
	switch (Action)
	{
		case 0:
			_struct ADDBARequest
			{
				UINT8 DialogToken;
				WiFiBlockAckParameterSet BlockAckParameterSet;
				UINT16 BlockAckTimeoutValue;
				UINT16 BlockAckStartingSequenceControl
				{
					UINT16 FragmentNumber:4 = FormatString("        ($s) %d", this.ToBitString, this);
					UINT16 StartingSequenceNumber:12 = FormatString("($s) %d", this.ToBitString, this);
				};
			}
		case 1:
			_struct ADDBAResponse
			{
				UINT8 DialogToken;
				UINT16 Status = WiFiStatusTable(this);
				WiFiBlockAckParameterSet BlockAckParameterSet;
				UINT16 BlockAckTimeoutValue;
			}
		case 2:
			_struct DELBA
			{
				WiFiDELBAParameterSet DELBAParameterSet;
				UINT16 Reason = WiFiReasonTable(this);
			}
	}
}

//From 802.11k: 7.4.7 Public Action details
struct WiFiPublicAction
{
	UINT8 Action = WiFiPublicActionTable(this);
	switch (Action)
	{
		case 0: WiFi20And40BSSCoexistenceManagement TwentyAndFortyBSSCoexistenceManagement;
		case 1: WiFiDSEEnablement DSEEnablement;
		case 2: WiFiDSEDeenablement DSEDeenablement;
		case 3: WiFiDSERegisteredLocationAnnouncement DSERegisteredLocationAnnouncement;
		case 4: WiFiExtendedChannelSwitchAnnouncement ExtendedChannelSwitchAnnouncement;
		case 5: WiFiDSEMeasurementRequest DSEMeasurementRequest;
		case 6: WiFiDSEMeasurementReport DSEMeasurementReport;
		case 7: WiFiMeasurementPilot MeasurementPilot;
		case 8: WiFiDSEPowerConstraint DSEPowerConstraint;
	}
}

//From 802.11n: 7.4.7.1a 20/40 BSS Coexistence Management frame format
struct WiFi20And40BSSCoexistenceManagement
{
	WiFiInformationFields TwentyAndFortyBSSCoexistenceManagementInfo;
}

//From 802.11y: 7.4.7.3 DSE Enablement frame format
struct WiFiDSEEnablement
{
	[DataFieldByteOrder = BigEndian]
	MacAddress RequesterSTAAddress = MacTable(this);
	[DataFieldByteOrder = BigEndian]
	MacAddress ResponderSTAAddress = MacTable(this);
	UINT8 ReasonResultCode = WiFiDSEEnablementReasonResultCode(this);
	UINT16 EnablementIdentifier;
}

table WiFiDSEEnablementReasonResultCode(value)
{
	switch(value)
	{
		case 2: "Enablement requested";
		case 3: "Success";
		case 4: "Request declined";
		case 5: "Request not successful as one or more parameters have invalid values";
		case 6: "Enablement denied because the enabling STA is unable to handle additional dependent STAs";
		case 7: "Handshake timeout";
		default: FormatString("Reserved (%d)", value);
	}
}

//From 802.11y: 7.4.7.4 DSE Deenablement frame format
struct WiFiDSEDeenablement
{
	[DataFieldByteOrder = BigEndian]
	MacAddress RequesterSTAAddress = MacTable(this);
	[DataFieldByteOrder = BigEndian]
	MacAddress ResponderSTAAddress = MacTable(this);
	UINT8 ReasonResultCode = WiFiWiFiDSEDeenablementReasonResultCode(this);
}

table WiFiWiFiDSEDeenablementReasonResultCode(value)
{
	switch(value)
	{
		case 2: "Deenablement requested";
		case 3: "Success";
		case 5: "Request not successful as one or more parameters have invalid values";
		default: FormatString("Reserved (%d)", value);
	}
}

//From 802.11y: 7.4.7.5 DSE Registered Location Announcement frame format
struct WiFiDSERegisteredLocationAnnouncement
{
	Struct
	{
		UINT128 LaRes:6 = FormatString("          (%s) Latitude resolution",this.ToBitString);
		UINT128 Latitude:34 = FormatString("       (%s) SHOULD be normalized to within +/- 90 degrees.",this.ToBitString);
		UINT128 LoRes:6 = FormatString("          (%s) Longitude resolution",this.ToBitString);
		UINT128 Longitude:34 = FormatString("      (%s) SHOULD be normalized to within +/- 180 degrees.",this.ToBitString);
		UINT128 AT:4 = FormatString("             (%s) Altitude Type for altitude.",this.ToBitString);
		UINT128 AltRes:6 = FormatString("         (%s) Altitude resolution.",this.ToBitString);
		UINT128 Altitude:30 = FormatString("       (%s) A 30 bit value defined by the AT field.",this.ToBitString);
		UINT128 Datum:3 = FormatString("          (%s) The Map Datum used for the coordinates given in this Option.",this.ToBitString);
		UINT128 RegLocAgreement:1 = FormatString("(%s) %s", this.ToBitString, this ? "The STA is operating within a national policy area or an international agreement area near a national border" : "The STA is NOT operating within a national policy area or an international agreement area near a national border");
		UINT128 RegLocDSE:1 = FormatString("      (%s) %s", this.ToBitString, this ? "The enabling STA is enabling the operation of STAs with DSE" : "The enabling STA is NOT enabling the operation of STAs with DSE");
		UINT128 DependentSTA:1 = FormatString("   (%s) %s", this.ToBitString, this ? "The STA is operating with the enablement of the enabling STA whose LCI is being reported" : "The STA is NOT operating with the enablement of the enabling STA whose LCI is being reported");
		UINT128 Reserved:2 = FormatString ("      (%s)", this.ToBitString);
	};
	UINT16 DependentEnablementIdentifier;
	UINT8 RegulatoryClass;
	UINT8 ChannelNumber;
}

//From 802.11y: 7.4.7.6 Extended Channel Switch Announcement frame format
struct WiFiExtendedChannelSwitchAnnouncement
{
	UINT8 ChannelSwitchMode = this ? "Shall transmit no further frames within the BSS until the scheduled channel switch" : "No requirement imposed on the receiving STA";
	UINT8 NewRegulatoryClass;
	UINT8 NewChannelNumber;
	UINT8 ChannelSwitchCount = WiFiChannelSwitchAnnouncementCountMeaningTable(this);}

//From 802.11y: 7.4.7.7 DSE Measurement Request frame format
struct WiFiDSEMeasurementRequest
{
	[DataFieldByteOrder = BigEndian]
	MacAddress RequesterSTAAddress = MacTable(this);
	[DataFieldByteOrder = BigEndian]
	MacAddress ResponderSTAAddress = MacTable(this);
	UINT8 RegulatoryClass;
	UINT8 ChannelNumber;
	UINT64 MeasurementStartTime = FormatString("%u microsecond(s)", this);
	UINT16 MeasurementDuration = FormatString("%u ms", this);
}

//From 802.11y: 7.4.7.8 DSE Measurement Report frame format
struct WiFiDSEMeasurementReport
{
	[DataFieldByteOrder = BigEndian]
	MacAddress RequesterSTAAddress = MacTable(this);
	[DataFieldByteOrder = BigEndian]
	MacAddress ResponderSTAAddress = MacTable(this);
	UINT16 Length;
	[ Property.WiFiReportStartOffset = Offset ]
	UINT8 RegulatoryClass;
	UINT8 ChannelNumber;
	UINT8 MeasurementReportMode
	{
		UINT8 Late:1 = FormatString("     (%s) %s", this.ToBitString, this ? "Request was too late" : "Received in time");
		UINT8 Incapable:1 = FormatString("(%s) %s", this.ToBitString, this ? "Incapable." : "Capable or the report is autonomous.");
		UINT8 Refused:1 = FormatString("  (%s) %s", this.ToBitString, this ? "Refusing." : "NOT refusing or the report is autonomous");
		UINT8 Reserved:5 = FormatString(" (%s)", this.ToBitString);
	};
	UINT64 ActualMeasurementStartTime = FormatString("%u microsecond(s)", this);
	UINT16 MeasurementDuration = FormatString("%u ms", this);
	while ReportedDSELCIFields[ (FrameOffset - Property.WiFiReportStartOffset) < Length ]
	{
		MacAddress SAMACAddress = MacTable(this);
		Struct
		{
			UINT128 LaRes:6 = FormatString("          (%s) Latitude resolution",this.ToBitString);
			UINT128 Latitude:34 = FormatString("       (%s) SHOULD be normalized to within +/- 90 degrees.",this.ToBitString);
			UINT128 LoRes:6 = FormatString("          (%s) Longitude resolution",this.ToBitString);
			UINT128 Longitude:34 = FormatString("      (%s) SHOULD be normalized to within +/- 180 degrees.",this.ToBitString);
			UINT128 AT:4 = FormatString("             (%s) Altitude Type for altitude.",this.ToBitString);
			UINT128 AltRes:6 = FormatString("         (%s) Altitude resolution.",this.ToBitString);
			UINT128 Altitude:30 = FormatString("       (%s) A 30 bit value defined by the AT field.",this.ToBitString);
			UINT128 Datum:3 = FormatString("          (%s) The Map Datum used for the coordinates given in this Option.",this.ToBitString);
			UINT128 RegLocAgreement:1 = FormatString("(%s) %s", this.ToBitString, this ? "The STA is operating within a national policy area or an international agreement area near a national border" : "The STA is NOT operating within a national policy area or an international agreement area near a national border");
			UINT128 RegLocDSE:1 = FormatString("      (%s) %s", this.ToBitString, this ? "The enabling STA is enabling the operation of STAs with DSE" : "The enabling STA is NOT enabling the operation of STAs with DSE");
			UINT128 DependentSTA:1 = FormatString("   (%s) %s", this.ToBitString, this ? "The STA is operating with the enablement of the enabling STA whose LCI is being reported" : "The STA is NOT operating with the enablement of the enabling STA whose LCI is being reported");
			UINT128 Reserved:2 = FormatString ("      (%s)", this.ToBitString);
		};
		UINT16 DependentEnablementIdentifier;
		UINT8 RegulatoryClass;
		UINT8 ChannelNumber;
	}
}

//From 802.11y: 7.4.7.9 DSE Power Constraint frame format
struct WiFiDSEPowerConstraint
{
	[DataFieldByteOrder = BigEndian]
	MacAddress RequesterSTAAddress = MacTable(this);
	[DataFieldByteOrder = BigEndian]
	MacAddress ResponderSTAAddress = MacTable(this);
	UINT8 ReasonResultCode = WiFiDSEPowerConstraintReasonResultCode(this);
	UINT8 LocalPowerConstraint;
}

table WiFiDSEPowerConstraintReasonResultCode(value)
{
	switch(value)
	{
		case 2: "Power constraint requested";
		case 3: "Success";
		case 5: "Request not successful as one or more parameters have invalid values";
		case 7: "Handshake timeout";
		default: FormatString("Reserved (%d)", value);
	}
}


//From 802.11k: 7.4.7.2 Measurement Pilot frame format
struct WiFiMeasurementPilot
{
	UINT8 CondensedCapabilityInformation
	{
		UINT8 SpectrumManagement:1 = FormatString("(%s) %s", this.ToBitString, this ? "Required" : "Not Required");
		UINT8 ShortSlotTime:1 = FormatString("     (%s) %s", this.ToBitString, this ? "Enabled" : "Disabled");
		UINT8 Reserved:6 = FormatString("          (%s) %s", this.ToBitString);
	};
	UINT16 CondensedCountryString;
	UINT8 RegulatoryClass;
	UINT8 Channel;
	UINT8 MeasurementPilotInterval;
	while OptionalSubElemnts[UINT8( Framedata, Offset + 1 ) + FrameOffset + 2 <= WiFiPktLen]
	{
		WiFiInformationSubelement Subelement;
	}
}

table WiFiPublicActionTable(value)
{
	switch(value)
	{
		case 0: "20/40 BSS Coexistence Management";
		case 1: "DSE enablement";
		case 2: "DSE deenablement";
		case 3: "DSE Registered Location Announcement";
		case 4: "Extended Channel Switch Announcement";
		case 5: "DSE measurement request";
		case 6: "DSE measurement report";
		case 7: "Measurement Pilot";
		case 8: "DSE power constraint";
		case 9: "Vendor Specific";
		default: FormatString("Reserved (%d)", value);
	}
}

//From 802.11k: 7.4.6 Radio Measurement action details
struct WiFiRadioMeasurementAction
{
	UINT8 Action = WiFiRadioMeasurementActionTable(this);
	switch (Action)
	{
		case 0:
			_struct RadioMeasurementRequest
			{
				UINT8 DialogToken;
				UINT16 RepetitionNumber;
				WiFiInformationFields InformationFields;
			}
		case 1:
			_struct RadioMeasurementReport
			{
				UINT8 DialogToken;
				WiFiInformationFields InformationFields;
			}
		case 2:
			_struct LinkMeasurementRequest
			{
				UINT8 DialogToken;
				UINT8 TransmitPowerUsed;
				UINT8 MaxTransmitPower;
				while OptionalSubElemnts[UINT8( Framedata, Offset + 1 ) + FrameOffset + 2 <= WiFiPktLen]
				{
					WiFiInformationSubelement Subelement;
				}
			}
		case 3:
			_struct LinkMeasurementReport
			{
				UINT8 DialogToken;
				WiFiTPCReport TPCReportElement;
				UINT8 ReceiveAntennaID;
				UINT8 TransmitAntennaID;
				UINT8 RCPI;
				UINT8 RSNI;
				while OptionalSubElemnts[UINT8( Framedata, Offset + 1 ) + FrameOffset + 2 <= WiFiPktLen]
				{
					WiFiInformationSubelement Subelement;
				}
			}
		case 4:
			_struct NeighborReportRequest
			{
				UINT8 DialogToken;
				while OptionalSubElemnts[UINT8( Framedata, Offset + 1 ) + FrameOffset + 2 <= WiFiPktLen]
				{
					WiFiInformationSubelement Subelement;
				}
			}
		case 5:
			_struct NeighborReportResponse
			{
				UINT8 DialogToken;
				while NeighborReportElements[UINT8( Framedata, Offset + 1 ) + FrameOffset + 2 <= WiFiPktLen]
				{
					WiFiNeighborReport NeighborReportElement;
				}
			}
	}
}

//From 802.11r: 7.4.8 FT Action frame details
struct WiFiFastBSSTransitionAction
{
	UINT8 Action = WiFiFastBSSTransitionActionTable(this);
	switch (Action)
	{
		case 1:
			_struct FTRequest
			{
				[DataFieldByteOrder = BigEndian]
				MacAddress STAAddress = MacTable(this);
				[DataFieldByteOrder = BigEndian]
				MacAddress TargetAPAddress = MacTable(this);
				WiFiInformationFields InformationFields;
			}
		case 2:
			_struct FTResponse
			{
				[DataFieldByteOrder = BigEndian]
				MacAddress STAAddress = MacTable(this);
				[DataFieldByteOrder = BigEndian]
				MacAddress TargetAPAddress = MacTable(this);
				UINT16 StatusCode = WiFiStatusTable(this);
				switch(StatusCode)
				{
					case 0: WiFiInformationFields InformationFields;
				}
			}
		case 3:
			_struct FTConfirm
			{
				[DataFieldByteOrder = BigEndian]
				MacAddress STAAddress = MacTable(this);
				[DataFieldByteOrder = BigEndian]
				MacAddress TargetAPAddress = MacTable(this);
				WiFiInformationFields InformationFields;
			}
		case 4:
			_struct FTAck
			{
				[DataFieldByteOrder = BigEndian]
				MacAddress STAAddress = MacTable(this);
				[DataFieldByteOrder = BigEndian]
				MacAddress TargetAPAddress = MacTable(this);
				UINT16 StatusCode = WiFiStatusTable(this);
				switch(StatusCode)
				{
					case 0: WiFiInformationFields InformationFields;
				}
			}
	}
}

Table WiFiFastBSSTransitionActionTable(value)
{
	switch (value)
	{
		case 1: "FT Request frames";
		case 2: "FT Response frames";
		case 3: "FT Confirm frames";
		case 4: "FT Ack frames";
		default: FormatString("Reserved (%d)", value);
	}
}

//From 802.11n: 7.4.10 HT Action frame details
struct WiFiHTAction
{
	UINT8 Action = WiFiWiFiHTActionTable(this);
	switch (Action)
	{
		case 0:
			_struct NotifyChannelWidth
			{
				UINT8 ChannelWidth = WiFiChannelWidthTable(this);
			}
		case 1:
			_struct SMPowerControl
			{
				UINT8 SMPowerSaveEnabled:1 = FormatString("(%s) %s", this.ToBitString, this ? "Enabled" : "Disabled");
				UINT8 SMMode:1 = FormatString("            (%s) %s", this.ToBitString, this? "Dynamic SM power save mode" : "Static SM power save mode");
				UINT8 Reserved:6 = FormatString("      (%s) %s", this.ToBitString);
			}
		case 2:
			_struct PSMP
			{
				struct PSMPParameterSet
				{
					[Property.WiFiSTAInfoNumber]
					UINT16 N_STA:5 = FormatString("                        (%s) Number of STA Info fields present in the PSMP frame: %d", this.ToBitString, this);
					UINT16 MorePSMP:1 = FormatString("                     (%s) %s", this.ToBitString, this? "The current PSMP sequence will be followed by another PSMP sequence" : "There will be no PSMP sequence following the current PSMP sequence");
					UINT16 ResePSMPSequenceDurationrved:10 = FormatString("(%s) Current PSMP sequence: %d", this.ToBitString, this);
				}
				[Local.STAInfoNumber = 0]
				while STAInfos[ Local.STAInfoNumber < Property.WiFiSTAInfoNumber ]
				{
					[Local.STAInfoNumber = Local.STAInfoNumber + 1]
					struct PSMPSTAInfo
					{
						switch(UINT8(Framedata, Offset) & 0x03)
						{
							case 1:
								_struct PSMPSTAInfoGroupAddressed
								{
									UINT64 STAInfoType:2 = PSMPSTAInfoTypeTable(this);
									UINT64 PSMPDTTStartOffset:11;
									UINT64 PSMPDTTDuration:8;
									UINT64 PSMPGroupAddressID:43;
								}
							case 2:
								_struct PSMPSTAInfoIndividuallyAddressed
								{
									UINT64 STAInfoType:2 = PSMPSTAInfoTypeTable(this);
									UINT64 PSMPDTTStartOffset:11;
									UINT64 PSMPDTTDuration:8;
									UINT64 STAID:16;
									UINT64 PSMPUTTStartOffset:11;
									UINT64 PSMPUTTDuration:10;
									UINT64 Reserved:6;
								}
						}
					}
				}
			}
		case 3:
			_struct SetPCOPhase
			{
				UINT8 PCOPhaseControl = WiFiPCOPhaseControlTable(this);
			}
		case 4:
			_struct CSI
			{
				struct MIMOControl
				{
					_struct
					{
						[ Property.WiFiNcCount = this + 1 ]
						UINT16 NcIndex:2 = FormatString("                (%s) %d", this.ToBitString, this);
						[ Property.WiFiNrCount = this + 1 ]
						UINT16 NrIndex:2 = FormatString("                (%s) %d", this.ToBitString, this);
						[ Property.WiFiMIMOControlChannelWidth ]
						UINT16 MIMOControlChannelWidth:1 = FormatString("(%s) %s", this.ToBitString, this ? "40 MHz" : "20 MHz");
						[ Property.WiFiNgCount ]
						UINT16 Grouping:2 = FormatString("               (%s) %d", this.ToBitString, this);
						[ Property.WiFiCpeffocoemtSize ]
						UINT16 CpeffocoemtSize:2 = FormatString("        (%s) %d", this.ToBitString, this);
						UINT16 CodebookInformation:2 = FormatString("    (%s) %d", this.ToBitString, this);
						UINT16 RemainingMatrixSegment:3 = FormatString(" (%s) %d", this.ToBitString, this);
						UINT16 Reserved:2 = FormatString("               (%s) %s", this.ToBitString);
					};
					UINT32 SoundingTimestamp;
				}
				struct CSIReport
				{
					switch(Property.WiFiMIMOControlChannelWidth)
					{
						case 0:
							[ Property.WiFiNbCount = WiFiCoefficientSizeTable(Property.WiFiCpeffocoemtSize) ]
							[ Local.WiFCarrierCount = WiFiCarrierCount20Table(Property.WiFiNgCount) ]
							_struct
							{
								UINT8 SNR[Property.WiFiNrCount];
								Bits( 3 + ( 2 * Property.WiFiNbCount * Property.WiFiNcCount * Property.WiFiNrCount ) ) CSIMatrix[Local.WiFCarrierCount];
							}
						case 1:
							[ Property.WiFiNbCount = WiFiCoefficientSizeTable(Property.WiFiCpeffocoemtSize) ]
							[ Local.WiFCarrierCount = WiFiCarrierCount40Table(Property.WiFiNgCount) ]
							_struct
							{
								UINT8 SNR[Property.WiFiNrCount];
								Bits( 3 + ( 2 * Property.WiFiNbCount * Property.WiFiNcCount * Property.WiFiNrCount ) ) CSIMatrix[Local.WiFCarrierCount];
							}
					}
					
				}
			}
		case 5:
			_struct NoncompressedBeamforming
			{
				struct MIMOControl
				{
					_struct
					{
						[ Property.WiFiNcCount = this + 1 ]
						UINT16 NcIndex:2 = FormatString("                (%s) %d", this.ToBitString, this);
						[ Property.WiFiNrCount = this + 1 ]
						UINT16 NrIndex:2 = FormatString("                (%s) %d", this.ToBitString, this);
						[ Property.WiFiMIMOControlChannelWidth ]
						UINT16 MIMOControlChannelWidth:1 = FormatString("(%s) %s", this.ToBitString, this ? "40 MHz" : "20 MHz");
						[ Property.WiFiNgCount ]
						UINT16 Grouping:2 = FormatString("               (%s) %d", this.ToBitString, this);
						[ Property.WiFiCpeffocoemtSize ]
						UINT16 CpeffocoemtSize:2 = FormatString("        (%s) %d", this.ToBitString, this);
						UINT16 CodebookInformation:2 = FormatString("    (%s) %d", this.ToBitString, this);
						UINT16 RemainingMatrixSegment:3 = FormatString(" (%s) %d", this.ToBitString, this);
						UINT16 Reserved:2 = FormatString("               (%s) %s", this.ToBitString);
					};
					UINT32 SoundingTimestamp;
				}
				struct NoncompressedBeamformingReport
				{
					switch(Property.WiFiMIMOControlChannelWidth)
					{
						case 0:
							[ Property.WiFiNbCount = WiFiCoefficientSizeNoncompressedBeamformingTable(Property.WiFiCpeffocoemtSize) ]
							[ Local.WiFCarrierCount = WiFiCarrierCount20Table(Property.WiFiNgCount) ]
							_struct
							{
								UINT8 SNR[Property.WiFiNcCount];
								Bits( 2 * Property.WiFiNbCount * Property.WiFiNcCount * Property.WiFiNrCount ) BeamformingFeedbackMatrix[Local.WiFCarrierCount];
							}
						case 1:
							[ Property.WiFiNbCount = WiFiCoefficientSizeNoncompressedBeamformingTable(Property.WiFiCpeffocoemtSize) ]
							[ Local.WiFCarrierCount = WiFiCarrierCount40Table(Property.WiFiNgCount) ]
							_struct
							{
								UINT8 SNR[Property.WiFiNcCount];
								Bits( 2 * Property.WiFiNbCount * Property.WiFiNcCount * Property.WiFiNrCount ) BeamformingFeedbackMatrix[Local.WiFCarrierCount];
							}
					}
				}
			}
		case 6:
			_struct CompressedBeamforming
			{
				struct MIMOControl
				{
					_struct
					{
						[ Property.WiFiNcCount = this + 1 ]
						UINT16 NcIndex:2 = FormatString("                (%s) %d", this.ToBitString, this);
						[ Property.WiFiNrCount = this + 1 ]
						UINT16 NrIndex:2 = FormatString("                (%s) %d", this.ToBitString, this);
						[ Property.WiFiMIMOControlChannelWidth ]
						UINT16 MIMOControlChannelWidth:1 = FormatString("(%s) %s", this.ToBitString, this ? "40 MHz" : "20 MHz");
						[ Property.WiFiNgCount ]
						UINT16 Grouping:2 = FormatString("               (%s) %d", this.ToBitString, this);
						[ Property.WiFiCpeffocoemtSize ]
						UINT16 CpeffocoemtSize:2 = FormatString("        (%s) %d", this.ToBitString, this);
						[ Property.WiFiCodebookInformation ]
						UINT16 CodebookInformation:2 = FormatString("    (%s) %d", this.ToBitString, this);
						UINT16 RemainingMatrixSegment:3 = FormatString(" (%s) %d", this.ToBitString, this);
						UINT16 Reserved:2 = FormatString("               (%s) %s", this.ToBitString);
					};
					UINT32 SoundingTimestamp;
				}
				struct CompressedBeamformingReport
				{
					switch(Property.WiFiMIMOControlChannelWidth)
					{
						case 0:
							[ Local.WiFCarrierCount = WiFiCarrierCount20Table(Property.WiFiNgCount) ]
							[ Local.WiFNaCount = WiFiNaCountTable(Property.WiFiNrCount, Property.WiFiNcCount) ]
							[ Local.WiFBit1Count = WiFBit1CountTable(Property.WiFiCodebookInformation) ]
							[ Local.WiFBit2Count = WiFBit2CountTable(Property.WiFiCodebookInformation) ]
							_struct
							{
								UINT8 SNR[Property.WiFiNcCount];
								Bits( Local.WiFNaCount * ( Local.WiFBit1Count + Local.WiFBit2Count) / 2 ) BeamformingFeedbackMatrix[Local.WiFCarrierCount];
							}
						case 1:
							[ Local.WiFCarrierCount = WiFiCarrierCount40Table(Property.WiFiNgCount) ]
							[ Local.WiFNaCount = WiFiNaCountTable(Property.WiFiNrCount, Property.WiFiNcCount) ]
							[ Local.WiFBit1Count = WiFBit1CountTable(Property.WiFiCodebookInformation) ]
							[ Local.WiFBit2Count = WiFBit2CountTable(Property.WiFiCodebookInformation) ]
							_struct
							{
								UINT8 SNR[Property.WiFiNcCount];
								Bits( Local.WiFNaCount * ( Local.WiFBit1Count + Local.WiFBit2Count ) / 2 ) BeamformingFeedbackMatrix[Local.WiFCarrierCount];
							}
					}
					
				}
			}
		case 7:
			_struct AntennaSelectionIndicesFeedback
			{
				UINT8 AntennaSelectionIndices = formatstring("%s", this ? "The corresponding antenna is selected" : "The corresponding antenna is NOT selected");
			}
	}
}

Table WiFiNaCountTable(Nr, Nc)
{
	switch
	{
		case Nr == 2 && Nc == 1:
		case Nr == 2 && Nc == 2: 2;
		case Nr == 3 && Nc == 1: 4;
		case Nr == 3 && Nc == 2: 
		case Nr == 3 && Nc == 3: 
		case Nr == 4 && Nc == 1: 6;
		case Nr == 4 && Nc == 2: 10;
		case Nr == 4 && Nc == 3: 
		case Nr == 4 && Nc == 4: 2;
	}
}

Table WiFBit1CountTable(value)
{
	switch (value)
	{
		case 0: 1;
		case 1: 2;
		case 2: 3;
		case 3: 4;
	}
}

Table WiFBit2CountTable(value)
{
	switch (value)
	{
		case 0: 3;
		case 1: 4;
		case 2: 5;
		case 3: 6;
	}
}

Table WiFiCarrierCount20Table(value)
{
	switch (value)
	{
		case 0: 56;
		case 1: 30;
		case 2: 16;
	}
}

Table WiFiCarrierCount40Table(value)
{
	switch (value)
	{
		case 0: 114;
		case 1: 58;
		case 2: 30;
	}
}

Table WiFiCoefficientSizeNoncompressedBeamformingTable(value)
{
	switch (value)
	{
		case 0: 4;
		case 1: 2;
		case 2: 6;
		case 3: 8;
	}
}

Table WiFiCoefficientSizeTable(value)
{
	switch (value)
	{
		case 0: 4;
		case 1: 5;
		case 2: 6;
		case 3: 8;
	}
}

Table WiFiPCOPhaseControlTable(value)
{
	switch (value)
	{
		case 0: "20 MHz phase";
		case 1: "40 MHz phase";
		default: FormatString("Reserved (%d)", value);
	}
}

Table WiFiChannelWidthTable(value)
{
	switch (value)
	{
		case 0: "20 MHz channel width";
		case 1: "Any channel width in the STAs Supported Channel Width Set subfield";
		default: FormatString("Reserved (%d)", value);
	}
}

Table PSMPSTAInfoTypeTable(value)
{
	switch (value)
	{
		case 1: "PSMP STA Info fixed field (group-addressed)";
		case 2: "PSMP STA Info fixed field (individually addressed)";
		default: FormatString("Unknown value (%d)", value);
	}
}

Table WiFiWiFiHTActionTable(value)
{
	switch (value)
	{
		case 0: "Notify Channel Width";
		case 1: "SM Power Save";
		case 2: "PSMP";
		case 3: "Set PCO Phase";
		case 4: "CSI";
		case 5: "Noncompressed Beamforming";
		case 6: "Compressed Beamforming";
		case 7: "ASEL Indices Feedback";
		default: FormatString("Reserved (%d)", value);
	}
}

//From 802.11w: 7.4.9 SA Query Action frame details
struct WiFiSAQueryActionFrameDetails
{
	UINT8 Action = WiFiSAQueryActionFrameDetailsActionTable(this);
	switch (Action)
	{
		case 1:
			_struct SAQueryRequest
			{
				UINT16 TransactionIdentifier;
			}
		case 2:
			_struct SAQueryResponse
			{
				UINT16 TransactionIdentifier;
			}
	}
}


//From 802.11w: 7.4.9a Protected Dual of Public Action frames
struct WiFiProtectedDualOfPublicAction
{
	UINT8 Action = WiFiProtectedDualOfPublicActionTable(this);
	switch (Action)
	{
		case 1: WiFiDSEEnablement ProtectedDSEEnablement;
		case 2: WiFiDSEDeenablement ProtectedDSEDeenablement;
		case 4: WiFiExtendedChannelSwitchAnnouncement ProtectedExtendedChannelSwitchAnnouncement;
		case 5: WiFiDSEMeasurementRequest ProtectedMeasurementRequest;
		case 6: WiFiDSEMeasurementReport ProtectedMeasurementReport;
		case 8: WiFiDSEPowerConstraint ProtectedDSEPowerConstraint;
	}
}

Table WiFiProtectedDualOfPublicActionTable(value)
{
	switch (value)
	{
		case 1: "Protected DSE Enablement";
		case 2: "Protected DSE Deenablement";
		case 4: "Protected Extended Channel Switch Announcement";
		case 5: "Protected Measurement Request";
		case 6: "Protected Measurement Report";
		case 8: "Protected DSE Power Constraint";
		default: FormatString("Reserved (%d)", value);
	}
}

Table WiFiSAQueryActionFrameDetailsActionTable(value)
{
	switch (value)
	{
		case 0: "SA Query Request";
		case 1: "SA Query Response";
		default: FormatString("Reserved (%d)", value);
	}
}

//From 802.11k: 7.3.3 Information Subelements
struct WiFiInformationSubelement
{
	UINT8 SubelementID;
	UINT8 Length;
	Blob( Length ) Data;
}

//From 802.11: 7.3.1.14 Block Ack Parameter Set field
struct WiFiBlockAckParameterSet
{
	UINT16 Reserved:1 = FormatString("      (%s) %s", this.ToBitString);
	UINT16 BlockAckPolicy:1 = FormatString("(%s) %s", this.ToBitString, this ? "Immediate Block Ack" : "Delayed Block Ack");
	UINT16 TID:4 = FormatString("           (%s) %d", this.ToBitString, this);
	UINT16 BufferSize:10 = FormatString("    (%s) %d", this.ToBitString, this);
}

//From 802.11: 7.2.1.7 Block Ack Request (BlockAckReq) frame format
struct WiFiBlockAckReq
{
	UINT16 BARControl
	{
		UINT16 BARAckPolicy:1 = FormatString("    (%s) %s", this.ToBitString, this ? "No Acknowledgment" : "Normal Acknowledgment");
		[Property.WiFiBlockAckReqInfo]
		UINT16 BlockAckReqInfo:2 = FormatString(" (%s) %s", this.ToBitString, this.ToBitString, WiFiBlockAckReqInfoTable(this));
		UINT16 Reserved:9 = FormatString("        (%s)", this.ToBitString);
		UINT16 TID:4 = FormatString("             (%s) %d", this.ToBitString, this);
	};
	Switch
	{
		case Property.WiFiBlockAckReqInfo == 3:
			UINT16 PerTIDInfo
			{
				UINT16 Reserved:12 = FormatString("         ($s) %d", this.ToBitString, this);
				UINT16 TIDValue:4 = FormatString("         ($s) %d", this.ToBitString, this);
			}
	}
	UINT16 BlockAckStartingSequenceControl
	{
		UINT16 FragmentNumber:4 = FormatString("        ($s) %d", this.ToBitString, this);
		UINT16 StartingSequenceNumber:12 = FormatString("($s) %d", this.ToBitString, this);
	};
}

Table WiFiBlockAckReqInfoTable(value)
{
	Switch(value)
	{
		case 0: "Basic BlockAckReq";
		case 1: "Reserved";
		case 2: "Compressed BlockAckReq";
		case 3: "Multi-TID BlockAckReq";
	}
}

//From 802.11n: 7.2.1.9 Control Wrapper frame
struct WiFiControlWrapper
{
	switch (Property.WiFiType) 
	{
		case 1:
			_struct Control
			{
				switch (Property.WiFiSubType)
				{
					case 8:
						_struct BlockAckReq
						{
							[DataFieldByteOrder = BigEndian]
							MacAddress TA = MacTable(this);
						}
					case 9:
						_struct BlockAck
						{
							[DataFieldByteOrder = BigEndian]
							MacAddress TA = MacTable(this);
						}
					case 10:
						_struct PSPoll
						{
							[DataFieldByteOrder = BigEndian]
							MacAddress TA = MacTable(this);
						}
					case 11:
						_struct RTS
						{
							[DataFieldByteOrder = BigEndian]
							MacAddress TA = MacTable(this);
						}
					case 12:
						_struct CTS{}
					case 13:
						_struct ACK{}
					case 14:
						_struct CFEnd
						{
							[DataFieldByteOrder = BigEndian]
							MacAddress BSSID = MacTable(this);
						}
					case 15:
						_struct CFEnd_CFAck
						{
							[DataFieldByteOrder = BigEndian]
							MacAddress BSSID = MacTable(this);
						}
				}
			}
	}
}

//From 802.11: 7.3.1.16 DELBA Parameter Set field
struct WiFiDELBAParameterSet
{
	UINT16 Reserved:11 = FormatString("      (%s) %s", this.ToBitString);
	UINT16 Initiator:1 = FormatString("     (%s) %s", this.ToBitString, this ? "Originator" : "Recipient");
	UINT16 TID:4 = FormatString("           (%s) %d", this.ToBitString, this);
}

//From 802.11: 7.2.1.8 Block Ack (BlockAck) frame format
struct WiFiBlockAck
{
	UINT16 BARControl
	{
		UINT16 BARAckPolicy:1 = FormatString("    (%s) %s", this.ToBitString, this ? "No Acknowledgment" : "Normal Acknowledgment");
		[Property.WiFiBlockAckReqInfo]
		UINT16 BlockAckReqInfo:2 = FormatString(" (%s) %s", this.ToBitString, this.ToBitString, WiFiBlockAckReqInfoTable(this));
		UINT16 Reserved:9 = FormatString("        (%s)", this.ToBitString);
		UINT16 TID:4 = FormatString("             (%s) %d", this.ToBitString, this);
	};
	Switch
	{
		case Property.WiFiBlockAckReqInfo == 3:
			UINT16 PerTIDInfo
			{
				UINT16 Reserved:12 = FormatString("         ($s) %d", this.ToBitString, this);
				UINT16 TIDValue:4 = FormatString("         ($s) %d", this.ToBitString, this);
			}
	}
	UINT16 BlockAckStartingSequenceControl
	{
		UINT16 FragmentNumber:4 = FormatString("        ($s) %d", this.ToBitString, this);
		UINT16 StartingSequenceNumber:12 = FormatString("($s) %d", this.ToBitString, this);
	};
	BLOB(128) BlockAckBitmap;
}

//From 802.11: 8.2.1.2 WEP MPDU format
struct WiFiWEPPayload
{
	UINT24 InitVector;
	UINT8 PadBits:6 = FormatString("(%s)", this.ToBitString);
	UINT8 KeyID:2 = FormatString("  (%s) %u", this.ToBitString, this);
	BLOB (WiFiPktLen - FrameOffset) EncryptedData;
}

//From 802.11: 8.3.2.2 TKIP MPDU formats
struct WiFiTKIP
{
	UINT8 TSC1;
	// WEPSeed is not used to construct the TSC, but is set to (TSC1 | 0x20) & 0x7f.
	UINT8 WepSeed;
	UINT8 TSC0;
	UINT8 Rsvd:5 = FormatString("        (%s)", this.ToBitString);
	UINT8 ExtIV:1 = FormatString("(%s) %s", this.ToBitString, this ? "ExtIV Present" : "ExtIV Absence");
	UINT8 KeyID:2 = FormatString("       (%s) %u", this.ToBitString, this);
	switch
	{
		case ExtIV:
			UINT32 ExtendedIV
			{
				UINT8 TSC2;
				UINT8 TSC3;
				UINT8 TSC4;
				UINT8 TSC5;
			};
	}
	BLOB (WiFiPktLen - FrameOffset) EncryptedData;
}

//From 802.11: 8.3.3.2 CCMP MPDU format
struct WiFiCCMP
{
	UINT8 PN0;
	UINT8 PN1;
	UINT8 Reserved;
	UINT8 Rsvd:5 = FormatString("        (%s)", this.ToBitString);
	UINT8 ExtIV:1 = FormatString("(%s) %s", this.ToBitString, this ? "ExtIV Present" : "ExtIV Absence");
	UINT8 KeyID:2 = FormatString("       (%s) %u", this.ToBitString, this);
	switch
	{
		case ExtIV:
			UINT32 ExtendedIV
			{
				UINT8 PN2;
				UINT8 PN3;
				UINT8 PN4;
				UINT8 PN5;
			};
	}
	BLOB (WiFiPktLen - FrameOffset) EncryptedData;
}

struct WiFiMetadata = WiFiMetadataDesc
{
	UINT8  Version;
	UINT16 Length;
	UINT32 OpMode = WifiOpMode(this) 
	{
		UINT32 StationMode:1 = FormatString("          (%s) %s", this.ToBitString, this ? "Station Mode" : "Not Station Mode");
		UINT32 APMode:1 = FormatString("               (%s) %s", this.ToBitString, this ? "AP Mode" : "Not AP Mode");
		UINT32 ExtensibleStationMode:1 = FormatString("(%s) %s", this.ToBitString, this ? "Extensible Station Mode" : "Not Extensible Station Mode");
		UINT32 Unused:28 = FormatString("               (%s)", this.ToBitString);
		[Property.WiFiMonitorMode]
		UINT32 MonitorMode:1 = FormatString("          (%s) %s", this.ToBitString, this ? "Monitor Mode" : "Not Monitor Mode");
	}
	UINT32 Flags; 
	switch
	{
		case Flags != 0xFFFFFFFF:
			[WiFiMetadataDesc = FormatString("RSSI = %s, Rate = %s", lRSSI.ToString, Rate.ToString)]
			struct 
			{
				UINT32 PhyType = WiFiPhyType(this);
				// The engine may set channel or center frequency to this field
				[Property.WifiChannel = this < 1000 ? this : WifiChannelTable(PhyType,this)]
				UINT32 Channel = this < 1000 ?  FormatString("%s", this) : Contains(WifiChannelTable(PhyType,this), "Undefined") ? FormatString("%s, Center Frequency: %u MHz", WifiChannelTable(PhyType,this), this) : FormatString("%u, Center Frequency: %u MHz", WifiChannelTable(PhyType,this), this);
				[Property.WiFilRSSI]
				INT32 lRSSI = FormatString ("%d dBm", this);
				[Property.WiFiDataRate]
				UINT8 Rate = this ? FormatString ("%s Mbps", WiFiPrintRate(this)) : "Unknown";
			}
		default:
			BLOB(13) RemData = FormatString("Outbound");
	}
	FILETIME TimeStamp;
}

Table WifiChannelTable(PhyType, CenterFrequency)
{
	Switch(PhyType)
	{
		case 4:
		case 7:
			Wifi80211ahjnCenterFrequencyToChannelTable(CenterFrequency);
		case 5:
		case 6:
			Wifi80211bgCenterFrequencyToChannelTable(CenterFrequency);
		default:
			FormatString("Undefined PhyType %u", PhyType);
	}
}


Table Wifi80211ahjnCenterFrequencyToChannelTable(CenterFrequency)
{
	switch(CenterFrequency)
	{
		case 4915: 183;
		case 4920: 184;
		case 4925: 185;
		case 4935: 187;
		case 4940: 188;
		case 4945: 189;
		case 4960: 192;
		case 4980: 196;
		case 5035: 7;
		case 5040: 8;
		case 5045: 9;
		case 5055: 11;
		case 5060: 12;
		case 5080: 16;
		case 5170: 34;
		case 5180: 36;
		case 5190: 38;
		case 5200: 40;
		case 5210: 42;
		case 5220: 44;
		case 5230: 46;
		case 5240: 48;
		case 5260: 52;
		case 5280: 56;
		case 5300: 60;
		case 5320: 64;
		case 5500: 100;
		case 5520: 104;
		case 5540: 108;
		case 5560: 112;
		case 5580: 116;
		case 5600: 120;
		case 5620: 124;
		case 5640: 128;
		case 5660: 132;
		case 5680: 136;
		case 5700: 140;
		case 5745: 149;
		case 5765: 153;
		case 5785: 157;
		case 5805: 161;
		case 5825: 165;
		default: FormatString("Undefined channel with center frequency %u", CenterFrequency);
	};
}

Table Wifi80211bgCenterFrequencyToChannelTable(CenterFrequency)
{
	switch(CenterFrequency)
	{
		case 2412: 1;
		case 2417: 2;
		case 2422: 3;
		case 2427: 4;
		case 2432: 5;
		case 2437: 6;
		case 2442: 7;
		case 2447: 8;
		case 2452: 9;
		case 2457: 10;
		case 2462: 11;
		case 2467: 12;
		case 2472: 13;
		case 2484: 14;
		default:
			FormatString("Undefined channel with center frequency %u", CenterFrequency);
	}
}

table WiFiHTCapabilitiesSMPowerSaveModes
{
	switch(value)
	{
		case 0: "Static SM power save mode";
		case 1: "Dynamic SM power save mode";
		case 2: "Reserved";
		case 3: "SM Power Save disabled";
	}
}

table WiFiHTCapabilitiesMaximumAMPDULengthExponent
{
	switch
	{
		default: (1<<(13+value))-1;
	}
}

table WiFiHTCapabilitiesMinimumMPDUStartSpacing
{
	switch(value)
	{
		case 0: "No restriction";
		case 1: "1/4 us";
		case 2: "1/2 us";
		case 3: "1 us";
		case 4: "2 us";
		case 5: "4 us";
		case 6: "8 us";
		case 7: "16 us";
	}
}

[DataTypeBitAlign]
struct WiFiRxMCSBitmask
{
	Bit MCS[77];
}

table WiFiMCSSetTxMaxNumberSpatialStreamsSupported(TxMCSSetDefined, TxRxMCSSetNotEqual, TxMaxNumberSpatialStreamsSupported)
{
	switch
	{
		case TxRxMCSSetNotEqual == 0: FormatString("%d%s", TxMaxNumberSpatialStreamsSupported, TxMaxNumberSpatialStreamsSupported == 0 ? "" : "(Should be 0)");
		case TxMCSSetDefined == 1 && TxRxMCSSetNotEqual == 1: FormatString("(%d) d% spatial stream(s)", TxMaxNumberSpatialStreamsSupported, TxMaxNumberSpatialStreamsSupported + 1);
	}
}

table WiFiMCSSetTxUnequalModulationSupported(TxMCSSetDefined, TxRxMCSSetNotEqual, TxUnequalModulationSupported)
{
	switch
	{
		case TxRxMCSSetNotEqual == 0: FormatString("%d%s", TxUnequalModulationSupported, TxUnequalModulationSupported == 0 ? "" : "(Should be 0)");
		case TxMCSSetDefined == 1 && TxRxMCSSetNotEqual == 1: FormatString("(d%) UEQM %ssupported", TxUnequalModulationSupported ? "" : "NOT ");
	}
}

[DataTypeBitAlign]
struct WiFiMCSSet
{
	WiFiRxMCSBitmask RxMCSBitmask;
	UINT8 Reserved:3;
	UINT16 RxHighestSupportedDataRate:10 = FormatString("%d Mb/s%s", this, this==0 ? " (the highest data rate is NOT specified)" : "");
	UINT8 Reserved1:6;
	UINT8 TxMCSSetDefined:1;
	UINT8 TxRxMCSSetNotEqual:1;
	UINT8 TxMaximumNumberSpatialStreamsSupported:2 = WiFiMCSSetTxMaxNumberSpatialStreamsSupported(TxMCSSetDefined, TxRxMCSSetNotEqual, this);
	UINT8 TxUnequalModulationSupported:1 = WiFiMCSSetTxUnequalModulationSupported(TxMCSSetDefined, TxRxMCSSetNotEqual, this);
	Bits(27) Reserved2;
}

table HTExtendedCapabilitiesPCOTransitionTime
{
	switch(value)
	{
		case 0: "No Transition";
		case 1: "400 us";
		case 2: "1.5 ms";
		case 3: "5 ms";
	}
}

table HTExtendedCapabilitiesMCSFeedback
{
	switch(value)
	{
		case 0: "(No Feedback) the STA does not provide MFB";
		case 1: "Reserved";
		case 2: "(Unsolicited) the STA provides only unsolicited MFB";
		case 3: "(Both) the STA can provide MFB in response to MRQ (either Delayed or Immediate) as well as unsolicited MFB";
	}
}

table TransmitBeamformingCapabilitiesCalibration
{
	switch(value)
	{
		case 0: "Not supported";
		case 1: "The STA can respond to a calibration request using the CSI report, but cannot initiate calibration";
		case 2: "Reserved";
		case 3: "The STA can both initiate and respond to a calibration request";
	}
}

table TransmitBeamformingCapabilitiesFeedback
{
	switch(value)
	{
		case 0: "Not supported";
		case 1: "Delayed feedback";
		case 2: "Immediate feedback";
		case 3: "Delayed and immediate feedback";
	}
}

table TransmitBeamformingCapabilitiesMinimalGrouping
{
	switch(value)
	{
		case 0: "groups of 1(no grouping)";
		case 1: "groups of 1, 2";
		case 2: "groups of 1, 4";
		case 3: "groups of 1, 2, 4";
	}
}

table TransmitBeamformingCapabilitiesNumberofBeamformerAntennas
{
	switch(value)
	{
		case 0: "single Tx antenna sounding";
		case 1: "2 Tx antenna sounding";
		case 2: "3 Tx antenna sounding";
		case 3: "4 Tx antenna sounding";
	}
}

//From 802.11n: 7.3.2.56 HT Capabilities element
struct WiFiHTCapabilities
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	UINT16 HTCapabilitiesInfo
	{
		UINT16 LDPCCodingCapability:1 = FormatString("     (%s) %ssupport for receiving LDPC coded packets.", this.ToBitString, this ? "" : "NOT ");
		UINT16 SupportedChannelWidthSet:1 = FormatString(" (%s) %s", this.ToBitString, this ? "both 20 MHz and 40 MHz operation is supported" : "only 20 MHz operation is supported");
		UINT16 SMPowerSave:2 = FormatString("              (%s) %s", this.ToBitString, WiFiHTCapabilitiesSMPowerSaveModes(this));
		UINT16 HTGreenfield:1 = FormatString("             (%s) %ssupport for the reception of PPDUs with HT-greenfield format", this.ToBitString, this ? "" : "NOT ");
		UINT16 ShortGIfor20MHz:1 = FormatString("          (%s) short GI %ssupport for the reception of packets transmitted with TXVECTOR parameter CH_BANDWIDTH set to HT_CBW20", this.ToBitString, this ? "" : "NOT ");
		UINT16 ShortGIfor40MHz:1 = FormatString("          (%s) short GI %ssupport for the reception of packets transmitted with TXVECTOR parameter CH_BANDWIDTH set to HT_CBW40", this.ToBitString, this ? "" : "NOT ");
		UINT16 TxSTBC:1 = FormatString("                   (%s) %ssupport for the transmission of PPDUs using STBC", this.ToBitString, this ? "" : "NOT ");
		UINT16 RxSTBC:2 = FormatString("                   (%s) %ssupport for the reception of PPDUs using STBC", this.ToBitString, this ? "" : "NOT ");
		UINT16 HTDelayedBlockAck:1 = FormatString("        (%s) %ssupport for HTdelayed Block Ack operation", this.ToBitString, this ? "" : "NOT ");
		UINT16 MaximumAMSDULength:1 = FormatString("       (%s) maximum AMSDU length is %s octets", this.ToBitString, this ? "7935" : "3839");
		UINT16 DSSSCCKModein40MHz:1 = FormatString("       (%s) %suse DSSS/CCK mode in a 20/40 MHz BSS", this.ToBitString, this ? "" : "Don't ");
		UINT16 Reserved:1 = FormatString("                 (%s) Reserved", this.ToBitString);
		UINT16 FortyMHzIntolerant:1 = FormatString("       (%s) %s a receiving AP from operating that APs BSS as a 20/40 MHz BSS", this.ToBitString, this ? "Prohibit" : "Allow");
		UINT16 LSIGTXOPProtectionSupport:1 = FormatString("(%s) %ssupport for the LSIG TXOP protection mechanism", this.ToBitString, this ? "" : "NOT ");
	};
	UINT8 AMPDUParameters
	{
		UINT8 MaximumAMPDULengthExponent:2 = FormatString("(%s) maximum length of A-MPDU that the STA can receive is %d octets", this.ToBitString, WiFiHTCapabilitiesMaximumAMPDULengthExponent(this));
		UINT8 MinimumMPDUStartSpacing:3 = FormatString("   (%s) the minimum time between the start of adjacent MPDUs within an AMPDU that the STA can receiveis is %s", this.ToBitString, WiFiHTCapabilitiesMinimumMPDUStartSpacing(this));
		UINT8 Reserved:3 = FormatString("                  (%s) Reserved", this.ToBitString);
	};
	WiFiMCSSet SupportedMCSSet;
	UINT16 HTExtendedCapabilities
	{
		UINT16 PCO:1 = FormatString("              (%s) PCO is %ssupported", this.ToBitString, this ? "" : "NOT ");
		UINT16 PCOTransitionTime:2 = FormatString("(%s) %s", this.ToBitString, PCO ? HTExtendedCapabilitiesPCOTransitionTime(this) : "Reserved");
		UINT16 Reserved:5 = FormatString("         (%s) Reserved", this.ToBitString);
		UINT16 MCSFeedback:2 = FormatString("      (%s) %s", this.ToBitString, HTExtendedCapabilitiesMCSFeedback(this));
		UINT16 HTCSupport:1 = FormatString("       (%s) %ssupport the HT Control field", this.ToBitString, this ? "" : "DON'T ");
		UINT16 RDResponder:1 = FormatString("      (%s) %ssupport acting as a reverse direction responder", this.ToBitString, this ? "" : "DON'T ");
		UINT16 Reserved1:4 = FormatString("        (%s) Reserved", this.ToBitString);
	};
	UINT32 TransmitBeamformingCapabilities
	{
		UINT32 ImplicitTransmitBeamformingReceivingCapable:1 = FormatString("             (%s) this STA can %sreceive Transmit Beamforming steered frames using implicit feedback", this.ToBitString, this ? "" : "NOT ");
		UINT32 ReceiveStaggeredSoundingCapable:1 = FormatString("                         (%s) this STA can %sreceive staggered sounding frames", this.ToBitString, this ? "" : "NOT ");
		UINT32 TransmitStaggeredSoundingCapable:1 = FormatString("                        (%s) this STA can %stransmit staggered sounding frames", this.ToBitString, this ? "" : "NOT ");
		UINT32 ReceiveNDPCapable:1 = FormatString("                                       (%s) this receiver can %sinterpret null data packets as sounding frames.", this.ToBitString, this ? "" : "NOT ");
		UINT32 TransmitNDPCapable:1 = FormatString("                                      (%s) this STA can %stransmit null data packets as sounding frames", this.ToBitString, this ? "" : "NOT ");
		UINT32 ImplicitTransmitBeamformingCapable:1 = FormatString("                      (%s) this STA can %sapply implicit transmit beamforming.", this.ToBitString, this ? "" : "NOT ");
		UINT32 Calibration:2 = FormatString("                                             (%s) %s", this.ToBitString, TransmitBeamformingCapabilitiesCalibration(this));
		UINT32 ExplicitCSITransmitBeamformingCapable:1 = FormatString("                   (%s) this STA can %sapply transmit beamforming using CSI explicit feedback in its transmission", this.ToBitString, this ? "" : "NOT ");
		UINT32 ExplicitNoncompressedSteeringCapable:1 = FormatString("                    (%s) this STA can %sapply transmit beamforming using noncompressed beamforming feedback matrix explicit feedback in its transmission", this.ToBitString, this ? "" : "NOT ");
		UINT32 ExplicitCompressedSteeringCapable:1 = FormatString("                       (%s) this STA can %sapply transmit beamforming using compressed beamforming feedback matrix explicit feedback in its transmission", this.ToBitString, this ? "" : "NOT ");
		UINT32 ExplicitTransmitBeamformingCSIFeedback:2 = FormatString("                  (%s) %s", this.ToBitString, TransmitBeamformingCapabilitiesFeedback(this));
		UINT32 ExplicitNoncompressedBeamformingFeedbackCapable:2 = FormatString("         (%s) %s", this.ToBitString, TransmitBeamformingCapabilitiesFeedback(this));
		UINT32 ExplicitCompressedBeamformingFeedbackCapable:2 = FormatString("            (%s) %s", this.ToBitString, TransmitBeamformingCapabilitiesFeedback(this));
		UINT32 MinimalGrouping:2 = FormatString("                                         (%s) %s", this.ToBitString, TransmitBeamformingCapabilitiesMinimalGrouping(this));
		UINT32 CSINumberofBeamformerAntennasSupported:2 = FormatString("                  (%s) %s", this.ToBitString, TransmitBeamformingCapabilitiesNumberofBeamformerAntennas(this));
		UINT32 NoncompressedSteeringNumberofBeamformerAntennasSupported:2 = FormatString("(%s) %s", this.ToBitString, TransmitBeamformingCapabilitiesNumberofBeamformerAntennas(this));
		UINT32 CompressedSteeringNumberofBeamformerAntennasSupported:2 = FormatString("   (%s) %s", this.ToBitString, TransmitBeamformingCapabilitiesNumberofBeamformerAntennas(this));
		UINT32 CSIMaxNumberofRowsBeamformerSupported:2 = FormatString("                   (%s) %d row(s) of CSI", this.ToBitString, this);
		UINT32 ChannelEstimationCapability:2 = FormatString("                             (%s) %d space-time stream(s)", this.ToBitString, this);
		UINT32 Reserved:3 = FormatString("                                                (%s) Reserved", this.ToBitString);
	};
	UINT8 ASELCapabilities
	{
		UINT8 AntennaSelectionCapable:1 = FormatString("                       (%s) ASEL is %ssupported", this.ToBitString, This ? "" : "NOT ");
		UINT8 ExplicitCSIFeedbackBasedTransmitASELCapable:1 = FormatString("   (%s) Transmit ASEL based on explicit CSI feedback is %ssupported", this.ToBitString, This ? "" : "NOT ");
		UINT8 AntennaIndicesFeedbackBasedTransmitASELCapable:1 = FormatString("(%s) Transmit ASEL based on antenna indices feedback is %ssupported", this.ToBitString, This ? "" : "NOT ");
		UINT8 ExplicitCSIFeedbackCapable:1 = FormatString("                    (%s) Compute CSI and provide CSI feedback in support of ASEL is %ssupported", this.ToBitString, This ? "" : "NOT ");
		UINT8 AntennaIndicesFeedbackCapable:1 = FormatString("                 (%s) Compute an antenna indices selection and return an antenna indices selection in support of ASEL is %ssupported", this.ToBitString, This ? "" : "NOT ");
		UINT8 ReceiveASELCapable:1 = FormatString("                            (%s) Receive ASEL is %ssupported", this.ToBitString, This ? "" : "NOT ");
		UINT8 TransmitSoundingPPDUsCapable:1 = FormatString("                  (%s) Transmit sounding PPDUs for ASEL training on request is %ssupported", this.ToBitString, This ? "" : "NOT ");
		UINT8 Reserved:1 = FormatString("                                      (%s) Reserved", this.ToBitString);
	};
}

table SecondaryChannelOffsetTable
{
	switch(value)
	{
		case 0:  "(SCN) no secondary channel is present";
		case 1:  "(SCA) the secondary channel is above the primary channel";
		case 2:  "Reserved";
		case 3:  "(SCB) the secondary channel is below the primary channel";
		default: "Reserved";
	}
}

table WiFiHTOperationHTProtection
{
	switch(value)
	{
		case 0: "no protection mode";
		case 1: "nonmember protection mode";
		case 2: "20 MHz protection mode";
		case 3: "non-HT mixed mode";
	}
}

//From 802.11n: 7.3.2.57 HT Operation element
struct WiFiHTOperation
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	UINT8 PrimaryChannel;
	//Flags 1
	struct {
		UINT8 SecondaryChannelOffset:2 = FormatString("(%s) %s", this.ToBitString, SecondaryChannelOffsetTable(this));
		UINT8 STAChannelWidth:1 = FormatString("       (%s) %s", this.ToBitString, this ? "allows use of any channel width in the Supported channel width set" : "20 MHz channel width");
		UINT8 RIFSMode:1 = FormatString("              (%s) Use of RIFS is %s", this.ToBitString, this ? "permitted" : "prohibited");
		UINT8 Reserved:4 = FormatString("              (%s) Reserved", this.ToBitString);
	}
	//Flags 2
	struct {
		UINT16 HTProtection:2 = FormatString("              (%s) %s", this.ToBitString, WiFiHTOperationHTProtection(this));
		UINT16 NongreenfieldHTSTAsPresent:1 = FormatString("(%s) %sall HT STAs that are associated are HT-greenfield capable", this.ToBitString, this ? "NOT " : "");
		UINT16 Reserved:1 = FormatString("                  (%s) Reserved", this.ToBitString);
		UINT16 OBSSNonHTSTAsPresent:1 = FormatString("      (%s) %s", this.ToBitString, this ? "on" : "off" );
		UINT16 Reserved1:11 = FormatString("                 (%s) Reserved", this.ToBitString);
	}
	//Flags 3
	struct {
		UINT16 Reserved:6 = FormatString("                     (%s) Reserved", this.ToBitString);
		UINT16 DualBeacon:1 = FormatString("                   (%s) %s STBC beacon is transmitted by the AP", this.ToBitString, this ? "An" : "No" );
		UINT16 DualCTSProtection:1 = FormatString("            (%s) Dual CTS protection is %srequired", this.ToBitString, this ? "" : "NOT " );
		UINT16 STBCBeacon:1 = FormatString("                   (%s) %s beacon", this.ToBitString, this ? "An STBC" : "A primary" );
		UINT16 LSIGTXOPProtectionFullSupport:1 = FormatString("(%s) %sAll HT STA in the BSS support L-SIG TXOP protection", this.ToBitString, this ? "" : "NOT " );
		UINT16 PCOActive:1 = FormatString("                    (%s) PCO is %sactive in the BSS", this.ToBitString, this ? "" : "NOT " );
		UINT16 PCOPhase:1 = FormatString("                     (%s) Switch to or continue %s MHz phase", this.ToBitString, this ? "40" : "20" );
		UINT16 Reserved1:4 = FormatString("                    (%s) Reserved", this.ToBitString);
	}
	WiFiMCSSet BasicMCSSet;
}

//From 802.11n: 7.3.2.20a Secondary Channel Offset element
struct WiFiSecondaryChannelOffset = SecondaryChannelOffset
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	UINT8 SecondaryChannelOffset = FormatString("%d, %s", this, SecondaryChannelOffsetTable(this));
}

//From 802.11n: 7.3.2.60 20/40 BSS Coexistence element
struct WiFi20and40BSSCoexistence
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	struct {
		UINT8 InformationRequest:1 = FormatString("          (%s) %sRequest to transmit a 20/40 BSS Coexistence Management frame with the transmitting STA as the recipient", this.ToBitString, this ? "" : "DON'T ");
		UINT8 FortyMHzIntolerant:1 = FormatString("          (%s) %s an AP that receives this information or reports of this information from operating a 20/40 MHz BSS", this.ToBitString, this ? "Prohibit" : "Allow");
		UINT8 TwentyMHzBSSWidthRequest:1 = FormatString("    (%s) %s a receiving AP from operating its BSS as a 20/40 MHz BSS", this.ToBitString, this ? "Prohibit" : "Allow");
		UINT8 OBSSScanningExemptionRequest:1 = FormatString("(%s) The transmitting non-AP STA is requesting the BSS to allow the STA to be exempt from OBSS scanning", this.ToBitString);
		UINT8 OBSSScanningExemptionGrant:1 = FormatString("  (%s) Reserved", this.ToBitString);
		UINT8 Reserved:3 = FormatString("                    (%s) Reserved", this.ToBitString);
	}
}

//From 802.11n 7.3.2.58 20/40 BSS Intolerant Channel Report element
struct WiFi20and40BSSIntolerantChannelReport
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	UINT8 RegulatoryClass;
	struct ChannelList
	{
		INT8 ChannelNumber[Length - 1];
	};
}

//From 802.11n: 7.3.2.59 Overlapping BSS Scan Parameters element
struct WiFiOverlappingBSSScanParameters
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	UINT16 OBSSScanPassiveDwell;
	UINT16 OBSSScanActiveDwell;
	UINT16 BSSChannelWidthTriggerScanInterval;
	UINT16 OBSSScanPassiveTotalPerChannel;
	UINT16 OBSSScanActiveTotalPerChannel;
	UINT16 BSSWidthChannelTransitionDelayFactor;
	UINT16 OBSSScanActivityThreshold;
}

//From 802.11: 7.3.2.27 Extended Capabilities information element
struct WiFiExtendedCapabilities
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	BLOB(Length) ExtendedCapabilities;
}

//From 802.11k 7.3.2.36 AP Channel Report element
struct WiFiAPChannelReport
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	UINT8 RegulatoryClass;
	struct ChannelList
	{
		INT8 ChannelNumber[Length - 1];
	};
}

//From 802.11k 7.3.2.37 Neighbor Report element
struct WiFiNeighborReport
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	UINT48 BSSID = MacTable(this);
	struct BSSIDInformation
	{
		UINT32 APReachability:2 = FormatString("    (%s) %s", this.ToBitString, WiFiAPReachabilityTable(this));
		UINT32 Security:1 = FormatString("          (%s) %s", this.ToBitString, this? "Security supported" : "Security Not supported");
		UINT32 KeyScope:1 = FormatString("          (%s) %d", this.ToBitString, this? "BSSID has the same authenticator as the AP sending the report" : "A distinct authenticator or the information is not available");
		UINT32 SpectrumManagement:1 = FormatString("(%s) %s", this.ToBitString, this ? "Required" : "Not Required");
		UINT32 QoS:1 = FormatString("               (%s) %s", this.ToBitString, this ? "Implemented" : "Not Implemented");
		UINT32 APSD:1 = FormatString("              (%s) %s", this.ToBitString, this ? "Implemented" : "Not Implemented");
		UINT32 RadioMeasurement:1 = FormatString("  (%s) %s", this.ToBitString, this ? "Enabled" : "Disabled");
		UINT32 DelayedBlockAck:1 = FormatString("   (%s) %s", this.ToBitString, this ? "Implemented" : "Not Implemented");
		UINT32 ImmediateBlockAck:1 = FormatString(" (%s) %s", this.ToBitString, this ? "Implemented" : "Not Implemented");
		UINT32 MobilityDomain:1 = FormatString("    (%s) %s", this.ToBitString, this? "Implemented" : "Not Implemented");
		UINT32 Reserved:21 = FormatString("          (%s) %d", this.ToBitString, this);
	}
	UINT8 RegulatoryClass;
	UINT8 ChannelNumber;
	UINT8 PHYType;
	while OptionalSubElemnts[UINT8( Framedata, Offset + 1 ) + FrameOffset + 2 <= WiFiPktLen]
	{
		WiFiInNeighborReportSubelement Subelement;
	}
}

struct WiFiInNeighborReportSubelement
{
	switch ( UINT8(Framedata, Offset) )
	{
		case 1:
			_struct TSFInfo
			{
				UINT8 SubelementID = WiFiInNeighborReportSubelementIDTable(this);
				UINT8 Length;
				UINT16 TSFOffset;
				UINT16 BeaconInterval;
			}
		case 2:
			_struct CondensedCountryString
			{
				UINT8 SubelementID = WiFiInNeighborReportSubelementIDTable(this);
				UINT8 Length;
				UINT16 CondensedCountryString;
			}
		case 66: WiFiMeasurementPilotTransInfo MeasurementPilotTransmissionInfo;
		case 70: WiFiRRMEnabledCapabilities RRMEnabledCapabilities;
		case 71: WiFiMultipleBSSID MultipleBSSID;
		case 221: WiFiVendorSpecificInfo VendorSpecificInfo;
		default:
			_struct
			{
				UINT8 SubelementID = WiFiInNeighborReportSubelementIDTable(this);
				UINT8 Length;
				Blob( Length ) Data;
			}
	}
}

table WiFiInNeighborReportSubelementIDTable(value)
{
	switch(value)
	{
		case 1: "TSF Information";
		case 2: "Condensed Country String";
		case 66: "Measurement Pilot Transmission Information";
		case 70: "RRM Enabled Capabilities";
		case 71: "Multiple BSSID";
		case 221: "Vendor Specific";
		default: FormatString("Reserved (%d)", value);
	}
}

table WiFiAPReachabilityTable(value)
{
	switch(value)
	{
		case 0: "Reserved";
		case 1: "Not Reachable";
		case 2: "Unknown";
		case 3: "Reachable";
		default: FormatString("Undefined Value (%d)", value);
	}
}

//From 802.11k: 7.3.2.38 RCPI element
struct WiFiRCPI
{
	UINT8 ElementID= WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	UINT8 RCPI;
}

//From 802.11k: 7.3.2.39 BSS Average Access Delay element
struct WiFiBSSAverageAccessDelay
{
	UINT8 ElementID = WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	UINT8 APAverageAccessDelay = WiFiAPAverageAccessDelayTable(this);
}

table WiFiAPAverageAccessDelayTable(value)
{
	switch
	{
		case value == 0: "Access Delay < 8 s";
		case value == 1: "8 s  Access Delay < 16 s";
		case value >= 2 && value <= 14: formatstring("%d s  Access Delay < %d s", value * 8, (value + 1) * 8);
		case value == 15: "120 s  Access Delay < 128 s";
		case value == 16: "128 s  Access Delay < 144 s";
		case value >= 17 && value <= 106: formatstring("%d s  Access Delay < %d s", value * 16 - 128, (value + 1) * 16 - 128);
		case value == 107: "1584 s  Access Delay < 1600 s";
		case value == 108: "1600 s  Access Delay < 1632 s";
		case value >= 109 && value <= 246: formatstring("%d s  Access Delay < %d s", value * 32 - 1856, (value + 1) * 32 - 1856);
		case value == 247: "6048 s  Access Delay < 6080 s";
		case value == 248: "6080 s  Access Delay < 8192 s";
		case value == 249: "8192 s  Access Delay < 12288 s";
		case value == 250: "12288 s  Access Delay < 16384 s";
		case value == 251: "16384 s  Access Delay < 20480 s";
		case value == 252: "20480 s  Access Delay < 24576 s";
		case value == 253: "24576 s  Access Delay";
		case value == 254: "Service unable to access channel";
		case value == 255: "Measurement not available";
	}
}

//From 802.11k: 7.3.2.40 Antenna Information element
struct WiFiAntennaInformation
{
	UINT8 ElementID = WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	UINT8 AntennaID;
}

//From 802.11k: 7.3.2.41 RSNI element
struct WiFiRSNI
{
	UINT8 ElementID = WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	UINT8 RSNI;
}

//From 802.11k: 7.3.2.42 Measurement Pilot Transmission Information element
struct WiFiMeasurementPilotTransInfo
{
	UINT8 ElementID = WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	UINT8 MeasurementPilotTransmission;
	while OptionalSubElemnts[UINT8( Framedata, Offset + 1 ) + FrameOffset + 2 <= WiFiPktLen]
	{
		WiFiFrameRequestSubelement Subelement;
	}
}

//From 802.11k: 7.3.2.43 BSS Available Admission Capacity element
struct WiFiBSSAvailableAdmissionCapacity
{
	UINT8 ElementID = WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	struct AvailableAdmissionCapacityBitmask
	{
		UINT16 UP0:1 = FormatString("     (%s) %s", this.ToBitString, this ? "Present" : "NotPresent");
		UINT16 UP1:1 = FormatString("     (%s) %s", this.ToBitString, this ? "Present" : "NotPresent");
		UINT16 UP2:1 = FormatString("     (%s) %s", this.ToBitString, this ? "Present" : "NotPresent");
		UINT16 UP3:1 = FormatString("     (%s) %s", this.ToBitString, this ? "Present" : "NotPresent");
		UINT16 UP4:1 = FormatString("     (%s) %s", this.ToBitString, this ? "Present" : "NotPresent");
		UINT16 UP5:1 = FormatString("     (%s) %s", this.ToBitString, this ? "Present" : "NotPresent");
		UINT16 UP6:1 = FormatString("     (%s) %s", this.ToBitString, this ? "Present" : "NotPresent");
		UINT16 UP7:1 = FormatString("     (%s) %s", this.ToBitString, this ? "Present" : "NotPresent");
		UINT16 AC0:1 = FormatString("     (%s) %s", this.ToBitString, this ? "Present" : "NotPresent");
		UINT16 AC1:1 = FormatString("     (%s) %s", this.ToBitString, this ? "Present" : "NotPresent");
		UINT16 AC2:1 = FormatString("     (%s) %s", this.ToBitString, this ? "Present" : "NotPresent");
		UINT16 AC3:1 = FormatString("     (%s) %s", this.ToBitString, this ? "Present" : "NotPresent");
		UINT16 Reserved:4 = FormatString("(%s) Reserved", this.ToBitString);
	}
	struct AvailableAdmissionCapacityList
	{
		switch
		{
			case AvailableAdmissionCapacityBitmask & 0x0001:
				UINT16 UP0AvailableAdmissionCapacity;
		}
		switch
		{
			case AvailableAdmissionCapacityBitmask & 0x0002:
				UINT16 UP1AvailableAdmissionCapacity;
		}
		switch
		{
			case AvailableAdmissionCapacityBitmask & 0x0004:
				UINT16 UP2AvailableAdmissionCapacity;
		}
		switch
		{
			case AvailableAdmissionCapacityBitmask & 0x0008:
				UINT16 UP3AvailableAdmissionCapacity;
		}
		switch
		{
			case AvailableAdmissionCapacityBitmask & 0x0010:
				UINT16 UP4AvailableAdmissionCapacity;
		}
		switch
		{
			case AvailableAdmissionCapacityBitmask & 0x0020:
				UINT16 UP5AvailableAdmissionCapacity;
		}
		switch
		{
			case AvailableAdmissionCapacityBitmask & 0x0040:
				UINT16 UP6AvailableAdmissionCapacity;
		}
		switch
		{
			case AvailableAdmissionCapacityBitmask & 0x0080:
				UINT16 UP7AvailableAdmissionCapacity;
		}
		switch
		{
			case AvailableAdmissionCapacityBitmask & 0x0100:
				UINT16 AC0AvailableAdmissionCapacity;
		}
		switch
		{
			case AvailableAdmissionCapacityBitmask & 0x0200:
				UINT16 AC1AvailableAdmissionCapacity;
		}
		switch
		{
			case AvailableAdmissionCapacityBitmask & 0x0400:
				UINT16 AC2AvailableAdmissionCapacity;
		}
		switch
		{
			case AvailableAdmissionCapacityBitmask & 0x0800:
				UINT16 AC3AvailableAdmissionCapacity;
		}
	}
}

//From 802.11k: 7.3.2.44 BSS AC Access Delay element
struct WiFiBSSACAccessDelay
{
	UINT8 ElementID = WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	struct AccessDelay
	{
		UINT8 ACBestEffort= WiFiAPAverageAccessDelayTable(this);
		UINT8 ACBackground= WiFiAPAverageAccessDelayTable(this);
		UINT8 ACVideo= WiFiAPAverageAccessDelayTable(this);
		UINT8 ACVoice= WiFiAPAverageAccessDelayTable(this);
	}
}

//From 802.11k: 7.3.2.45 RRM Enabled Capabilities Element
struct WiFiRRMEnabledCapabilities
{
	UINT8 ElementID = WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	UINT40 RRMEnabledCapabilities
	{
		UINT40 LinkMeasurementCapability:1 = FormatString("                             (%s) %s", this.ToBitString, this ? "Enabled" : "Disabled");
		UINT40 NeighborReportCapability:1 = FormatString("                              (%s) %s", this.ToBitString, this ? "Enabled" : "Disabled");
		UINT40 ParallelMeasurementsCapability:1 = FormatString("                        (%s) %s", this.ToBitString, this ? "Enabled" : "Disabled");
		UINT40 RepeatedMeasurementsCapability:1 = FormatString("                        (%s) %s", this.ToBitString, this ? "Enabled" : "Disabled");
		UINT40 BeaconPassiveMeasurementCapability:1 = FormatString("                    (%s) %s", this.ToBitString, this ? "Enabled" : "Disabled");
		UINT40 BeaconActiveMeasurementCapability:1 = FormatString("                     (%s) %s", this.ToBitString, this ? "Enabled" : "Disabled");
		UINT40 BeaconTableMeasurementCapability:1 = FormatString("                      (%s) %s", this.ToBitString, this ? "Enabled" : "Disabled");
		UINT40 BeaconMeasurementReportingConditionsCapability:1 = FormatString("        (%s) %s", this.ToBitString, this ? "Enabled" : "Disabled");
		UINT40 FrameMeasurementCapability:1 = FormatString("                            (%s) %s", this.ToBitString, this ? "Enabled" : "Disabled");
		UINT40 ChannelLoadMeasurementCapability:1 = FormatString("                      (%s) %s", this.ToBitString, this ? "Enabled" : "Disabled");
		UINT40 NoiseHistogramMeasurementCapability:1 = FormatString("                   (%s) %s", this.ToBitString, this ? "Enabled" : "Disabled");
		UINT40 StatisticsMeasurementCapability:1 = FormatString("                       (%s) %s", this.ToBitString, this ? "Enabled" : "Disabled");
		UINT40 LCIMeasurementCapability:1 = FormatString("                              (%s) %s", this.ToBitString, this ? "Enabled" : "Disabled");
		UINT40 LCIAzimuthCapability:1 = FormatString("                                  (%s) %s", this.ToBitString, this ? "Enabled" : "Disabled");
		UINT40 TransmitStreamOrCategoryMeasurementCapability:1 = FormatString("         (%s) %s", this.ToBitString, this ? "Enabled" : "Disabled");
		UINT40 TriggeredTransmitStreamOrCategoryMeasurementCapability:1 = FormatString("(%s) %s", this.ToBitString, this ? "Enabled" : "Disabled");
		UINT40 APChannelReportCapability:1 = FormatString("                             (%s) %s", this.ToBitString, this ? "Enabled" : "Disabled");
		UINT40 RRMMIBCapability:1 = FormatString("                                      (%s) %s", this.ToBitString, this ? "Enabled" : "Disabled");
		UINT40 OperatingChannelMaxMeasurementDuration:3 = FormatString("                (%s) %d", this.ToBitString, this);
		UINT40 NonOperatingChannelMaxMeasurementDuration:3 = FormatString("             (%s) %d", this.ToBitString, this);
		//UINT40 MeasurementPilotCapability:3 = FormatString("                            (%s) %s", this.ToBitString, WiFiMeasurementPilotCapabilityTable(this));
UINT40 MeasurementPilotCapability:3 = FormatString("                            (%s) %s", this.ToBitString, this);
		UINT40 MeasurementPilotTransmissionInformationCapability:1 = FormatString("     (%s) %s", this.ToBitString, this ? "Enabled" : "Disabled");
		UINT40 NeighborReportTSFOffsetCapability:1 = FormatString("                     (%s) %s", this.ToBitString, this ? "Enabled" : "Disabled");
		UINT40 RCPIMeasurementCapability:1 = FormatString("                             (%s) %s", this.ToBitString, this ? "Enabled" : "Disabled");
		UINT40 RSNIMeasurementCapability:1 = FormatString("                             (%s) %s", this.ToBitString, this ? "Enabled" : "Disabled");
		UINT40 BSSAverageAccessDelayCapability:1 = FormatString("                       (%s) %s", this.ToBitString, this ? "Enabled" : "Disabled");
		UINT40 BSSAvailableAdmissionCapacityCapability:1 = FormatString("               (%s) %s", this.ToBitString, this ? "Enabled" : "Disabled");
		UINT40 AntennaInformationCapability:1 = FormatString("                          (%s) %s", this.ToBitString, this ? "Enabled" : "Disabled");
		UINT40 Reserved:6 = FormatString("                                              (%s) Reserved", this.ToBitString);
	};
}

//From 802.11k: 7.3.2.46 Multiple BSSID Element
struct WiFiMultipleBSSID
{
	UINT8 ElementID = WiFiInformationFieldsTypeTable(this);
	UINT8 Length;
	UINT8 MaxBSSIDIndicator;
	while OptionalSubElemnts[UINT8( Framedata, Offset + 1 ) + FrameOffset + 2 <= WiFiPktLen]
	{
		WiFiFrameRequestSubelement Subelement;
	}
}

//How to distinguish AP from Non-AP STA
//From 802.11k: Table 11-11Measurement Pilot Capability definition
//table WiFiMeasurementPilotCapabilityTable(value)
//{
	//switch
	//{
		//case "AP" && "Non-AP STA" && value == 0: "The STA does not support Measurement Pilots";
		//case "AP" && "Non-AP STA" && value == 1: "The STA supports Measurement Pilots";
		//case "Non-AP STA" && value == 2: "The non-AP STA is making use of the MPs it receives or would receive if they were being transmitted";
		//case "Non-AP STA" && value >= 3 && value <= 7: "Reserved";
		//case "AP" && value == 2: "> 3% and < 5% of Beacon Interval";
		//case "AP" && value == 3: " 5% and < 10% of Beacon Interval"";
		//case "AP" && value == 4: " 10% and < 15% of Beacon Interval"";
		//case "AP" && value == 5: " 15% and < 20% of Beacon Interval"";
		//case "AP" && value == 6: " 20% and < 25% of Beacon Interval"";
		//case "AP" && value == 7: " 25% and < 50% of Beacon Interval"";
	//}
//}