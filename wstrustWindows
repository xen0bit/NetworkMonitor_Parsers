//#  (c) 2009 CodePlex Foundation
//#
//#  Title:                  Web Services Trust Language (WS-Trust)
//#
//#  Details:                
//#
//#  Public References:      http://specs.xmlsoap.org/ws/2005/02/trust/WS-Trust.pdf
//#  Microsoft References:   [MS-CTAP]: CardSpace Token Acquisition Protocol Specification (4.0)
//#                          [MS-LWSSP]: Lightweight Web Services Security Profile (2.0)
//#
//#  Comments:               Microsoft implementation is encrypted
//#
//#  Revision Class and Date:Major, 8/31/2009
//#                          Minor, 2/2/2010
//#
//####

[Property.SoapBodySummary = "WS-Trust Payload"]
[RegisterBefore(SoapBody.DefaultSoapBody, WSTrust, WSTrustSoapActionTable(Property.SOAPAction))]
Protocol WSTrust = Property.WSTrustSummary
{
	Switch(Property.SOAPAction)
	{
		Case "http://schemas.xmlsoap.org/ws/2005/02/trust/RST/Issue":
		Case "http://schemas.xmlsoap.org/ws/2005/02/trust/RSTR/Issue":
			[Property.WSTrustSummary = this.ToString]
			WSTrustIssue WSTrustIssue;
		Case "http://schemas.xmlsoap.org/ws/2005/02/trust/RST/Renew":
		Case "http://schemas.xmlsoap.org/ws/2005/02/trust/RSTR/Renew":
			[Property.SSDPWPSummary = this.ToString]
			WSTrustRenew WSTrustRenew;
		Case "http://schemas.xmlsoap.org/ws/2005/02/trust/RST/Cancel":
		Case "http://schemas.xmlsoap.org/ws/2005/02/trust/RSTR/Cancel":
			[Property.SSDPWPSummary = this.ToString]
			WSTrustCancel WSTrustCancel;
		Case "http://schemas.xmlsoap.org/ws/2005/02/trust/RST/Validate":
		Case "http://schemas.xmlsoap.org/ws/2005/02/trust/RSTR/Validate":
			[Property.SSDPWPSummary = this.ToString]
			WSTrustValidate WSTrustValidate;
		Default:
			[Property.SSDPWPSummary = "Unknown Message"]
			While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
			{
				XmlElement(true) AnyNode;
			}
	}
}

table WSTrustSoapActionTable(value)
{
	switch(value)
	{
		Case "http://schemas.xmlsoap.org/ws/2005/02/trust/RST/Issue":
		Case "http://schemas.xmlsoap.org/ws/2005/02/trust/RSTR/Issue":
		Case "http://schemas.xmlsoap.org/ws/2005/02/trust/RST/Renew":
		Case "http://schemas.xmlsoap.org/ws/2005/02/trust/RSTR/Renew":
		Case "http://schemas.xmlsoap.org/ws/2005/02/trust/RST/Cancel":
		Case "http://schemas.xmlsoap.org/ws/2005/02/trust/RSTR/Cancel":
		Case "http://schemas.xmlsoap.org/ws/2005/02/trust/RST/Validate":
		Case "http://schemas.xmlsoap.org/ws/2005/02/trust/RSTR/Validate":true;
		default : false;
	}
}

struct WSTrustIssue = FormatString("%s Message", Property.WSTrustIssueSummary)
{
	[Post.Local.SoapBody_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.SoapBody_IsEmpty:
			struct
			{
				switch
				{
					case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RequestSecurityTokenResponseCollection"): 
						[Property.WSTrustIssueSummary = "Issue Response"]
						WSTrustRequestSecurityTokenResponseCollection RequestSecurityTokenResponseCollection;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RequestSecurityTokenResponse"): 
						[Property.WSTrustIssueSummary = "Issue Response"]
						WSTrustRequestSecurityTokenResponse RequestSecurityTokenResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RequestSecurityToken"): 
						[Property.WSTrustIssueSummary = "Issue Request"]
						WSTrustRequestSecurityToken RequestSecurityToken;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"): 
						[Property.WSTrustIssueSummary = "Fault Issue Response"]
						SoapFaultElement FaultIssueElement;
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WSTrustIssueSummary = "Encrypted Issue Data"]
						XMLENCEncryptedData EncryptedData;
				}
				XmlTag("Body") ETag;
			}
	}
}

struct WSTrustRenew = FormatString("%s Message", Property.WSTrustRenewSummary)
{
	[Post.Local.SoapBody_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.SoapBody_IsEmpty:
			struct
			{
				switch
				{
					case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RequestSecurityTokenResponseCollection"): 
						[Property.WSTrustRenewSummary = "Renew Response"]
						WSTrustRequestSecurityTokenResponseCollection RequestSecurityTokenResponseCollection;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RequestSecurityTokenResponse"): 
						[Property.WSTrustRenewSummary = "Renew Response"]
						WSTrustRequestSecurityTokenResponse RequestSecurityTokenResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RequestSecurityToken"): 
						[Property.WSTrustRenewSummary = "Renew Request"]
						WSTrustRequestSecurityToken RequestSecurityToken;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"): 
						[Property.WSTrustRenewSummary = "Fault Renew Response"]
						SoapFaultElement FaultRenewElement;
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WSTrustRenewSummary = "Encrypted Renew Data"]
						XMLENCEncryptedData EncryptedData;
				}
				XmlTag("Body") ETag;
			}
	}
}

struct WSTrustCancel = FormatString("%s Message", Property.WSTrustCancelSummary)
{
	[Post.Local.SoapBody_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.SoapBody_IsEmpty:
			struct
			{
				switch
				{
					case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RequestSecurityTokenResponseCollection"): 
						[Property.WSTrustCancelSummary = "Cancel Response"]
						WSTrustRequestSecurityTokenResponseCollection RequestSecurityTokenResponseCollection;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RequestSecurityTokenResponse"): 
						[Property.WSTrustCancelSummary = "Cancel Response"]
						WSTrustRequestSecurityTokenResponse RequestSecurityTokenResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RequestSecurityToken"): 
						[Property.WSTrustCancelSummary = "Cancel Request"]
						WSTrustRequestSecurityToken RequestSecurityToken;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"): 
						[Property.WSTrustCancelSummary = "Fault Cancel Response"]
						SoapFaultElement FaultCancelElement;
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WSTrustCancelSummary = "Encrypted Cancel Data"]
						XMLENCEncryptedData EncryptedData;
				}
				XmlTag("Body") ETag;
			}
	}
}

struct WSTrustValidate = FormatString("%s Message", Property.WSTrustValidateSummary)
{
	[Post.Local.SoapBody_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.SoapBody_IsEmpty:
			struct
			{
				switch
				{
					case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RequestSecurityTokenResponseCollection"): 
						[Property.WSTrustValidateSummary = "Validate Response"]
						WSTrustRequestSecurityTokenResponseCollection RequestSecurityTokenResponseCollection;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RequestSecurityTokenResponse"): 
						[Property.WSTrustValidateSummary = "Validate Response"]
						WSTrustRequestSecurityTokenResponse RequestSecurityTokenResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RequestSecurityToken"): 
						[Property.WSTrustValidateSummary = "Validate Request"]
						WSTrustRequestSecurityToken RequestSecurityToken;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"): 
						[Property.WSTrustValidateSummary = "Fault Validate Response"]
						SoapFaultElement FaultValidateElement;
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WSTrustValidateSummary = "Encrypted Validate Data"]
						XMLENCEncryptedData EncryptedData;
				}
				XmlTag("Body") ETag;
			}
	}
}


[RegisterBefore(
    SoapHeader.SoapHeaderNodes.Node,
    IssuedTokens,
    Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "IssuedTokens"))]
struct WSTrustIssuedTokens = this.STag.ToString
{
	XMLTag("IssuedTokens") STag;
	switch
	{
		case !(Property.IsXmlEmptyElement):
			struct
			{
				While [String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
				{
					switch
					{
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("RequestSecurityTokenResponse"):
							WSTrustRequestSecurityTokenResponse RequestSecurityTokenResponse;
						default:
							xmlelement(true) element;
					}
				}
				XMLTag("IssuedTokens") ETag;
			}
	}
}

struct WSTrustRequestSecurityTokenResponse = this.STag.ToString
{
	XMLTag("RequestSecurityTokenResponse") STag;
	switch
	{
		case !(Property.IsXmlEmptyElement):
			struct
			{
				While [String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
				{
					switch
					{
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("RequestType"):
							xmlelement(true) RequestType;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("KeyType"):
							xmlelement(true) KeyType;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("TokenType"):
							xmlelement(true) TokenType;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("AppliesTo"):
							xmlelement(true) AppliesTo;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("RequestedAttachedReference"):
							xmlelement(true) RequestedAttachedReference;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("RequestedUnattachedReference"):
							xmlelement(true) RequestedUnattachedReference;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("RequestedProofToken"):
							WSTrustRequestedProofToken RequestedProofToken;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("RequestedDisplayToken"):
							WSTrustRequestedDisplayToken RequestedDisplayToken;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Entropy"):
							xmlelement(true) Entropy;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Lifetime"):
							WSTrustLifetime Lifetime;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Status"):
							WSTrustStatus Status;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("AllowPostdating"):
							xmlelement(true) AllowPostdating;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Renewing"):
							xmlelement(true) Renewing;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("OnBehalfOf"):
							xmlelement(true) OnBehalfOf;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Issuer"):
							xmlelement(true) Issuer;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Authenticator"):
							struct WSTrustAuthenticator
							{
								XMLTag("Participants") ParticipantsSTag;
								switch
								{
									case !(Property.IsXmlEmptyElement):
										struct
										{
											While [String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
											{
												switch
												{
													case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("CombinedHash"):
														xmlelement(true) CombinedHash;
													default:
														xmlelement(true) element;
												}
											}
											XMLTag("Participants") ParticipantsETag;
										}
								}
							}
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("KeySize"):
							xmlelement(true) KeySize;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("SignatureAlgorithm"):
							xmlelement(true) SignatureAlgorithm;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("EncryptionAlgorithm"):
							xmlelement(true) EncryptionAlgorithm;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Encryption"):
							xmlelement(true) Encryption;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("CanonicalizationAlgorithm"):
							xmlelement(true) CanonicalizationAlgorithm;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("ProofEncryption"):
							xmlelement(true) ProofEncryption;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("UseKey"):
							xmlelement(true) UseKey;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("SignWith"):
							xmlelement(true) SignWith;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("EncryptWith"):
							xmlelement(true) EncryptWith;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("DelegateTo"):
							xmlelement(true) DelegateTo;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Forwardable"):
							xmlelement(true) Forwardable;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Delegatable"):
							xmlelement(true) Delegatable;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("PolicyReference"):
							xmlelement(true) PolicyReference;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Policy"):
							xmlelement(true) Policy;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("SignChallengeResponse"):
							struct WSTrustSignChallengeResponse
							{
								XMLTag("SignChallengeResponse") SignChallengeResponseSTag;
								switch
								{
									case !(Property.IsXmlEmptyElement):
										struct
										{
											While [String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
											{
												switch
												{
													case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Challenge"):
														xmlelement(true) Challenge;
													default:
														xmlelement(true) element;
												}
											}
											XMLTag("SignChallengeResponse") SignChallengeResponseETag;
										}
								}
							}
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("SignChallenge"):
							struct WSTrustSignChallenge
							{
								XMLTag("SignChallenge") SignChallengeSTag;
								switch
								{
									case !(Property.IsXmlEmptyElement):
										struct
										{
											While [String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
											{
												switch
												{
													case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Challenge"):
														xmlelement(true) CombinedHash;
													default:
														xmlelement(true) element;
												}
											}
											XMLTag("SignChallenge") SignChallengeETag;
										}
								}
							}
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("EncryptedData"):
							XMLENCEncryptedData EncryptedData;
						default:
							xmlelement(true) element;
					}
				}
				XMLTag("RequestSecurityTokenResponse") ETag;
			}
	}
}

struct WSTrustStatus = this.STag.ToString
{
	XMLTag("Status") STag;
	switch
	{
		case !(Property.IsXmlEmptyElement):
			struct
			{
				While [String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
				{
					switch
					{
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Code"):
							xmlelement(true) Code;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Reason"):
							xmlelement(true) Reason;
					}
				}
				XMLTag("Status") ETag;
			}
	}
}

struct WSTrustRequestSecurityTokenResponseCollection = this.STag.ToString
{
	XMLTag("RequestSecurityTokenResponseCollection") STag;
	switch
	{
		case !(Property.IsXmlEmptyElement):
			struct
			{
				While [String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
				{
					switch
					{
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("RequestSecurityTokenResponse"):
							WSTrustRequestSecurityTokenResponse RequestSecurityTokenResponse;
						default:
							xmlelement(true) element;
					}
				}
				XMLTag("RequestSecurityTokenResponseCollection") ETag;
			}
	}
}

struct WSTrustRequestedProofToken = this.STag.ToString
{
	XMLTag("RequestedProofToken") STag;
	switch
	{
		case !(Property.IsXmlEmptyElement):
			struct
			{
				While [String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
				{
					switch
					{
						case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedKey"):
							XMLENCxencEncryptedKeyElement EncryptedKeyElement;
						default:
							xmlelement(true) Element;
					}
				}
				XMLTag("RequestedProofToken") ETag;
			}
	}
}

struct WSTrustRequestedDisplayToken = this.STag.ToString
{
	XMLTag("RequestedDisplayToken") STag;
	switch
	{
		case !(Property.IsXmlEmptyElement):
			struct
			{
				switch
				{
					case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("DisplayToken"):
						WSTrustDisplayToken DisplayToken;
				}
				XMLTag("RequestedDisplayToken") ETag;
			}
	}
}

struct WSTrustDisplayToken = this.STag.ToString
{
	XMLTag("DisplayToken") STag;
	switch
	{
		case !(Property.IsXmlEmptyElement):
			struct
			{
				While [ StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("DisplayClaim") && StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("</")]
				{
					WSTrustDisplayClaim DisplayClaim;
				}
				XMLTag("DisplayToken") ETag;
			}
	}
}

struct WSTrustDisplayClaim = this.STag.ToString
{
	XMLTag("DisplayClaim") STag;
	switch
	{
		case !(Property.IsXmlEmptyElement):
			struct
			{
				While [String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
				{
					switch
					{
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("DisplayTag"):
							xmlelement(true) DisplayClaim;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Description"):
							xmlelement(true) Description;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("DisplayValue"):
							xmlelement(true) DisplayValue;
						default:
							xmlelement(true) DisplayClaimelement;
					}
				}
				XMLTag("DisplayClaim") ETag;
			}
	}
}

struct WSTrustLifetime = this.STag.ToString
{
	XMLTag("Lifetime") STag;
	switch
	{
		case !(Property.IsXmlEmptyElement):
			struct
			{
				
				While [String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
				{
					switch
					{
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Created"):
							xmlelement(true) Created;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Expires"):
							xmlelement(true) Expires;
						default:
							xmlelement(true) Element;
					}
				}
				XMLTag("Lifetime") ETag;
			}
	}
}

[RegisterBefore(
    SoapHeader.SoapHeaderNodes.Node,
    WSSecurity,
    Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Security") 
				&& Contains(Property.SoapEnvelopeAttributes, "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"))]
struct WSTrustSecurity = this.STag.ToString
{
	XMLTag("Security") STag;
	switch
	{
		case !(Property.IsXmlEmptyElement):
		struct
		{
			While [String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
			{
				switch
				{
					case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Timestamp"):
						WSTrustTimestamp Timestamp;
					case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("DerivedKeyToken"):
						WSTrustDerivedKeyToken DerivedKeyToken;
					case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("ReferenceList"):
						xmlelement(true) ReferenceList;
					case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("SignatureConfirmation"):
						xmlelement(true) SignatureConfirmation;
					case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Signature"):
						WSTrustSignature Signature;
					case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("SecurityContextToken"):
						WSTrustSecurityContextToken SecurityContextToken;
					case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("BinarySecurityToken"):
						xmlelement(true) BinarySecurityToken;
					case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("UsernameToken"):
						WSTrustUsernameToken UsernameToken;
					case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Assertion"):
						WSTrustAssertion Assertion;
					case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("EncryptedData"):
						XMLENCEncryptedData EncryptedData;
					case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedKey"):
						XMLENCxencEncryptedKeyElement EncryptedKeyElement;
					default:
						xmlelement(true) Element;
				}
			}
			XMLTag("Security") ETag;
		}
	}
}

struct WSTrustUsernameToken = this.STag.ToString
{
	XMLTag("UsernameToken") STag;
	switch
	{
		case !(Property.IsXmlEmptyElement) :
			struct
			{
				while[!Contains(StringTerm(FrameData,FrameOffset,Property.XmlEncoding,Property.XMLElementNameTerm,True,False,False),"UsernameToken")]
				{
					switch
					{
						case Contains(StringTerm(FrameData,FrameOffset,Property.XmlEncoding,Property.XMLElementNameTerm,True,False,False),"Username") :
							XMLElement(true) Username;
						case Contains(StringTerm(FrameData,FrameOffset,Property.XmlEncoding,Property.XMLElementNameTerm,True,False,False),"Password ") :
							XMLElement(true) Password ;
						default: 
							XmlElement(true) Element;
					}
				}
				XmlTag("UsernameToken") ETag;
			}
	}
}

struct WSTrustSecurityContextToken = this.STag.ToString
{
	XMLTag("SecurityContextToken") STag;
	switch
	{
		case !(Property.IsXmlEmptyElement) :
			struct
			{
				while[!Contains(StringTerm(FrameData,FrameOffset,Property.XmlEncoding,Property.XMLElementNameTerm,True,False,False),"SecurityContextToken")]
				{
					switch
					{
						case Contains(StringTerm(FrameData,FrameOffset,Property.XmlEncoding,Property.XMLElementNameTerm,True,False,False),"Identifier") :
							XMLElement(true) Identifier;
						case Contains(StringTerm(FrameData,FrameOffset,Property.XmlEncoding,Property.XMLElementNameTerm,True,False,False),"Instance") :
							XMLElement(true) Instance;
						default:
							XMLElement(true) Element;
					}
				}
				XmlTag("SecurityContextToken") ETag;
			}
	}
}

struct WSTrustTimestamp = this.STag.ToString
{
	XMLTag("Timestamp") STag;
	switch
	{
		case !(Property.IsXmlEmptyElement):
			struct
			{
				While [String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
				{
					switch
					{
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Created"):
							xmlelement(true) Created;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Expires"):
							xmlelement(true) Expires;
						default:
							xmlelement(true) Element;
					}
				}
				XMLTag("Timestamp") ETag;
			}
	}
}

[RegisterBefore(XMLENCdsKeyInfoType.AnyChoice, SecurityTokenReference, Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "SecurityTokenReference"))]
struct WSTrustSecurityTokenReference = this.STag.ToString
{
	XMLTag("SecurityTokenReference") STag;
	switch
	{
		case !(Property.IsXmlEmptyElement):
			struct
			{
				While [String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
				{
					switch
					{
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("KeyIdentifier"):
							xmlelement(true) KeyIdentifier;
						case  StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Reference"):
							xmlelement(true) Reference;
						default:
							xmlelement(true) element;
					}
				}
				XMLTag("SecurityTokenReference") ETag;
			}
	}
}

struct WSTrustDerivedKeyToken = this.STag.ToString
{
	XMLTag("DerivedKeyToken") STag;
	switch
	{
		case !(Property.IsXmlEmptyElement):
			struct
			{
				While [String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
				{
					switch
					{
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("SecurityTokenReference"):
							WSTrustSecurityTokenReference KeyIdentifier;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Nonce"):
							xmlelement(true) Nonce;
						default:
							xmlelement(true) element;
					}
				}
				XMLTag("DerivedKeyToken") ETag;
			}
	}
}

struct WSTrustSignature = this.STag.ToString
{
	XMLTag("Signature") STag;
	switch
	{
		case !(Property.IsXmlEmptyElement):
			struct
			{
				
				struct WSTrustSignedInfo = this.STag.ToString
				{
					XMLTag("SignedInfo") STag;
					switch
					{
						case !(Property.IsXmlEmptyElement):
							struct
							{
								xmlelement(true) CanonicalizationMethod;
								xmlelement(true) SignatureMethod;
								While [String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
								{
									switch
									{
										case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Reference"):
											xmlelement(true) Reference;
										default:
											xmlelement(true) Element;
									}
								}
								XMLTag("SignedInfo") ETag;
							}
					}
				}
				xmlelement(true) SignatureValue;
				XMLENCdsKeyInfoElement KeyInfo;
				While [String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
				{
					switch
					{
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Object"):
							xmlelement(true) Object;
						default:
							xmlelement(true) Element;
					}
				}
				XMLTag("Signature") ETag;
			}
	}
}

struct WSTrustAssertion = this.STag.ToString
{
	XMLTag("Assertion") STag;
	switch
	{
		case !(Property.IsXmlEmptyElement):
			struct
			{
				While [String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
				{
					switch
					{
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Conditions"):
							WSTrustConditions Conditions;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Advice"):
							xmlelement(true) Advice;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Signature"):
							WSTrustSignature Signature;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Statement"):
							xmlelement(true) Statement;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("SubjectStatement"):
							xmlelement(true) SubjectStatement;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("AuthenticationStatement"):
							xmlelement(true) AuthenticationStatement;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("AuthorizationDecisionStatement"):
							xmlelement(true) AuthorizationDecisionStatement;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("AttributeStatement"):
							struct WSTrustAttributeStatement = this.STag.ToString
							{
								XMLTag("AttributeStatement") STag;
								switch
								{
									case !(Property.IsXmlEmptyElement):
										struct
										{
											WSTrustSubjectStatementAbstractType SubjectStatementAbstractType;
											XMLTag("AttributeStatement") ETag;
										}
								}
							}
						default:
							ReportParserError(ParserErrorProtocolClassPublic, "WSTrust", "Invalid Element") ElementError;
					}
				}
				XMLTag("Assertion") ETag;
			}
	}
}

struct WSTrustConditions = this.STag.ToString
{
	XMLTag("Conditions") STag;
	switch
	{
		case !(Property.IsXmlEmptyElement):
			struct
			{
				While [String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
				{
					switch
					{
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("AudienceRestrictionCondition"):
							struct
							{
								XMLTag("AudienceRestrictionCondition") AudienceRestrictionConditionSTag;
									switch
									{
										case !(Property.IsXmlEmptyElement):
											struct
											{
												While [String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
												{
													switch
													{
														case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Audience"):
															xmlelement(true) Audience;
													}
												}
												XMLTag("AudienceRestrictionCondition") AudienceRestrictionConditionETag;
											}
									}
							}
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("DoNotCacheCondition"):
							xmlelement(true) DoNotCacheCondition;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Condition"):
							xmlelement(true) Condition;
						default:
							ReportParserError(ParserErrorProtocolClassPublic, "WSTrust", "Invalid Element") ElementError;
					}
				}
				XMLTag("Conditions") ETag;
			}
	}
}

struct WSTrustSubjectStatementAbstractType
{
	While [String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
	{
		switch
		{
			case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Subject"):
				WSTrustSubject Subject;
			case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Attribute"):
				struct WSTrustAttribute = this.STag.ToString
				{
					XMLTag("Attribute") STag;
					switch
					{
						case !(Property.IsXmlEmptyElement):
							struct
							{
								While [String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
								{
									switch
									{
										case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("AttributeValue"):
											xmlelement(true) AttributeValue;
										default:
											xmlelement(true) Element;
										
									}
								}
								XMLTag("Attribute") ETag;
							}
					}
				}
			case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("SubjectLocality"):
				xmlelement(true) SubjectLocality;
			case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("AuthorityBinding"):
				xmlelement(true) AuthorityBinding;
			case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Action"):
				xmlelement(true) Action;
			case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Evidence"):
				xmlelement(true) Evidence;
			default:
				xmlelement(true) Element;
		}
	}
}

struct WSTrustSubject = this.STag.ToString
{
	XMLTag("Subject") STag;
	switch
	{
		case !(Property.IsXmlEmptyElement):
			struct
			{
				While [String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
				{
					switch
					{
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("NameIdentifier"):
							xmlelement(true) NameIdentifier;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("SubjectConfirmation"):
							struct WSTrustSubjectConfirmation = this.STag.ToString
							{
								XMLTag("SubjectConfirmation") STag;
								switch
								{
									case !(Property.IsXmlEmptyElement):
										struct
										{
											While [String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
											{
												switch
												{
													case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("ConfirmationMethod"):
														xmlelement(true) ConfirmationMethod;
													case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("SubjectConfirmationData"):
														xmlelement(true) SubjectConfirmationData;
													case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("KeyInfo"):
														XMLENCdsKeyInfoElement KeyInfo;
													default:
														xmlelement(true) element;
												}
											}
											XMLTag("SubjectConfirmation") ETag;
										}
								}
							}
						default:
							xmlelement(true) Element;
					}
				}
				XMLTag("Subject") ETag;
			}
	}
}

struct WSTrustRequestSecurityToken = this.STag.ToString
{
	XMLTag("RequestSecurityToken") STag;
	switch
	{
		case !(Property.IsXmlEmptyElement):
			struct
			{
				While [String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
				{
					switch
					{
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("TokenType"):
							xmlelement(true) TokenType;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("RequestType"):
							xmlelement(true) RequestType;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("AppliesTo"):
							WSTrustAppliesTo AppliesTo;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Claims"):
							WSTrustClaims Claims;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Entropy"):
							xmlelement(true) Entropy;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Lifetime"):
							xmlelement(true) Lifetime;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("AllowPostdating"):
							xmlelement(true) AllowPostdating;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Renewing"):
							xmlelement(true) Renewing;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Issuer"):
							xmlelement(true) Issuer;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("AuthenticationType"):
							xmlelement(true) AuthenticationType;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("KeyType"):
							xmlelement(true) KeyType;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("KeySize"):
							xmlelement(true) KeySize;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("SignatureAlgorithm"):
							xmlelement(true) SignatureAlgorithm;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("EncryptionAlgorithm"):
							xmlelement(true) EncryptionAlgorithm;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Encryption"):
							xmlelement(true) Encryption;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("EncryptWith"):
							xmlelement(true) EncryptWith;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("CanonicalizationAlgorithm"):
							xmlelement(true) CanonicalizationAlgorithm;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("ProofEncryption"):
							xmlelement(true) ProofEncryption;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("UseKey"):
							xmlelement(true) UseKey;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("SignWith"):
							xmlelement(true) SignWith;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("InformationCardReference"):
							WSTrustInformationCardReference InformationCardReference;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("RequestDisplayToken"):
							xmlelement(true) RequestDisplayToken;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("ClientPseudonym"):
							WSTrustClientPseudonym ClientPseudonym;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("OnBehalfOf"):
							xmlelement(true) OnBehalfOf;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("DelegateTo"):
							xmlelement(true) DelegateTo;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Forwardable"):
							xmlelement(true) Forwardable;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("PolicyReference"):
							xmlelement(true) PolicyReference;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Policy"):
							xmlelement(true) Policy;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Participants"):
							struct WSTrustParticipants = this.STag.ToString
							{
								XMLTag("Participants") STag;
								switch
								{
									case !(Property.IsXmlEmptyElement):
										struct
										{
											While [String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
											{
												switch
												{
													case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Primary"):
														xmlelement(true) Primary;
													case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Participant"):
														xmlelement(true) Participant;
													default:
														xmlelement(true) element;
												}
											}
											XMLTag("Participants") ETag;
										}
								}
							}
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("RequestKET"):
							xmlelement(true) RequestKET;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("KeyExchangeToken"):
							xmlelement(true) KeyExchangeToken;
						case Contains(StringTerm(FrameData,FrameOffset,Property.XmlEncoding,True,False,False),"SecondaryParameters") :
							XMLElement(true) SecondaryParameters;
						default:
							xmlelement(true) Element;
					}
				}
				XMLTag("RequestSecurityToken") ETag;
			}
	}
}

struct WSTrustClaims = this.STag.ToString
{
	XMLTag("Claims") STag;
	switch
	{
		case !(Property.IsXmlEmptyElement):
			struct
			{
				While [String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
				{
					switch
					{
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("ClaimType"):
							xmlelement(true) ClaimType;
						default:
							xmlelement(true) Element;
					}
				}
				XMLTag("Claims") ETag;
			}
	}
}

struct WSTrustInformationCardReference = this.STag.ToString
{
	XMLTag("InformationCardReference") STag;
	switch
	{
		case !(Property.IsXmlEmptyElement):
			struct
			{
				While [String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
				{
					switch
					{
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("CardId"):
							xmlelement(true) CardId;
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("CardVersion"):
							xmlelement(true) CardVersion;
						default:
							xmlelement(true) element;
					}
				}
				XMLTag("InformationCardReference") ETag;
			}
	}
}

struct WSTrustClientPseudonym = this.STag.ToString
{
	XMLTag("ClientPseudonym") STag;
	switch
	{
		case !(Property.IsXmlEmptyElement):
			struct
			{
				While [String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
				{
					switch
					{
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("PPID"):
							xmlelement(true) PPID;
						default:
							xmlelement(true) element;
					}
				}
				XMLTag("ClientPseudonym") ETag;
			}
	}
}

struct WSTrustAppliesTo = this.STag.ToString
{
	XMLTag("AppliesTo") STag;
	switch
	{
		case !(Property.IsXmlEmptyElement):
			struct
			{
				While [String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
				{
					switch
					{
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("EndpointReference"):
							WSTrustEndpointReference EndpointReference;
						default:
							xmlelement(true) Element;
					}
				}
				XMLTag("AppliesTo") ETag;
			}
	}
}

struct WSTrustEndpointReference = this.STag.ToString
{
	XMLTag("EndpointReference") STag;
	switch
	{
		case !(Property.IsXmlEmptyElement):
			struct
			{
				While [String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
				{
					switch
					{
						case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("Identity"):
							struct WSTrustIdentity = this.STag.ToString
							{
								XMLTag("Identity") STag;
								switch
								{
									case !(Property.IsXmlEmptyElement):
										struct
										{
											While [String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
											{
												switch
												{
													case StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false).contains("KeyInfo"):
														XMLENCdsKeyInfoElement Identity;
													default:
														xmlelement(true) element;
												}
											}
											XMLTag("Identity") ETag;
										}
								}
							}
						default:
							xmlelement(true) element;
					}
				}
				XMLTag("EndpointReference") ETag;
			}
	}
}



