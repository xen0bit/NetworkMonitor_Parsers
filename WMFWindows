//#  (c) 2009 CodePlex Foundation
//#
//#  Title:                  Windows Metafile Format (WMF)
//#
//#  Details:                
//#
//#  Microsoft References:   [MS-WMF]: Windows Metafile Format Specification
//#
//#  Comments:               
//#
//#  Revision Class and Date:Minor, 01/19/2010
//#
//####

//******************************************************************************************
//WMF TABLES
//******************************************************************************************

Table WMFRecordTypeTable(value)
{
	switch(value)
	{
		case 0x0000: "Nonamegiven";
		case 0x0201: "META_SETBKCOLOR";
		case 0x0102: "META_SETBKMODE";
		case 0x0103: "META_SETMAPMODE";
		case 0x0104: "META_SETROP2";
		case 0x0105: "META_SETRELABS";
		case 0x0106: "META_SETPOLYFILLMODE";
		case 0x0107: "META_SETSTRETCHBLTMODE";
		case 0x0108: "META_SETTEXTCHAREXTRA";
		case 0x0209: "META_SETTEXTCOLOR";
		case 0x020A: "META_SETTEXTJUSTIFICATION";
		case 0x020B: "META_SETWINDOWORG";
		case 0x020C: "META_SETWINDOWEXT";
		case 0x020D: "META_SETVIEWPORTORG";
		case 0x020E: "META_SETVIEWPORTEXT";
		case 0x020F: "META_OFFSETWINDOWORG";
		case 0x0410: "META_SCALEWINDOWEXT";
		case 0x0211: "META_OFFSETVIEWPORTORG";
		case 0x0412: "META_SCALEVIEWPORTEXT";
		case 0x0213: "META_LINETO";
		case 0x0214: "META_MOVETO";
		case 0x0415: "META_EXCLUDECLIPRECT";
		case 0x0416: "META_INTERSECTCLIPRECT";
		case 0x0817: "META_ARC";
		case 0x0418: "META_ELLIPSE";
		case 0x0419: "META_FLOODFILL";
		case 0x081A: "META_PIE";
		case 0x041B: "META_RECTANGLE";
		case 0x061C: "META_ROUNDRECT";
		case 0x061D: "META_PATBLT";
		case 0x001E: "META_SAVEDC";
		case 0x041F: "META_SETPIXEL";
		case 0x0220: "META_OFFSETCLIPRGN";
		case 0x0521: "META_TEXTOUT";
		case 0x0922: "META_BITBLT";
		case 0x0B23: "META_STRETCHBLT";
		case 0x0324: "META_POLYGON";
		case 0x0325: "META_POLYLINE";
		case 0x0626: "META_ESCAPE";
		case 0x0127: "META_RESTOREDC";
		case 0x0228: "META_FILLREGION";
		case 0x0429: "META_FRAMEREGION";
		case 0x012A: "META_INVERTREGION";
		case 0x012B: "META_PAINTREGION";
		case 0x012C: "META_SELECTCLIPREGION";
		case 0x012D: "META_SELECTOBJECT";
		case 0x012E: "META_SETTEXTALIGN";
		case 0x062F: "META_DRAWTEXT";
		case 0x0830: "META_CHORD";
		case 0x0231: "META_SETMAPPERFLAGS";
		case 0x0a32: "META_EXTTEXTOUT";
		case 0x0d33: "META_SETDIBTODEV";
		case 0x0234: "META_SELECTPALETTE";
		case 0x0035: "META_REALIZEPALETTE";
		case 0x0436: "META_ANIMATEPALETTE";
		case 0x0037: "META_SETPALENTRIES";
		case 0x0538: "META_POLYPOLYGON";
		case 0x0139: "META_RESIZEPALETTE";
		case 0x0940: "META_DIBBITBLT";
		case 0x0b41: "META_DIBSTRETCHBLT";
		case 0x0142: "META_DIBCREATEPATTERNBRUSH";
		case 0x0f43: "META_STRETCHDIB";
		case 0x0548: "META_EXTFLOODFILL";
		case 0x0149: "META_SETLAYOUT";
		case 0x01f0: "META_DELETEOBJECT";
		case 0x00f7: "META_CREATEPALETTE";
		case 0x01F9: "META_CREATEPATTERNBRUSH";
		case 0x02FA: "META_CREATEPENINDIRECT";
		case 0x02FB: "META_CREATEFONTINDIRECT";
		case 0x02FC: "META_CREATEBRUSHINDIRECT";
		case 0x06FF: "META_CREATEREGION";
		default: "Undefined RecordType";
	}
}

Table WMFBinaryRasterOperationTable(value)
{
	switch(value)
	{
		case 0x00000001: FormatString ("0x%08X - R2_BLACK - 0, Pixel is always 0", value);
		case 0x00000002: FormatString ("0x%08X - R2_NOTMERGEPEN - DPon, Pixel is the inverse of the R2_MERGEPEN color", value);
		case 0x00000003: FormatString ("0x%08X - R2_MASKNOTPEN - DPna, Pixel is a combination of the screen color and the inverse of the pen color", value);
		case 0x00000004: FormatString ("0x%08X - R2_NOTCOPYPEN - Pn, Pixel is the inverse of the pen color", value);
		case 0x00000005: FormatString ("0x%08X - R2_MASKPENNOT - PDna, Pixel is a combination of the colors common to both the pen and the inverse of the screen", value);
		case 0x00000006: FormatString ("0x%08X - R2_NOT - Dn, Pixel is the inverse of the screen color", value);
		case 0x00000007: FormatString ("0x%08X - R2_XORPEN - DPx, Pixel is a combination of the colors in the pen and in the screen, but not in both", value);
		case 0x00000008: FormatString ("0x%08X - R2_NOTMASKPEN - DPan, Pixel is the inverse of the R2_MASKPEN color", value);
		case 0x00000009: FormatString ("0x%08X - R2_MASKPEN - DPa, Pixel is a combination of the colors common to both the pen and the screen", value);
		case 0x0000000A: FormatString ("0x%08X - R2_NOTXORPEN - DPxn, Pixel is the inverse of the R2_XORPEN color", value);
		case 0x0000000B: FormatString ("0x%08X - R2_NOP - D, Pixel remains unchanged", value);
		case 0x0000000C: FormatString ("0x%08X - R2_MERGENOTPEN - DPno, Pixel is a combination of the colors common to both the screen and the inverse of the pen", value);
		case 0x0000000D: FormatString ("0x%08X - R2_COPYPEN - P, Pixel is the pen color", value);
		case 0x0000000E: FormatString ("0x%08X - R2_MERGEPENNOT - DPno, Pixel is a combination of the colors common to both the screen and the inverse of the pen", value);
		case 0x0000000F: FormatString ("0x%08X - R2_MERGEPEN - DPo, Pixel is a combination of the pen color and the screen color", value);
		case 0x00000010: FormatString ("0x%08X - R2_WHITE - 1, Pixel is always 1", value);
		default : FormatString ("0x%08X - No Description Available", value);
	}
}

Table WMFBitCountTable(value)
{
	switch(value)
	{
		case 0x0000: "BITCOUNT_0";
		case 0x0001: "BITCOUNT_1";
		case 0x0004: "BITCOUNT_2";
		case 0x0008: "BITCOUNT_3";
		case 0x0010: "BITCOUNT_4";
		case 0x0018: "BITCOUNT_5";
		case 0x0020: "BITCOUNT_6";
		default: FormatString ("(0x%04X) Undefined BitCount", value);
	}
}
Table WMFBrushStyleTable(value)
{
	switch(value)
	{
		case 0x00000000: FormatString ("0x%08X - BS_SOLID - Solid brush", value);
		case 0x00000001: FormatString ("0x%08X - BS_NULL or BS_HOLLOW - Hollow brush", value);
		case 0x00000002: FormatString ("0x%08X - BS_HATCHED - Hatched brush", value);
		case 0x00000003: FormatString ("0x%08X - BS_PATTERN - A pattern brush defined by a device-independent bitmap (DIB) specification", value);
		case 0x00000005: FormatString ("0x%08X - BS_DIBPATTERN - A pattern brush defined by a device-independent bitmap (DIB) specification", value);
		case 0x00000006: FormatString ("0x%08X - BS_DIBPATTERNPT - A pattern brush defined by a device-independent bitmap (DIB) specification", value);
		case 0x00000007: FormatString ("0x%08X - BS_PATTERN8X8 - A pattern brush defined by a device-independent bitmap (DIB) specification", value);
		case 0x00000008: FormatString ("0x%08X - BS_DIBPATTERN8X8 - A pattern brush defined by a device-independent bitmap (DIB) specification", value);
		default : FormatString ("0x%08X - No Description Available", value);
	}
}

Table WMFCharacterSetTable(value)
{
	switch(value)
	{
		case 0x00000000: "ANSI_CHARSET";
		case 0x00000001: "DEFAULT_CHARSET";
		case 0x00000002: "SYMBOL_CHARSET";
		case 0x0000004D: "MAC_CHARSET";
		case 0x00000080: "SHIFTJIS_CHARSET";
		case 0x00000081: "HANGUL_CHARSET";
		case 0x00000082: "JOHAB_CHARSET";
		case 0x00000086: "GB2312_CHARSET";
		case 0x00000088: "CHINESEBIG5_CHARSET";
		case 0x000000A1: "GREEK_CHARSET";
		case 0x000000A2: "TURKISH_CHARSET";
		case 0x000000A3: "VIETNAMESE_CHARSET";
		case 0x000000B1: "HEBREW_CHARSET";
		case 0x000000B2: "ARABIC_CHARSET";
		case 0x000000BA: "BALTIC_CHARSET";
		case 0x000000CC: "RUSSIAN_CHARSET";
		case 0x000000EE: "DEFAULT_CHARSET";
		case 0x000000FF: "OEM_CHARSET";
		default: FormatString ("(0x%08X) Undefined CharacterSet", value);
	}
}

Table WMFClipPrecisionTable(value)
{
	switch(value)
	{
		case 0x00: FormatString ("0x%02X - CLIP_DEFAULT_PRECIS - Specifies default clipping behavior", value);
		case 0x01: FormatString ("0x%02X - CLIP_CHARACTER_PRECIS - This value SHOULD NOT be used.", value);
		case 0x02: FormatString ("0x%02X - CLIP_STROKE_PRECIS - This value MAY be returned when enumerating rasterized, TrueType and vector fonts.", value);
		case 0x10: FormatString ("0x%02X - CLIP_LH_ANGLES - When this value is used, the rotation for all fonts depends on whether the orientation of the coordinate system is left-handed or right-handed", value);
		case 0x20: FormatString ("0x%02X - CLIP_TT_ALWAYS - This value SHOULD NOT be used.", value);
		case 0x40: FormatString ("0x%02X - CLIP_DFA_DISABLE - Windows XP SP1: Turns off font association for the font; Windows Server 2003 and after:No effect", value);
		case 0x80: FormatString ("0x%02X - CLIP_EMBEDDED - You must specify this value to use an embedded read-only font", value);
		default	 : FormatString ("0x%02X - No Description Available", value);
	}
}

Table WMFColorUsageTable(value)
{
	switch(value)
	{
		case 0x0000: "DIB_RGB_COLORS";
		case 0x0001: "DIB_PAL_COLORS";
		case 0x0002: "DIB_PAL_INDICES";
		default: FormatString ("(0x%04X) Undefined ColorUsage", value);
	}
}

Table WMFCompressionTable(value)
{
	switch(value)
	{
		case 0x0000: "BI_RGB";
		case 0x0001: "BI_RLE8";
		case 0x0002: "BI_RLE4";
		case 0x0003: "BI_BITFIELDS";
		case 0x0004: "BI_JPEG";
		case 0x0005: "BI_PNG";
		case 0x000B: "BI_CMYK";
		case 0x000C: "BI_CMYKRLE8";
		case 0x000D: "BI_CMYKRLE4";
		default: FormatString ("(0x%04X) Undefined Compression", value);
	}
}

struct WMFExtendedTextOutOptions = FormatString("0x%X", this)
{
	UINT16 ExtendedTextOutOptions
	{
		UINT16 ASPECT_FILTERING:1 = FormatString("     (%s) %s", this.ToBitString, this ? "SHOULD select only fonts whose x-aspect and y-aspect exactly match those of the specified device." : "SHOULD NOT select only fonts whose x-aspect and y-aspect exactly match those of the specified device.");
		UINT16 ETO_OPAQUE:1 = FormatString("           (%s) %s", this.ToBitString, this ? "SHOULD be used to fill the rectangle" : "SHOULD NOT be used to fill the rectangle");
		UINT16 ETO_CLIPPED:1 = FormatString("          (%s) %s", this.ToBitString, this ? "The text will be clipped to the rectangle." : "The text will NOT be clipped to the rectangle.");
		UINT16 Reserved_bits4:1 = FormatString("       (%s) Reserved" , this.ToBitString);
		UINT16 ETO_GLYPH_INDEX:1 = FormatString("      (%s) %s", this.ToBitString, this ? "should be parsed directly by GDI" : "should NOT be parsed directly by GDI");
		UINT16 Reserved_bits6_7:2 = FormatString("     (%s) Reserved" , this.ToBitString);
		UINT16 ETO_RTLREADING:1 = FormatString("       (%s) %s", this.ToBitString, this ? "string is output using right-to-left reading order" : "string is output in left-to-right order");
		UINT16 ETO_NO_RECT:1 = FormatString("          (%s) %s", this.ToBitString, this ? "The optional Bounds field in the EMR_SMALLTEXTOUT record is NOT included." : "The optional Bounds field in the EMR_SMALLTEXTOUT record is included.");
		UINT16 ETO_SMALL_CHARS:1 = FormatString("      (%s) %s", this.ToBitString, this ? "the text string in a text output operation is made up of 8-bit characters" : "the text string in a text output operation is made up of 16-bit characters");
		UINT16 ETO_NUMERICSLOCAL:1 = FormatString("    (%s) %s", this.ToBitString, this ? "use digits appropriate to the locale" : "NOT use digits appropriate to the locale");
		UINT16 ETO_NUMERICSLATIN:1 = FormatString("    (%s) %s", this.ToBitString, this ? "use European digits" : "NOT use European digits");
		UINT16 ETO_IGNORELANGUAGE:1 = FormatString("   (%s) Reserved for system use", this.ToBitString);
		UINT16 ETO_PDY:1 = FormatString("              (%s) %s", this.ToBitString, this ? "the array pointed to by lpDx contains pairs of values" : "the array NOT pointed to by lpDx contains pairs of values");
		UINT16 Reserved_bits15_16:2 = FormatString("   (%s) Reserved" , this.ToBitString);
//		UINT16 ETO_REVERSE_INDEX_MAP:1 = FormatString("(%s) %s", this.ToBitString, this ? "the mapper SHOULD reverse-map them back to characters" : "the mapper SHOULD NOT reverse-map them back to characters");
	}
}

Table WMFFamilyFontTable(value)
{
	switch(value)
	{
		case 0x0: FormatString ("0x%X - FF_DONTCARE - Use default font", value);
		case 0x1: FormatString ("0x%X - FF_ROMAN - Fonts with variable stroke width (proportional) and with serifs", value);
		case 0x2: FormatString ("0x%X - FF_SWISS - Fonts with variable stroke width (proportional) and without serifs", value);
		case 0x3: FormatString ("0x%X - FF_MODERN - Fonts with constant stroke width (monospace), with or without serifs", value);
		case 0x4: FormatString ("0x%X - FF_SCRIPT - Fonts designed to look like handwriting", value);
		case 0x5: FormatString ("0x%X - FF_DECORATIVE - Novelty fonts", value);
		default	 : FormatString ("0x%X - No Description Available", value);
	}
}

Table WMFFloodFillTable(value) 
{
	switch(value)
	{
		case 0x0000: "FLOODFILLBORDER";
		case 0x0001: "FLOODFILLSURFACE";
		default: FormatString ("(0x%0X) Undefined FloodFill", value);
	}
}

Table WMFFontQualityTable(value)//2.1.1.12
{
	switch(value)
	{
		case 0x00: FormatString ("0x%02X - DEFAULT_QUALITY - Appearance of the font does not matter", value);
		case 0x01: FormatString ("0x%02X - DRAFT_QUALITY - Appearance of the font is less important than when PROOF_QUALITY is used", value);
		case 0x02: FormatString ("0x%02X - PROOF_QUALITY - Character quality of the font is more important than exact matching of the logical-font attributes", value);
		case 0x03: FormatString ("0x%02X - NONANTIALIASED_QUALITY - Font is never antialiased", value);
		case 0x04: FormatString ("0x%02X - ANTIALIASED_QUALITY - Font is always antialiased if the font supports it and the size of the font is not too small or too large", value);
		case 0x05: FormatString ("0x%02X - CLEARTYPE_QUALITY - If set, text is rendered (when possible) using ClearType antialiasing method", value);
		default	 : FormatString ("0x%02X - No Description Available", value);
	}
}

Table WMFGamutMappingIntentTable(value)//2.1.1.13
{
	switch(value)
	{
		case 0x00000001: "LCS_GM_BUSINESS";
		case 0x00000002: "LCS_GM_GRAPHICS";
		case 0x00000004: "LCS_GM_IMAGES";
		case 0x00000008: "LCS_GM_ABS_COLORIMETRIC";
		default: FormatString("(0x%x) Undefined GamutMappingIntent", value);
	}
}

Table WMFGDIEscapesTable(value)//2.1.1.14
{
	switch(value)
	{
		case 0x0001: "NEWFRAME";
		case 0x0003: "NEXTBAND";
		case 0x0004: "SETCOLORTABLE";
		case 0x0005: "GETCOLORTABLE";
		case 0x0008: "QUERYESCSUPPORT";
		case 0x000A: "STARTDOC";
		case 0x000B: "ENDDOC";
		case 0x000C: "GETPHYSPAGESIZE";
		case 0x000D: "GETPRINTINGOFFSET";
		case 0x000E: "GETSCALINGFACTOR";
		case 0x0011: "SETCOPYCOUNT";
		case 0x0013: "PASSTHROUGH";
		case 0x0015: "SETLINECAP";
		case 0x0016: "SETLINEJOIN";
		case 0x0017: "SETMITERLIMIT";
		case 0x0019: "DRAWPATTERNRECT";
		case 0x0021: "EPSPRINTING";
		case 0x0025: "POSTSCRIPT_DATA";
		case 0x0026: "POSTSCRIPT_IGNORE";
		case 0x002A: "GETDEVICEUNITS";
		case 0x0100: "GETEXTENDEDTEXTMETRICS";
		case 0x0102: "GETPAIRKERNTABLE";
		case 0x0200: "EXTTEXTOUT";
		case 0x0201: "GETFACENAME";
		case 0x0202: "DOWNLOADFACE";
		case 0x0801: "METAFILE_DRIVER";
		case 0x0C01: "QUERYDIBSUPPORT";
		case 0x1000: "BEGIN_PATH";
		case 0x1001: "CLIP_TO_PATH";
		case 0x1002: "END_PATH";
		case 0x1005: "POSTSCRIPT_IDENTIFY";
		case 0x1006: "POSTSCRIPT_INJECTION";
		case 0x1007: "CHECKJPEGFORMAT";
		case 0x1008: "CHECKPNGFORMAT";
		case 0x1009: "GET_PS_FEATURESETTING";
		case 0x100A: "GDIPLUS_TS_QUERYVER";
		case 0x100B: "GDIPLUS_TS_RECORD";
		case 0x1010: "OPENCHANNEL";
		case 0x1011: "DOWNLOADHEADER";
		case 0x1012: "CLOSECHANNEL";
		case 0x1013: "POSTSCRIPT_PASSTHROUGH";
		case 0x1014: "ENCAPSULATED_POSTSCRIPT";
		case 0x11DB: "SPCLPASSTHROUGH2";
		default: FormatString("(0x%x) Undefined GDIEscape",value);
	}
}

Table WMFGDIEscapesCLIP_TO_PATHTable(value)//2.1.1.16
{
	switch(value)
	{
		case 0x00: "CLIP_SAVE";
		case 0x01: "CLIP_RESTORE";
		case 0x02: "CLIP_INCLUSIVE";		
		default: FormatString("(0x%x) Undefined Clip_to_path",value);
	}
}

Table WMFGDIEscapesPOSTSCRIPT_IDENTIFYTable(value)//2.1.1.17
{
	switch(value)
	{
		case 0x00: "PSIDENT_GDICENTRIC";
		case 0x01: "PSIDENT_PSCENTRIC";             
		default: FormatString("(0x%x) Undefined postscript_identify",value);
	}                                             
}                                               
                                                
Table WMFHatchStyleTable(value)//2.1.1.18       
{                                               
	switch(value)                                 
	{                                             
		case 0x0000: "HS_HORIZONTAL";               
		case 0x0001: "HS_VERTICAL";                 
		case 0x0002: "HS_FDIAGONAL";                
		case 0x0003: "HS_BDIAGONAL";                
		case 0x0004: "HS_CROSS";                    
		case 0x0005: "HS_DIAGCROSS";                
		default: FormatString("(0x%x) Undefined Hatch Style",value);
	}                                             
}                                               
                                                
Table WMFLayoutTable(value)//2.1.1.19           
{                                               
	switch(value)                                 
	{                                             
		case 0x00000001: FormatString ("0x%08X - LAYOUT_RTL - Sets the default horizontal layout to be right to left", value);
		case 0x00000002: FormatString ("0x%08X - LAYOUT_BTT - Sets the default horizontal layout to be bottom to top", value);
		case 0x00000004: FormatString ("0x%08X - LAYOUT_VBH - Sets the default layout to be vertical before horizontal", value);
		case 0x00000008: FormatString ("0x%08X - LAYOUT_BITMAPORIENTATIONPRESERVED - Disables any reflection during BitBlt and StretchBlt operations", value);
		default		   : FormatString ("0x%08X - No Description Available", value);
	}                                             
}                                               
                                                
Table WMFLogicalColorSpaceTable(value)//2.1.1.20
{
	switch(value)
	{
		case 0x00000000: "LCS_CALIBRATED_RGB";
		case 0x73524742: "LCS_sRGB";
		case 0x57696E20: "LCS_WINDOWS_COLOR_SPACE";
		default: FormatString("(0x%x) Undefined LogicalColorSpace",value);
	}
}

Table WMFMapModeTable(value)//2.1.1.21
{
	switch(value)
	{
		case 0x0001: "MM_TEXT";
		case 0x0002: "MM_LOMETRIC";
		case 0x0003: "MM_HIMETRIC";
		case 0x0004: "MM_LOENGLISH";
		case 0x0005: "MM_HIENGLISH";
		case 0x0006: "MM_TWIPS";
		case 0x0007: "MM_ISOTROPIC";
		case 0x0008: "MM_ANISOTROPIC";
		default: FormatString("(0x%x) Undefined MapMode",value);
	}
}

Table WMFMetafileTypeTable(value)//2.1.1.22
{
	switch(value)
	{
		case 0x0001: "MEMORYMETAFILE";
		case 0x0002: "DISKMETAFILE";
		default: FormatString("(0x%x) Undefined MetafileType",value);
	}
}

Table WMFMetafileVersionTable(value)//2.1.1.23
{
	switch(value)
	{
		case 0x0100: "METAVERSION100";
		case 0x0300: "METAVERSION300";
		default: FormatString("(0x%x) Undefined MetafileVersion",value);
	}
}

Table WMFMixModeTable(value)//2.1.1.24
{
	switch(value)
	{
		case 0x0001: "TRANSPARENT";
		case 0x0002: "OPAQUE";
		default: FormatString("(0x%x) Undefined MexMode",value);
	}
}

Table WMFPaletteEntryFlagTable(value)//2.1.1.25
{
	switch(value)
	{
		case 0x01: FormatString ("0x%02X - PC_RESERVED - Specifies that the logical palette entry be used for palette animation", value);
		case 0x02: FormatString ("0x%02X - PC_EXPLICIT - Specifies that the low-order word of the logical palette entry designates a hardware palette index", value);
		case 0x04: FormatString ("0x%02X - PC_NOCOLLAPSE - Specifies that the color be placed in an unused entry in the system palette instead of being matched to an existing color in the system palette", value);
		default	 : FormatString ("0x%02X - No Description Available", value);
	}
}

Table WMFPenStyleTable(value)//2.1.1.26
{
	switch(value)
	{
		case 0x00: "PS_SOLID";
		case 0x01: "PS_DASH";
		case 0x02: "PS_DOT";
		case 0x03: "PS_DASHDOT";
		case 0x04: "PS_DASHDOTDOT";
		case 0x05: "PS_NULL";
		case 0x06: "PS_INSIDEFRAME";
		case 0x07: "PS_USERSTYLE";
		case 0x08: "PS_ALTERNATE";
		default: FormatString("(0x%x) Undefined Pen Style",value);
	}
}

Table WMFPenStyleEndcapTable(value)
{
	switch(value)
	{
		case 0x00000000: FormatString ("0x%08X - PS_ENDCAP_ROUND - Line end caps are round", value);
		case 0x00000100: FormatString ("0x%08X - PS_ENDCAP_SQUARE - Line end caps are square", value);
		case 0x00000200: FormatString ("0x%08X - PS_ENDCAP_FLAT - Line end caps are flat", value);
		default		   : FormatString ("0x%08X - No Description Available", value);
	}
}

Table WMFPenStyleJoinTable(value)
{
	switch(value)
	{
		case 0x00000000: FormatString ("0x%08X -PS_JOIN_ROUND - Line joins are round", value);
		case 0x00001000: FormatString ("0x%08X -PS_JOIN_BEVEL - Line joins are beveled", value);
		case 0x00002000: FormatString ("0x%08X -PS_JOIN_MITER - Line joins are mitered when they are within the current limit set by the SetMiterLimit record", value);
		default		   : FormatString ("0x%08X - No Description Available", value);
	}
}

Table WMFPenStyleTypeTable(value)
{
	switch(value)
	{
		case 0x00000000: FormatString ("0x%08X - PS_COSMETIC - The pen is cosmetic", value);  
		case 0x00010000: FormatString ("0x%08X - PS_GEOMETRIC - The pen is geometric", value); 
		default		   : FormatString ("0x%08X - No Description Available", value);
	}
}

[DataTypeByteOrder = LittleEndian]
struct WMFPenStyle = FormatString("%s",PenStyleEnum.toString)
	
{
	UINT32 PenStyleEnum = FormatString("PenStyle:%s, Endcap:%s, Join:%s, Type:%s",
																			PenStyle.toString,
																			PenEndcap.toString,
																			PenJoin.toString,
																			PenType.toString)
	{
		UINT32 PenStyle:8 = WMFPenStyleTable(this);																														
		UINT32 PenEndcap:4= WMFPenStyleEndcapTable(this);																														
		UINT32 PenJoin:4  = WMFPenStyleJoinTable(this);																														
		UINT32 PenType:4  = WMFPenStyleTypeTable(this);																														
		UINT32 Reserve:12 = "Reserverd";	
	};																													
}

Table WMFPitchFontTable(value)//2.1.1.27
{
	switch(value)
	{
		case 0: FormatString ("0x%X - DEFAULT_PITCH", value);
		case 1: FormatString ("0x%X - FIXED_PITCH - The font has a fixed pitch", value);
		case 2: FormatString ("0x%X - VARIABLE_PITCH - The font has a variable pitch", value);
		default	 : FormatString ("0x%X - No Description Available", value);
	}
}

Table WMFPolyFillModeTable(value)//2.1.1.28
{
	switch(value)
	{
		case 0x0001: "ALTERNATE";
		case 0x0002: "WINDING";
		default: FormatString("(0x%x) Undefined Poly Fill Mode",value);
	}
}

Table WMFOutPrecisionTable(value)//2.1.1.29
{
	switch(value)
	{
		case 0x00: FormatString ("0x%02X - OUT_DEFAULT_PRECIS - Specifies the default font mapper behavior", value);
		case 0x01: FormatString ("0x%02X - OUT_STRING_PRECIS - This value is not used by the font mapper, but it is returned when raster fonts are enumerated", value);
		case 0x02: FormatString ("0x%02X - OUT_CHARACTER_PRECIS - Not used", value);
		case 0x03: FormatString ("0x%02X - OUT_STROKE_PRECIS - This value is not used by the font mapper, but it is returned when TrueType, other outline-based fonts, and vector fonts are enumerated", value);
		case 0x04: FormatString ("0x%02X - OUT_TT_PRECIS - This record specifies the font mapper to choose a TrueType font when the system contains multiple fonts with the same name", value);
		case 0x05: FormatString ("0x%02X - OUT_DEVICE_PRECIS - This record specifies the font mapper to choose a Device font when the system contains multiple fonts with the same name", value);
		case 0x06: FormatString ("0x%02X - OUT_RASTER_PRECIS - This record specifies the font mapper to choose a raster font when the system contains multiple fonts with the same name", value);
		case 0x07: FormatString ("0x%02X - OUT_TT_ONLY_PRECIS - This record specifies the font mapper to choose from only TrueType fonts", value);
		case 0x08: FormatString ("0x%02X - OUT_OUTLINE_PRECIS - This value specifies that the font mapper to choose from TrueType and other outline-based fonts", value);
		case 0x09: FormatString ("0x%02X - OUT_SCREEN_OUTLINE_PRECIS - This value specifies that the font mapper to have a preference for TrueType and other outline-based fonts", value);
		case 0x0A: FormatString ("0x%02X - OUT_PS_ONLY_PRECIS - This record specifies the font mapper to choose from only PostScript fonts", value);
		default	 : FormatString ("0x%02X - No Description Available", value);
	}
}

Table WMFSelectableObjectTable(value)//2.1.1.30
{
	switch(value)
	{
		case 0x0004: "RGN_TYPE";
		case 0x0005: "SURF_TYP";
		case 0x0009: "ICMLCS_TYPE";
		case 0x000A: "LFONT_TYPE";
		case 0x0010: "BRUSH_TYPE";
		default: FormatString("(0x%x) Undefined SelectableObject",value);
	}
}

Table WMFStretchModeTable(value)//2.1.1.31
{
	switch(value)
	{
		case 0x0001: "BLACKONWHITE";
		case 0x0002: "WHITEONBLACK";
		case 0x0003: "COLORONCOLOR";
		case 0x0004: "HALFTONE";
		default: FormatString("(0x%x) Undefined StrechMode",value);
	}
}

//2.1.1.31 TernaryRasterOperation Enumeration
Table WMFTernaryRasterOperationTable(value)
{
	switch(value)
	{
		case 0x00: "BLACKNESS";
		case 0x01: "DPSOON";
		case 0x02: "DPSONA";
		case 0x03: "PSON";
		case 0x04: "SDPONA";
		case 0x05: "DPON";
		case 0x06: "PDSXNON";
		case 0x07: "PDSAON";
		case 0x08: "SDPNAA";
		case 0x09: "PDSXON";
		case 0x0A: "DPNA";
		case 0x0B: "PSDNAON";
		case 0x0C: "SPNA";
		case 0x0D: "PDSNAON";
		case 0x0E: "PDSONON";
		case 0x0F: "PN";
		case 0x10: "PDSONA";
		case 0x11: "NOTSRCERASE";
		case 0x12: "SDPXNON";
		case 0x13: "SDPAON";
		case 0x14: "DPSXNON";
		case 0x15: "DPSAON";
		case 0x16: "PSDPSANAXX";
		case 0x17: "SSPXDSXAXN";
		case 0x18: "SPXPDXA";
		case 0x19: "SDPSANAXN";
		case 0x1A: "PDSPAOX";
		case 0x1B: "SDPSXAXN";
		case 0x1C: "PSDPAOX";
		case 0x1D: "DSPDXAXN";
		case 0x1E: "PDSOX";
		case 0x1F: "PDSOAN";
		case 0x20: "DPSNAA";
		case 0x21: "SDPXON";
		case 0x22: "DSNA";
		case 0x23: "SPDNAON";
		case 0x24: "SPXDSXA";
		case 0x25: "PDSPANAXN";
		case 0x26: "SDPSAOX";
		case 0x27: "SDPSXNOX";
		case 0x28: "DPSXA";
		case 0x29: "PSDPSAOXXN";
		case 0x2A: "DPSANA";
		case 0x2B: "SSPXPDXAXN";
		case 0x2C: "SPDSOAX";
		case 0x2D: "PSDNOX";
		case 0x2E: "PSDPXOX";
		case 0x2F: "PSDNOAN";
		case 0x30: "PSNA";
		case 0x31: "SDPNAON";
		case 0x32: "SDPSOOX";
		case 0x33: "NOTSRCCOPY";
		case 0x34: "SPDSAOX";
		case 0x35: "SPDSXNOX";
		case 0x36: "SDPOX";
		case 0x37: "SDPOAN";
		case 0x38: "PSDPOAX";
		case 0x39: "SPDNOX";
		case 0x3A: "SPDSXOX";
		case 0x3B: "SPDNOAN";
		case 0x3C: "PSX";
		case 0x3D: "SPDSONOX";
		case 0x3E: "SPDSNAOX";
		case 0x3F: "PSAN";
		case 0x40: "PSDNAA";
		case 0x41: "DPSXON";
		case 0x42: "SDXPDXA";
		case 0x43: "SPDSANAXN";
		case 0x44: "SRCERASE";
		case 0x45: "DPSNAON";
		case 0x46: "DSPDAOX";
		case 0x47: "PSDPXAXN";
		case 0x48: "SDPXA";
		case 0x49: "PDSPDAOXXN";
		case 0x4A: "DPSDOAX";
		case 0x4B: "PDSNOX";
		case 0x4C: "SDPANA";
		case 0x4D: "SSPXDSXOXN";
		case 0x4E: "PDSPXOX";
		case 0x4F: "PDSNOAN";
		case 0x50: "PDNA";
		case 0x51: "DSPNAON";
		case 0x52: "DPSDAOX";
		case 0x53: "SPDSXAXN";
		case 0x54: "DPSONON";
		case 0x55: "DSTINVERT";
		case 0x56: "DPSOX";
		case 0x57: "DPSOAN";
		case 0x58: "PDSPOAX";
		case 0x59: "DPSNOX";
		case 0x5A: "PATINVERT";
		case 0x5B: "DPSDONOX";
		case 0x5C: "DPSDXOX";
		case 0x5D: "DPSNOAN";
		case 0x5E: "DPSDNAOX";
		case 0x5F: "DPAN";
		case 0x60: "PDSXA";
		case 0x61: "DSPDSAOXXN";
		case 0x62: "DSPDOAX";
		case 0x63: "SDPNOX";
		case 0x64: "SDPSOAX";
		case 0x65: "DSPNOX";
		case 0x66: "SRCINVERT";
		case 0x67: "SDPSONOX";
		case 0x68: "DSPDSONOXXN";
		case 0x69: "PDSXXN";
		case 0x6A: "DPSAX";
		case 0x6B: "PSDPSOAXXN";
		case 0x6C: "SDPAX";
		case 0x6D: "PDSPDOAXXN";
		case 0x6E: "SDPSNOAX";
		case 0x6F: "PDXNAN";
		case 0x70: "PDSANA";
		case 0x71: "SSDXPDXAXN";
		case 0x72: "SDPSXOX";
		case 0x73: "SDPNOAN";
		case 0x74: "DSPDXOX";
		case 0x75: "DSPNOAN";
		case 0x76: "SDPSNAOX";
		case 0x77: "DSAN";
		case 0x78: "PDSAX";
		case 0x79: "DSPDSOAXXN";
		case 0x7A: "DPSDNOAX";
		case 0x7B: "SDPXNAN";
		case 0x7C: "SPDSNOAX";
		case 0x7D: "DPSXNAN";
		case 0x7E: "SPXDSXO";
		case 0x7F: "DPSAAN";
		case 0x80: "DPSAA";
		case 0x81: "SPXDSXON";
		case 0x82: "DPSXNA";
		case 0x83: "SPDSNOAXN";
		case 0x84: "SDPXNA";
		case 0x85: "PDSPNOAXN";
		case 0x86: "DSPDSOAXX";
		case 0x87: "PDSAXN";
		case 0x88: "SRCAND";
		case 0x89: "SDPSNAOXN";
		case 0x8A: "DSPNOA";
		case 0x8B: "DSPDXOXN";
		case 0x8C: "SDPNOA";
		case 0x8D: "SDPSXOXN";
		case 0x8E: "SSDXPDXAX";
		case 0x8F: "PDSANAN";
		case 0x90: "PDSXNA";
		case 0x91: "SDPSNOAXN";
		case 0x92: "DPSDPOAXX";
		case 0x93: "SPDAXN";
		case 0x94: "PSDPSOAXX";
		case 0x95: "DPSAXN";
		case 0x96: "DPSXX";
		case 0x97: "PSDPSONOXX";
		case 0x98: "SDPSONOXN";
		case 0x99: "DSXN";
		case 0x9A: "DPSNAX";
		case 0x9B: "SDPSOAXN";
		case 0x9C: "SPDNAX";
		case 0x9D: "DSPDOAXN";
		case 0x9E: "DSPDSAOXX";
		case 0x9F: "PDSXAN";
		case 0xA0: "DPA";
		case 0xA1: "PDSPNAOXN";
		case 0xA2: "DPSNOA";
		case 0xA3: "DPSDXOXN";
		case 0xA4: "PDSPONOXN";
		case 0xA5: "PDXN";
		case 0xA6: "DSPNAX";
		case 0xA7: "PDSPOAXN";
		case 0xA8: "DPSOA";
		case 0xA9: "DPSOXN";
		case 0xAA: "D";
		case 0xAB: "DPSONO";
		case 0xAC: "SPDSXAX";
		case 0xAD: "DPSDAOXN";
		case 0xAE: "DSPNAO";
		case 0xAF: "DPNO";
		case 0xB0: "PDSNOA";
		case 0xB1: "PDSPXOXN";
		case 0xB2: "SSPXDSXOX";
		case 0xB3: "SDPANAN";
		case 0xB4: "PSDNAX";
		case 0xB5: "DPSDOAXN";
		case 0xB6: "DPSDPAOXX";
		case 0xB7: "SDPXAN";
		case 0xB8: "PSDPXAX";
		case 0xB9: "DSPDAOXN";
		case 0xBA: "DPSNAO";
		case 0xBB: "MERGEPAINT";
		case 0xBC: "SPDSANAX";
		case 0xBD: "SDXPDXAN";
		case 0xBE: "DPSXO";
		case 0xBF: "DPSANO";
		case 0xC0: "MERGECOPY";
		case 0xC1: "SPDSNAOXN";
		case 0xC2: "SPDSONOXN";
		case 0xC3: "PSXN";
		case 0xC4: "SPDNOA";
		case 0xC5: "SPDSXOXN";
		case 0xC6: "SDPNAX";
		case 0xC7: "PSDPOAXN";
		case 0xC8: "SDPOA";
		case 0xC9: "SPDOXN";
		case 0xCA: "DPSDXAX";
		case 0xCB: "SPDSAOXN";
		case 0xCC: "SRCCOPY";
		case 0xCD: "SDPONO";
		case 0xCE: "SDPNAO";
		case 0xCF: "SPNO";
		case 0xD0: "PSDNOA";
		case 0xD1: "PSDPXOXN";
		case 0xD2: "PDSNAX";
		case 0xD3: "SPDSOAXN";
		case 0xD4: "SSPXPDXAX";
		case 0xD5: "DPSANAN";
		case 0xD6: "PSDPSAOXX";
		case 0xD7: "DPSXAN";
		case 0xD8: "PDSPXAX";
		case 0xD9: "SDPSAOXN";
		case 0xDA: "DPSDANAX";
		case 0xDB: "SPXDSXAN";
		case 0xDC: "SPDNAO";
		case 0xDD: "SDNO";
		case 0xDE: "SDPXO";
		case 0xDF: "SDPANO";
		case 0xE0: "PDSOA";
		case 0xE1: "PDSOXN";
		case 0xE2: "DSPDXAX";
		case 0xE3: "PSDPAOXN";
		case 0xE4: "SDPSXAX";
		case 0xE5: "PDSPAOXN";
		case 0xE6: "SDPSANAX";
		case 0xE7: "SPXPDXAN";
		case 0xE8: "SSPXDSXAX";
		case 0xE9: "DSPDSANAXXN";
		case 0xEA: "DPSAO";
		case 0xEB: "DPSXNO";
		case 0xEC: "SDPAO";
		case 0xED: "SDPXNO";
		case 0xEE: "SRCPAINT";
		case 0xEF: "SDPNOO";
		case 0xF0: "PATCOPY";
		case 0xF1: "PDSONO";
		case 0xF2: "PDSNAO";
		case 0xF3: "PSNO";
		case 0xF4: "PSDNAO";
		case 0xF5: "PDNO";
		case 0xF6: "PDSXO";
		case 0xF7: "PDSANO";
		case 0xF8: "PDSAO";
		case 0xF9: "PDSXNO";
		case 0xFA: "DPO";
		case 0xFB: "PATPAINT";
		case 0xFC: "PSO";
		case 0xFD: "PSDNOO";
		case 0xFE: "DPSOO"; 
		case 0xFF: "WHITENESS";
		default: FormatString("(0x%x) Undefined Ternary Raster Operation",value);
	}
}

Table WMFTextAlignmentModeIsLeftTable(value)//2.1.1.33
{
	switch(value)
	{
		case 0: "TA_LEFT";
		case 1: "TA_RIGHT";
		case 3: "TA_CENTER";
		default: FormatString("(0x%x) Undefined TextAlignmentMode", value);
	}
}

Table WMFTextAlignmentModeIsTopTable(value)//2.1.1.33
{
	switch(value)
	{
		case 0: "TA_TOP";
		case 1: "TA_BOTTOM";
		case 3: "TA_BASELINE";
		default: FormatString("(0x%x) Undefined TextAlignmentMode", value);
	}
}

struct WMFTextAlignmentMode = FormatString("AlignmengMode:%s",TextAlignmentMode.toString)//2.1.1.33
{
	UINT16 TextAlignmentMode = FormatString("UpdateCase:%s, Horizontal Alignment:%s, vertical Alignmeng:%s",
																					IsUpdate.toString,
																					IsLeft.toString,
																					IsTop.toString)
	{
		UINT16 IsUpdate:1 = FormatString("%s",this==1?"TA_UPDATECP":"TA_NOUPDATECP");
		UINT16 IsLeft:2 = WMFTextAlignmentModeIsLeftTable(this);
		UINT16 IsTop:5 = WMFTextAlignmentModeIsTopTable(this);
		UINT16 IsRtl:8 = FormatString("%s",this==1?"TA_RTLREADING":"");
	};
}
		
Table WMFV5CSTypeTable(value)//2.1.1.34
{
	switch(value)
	{
		case 0x4C494E4B: "PROFILE_LINKED";
		case 0x4D424544: "PROFILE_EMBEDDED";
		default:FormatString("(0x%x) Undefined V5CSType",value);
	}
}
	
//******************************************************************************************
//WMF STRUCTURES
//******************************************************************************************
[DataTypeByteOrder = LittleEndian]
struct WMF
{
	struct WMFHeader = FormatString("Type: %s, Version: %s, NumberOfObjects: %s, MaxRecord: %s, NumberOfMembers: %s", Type, Version, NumberOfObjects, MaxRecord, NumberOfMembers)
	{
		UINT16 Type = WMFMetafileTypeTable(this);
		UINT16 HeaderSize;
		UINT16 Version = WMFMetafileVersionTable(this);
		UINT16 LowSize;
		UINT16 HighSize;
		UINT16 NumberOfObjects;
		UINT32 MaxRecord;
		UINT16 NumberOfMembers = FormatString("NOT used, Should be 0x0000");
	}
	[WMFRecordType = 0xFFFF]
	while [WMFRecordType != 0x0000]
	{
		WMFRecords record;
	}
}

[DataTypeByteOrder = LittleEndian]
struct WMFDeviceIndependentBitmapobject
{
	switch
	{
		case UINT32(FrameData, FrameOffset)==0x0C:
			_struct CoreHeadBitMap
			{
				WMFBitmapCoreHeaderObject Header;
				WMFRGBquadObject Colors[Header.BitCount];
				BLOB((((Header.Width * Header.Planes * Header.BitCount + 31) & ~31) / 8) * Header.Height) CoreaData;
			}
		default:
			_struct BitmapInforHead
			{
				WMFBitmapInfoHeaderObject Header;
				switch(Header.ColorUsed)
				{
					case 0x0000:
						switch(Header.BitCount)
						{
//							case 0x0000: "BITCOUNT_0";
							case 0x0001: WMFRGBquadObject ColorObject1[2];
							case 0x0004: WMFRGBquadObject ColorObject4[16];
							case 0x0008: WMFRGBquadObject ColorObject8[256];
//							case 0x0010: "BITCOUNT_4"; // the Colors field of DeviceIndependentBitmap is NULL
//							case 0x0018: "BITCOUNT_5"; // the Colors field of DeviceIndependentBitmap is NULL
//							case 0x0020: "BITCOUNT_6"; // the Colors field of DeviceIndependentBitmap is NULL
						}					
//						WMFRGBquadObject ColorObjects[Header.BitCount];
					case 0x0001:
						switch(Header.BitCount)
						{
//							case 0x0000: "BITCOUNT_0";
							case 0x0001: UINT16 Color1[2];
							case 0x0004: UINT16 Color4[16];
							case 0x0008: UINT16 Color8[256];
//							case 0x0010: "BITCOUNT_4"; // the Colors field of DeviceIndependentBitmap is NULL
//							case 0x0018: "BITCOUNT_5"; // the Colors field of DeviceIndependentBitmap is NULL
//							case 0x0020: "BITCOUNT_6"; // the Colors field of DeviceIndependentBitmap is NULL
						}					
				}
				switch
				{
					case Header.Compression != 0x0000 &&				// BI_RGB
							Header.Compression != 0x0003 &&					// BI_BITFIELDS
							Header.Compression != 0x000B:						// BI_CMYK
								BLOB(Header.ImageSize < (FrameLength - FrameOffset) ? Header.ImageSize : (FrameLength - FrameOffset)) aDataC;
					default:
						[Local.size = (((Header.Width * Header.Planes * Header.BitCount + 31) & ~31) / 8) * Header.Height]
						BLOB(Local.size < (FrameLength - FrameOffset) ? Local.size : (FrameLength - FrameOffset)) CoreaData;
				}
			}
	}
	
}

[DataTypeByteOrder = LittleEndian]
struct WMFRecords = FormatString("RecordSize: %u, WMFRecordType: %s, rdParam: %s", RecordSize*2, RecordFunction.LowByte.toString, rdParam.toString)
{
	UINT32 RecordSize;
	[WMFRecordType = UINT8(frameData, offset + 1)]
	UINT16 RecordFunction = FormatString("WMFRecordType: %s(0x%x)",LowByte.toString, LowByte)
	{
		UINT16 HighByte:8= FormatString("0x%x",this);
		UINT16 LowByte:8 = FormatString("%s", WMFRecordTypeTable(this));
	}
	struct rdParam = FormatString("rdParam: %s", WMFrdParamSummary)
	{
		switch(WMFRecordType)
		{
			case 0x01:
				_struct WMFSetBKColorRecord
				{
					[WMFrdParamSummary = ColorRef.toString]
					WMFColorRefObject ColorRef;
				}
			case 0x02:
				_struct WMFSetBKModeRecord
				{
					[WMFrdParamSummary = WMFMixModeTable(BkMode)]
					UINT16 BkMode = WMFMixModeTable(this);
				}
			case 0x03:
				_struct WMFSetMapModeRecord
				{
					[WMFrdParamSummary = WMFMapModeTable(MapMode)]
					UINT16 MapMode = WMFMapModeTable(this);
				}
			case 0x04:
				_struct WMFSetROP2Record
				{
					[WMFrdParamSummary = WMFBinaryRasterOperationTable(DrawMode)]
					UINT16 DrawMode = WMFBinaryRasterOperationTable(this);
				}
			case 0x05:
				_struct WMFSetRelabsRecord {}
			case 0x06:
				_struct WMFSetPolyFillModeRecord
				{
					[WMFrdParamSummary = WMFPolyFillModeTable(PolyFillMode)]
					UINT16 PolyFillMode = WMFPolyFillModeTable(this);
				}
			case 0x07:
				_struct WMFSetStretchBLTModeRecord
				{
					[WMFrdParamSummary = WMFStretchModeTable(StretchMode)]
					UINT16 StretchMode = WMFStretchModeTable(this);
				}
			case 0x08:
				_struct WMFTextChareXtraRecord
				{
					[WMFrdParamSummary = FormatString("CharExtra: %u", CharExtra)]
					UINT16 CharExtra;
				}
			case 0x09:
				_struct WMFSetTextColorRecord
				{
					[WMFrdParamSummary = ColorRef.toString]
					WMFColorRefObject ColorRef;
				}
			case 0x0A:
				[WMFrdParamSummary = FormatString("BreakCount: %u, BreakExtra: %u", WMFSetTextJustificationRecord.BreakCount, WMFSetTextJustificationRecord.BreakExtra)]
				_struct WMFSetTextJustificationRecord
				{
					UINT16 BreakCount;
					UINT16 BreakExtra;
				}
			case 0x0B:
				[WMFrdParamSummary = FormatString("Y: %u, X: %u", WMFSetWindowOrgRecord.Y, WMFSetWindowOrgRecord.X)]
				_struct WMFSetWindowOrgRecord
				{
					UINT16 Y;
					UINT16 X;
				}
			case 0x0C:
				[WMFrdParamSummary = FormatString("Y: %u, X: %u", WMFSetWindowExtRecord.Y, WMFSetWindowExtRecord.X)]
				_struct WMFSetWindowExtRecord
				{
					UINT16 Y;
					UINT16 X;
				}
			case 0x0D:
				[WMFrdParamSummary = FormatString("Y: %u, X: %u", WMFSetViewPortOrgRecord.Y, WMFSetViewPortOrgRecord.X)]
				_struct WMFSetViewPortOrgRecord
				{
					UINT16 Y;
					UINT16 X;
				}
			case 0x0E:
				[WMFrdParamSummary = FormatString("Y: %u, X: %u", WMFSetViewPortExtRecord.Y, WMFSetViewPortExtRecord.X)]
				_struct WMFSetViewPortExtRecord
				{
					UINT16 Y;
					UINT16 X;
				}
			case 0x0F:
				[WMFrdParamSummary = FormatString("YOffset: %u, XOffset: %u", WMFOffSetWindowOrgRecord.YOffset, WMFOffSetWindowOrgRecord.XOffset)]
				_struct WMFOffSetWindowOrgRecord
				{
					UINT16 YOffset;
					UINT16 XOffset;
				}
			case 0x10:
				[WMFrdParamSummary = FormatString("yDenom: %u, yNum: %u, xDenom: %u, xNum: %u", WMFScaleWindowExtRecord.yDenom, WMFScaleWindowExtRecord.yNum, WMFScaleWindowExtRecord.xDenom, WMFScaleWindowExtRecord.xNum)]
				_struct WMFScaleWindowExtRecord
				{
					UINT16 yDenom;
					UINT16 yNum;
					UINT16 xDenom;
					UINT16 xNum;
				}
			case 0x11:
				[WMFrdParamSummary = FormatString("YOffset: %u, XOffset: %u", WMFOffSetViewPortOrgRecord.YOffset, WMFOffSetViewPortOrgRecord.XOffset)]
				_struct WMFOffSetViewPortOrgRecord
				{
					UINT16 YOffset;
					UINT16 XOffset;
				}
			case 0x12:
				[WMFrdParamSummary = FormatString("yDenom: %u, yNum: %u, xDenom: %u, xNum: %u", WMFScaleViewPortExtRecord.yDenom, WMFScaleViewPortExtRecord.yNum, WMFScaleViewPortExtRecord.xDenom, WMFScaleViewPortExtRecord.xNum)]
				_struct WMFScaleViewPortExtRecord
				{
					UINT16 yDenom;
					UINT16 yNum;
					UINT16 xDenom;
					UINT16 xNum;
				}
			case 0x13:
				[WMFrdParamSummary = FormatString("Y: %u, X: %u", WMFLineToRecord.Y, WMFLineToRecord.X)]
				_struct WMFLineToRecord
				{
					UINT16 Y;
					UINT16 X;
				}
			case 0x14:
				[WMFrdParamSummary = FormatString("Y: %u, X: %u", WMFMoveToRecord.Y, WMFMoveToRecord.X)]
				_struct WMFMoveToRecord
				{
					UINT16 Y;
					UINT16 X;
				}
			case 0x15:
				[WMFrdParamSummary = FormatString("Bottom: %u, Right: %u, Top: %u, Left: %u", WMFExcludeClipRectRecord.Bottom, WMFExcludeClipRectRecord.Right, WMFExcludeClipRectRecord.Top, WMFExcludeClipRectRecord.Left)]
				_struct WMFExcludeClipRectRecord		
				{
					UINT16 Bottom;
					UINT16 Right;
					UINT16 Top;
					UINT16 Left;
				}
			case 0x16:
				[WMFrdParamSummary = FormatString("Bottom: %u, Right: %u, Top: %u, Left: %u", WMFIntersectClipRectRecord.Bottom, WMFIntersectClipRectRecord.Right, WMFIntersectClipRectRecord.Top, WMFIntersectClipRectRecord.Left)]
				_struct WMFIntersectClipRectRecord			
				{
					UINT16 Bottom;
					UINT16 Right;
					UINT16 Top;
					UINT16 Left;
				}
			case 0x17:
				[WMFrdParamSummary = FormatString("YEndArc: %u, XEndArc: %u, YStartArc: %u, XStartArc: %u, BottomRect: %u, RightRect: %u, TopRect: %u, LeftRect: %u", WMFArcRecord.YEndArc, WMFArcRecord.XEndArc, WMFArcRecord.YStartArc, WMFArcRecord.XStartArc, WMFArcRecord.BottomRect, WMFArcRecord.RightRect, WMFArcRecord.TopRect, WMFArcRecord.LeftRect)]
				_struct WMFArcRecord
				{
					UINT16 YEndArc;
					UINT16 XEndArc;
					UINT16 YStartArc;
					UINT16 XStartArc;
					UINT16 BottomRect;
					UINT16 RightRect;
					UINT16 TopRect;
					UINT16 LeftRect;
				}
			case 0x18:
				[WMFrdParamSummary = FormatString("BottomRect: %u, RightRect: %u, TopRect: %u, LeftRect: %u", WMFEllipseRecord.BottomRect, WMFEllipseRecord.RightRect, WMFEllipseRecord.TopRect, WMFEllipseRecord.LeftRect)]
				_struct WMFEllipseRecord
				{
					UINT16 BottomRect;
					UINT16 RightRect;
					UINT16 TopRect;
					UINT16 LeftRect;
				}
			case 0x19:
				[WMFrdParamSummary = FormatString("ColorRef: %s, YStart: %u, XStart: %u", WMFFloodFillRecord.ColorRef.toString, WMFFloodFillRecord.YStart, WMFFloodFillRecord.XStart)]
				_struct WMFFloodFillRecord
				{
					WMFColorRefObject ColorRef;
					UINT16 YStart;
					UINT16 XStart;
				}
			case 0x1A:
				[
					WMFrdParamSummary = FormatString("YRadial2: %u, XRadial2: %u, YRadial1: %u, XRadial1: %u, BottomRect: %u, RightRect: %u, TopRect: %u, LeftRect: %u",
																						WMFPieRecord.YRadial2, WMFPieRecord.XRadial2, 
																						WMFPieRecord.YRadial1, WMFPieRecord.XRadial2,
																						WMFPieRecord.BottomRect, WMFPieRecord.RightRect,
																						WMFPieRecord.TopRect, WMFPieRecord.LeftRect)
				]
				_struct WMFPieRecord
				{
					UINT16 YRadial2;
					UINT16 XRadial2;
					UINT16 YRadial1;
					UINT16 XRadial1;
					UINT16 BottomRect;
					UINT16 RightRect;
					UINT16 TopRect;
					UINT16 LeftRect;
				}
			case 0x1B:
				[
					WMFrdParamSummary = FormatString("BottomRect: %u, RightRect: %u, TopRect: %u, LeftRect: %u",
																						WMFRectangleRecord.BottomRect, WMFRectangleRecord.RightRect,
																						WMFRectangleRecord.TopRect, WMFRectangleRecord.LeftRect)
				]
				_struct WMFRectangleRecord
				{
					UINT16 BottomRect;
					UINT16 RightRect;
					UINT16 TopRect;
					UINT16 LeftRect;
				}
			case 0x1C:
				[
					WMFrdParamSummary = FormatString("Height: %u, Width: %u, BottomRect: %u, RightRect: %u, TopRect: %u, LeftRect: %u",
																						WMFRoundRectRecord.Height, WMFRoundRectRecord.Width,
																						WMFRoundRectRecord.BottomRect, WMFRoundRectRecord.RightRect,
																						WMFRoundRectRecord.TopRect, WMFRoundRectRecord.LeftRect)
				]
				_struct WMFRoundRectRecord
				{
					UINT16 Height;
					UINT16 Width;
					UINT16 BottomRect;
					UINT16 RightRect;
					UINT16 TopRect;
					UINT16 LeftRect;				
				}
			case 0x1D:
				[
					WMFrdParamSummary = FormatString("Height: %u, Width: %u, YLeft: %u, XLeft: %u",
																						WMFPATBLTRecord.Height, WMFPATBLTRecord.Width,
																						WMFPATBLTRecord.YLeft, WMFPATBLTRecord.XLeft)
				]
				_struct WMFPATBLTRecord
				{
					UINT16 Height;
					UINT16 Width;
					UINT16 YLeft;
					UINT16 XLeft;
				}
			case 0x1E:				//META_SAVEDC Record
				_struct WMFSaveDCRecord{}
			case 0x1F:
				[
					WMFrdParamSummary = FormatString("ColorRef: %s, Y: %u, X: %u",
																						WMFSetPixelRecord.ColorRef.toString, 
																						WMFSetPixelRecord.Y, WMFSetPixelRecord.X)
				]
				_struct WMFSetPixelRecord
				{
					WMFColorRefObject ColorRef;
					UINT16 Y;
					UINT16 X;
				}
			case 0x20:
				[
					WMFrdParamSummary = FormatString("YOffset: %u, XOffset: %u",
																						WMFOffsetClipRGNRecord.YOffset, WMFOffsetClipRGNRecord.XOffset)
				]
				_struct WMFOffsetClipRGNRecord
				{
					UINT16 YOffset;
					UINT16 XOffset;
				}
			case 0x21:
				[
					WMFrdParamSummary = FormatString("String: %s, YStart: %u, XStart: %u",
																						WMFTextOutRecord.String, 
																						WMFTextOutRecord.YStart, WMFTextOutRecord.XStart)
				]
				_struct WMFTextOutRecord
				{
					UINT16 StringLength;
					AsciiString(StringLength) String;
					UINT16 YStart;
					UINT16 XStart;
				}
			case 0x22:
				[
					WMFrdParamSummary = FormatString("RasterOperation: %s, YSrc: %u, XSrc: %u, Height: %u, Width: %u, YDest: %u, XDest: %u",
																						WMFTernaryRasterOperationTable(WMFBitBLTRecord.RasterOperation), 
																						WMFBitBLTRecord.YSrc, WMFBitBLTRecord.XSrc,
																						WMFBitBLTRecord.Height, WMFBitBLTRecord.Width,
																						WMFBitBLTRecord.YDest, WMFBitBLTRecord.XDest)
				]
				_struct WMFBitBLTRecord
				{
					UINT32 RasterOperation = WMFTernaryRasterOperationTable(this);
					UINT16 YSrc;
					UINT16 XSrc;
					UINT16 Height;
					UINT16 Width;
					UINT16 YDest;
					UINT16 XDest;
					switch(Height)
					{
						case 0x0000: UINT16 Target;
						default: WMFBitmap16Object ObjectTarget;
					}
				}
			case 0x23:
				[
					WMFrdParamSummary = FormatString("RasterOperation: %s, SrcHeight: %u, SrcWidth: %u, YSrc: %u, XSrc: %u, Height: %u, Width: %u, YDest: %u, XDest: %u",
																						WMFTernaryRasterOperationTable(WMFStretchBLTRecord.RasterOperation), 
																						WMFStretchBLTRecord.SrcHeight, WMFStretchBLTRecord.SrcWidth,
																						WMFStretchBLTRecord.YSrc, WMFStretchBLTRecord.XSrc,
																						WMFStretchBLTRecord.Height, WMFStretchBLTRecord.Width,
																						WMFStretchBLTRecord.YDest, WMFStretchBLTRecord.XDest)
				]
				_struct WMFStretchBLTRecord
				{
					UINT32 RasterOperation = WMFTernaryRasterOperationTable(this);
					UINT16 SrcHeight;
					UINT16 SrcWidth;
					UINT16 YSrc;
					UINT16 XSrc;
					UINT16 Height;
					UINT16 Width;
					UINT16 YDest;
					UINT16 XDest;
					switch(Height)
					{
						case 0x0000: UINT16 Target;
						default: WMFBitmap16Object ObjectTarget;
					}
				}
			case 0x24:
				[
					WMFrdParamSummary = FormatString("NumberofPoints: %u",
																						WMFPolyGonRecord.NumberofPoints)
				]
				_struct WMFPolyGonRecord
				{
					UINT16 NumberofPoints;
					WMFPointSObject aPoints[NumberofPoints];
				}
			case 0x25:
				[
					WMFrdParamSummary = FormatString("NumberofPoints: %u",
																						WMFPolyLineRecord.NumberofPoints)
				]
				_struct WMFPolyLineRecord
				{
					UINT16 NumberofPoints;
					WMFPointSObject aPoints[NumberofPoints];
				}
			case 0x26:
				_struct WMFEscapeRecord = FormatString("EscapeFunction: %s", WMFGDIEscapesTable(EscapeFunction))
				{
					UINT16 EscapeFunction = WMFGDIEscapesTable(this);
					switch(EscapeFunction)
					{
						case 0x1014:
							[WMFrdParamSummary = FormatString("Size: %u, Version: %u, Data: %s", Size, Version, Data)]
							_struct Encapsulated
							{
								UINT32 Size;
								UINT32 Version;
								WMFPointLObject Points[3];
								AsciiString Data;
							};
						default:
							[WMFrdParamSummary = FormatString("ByteCount: %u", ByteCount)]
							_struct EscapeRecord
							{		
								UINT16 ByteCount;
								switch(EscapeFunction)
								{
									case 0x1007:
										BLOB(ByteCount) JPEGBuffer;
									case 0x1008:
										BLOB(ByteCount) PNGBuffer;
									case 0x0019:
										[WMFrdParamSummary = WMFrdParamSummary + FormatString("Style: %u, Pattern %u", Style, Pattern)]
										_struct DrawRect
										{
											BLOB(8) Position;
											BLOB(8) Size;
											UINT16 Style;
											UINT16 Pattern;
										}			
									case 0x0021:
										[WMFrdParamSummary = WMFrdParamSummary + FormatString("SetEpsPrinting: %s", SetEpsPrinting.toString)]
										UINT16 SetEpsPrinting = FormatString("%s",this ==0?"EPSPRINTINGESCAPE is cleared":"EPSPRINTINGESCAPE is set");
									case 0x0005:
										[WMFrdParamSummary = WMFrdParamSummary + FormatString("Start: %u", Start)]
										UINT16 Start;
									case 0x0013:
									case 0x0025:
									case 0x1005:
									case 0x1006:
									case 0x1013:
										BLOB(ByteCount) Data;
									case 0x0008:
										[WMFrdParamSummary = WMFrdParamSummary + FormatString("Query: %s", WMFGDIEscapesTable(Query))]
										UINT16 Query = WMFGDIEscapesTable(this);
									case 0x0004:
										BLOB(ByteCount) ColorTable;
									case 0x0011:
										[WMFrdParamSummary = WMFrdParamSummary + FormatString("CopyCount: %u", CopyCount)]
										UINT16 CopyCount;
									//TD Maybe we need a table of these descriptions
									case 0x0015:
										[WMFrdParamSummary = WMFrdParamSummary + FormatString("Cap: %u", Cap)]
										UINT32 Cap;
									//TD Maybe we need a table of these descriptions
									case 0x0016:
										[WMFrdParamSummary = WMFrdParamSummary + FormatString("Join: %u", Join)]
										UINT32 Join;
									//TD Maybe we need a table of these descriptions
									case 0x1009:
										[WMFrdParamSummary = WMFrdParamSummary + FormatString("Feature: %u", Feature)]
										UINT32 Feature;
									case 0x0017:
										[WMFrdParamSummary = WMFrdParamSummary + FormatString("MeterLimit: %u", MeterLimit)]
										UINT32 MeterLimit;
									case 0x11DB:
										[WMFrdParamSummary = WMFrdParamSummary + FormatString("VMUsage: %u, Size: %u", SPCLPASSTHROUGH2.VMUsage, SPCLPASSTHROUGH2.Size)]
										_struct SPCLPASSTHROUGH2
										{
											UINT32 VMUsage;
											UINT16 Size;
											BLOB(Size) RawData;
										}
									case 0x000A:
										[WMFrdParamSummary = WMFrdParamSummary + FormatString("DocName: %s", DocName)]
										AsciiString DocName;	
									case 0x100B:
										_struct GDIPLUS_TS_Record
										{
											INT16 Type;
											UINT16 Value;
											BLOB(ByteCount - 4) RecordData;
										}
									default:
										Struct {
											ReportParserError(ParserErrorProtocolClassWindows, "WMF", "Unknown Escapes Type" ) ProtocolError;
										}
								}
							}
					}
				}
			case 0x27:
				[
					WMFrdParamSummary = FormatString("nSavedDC: %u",
																						WMFRestoreDCRecord.nSavedDC)
				]
				_struct WMFRestoreDCRecord
				{
					UINT16 nSavedDC;
				}
			case 0x28:
				[
					WMFrdParamSummary = FormatString("Region: %u, Brush: %u",
																						WMFFillRegionRecord.Region, WMFFillRegionRecord.Brush)
				]
				_struct WMFFillRegionRecord
				{
					UINT16 Region;
					UINT16 Brush;
				}
			case 0x29:
				[
					WMFrdParamSummary = FormatString("Region: %u, Brush: %u, Height: %u, Width: %u",					
																						WMFFrameRegionRecord.Region, WMFFrameRegionRecord.Brush,
																						WMFFrameRegionRecord.Height, WMFFrameRegionRecord.Width)
				]
				_struct WMFFrameRegionRecord
				{
					UINT16 Region;
					UINT16 Brush;
					UINT16 Height;
					UINT16 Width;					
				}
			case 0x2A:
				[WMFrdParamSummary = FormatString("Region: %u", WMFInvertreGionRecord.Region)]
				_struct WMFInvertreGionRecord
				{
					UINT16 Region;
				}
			case 0x2B:
				[WMFrdParamSummary = FormatString("Region: %u", WMFPaintRegionRecord.Region)]
				_struct WMFPaintRegionRecord
				{
					UINT16 Region;
				}
			case 0x2C:
				[WMFrdParamSummary = FormatString("Region: %u", WMFSelectClipRegionRecord.Region)]
				_struct WMFSelectClipRegionRecord
				{
					UINT16 Region;
				}
			case 0x2D:
				[WMFrdParamSummary = FormatString("ObjectIndex: %u", WMFSelectObjectRecord.ObjectIndex)]
				_struct WMFSelectObjectRecord
				{
					UINT16 ObjectIndex;
				}
			case 0x2E:
				[WMFrdParamSummary = FormatString("%s", TextAlignmentMode.toString)]
				_struct WMFSetTextAlignRecord
				{
					WMFTextAlignmentMode TextAlignmentMode;
				}
			case 0x2F:
				_struct WMFDrawTextRecord
				{
				}
			case 0x30:
				[
					WMFrdParamSummary = FormatString("YRadial2: %u, XRadial2: %u, YRadial1: %u, XRadial1: %u, BottomRect: %u, RightRect: %u, TopRect: %u, LeftRect: %u",
																						WMFChordRecord.YRadial2, WMFChordRecord.XRadial2, 
																						WMFChordRecord.YRadial1, WMFChordRecord.XRadial2,
																						WMFChordRecord.BottomRect, WMFChordRecord.RightRect,
																						WMFChordRecord.TopRect, WMFChordRecord.LeftRect)
				]
				_struct WMFChordRecord
				{
					UINT16 YRadial2;
					UINT16 XRadial2;
					UINT16 YRadial1;
					UINT16 XRadial1;
					UINT16 BottomRect;
					UINT16 RightRect;
					UINT16 TopRect;
					UINT16 LeftRect;
				}
			case 0x31:
				[WMFrdParamSummary = FormatString("MapperValues: %s", WMFSetMapperFlagsRecord.MapperValues.toString)]
				_struct WMFSetMapperFlagsRecord
				{
					UINT32 MapperValues = FormatString("%s", this ? "match a font's aspect ratio to the current device's aspect ratio" : "only matching fonts");
				}
			case 0x32:
				[
					WMFrdParamSummary = FormatString("Y: %u, X: %u, WMFExtendedTextOutOptions: %s, WMFRectObject: %s, String: %s",
																						WMFExtTextOutRecord.Y, WMFExtTextOutRecord.X, 
																						WMFExtTextOutRecord.fwOpts.toString, WMFExtTextOutRecord.Rectangle.toString,
																						WMFExtTextOutRecord.String)
				]
				_struct WMFExtTextOutRecord
				{
					UINT16 Y;
					UINT16 X;
					UINT16 StringLength;
					WMFExtendedTextOutOptions fwOpts;
					WMFRectObject Rectangle;
					AsciiString(StringLength) String;
					Align2 align;
					switch
					{
						case StringLength > 0: INT16 Dx[StringLength];
					}
				}
			case 0x33:
				[
					WMFrdParamSummary = FormatString("ColorUsage: %s, ScanCount: %u, StartScan: %u, yDib: %u, xDib: %u, Height: %u, Width: %u, yDest: %u, xDest: %u",
																						WMFColorUsageTable(WMFSetDIBToDevRecord.ColorUsage), 
																						WMFSetDIBToDevRecord.ScanCount, WMFSetDIBToDevRecord.StartScan,
																						WMFSetDIBToDevRecord.yDib, WMFSetDIBToDevRecord.xDib,
																						WMFSetDIBToDevRecord.Height, WMFSetDIBToDevRecord.Width,
																						WMFSetDIBToDevRecord.yDest, WMFSetDIBToDevRecord.xDest)
				]
				_struct WMFSetDIBToDevRecord
				{
					UINT16 ColorUsage = WMFColorUsageTable(this);
					UINT16 ScanCount;
					UINT16 StartScan;
					UINT16 yDib;
					UINT16 xDib;
					UINT16 Height;
					UINT16 Width;
					UINT16 yDest;
					UINT16 xDest;
					WMFBitmapObject DIB;
				}
			case 0x34:
				[WMFrdParamSummary = FormatString("Palette: %u", WMFSelectPaletteRecord.Palette)]
				_Struct WMFSelectPaletteRecord
				{
					UINT16 Palette;
				}
			case 0x35:
				[WMFrdParamSummary = FormatString("NumberOfEntries: %u", WMFRealizePaletteRecord.NumberOfEntries)]
				_Struct WMFRealizePaletteRecord
				{
					UINT16 NumberOfEntries;
				}
			case 0x36:
				[WMFrdParamSummary = FormatString("Palette: %u", WMFAnimatePaletteRecord.Palette)]
				_Struct WMFAnimatePaletteRecord
				{
					WMFPaletteObject Palette;
				}
			case 0x37:
				[
					WMFrdParamSummary = FormatString("ColorRef: %s, Y: %u, X: %u", 
																						WMFSetPalentriesRecord.ColorRef.toString,
																						WMFSetPalentriesRecord.Y, WMFSetPalentriesRecord.X)
				]
				_struct WMFSetPalentriesRecord
				{
					WMFColorRefObject ColorRef;
					UINT16 Y;
					UINT16 X;
				}
			case 0x38:
				[WMFrdParamSummary = FormatString("PolyPolygon: %s", WMFPolyPolygonRecord.PolyPolygon.toString)]
				_struct WMFPolyPolygonRecord
				{
					WMFPolyPolygonObject PolyPolygon;
				}
			case 0x39:
				[WMFrdParamSummary = FormatString("NumberOfEntries: %u", WMFResizePaletteRecord.NumberOfEntries)]
				_struct WMFResizePaletteRecord
				{
					UINT16 NumberOfEntries;
				}
			case 0x40:
				[
					WMFrdParamSummary = FormatString("RasterOperation: %s, YSrc: %u, XSrc: %u, Height: %u, Width: %u, YDest: %u, XDest: %u",
																						WMFTernaryRasterOperationTable(WMFDIBBitBLTRecord.RasterOperation), 
																						WMFDIBBitBLTRecord.YSrc, WMFDIBBitBLTRecord.XSrc,
																						WMFDIBBitBLTRecord.Height, WMFDIBBitBLTRecord.Width,
																						WMFDIBBitBLTRecord.YDest, WMFDIBBitBLTRecord.XDest)
				]
				_struct WMFDIBBitBLTRecord
				{
					UINT32 RasterOperation = WMFTernaryRasterOperationTable(this);
					UINT16 ySrc;
					UINT16 xSrc;
					UINT16 Height;
					UINT16 Width;
					UINT16 YDest;
					UINT16 XDest;
					switch(Height)
					{
						case 0x0000: UINT16 Target;
						default: WMFBitmapObject ObjectTarget;
					}
				}
			case 0x41:
				[
					WMFrdParamSummary = FormatString("RasterOperation: %s, SrcHeight: %u, SrcWidth: %u, YSrc: %u, XSrc: %u, Height: %u, Width: %u, YDest: %u, XDest: %u",
																						WMFTernaryRasterOperationTable(WMFDIBStretchBLTRecord.RasterOperation), 
																						WMFDIBStretchBLTRecord.SrcHeight, WMFDIBStretchBLTRecord.SrcWidth,
																						WMFDIBStretchBLTRecord.YSrc, WMFDIBStretchBLTRecord.XSrc,
																						WMFDIBStretchBLTRecord.DestHeight, WMFDIBStretchBLTRecord.DestWidth,
																						WMFDIBStretchBLTRecord.YDest, WMFDIBStretchBLTRecord.XDest)
				]
				_struct WMFDIBStretchBLTRecord
				{
					UINT32 RasterOperation = WMFTernaryRasterOperationTable(this);
					UINT16 SrcHeight;
					UINT16 SrcWidth;
					UINT16 ySrc;
					UINT16 xSrc;
					UINT16 DestHeight;
					UINT16 DestWidth;
					UINT16 YDest;
					UINT16 XDest;
//					switch(Height)
//					{
//						case 0x0000: UINT16 Target;
//						default: WMFBitmapObject ObjectTarget;
//					}
				}
			case 0x42:
				[
					WMFrdParamSummary = FormatString("Style: %u, ColorUsage: %s",
																						WMFDIBCreatePatternBrushRecord.Style, WMFColorUsageTable(WMFDIBCreatePatternBrushRecord.ColorUsage))
				]
				_struct WMFDIBCreatePatternBrushRecord
				{
					UINT16 Style = FormatString("0x%x--%s", this, this ==  0x0003? "DeviceDependentBitmap" : "DeviceIndependentBitmap");
					UINT16 ColorUsage = WMFColorUsageTable(this);
					switch(Style)
					{
						case 0x0003:
							WMFBitmap16Object target;
						default:
							WMFDeviceIndependentBitmapObject DIB;
					}
				}
			case 0x43:
				[
					WMFrdParamSummary = FormatString("RasterOperation: %s, ColorUsage: %s, SrcHeight: %u, SrcWidth: %u, YSrc: %u, XSrc: %u, DestHeight: %u, DestWidth: %u, YDest: %u, XDest: %u",
																						WMFTernaryRasterOperationTable(WMFStretchDIBRecord.RasterOperation), WMFColorUsageTable(WMFStretchDIBRecord.ColorUsage),
																						WMFStretchDIBRecord.SrcHeight, WMFStretchDIBRecord.SrcWidth,
																						WMFStretchDIBRecord.YSrc, WMFStretchDIBRecord.XSrc,
																						WMFStretchDIBRecord.DestHeight, WMFStretchDIBRecord.DestWidth,
																						WMFStretchDIBRecord.YDest, WMFStretchDIBRecord.XDest)
				]
				_struct WMFStretchDIBRecord
				{
					UINT32 RasterOperation = WMFTernaryRasterOperationTable(this);
					UINT16 ColorUsage = WMFColorUsageTable(this);
					UINT16 SrcHeight;
					UINT16 SrcWidth;
					UINT16 ySrc;
					UINT16 xSrc;
					UINT16 DestHeight;
					UINT16 DestWidth;
					UINT16 YDest;
					UINT16 XDest;
					WMFBitmapObject Target;
				}
			case 0x48:
				[
					WMFrdParamSummary = FormatString("Mode: %s, ColorRef: %s, Y: %u, X: %u",
																						WMFFloodFillTable(WMFExtFloodFillRecord.Mode), WMFExtFloodFillRecord.ColorRef.toString,
																						WMFExtFloodFillRecord.Y, WMFExtFloodFillRecord.X)
				]
				_struct WMFExtFloodFillRecord
				{
					UINT16 Mode = WMFFloodFillTable(this);
					WMFColorRefObject ColorRef;
					UINT16 Y;
					UINT16 X;
				}
			case 0x49:
				[
					WMFrdParamSummary = FormatString("Layout: %s", WMFLayoutTable(WMFSetLayoutRecord.Layout))
				]
				_struct WMFSetLayoutRecord
				{
					UINT16 Layout = WMFLayoutTable(this);
				}
			case 0xF0:
				[WMFrdParamSummary = FormatString("Layout: %u", WMFDeleteObjectRecord.ObjectIndex)]
				_struct WMFDeleteObjectRecord
				{
					UINT16 ObjectIndex;
				}
			case 0xF7:
				[WMFrdParamSummary = FormatString("Palette: %s", WMFCreatePaletteRecord.Palette.toString)]
				_struct WMFCreatePaletteRecord
				{
					WMFPaletteObject Palette;
				}
			case 0xF9:
				[WMFrdParamSummary = FormatString("Bitmap16: %s", WFMCreatePatternBrushRecord.Bitmap16.toString)]
				_struct WFMCreatePatternBrushRecord
				{
					WMFBITMAP16Object Bitmap16;
				}
			case 0xFA:
				[WMFrdParamSummary = FormatString("Pen: %s", WMFCreatePenIndirectRecord.Pen.toString)]
				_struct WMFCreatePenIndirectRecord
				{
					WMFPenObject Pen;
				}
			case 0xFB:
				[WMFrdParamSummary = FormatString("Font: %s", WMFCreateFontIndirectRecord.Font.toString)]
				_struct WMFCreateFontIndirectRecord
				{
					WMFFontObject Font;
				}
			case 0xFC:
				[WMFrdParamSummary = FormatString("Brush: %s", WMFCreateBrushIndirectRecord.Brush.toString)]
				_struct WMFCreateBrushIndirectRecord
				{
					WMFLogBrushObject Brush;
				}
			case 0xFF:
				[WMFrdParamSummary = FormatString("Region: %s", WMFCreateRegionRecord.Region.toString)]
				_struct WMFCreateRegionRecord
				{
					WMFRegionObject Region;
				}
		}
	}
}

[DataTypeByteOrder = LittleEndian]
struct WMFBitmap16Object = FormatString("Type: %u, Width: %u, Height: %u, WidthBytes: %u, Planes: %u", Type, Width, Height, WidthBytes, Planes)
{
	UINT16 Type;
	UINT16 Width;
	UINT16 Height;
	UINT16 WidthBytes;
	UINT8 Planes;
	UINT8 BitsPixel;
	UINT8 Bits[(((Width * Planes * BitsPixel + 15) >> 4) << 1) * Height];
}

[DataTypeByteOrder = LittleEndian]
struct WMFBitmapObject = FormatString("Type: %u, Width: %u, Height: %u, WidthBytes: %u, Planes: %u", Type, Width, Height, WidthBytes, Planes)
{
	UINT32 Type;
	UINT32 Width;
	UINT32 Height;
	UINT32 WidthBytes;
	UINT16 Planes;
	UINT16 BitsPixel;
	UINT8 Bits[(((Width * Planes * BitsPixel + 15) >> 4) << 1) * Height];
}

[DataTypeByteOrder = LittleEndian]
struct WMFBitmapCoreHeaderObject = FormatString("HeaderSize: %u, Width: %u, Height: %u, Planes: %u", HeaderSize, Width, Height, Planes)
{
	UINT32 HeaderSize;
	UINT16 Width;
	UINT16 Height;
	UINT16 Planes;
	UINT16 BitCount = WMFBitCountTable(this);
}

//// 2.2.2.3   BitmapInfoHeader Object 
[DataTypeByteOrder = LittleEndian]
struct WMFBitmapInfoHeaderObject = FormatString("HeaderSize: %u, Height: %u, Planes: %u, BitCount: %u, Compression: %s, ImageSize: %u, XPelsPerMeter: %u, YPelsPerMeter: %u, ColorUsed: %u, ColorImportant: %u, ", 
																			HeaderSize, Height, Planes, BitCount, 
																			WMFCompressionTable(Compression), ImageSize, 
																			XPelsPerMeter, YPelsPerMeter, ColorUsed, ColorImportant)
{
	UINT32 HeaderSize;
	UINT32 Width;
	UINT32 Height;
	UINT16 Planes;
	UINT16 BitCount = WMFBitCountTable(this);
	UINT32 Compression = WMFCompressionTable(this);
	UINT32 ImageSize;
	UINT32 XPelsPerMeter;
	UINT32 YPelsPerMeter;
	UINT32 ColorUsed = WMFColorUsageTable(this);
	UINT32 ColorImportant;
}

[DataTypeByteOrder = LittleEndian]
struct WMFBitmapV4HeaderObject= FormatString("BitmapInfoHeader: %s, RedMask: %s, GreenMask: %s, BlueMask: %s, AlphaMask: %u, CSType: %s",BitmapInfoHeader.toString, RedMask.toString, GreenMask.toString, BlueMask.toString, AlphaMask, CSType.toString)
{
	WMFBitmapInfoHeaderObject BitmapInfoHeader;
	UINT32 RedMask = FormatString("%s",BitmapInfoHeader.Compression == 0x0003?this:"Invalid Value");
	UINT32 GreenMask = FormatString("%s",BitmapInfoHeader.Compression == 0x0003?this:"Invalid Value");
	UINT32 BlueMask = FormatString("%s",BitmapInfoHeader.Compression == 0x0003?this:"Invalid Value");
	UINT32 AlphaMask;
	UINT32 CSType = MUSTBeSetToTable(this, this == 0?Wmflogicalcolorspacetable(0x00000000):"Invalid Value");
	switch(CSType)
	{
		case 0x00000000:
			_struct validdata = FormatString("EndPoints: %s, GammaRed: %u, GammaGreen: %u, GammaBlue: %u",WMFCiexyzTripleObject.toString, GammaRed, GammaGreen, GammaBlue)
			{
				WMFCiexyzTripleObject EndPoints;
				UINT32 GammaRed;
				UINT32 GammaGreen;
				UINT32 GammaBlue;
			}
		default:
			BLOB(48) IgnoredData;
	}	
}

[DataTypeByteOrder = LittleEndian]
struct WMFBitmapV5HeaderObject = FormatString("BitmapV5Header: %s, Intent: %u, ProfileSize: %u", BitmapV5Header.toString, Intent, ProfileSize)
{
	WMFBitmapV4HeaderObject BitmapV5Header;
	UINT32 Intent;
	switch(BitmapV5header.CSType)
	{
		case 0x4C494E4B: 
		case 0x4D424544: 
			UINT32 ProfileData;
		default:
			BLOB(4) IgnoredData = "Ignored";
	}
	UINT32 ProfileSize;
	UINT32 Reserved;
}

[DataTypeByteOrder = LittleEndian]
struct WMFLogBrushObject = FormatString("BrushStyle: %s", WMFBrushStyleTable(BrushStyle))
{
	UINT16 BrushStyle = WMFBrushStyleTable(this);
	switch(BrushStyle)
	{
		case 0:
		case 2:
			WMFColorRefObject ColorRefObject;
		default:
			BLOB(4) ColorRef = "Ignored";
	}
	switch(BrushStyle)
	{
		case 2:
			UINT16 HatchStyle = WMFHatchStyleTable(this);
		default:
			BLOB(4) BrushHatch = "Ignored";
	}
}

[DataTypeByteOrder = LittleEndian]
struct WMFBrushObject = FormatString("BrushStyle: %s", WMFBrushStyleTable(BrushStyle))
{
	UINT16 BrushStyle = WMFBrushStyleTable(this);
	switch(BrushStyle)
	{
		case 0:
		case 2:
			WMFColorRefObject ColorRefObject;
		case 6:
			UINT32 ColorUsage = WMFColorUsageTable(this);
		default:
			BLOB(4) ColorRef = "Ignored";
	}
	switch(BrushStyle)
	{
		case 2:
			UINT16 HatchStyle = WMFHatchStyleTable(this);
		case 3:
			WMFBitmap16Object target;
		case 6:
			WMFDeviceIndependentBitmapObject BrushhatchObject;
		default:
			BLOB(4) BrushHatch = "Ignored";
	}
}

[DataTypeByteOrder = LittleEndian]
struct WMFCieXYZObject = FormatString("CiexyzX: %u, CiexyzY: %u, CiexyzZ: %u", CiexyzX, CiexyzY, CiexyzZ)
{
	UINT32 CiexyzX;
	UINT32 CiexyzY;
	UINT32 CiexyzZ;
}

[DataTypeByteOrder = LittleEndian]
struct WMFCiexyzTripleObject = FormatString("CiexyzRed: %s, CiexyzGreen: %s, CiexyzBlue: %s", CiexyzRed.toString, CiexyzGreen.toString, CiexyzBlue.toString)
{
	WMFCieXYZObject CiexyzRed;
	WMFCieXYZObject CiexyzGreen;
	WMFCieXYZObject CiexyzBlue;
}

// 2.2.2.8   ColorRef Object
[DataTypeByteOrder = LittleEndian]
struct WMFColorRefObject = FormatString("Red: %u, Green: %u, Blue: %u", Red, Green, Blue)
{
	UINT8 Red;
	UINT8 Green;
	UINT8 Blue;
	UINT8 Reserved;
}

[DataTypeByteOrder = LittleEndian]
struct WMFFontObject = FormatString("Height: %u, Width: %u, Escapement: %u, Orientation: %u, Weight: %u, Italic: %u, UnderLine: %u, StrikeOut: %u, ClipPrecision: %s, Quality: %s, FaceName: %s", Height, Width, Escapement, Orientation, Weight, Italic, UnderLine, StrikeOut, WMFClipPrecisionTable(ClipPrecision), WMFFontQualityTable(Quality), FaceName)
{
	INT16 Height;
	UINT16 Width;
	UINT16 Escapement;
	UINT16 Orientation;
	UINT16 Weight;
	UINT8 Italic;
	UINT8 UnderLine;
	UINT8 StrikeOut;	
	switch(UINT8(FrameData, Offset))
	{
		case 0x00000000: 
		case 0x00000001: 
		case 0x00000002: 
		case 0x0000004D: 
		case 0x00000080:
		case 0x00000081:
		case 0x00000082:
		case 0x00000086:
		case 0x00000088: 
		case 0x000000A1: 
		case 0x000000A2:
		case 0x000000A3:
		case 0x000000B1:
		case 0x000000B2:
		case 0x000000BA:
		case 0x000000CC:
		case 0x000000EE:
		case 0x000000FF:
			UINT8 CharSet = WMFCharacterSetTable(this);
		default:
			UINT8 CharsetDefault = FormatString("%d (0x%x)", this, this);
	}
	switch(UINT8(FrameData, Offset))
	{
		case 0x00000000: 
		case 0x00000001:
		case 0x00000002:
		case 0x00000003:
		case 0x00000004:
		case 0x00000005:
		case 0x00000006:
		case 0x00000007:
		case 0x00000008:
		case 0x00000009:
		case 0x0000000A:
			UINT8 OutPrecision = WMFOutPrecisionTable(this);
		default: 
			UINT8 OutPrecisionDefault = FormatString("ox%x",this);
	}
	UINT8 ClipPrecision = WMFClipPrecisionTable(this);// one or more values?
	UINT8 Quality = WMFFontQualityTable(this);
	UINT8 PitchAndFamiliy
	{
		UINT8 FontPitch:4 = WMFPitchFontTable(this);
		UINT8 FontFamily:4= WMFFamilyFontTable(this);
	}
	AsciiString FaceName;
}

[DataTypeByteOrder = LittleEndian]
struct WMFPaletteEntryObject = FormatString("Values: %s, Blue: %u, Green: %u, Red: %u", Values.toString, Blue, Green, Red)
{
	UINT8 Values = FormatString("%s",this == 0?"0x00":WMFPaletteEntryFlagTable(this));
	UINT8 Blue;
	UINT8 Green;
	UINT8 Red;
}
		
[DataTypeByteOrder = LittleEndian]
struct WMFPenObject = FormatString("PenStyle: %s, Width: %s, ColorRef: %s", PenStyle.toString, Width.toString, ColorRef.toString)
{
	WMFPenStyle PenStyle;
	WMFPointSObject Width = FormatString("%d", Width.X);
	WMFColorRefObject ColorRef;
}

//2.2.2.15   PointL Object
[DataTypeByteOrder = LittleEndian]
struct WMFPointLObject = FormatString("X: %u, Y: %u", X, Y)
{
	INT32 X;
	INT32 Y;
}

[DataTypeByteOrder = LittleEndian]
struct WMFPointSObject = FormatString("X: %u, Y: %u", X, Y)
{
	UINT16 X;
	UINT16 Y;
}

[DataTypeByteOrder = LittleEndian]
struct WMFRectobject = FormatString("Left: %u, Top: %u, Right: %u, Bottom: %u", Left, Top, Right, Bottom)
{
	UINT16 Left;
	UINT16 Top;
	UINT16 Right;
	UINT16 Bottom;
}

[DataTypeByteOrder = LittleEndian]
struct WMFRectLObject = FormatString("Left: %u, Top: %u, Right: %u, Bottom: %u", Left, Top, Right, Bottom)
{
	UINT32 Left;
	UINT32 Top;
	UINT32 Right;
	UINT32 Bottom;
}

// 2.2.2.20   RGBQuad Object
[DataTypeByteOrder = LittleEndian]
struct WMFRGBquadObject = FormatString("Blue: %u, Green: %u, Red: %u", Blue, Green, Red)
{
	UINT8 Blue;
	UINT8 Green;
	UINT8 Red;
	UINT8 Reserved;
}

[DataTypeByteOrder = LittleEndian]
struct WMFScanObject = FormatString("Count: %u,Top: %u, Bottom: %u, Left: %u, Right: %u, ScnPtCntToo: %u", Count, Top, Bottom, Left, Right, ScnPtCntToo)
{
	UINT16 Count;
	UINT16 Top;
	UINT16 Bottom;
	UINT16 Left;
	UINT16 Right;
	INT16 ScnPtCntToo;
}

[DataTypeByteOrder = LittleEndian]
struct WMFSizeLObject = FormatString("CX: %u, CY: %u", CX, CY)
{
	UINT32 CX;
	UINT32 CY;
}
//*********************************************************************
//Variable Length structure
//*********************************************************************
[DataTypeByteOrder = LittleEndian]
struct WMFRegionObject = FormatString("NextInChain: %u, ObjectType: %s, ObjectCount: %u, , RegionSize: %u, , ScanCount: %u, , MaxScan: %u, , BoundingRectangle: %s, Scans: %s", NextInChain, ObjectType.toString, ObjectCount, RegionSize, ScanCount, MaxScan, BoundingRectangle.toString, Scans.toString)
{
	INT16 NextInChain;
	INT16 ObjectType = FormatString("%s",this == 0x0006?"0x0006":"Invalid Value");
	INT32 ObjectCount;
	INT16 RegionSize;
	INT16 ScanCount;
	INT16 MaxScan;
	WMFRectobject BoundingRectangle;
	WMFScanObject Scans;
}

[DataTypeByteOrder = LittleEndian]
struct WMFPaletteObject = FormatString("Start: %u, NumberOfEntries: %u", Start, NumberOfEntries)
{
	UINT16 Start;
	UINT16 NumberOfEntries;
	WMFPaletteEntryObject PaletteEntries[NumberOfEntries];
}

[DataTypeByteOrder = LittleEndian]
//TD make sure of the Bits
struct WMFPolyPolygonObject = FormatString("NumberOfPolygons: %u", NumberOfPolygons)
{
	[Local.Count]
	UINT16 NumberOfPolygons;
	[Local.Sum = 0]
	while[Local.Count > 0]
	{
		[Local.Sum = Local.sum + PolugonPoints,Local.Count = Local.Count -1]
		UINT16 PolugonPoints = FormatString("The %d PolyGon have %d Points",Local.Count,this);
	}
	BLOB(Local.Sum*4) Bits;
}

//[DataTypeByteOrder = LittleEndian]
//struct WMFBitmapInfoObject = FormatString("Colors: %u", Header.ColorUsed)
//{
//	WMFBitmapInfoHeaderObject Header;
//	WMFRGBquadObject Colors[Header.ColorUsed];
//}

[DataTypeByteOrder = LittleEndian]
struct WMFlogColorSpaceAObject = FormatString("Version: %u, Size: %u, FileName: %s", Version, Size, FileName)
{
	UINT32 Signature = MustBeSetToTable(this, "LCS_SIGNATURE");
	UINT32 Version;
	UINT32 Size;
	switch(INT32(FrameData,Offset))
	{
		case 0x00000000:
		case 0x73524742:
		case 0x57696E20:
			UINT32 CSType = WMFLogicalColorSpaceTable(this);
		default: 
			UINT32 CSTypeDefault = FormatString("0x%x",this);
	}
	switch(INT32(FrameData,Offset))
	{
		case 0x00000001:
		case 0x00000002:
		case 0x00000004:
		case 0x00000008:
			UINT32 Intent = WMFGamutMappingIntentTable(this);
		default: 
			UINT32 IntentDefault = FormatString("0x%x",this);
	}
	switch(CSType)
	{
		case 0x00000000:
			BLOB(48) EndPoints = "Ignored";
		default:
			_struct
			{
				WMFCiexyzTripleObject EndPointsObject;
				UINT32 GammaRed;
				UINT32 GammaGreen;
				UINT32 GammaBlue;
			}
	}
	AsciiString FileName;
}

[DataTypeByteOrder = LittleEndian]
struct WMFlogColorSpaceWObject = FormatString("Version: %u, Size: %u, FileName: %s", Version, Size, FileName)
{
	UINT32 Signature = MustBeSetToTable(this, "LCS_SIGNATURE");
	UINT32 Version;
	UINT32 Size;
	switch(INT32(FrameData,Offset))
	{
		case 0x00000000:
		case 0x73524742:
		case 0x57696E20:
			INT32 CSType = WMFLogicalColorSpaceTable(this);
		default: 
			INT32 CSTypeDefault = FormatString("0x%x",this);
	}
	switch(INT32(FrameData,Offset))
	{
		case 0x00000001:
		case 0x00000002:
		case 0x00000004:
		case 0x00000008:
			UINT32 Intent = WMFGamutMappingIntentTable(this);
		default: 
			UINT32 IntentDefault = FormatString("0x%x",this);
	}
	switch(CSType)
	{
		case 0x00000000:
			BLOB(48) EndPoints = "Ignored";
		default:
			_struct
			{
				WMFCiexyzTripleObject EndPointsObject;
				UINT32 GammaRed;
				UINT32 GammaGreen;
				UINT32 GammaBlue;
			}
	}
	UnicodeString FileName;
}
