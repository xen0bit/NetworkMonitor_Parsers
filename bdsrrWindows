//#  (c) 2009 CodePlex Foundation
//#
//#  Title:                  Business Document Scanning: Scan Repository Capabilities and Status Retrieval Protocol
//#
//#  Details:                
//#
//#  Microsoft References:   [MS-BDSRR]: Business Document Scanning: Scan Repository Capabilities and Status Retrieval Protocol Specification (3.1)
//#
//#  Comments:               Microsoft implementation is encrypted.  The parser is un-verified due to lack of network capture.
//#
//#  Revision Class and Date:Major, 4/9/2009
//#                          Minor, 3/11/2009
//#
//####

[Property.SoapBodySummary = "BDSRR Payload"]
[RegisterBefore(SoapBody.DefaultSoapBody, BDSRR, BDSRRSoapActionTable(Property.SOAPAction))]
Protocol BDSRR = Property.BDSRRSummary
{
	Switch(Property.SOAPAction)
	{
		Case "http://schemas.microsoft.com/windows/2008/12/wdp/distributedscan/configuration/GetRepositoryElements":
		Case "http://schemas.microsoft.com/windows/2008/12/wdp/distributedscan/configuration/GetRepositoryElementsResponse":
			[Property.BDSRRSummary = this.ToString]
			BDSRRGetRepositoryElements BDSRRGetRepositoryElements;
		Case "http://schemas.microsoft.com/windows/2008/12/wdp/distributedscan/configuration/CancelPostScanJob":
		Case "http://schemas.microsoft.com/windows/2008/12/wdp/distributedscan/configuration/CancelPostScanJobResponse":
			[Property.BDSRRSummary = this.ToString]
			BDSRRCancelPostScanJob BDSRRCancelPostScanJob;
		Case "http://schemas.microsoft.com/windows/2008/12/wdp/distributedscan/configuration/GetPostScanJobElements":
		Case "http://schemas.microsoft.com/windows/2008/12/wdp/distributedscan/configuration/GetPostScanJobElementsResponse":
			[Property.BDSRRSummary = this.ToString]
			BDSRRGetPostScanJobElements BDSRRGetPostScanJobElements;
		Case "http://schemas.microsoft.com/windows/2008/12/wdp/distributedscan/configuration/GetActiveJobs":
		Case "http://schemas.microsoft.com/windows/2008/12/wdp/distributedscan/configuration/GetActiveJobsResponse":
			[Property.BDSRRSummary = this.ToString]
			BDSRRGetActiveJobs BDSRRGetActiveJobs;
		Case "http://schemas.microsoft.com/windows/2008/12/wdp/distributedscan/configuration/GetJobHistory":
		Case "http://schemas.microsoft.com/windows/2008/12/wdp/distributedscan/configuration/GetJobHistoryResponse":
			[Property.BDSRRSummary = this.ToString]
			BDSRRGetJobHistory BDSRRGetJobHistory;
		Case "http://schemas.microsoft.com/windows/2008/12/wdp/distributedscan/configuration/RepositoryElementsChangeEvent":
			[Property.BDSRRSummary = this.ToString]
			BDSRRRepositoryElementsChangeEvent BDSRRRepositoryElementsChangeEvent;
		Case "http://schemas.microsoft.com/windows/2008/12/wdp/distributedscan/configuration/RepositoryStatusSummaryEvent":
			[Property.BDSRRSummary = this.ToString]
			BDSRRRepositoryStatusSummaryEvent BDSRRRepositoryStatusSummaryEvent;
		Case "http://schemas.microsoft.com/windows/2008/12/wdp/distributedscan/configuration/PostScanJobStatusEvent":
			[Property.BDSRRSummary = this.ToString]
			BDSRRPostScanJobStatusEvent BDSRRPostScanJobStatusEvent;
		Case "http://schemas.microsoft.com/windows/2008/12/wdp/distributedscan/configuration/PostScanJobEndStateEvent":
			[Property.BDSRRSummary = this.ToString]
			BDSRRPostScanJobEndStateEvent BDSRRPostScanJobEndStateEvent;
		Default:
			While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
			{
				XmlElement(true) AnyNode;
			}
	}
	
}

struct BDSRRGetRepositoryElements = FormatString("%s Message", Property.BDSRRGetRepositoryElementsSummary)
{
	[Post.Local.BDSRRGetRepositoryElements_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.BDSRRGetRepositoryElements_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetRepositoryElementsResponse"):
						[Property.BDSRRGetRepositoryElementsSummary = "GetRepositoryElements Response"]
						BDSRRdscGetRepositoryElementsResponseElement GetRepositoryElementsResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetRepositoryElementsRequest"):
						[Property.BDSRRGetRepositoryElementsSummary = "GetRepositoryElements Request"]
						BDSRRdscGetRepositoryElementsRequestElement GetRepositoryElementsRequest;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.BDSRRGetRepositoryElementsSummary = "Fault GetRepositoryElements Response"]
						SoapFaultElement FaultGetRepositoryElementsElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.BDSRRGetRepositoryElementsSummary = "Encrypted GetRepositoryElements Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

struct BDSRRCancelPostScanJob = FormatString("%s Message", Property.BDSRRCancelPostScanJobSummary)
{
	[Post.Local.BDSRRCancelPostScanJob_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.BDSRRCancelPostScanJob_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "CancelPostScanJobResponse"):
						[Property.BDSRRCancelPostScanJobSummary = "CancelPostScanJob Response"]
						BDSRRdscCancelPostScanJobResponseElement CancelPostScanJobResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "CancelPostScanJobRequest"):
						[Property.BDSRRCancelPostScanJobSummary = "CancelPostScanJob Request"]
						BDSRRdscCancelPostScanJobRequestElement CancelPostScanJobRequest;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.BDSRRCancelPostScanJobSummary = "Fault CancelPostScanJob Response"]
						SoapFaultElement FaultCancelPostScanJobElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.BDSRRCancelPostScanJobSummary = "Encrypted CancelPostScanJob Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

struct BDSRRGetPostScanJobElements = FormatString("%s Message", Property.BDSRRGetPostScanJobElementsSummary)
{
	[Post.Local.BDSRRGetPostScanJobElements_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.BDSRRGetPostScanJobElements_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetPostScanJobElementsResponse"):
						[Property.BDSRRGetPostScanJobElementsSummary = "GetPostScanJobElements Response"]
						BDSRRdscGetPostScanJobElementsResponseElement GetPostScanJobElementsResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetPostScanJobElementsRequest"):
						[Property.BDSRRGetPostScanJobElementsSummary = "GetPostScanJobElements Request"]
						BDSRRdscGetPostScanJobElementsRequestElement GetPostScanJobElementsRequest;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.BDSRRGetPostScanJobElementsSummary = "Fault GetPostScanJobElements Response"]
						SoapFaultElement FaultGetPostScanJobElementsElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.BDSRRGetPostScanJobElementsSummary = "Encrypted GetPostScanJobElements Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

struct BDSRRGetActiveJobs = FormatString("%s Message", Property.BDSRRGetActiveJobsSummary)
{
	[Post.Local.BDSRRGetActiveJobs_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.BDSRRGetActiveJobs_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetActiveJobsResponse"):
						[Property.BDSRRGetActiveJobsSummary = "GetActiveJobs Response"]
						BDSRRdscGetActiveJobsResponseElement GetActiveJobsResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetActiveJobsRequest"):
						[Property.BDSRRGetActiveJobsSummary = "GetActiveJobs Request"]
						BDSRRdscGetActiveJobsRequestElement GetActiveJobsRequest;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.BDSRRGetActiveJobsSummary = "Fault GetActiveJobs Response"]
						SoapFaultElement FaultGetActiveJobsElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.BDSRRGetActiveJobsSummary = "Encrypted GetActiveJobs Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

struct BDSRRGetJobHistory = FormatString("%s Message", Property.BDSRRGetJobHistorySummary)
{
	[Post.Local.BDSRRGetJobHistory_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.BDSRRGetJobHistory_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetJobHistoryResponse"):
						[Property.BDSRRGetJobHistorySummary = "GetJobHistory Response"]
						BDSRRdscGetJobHistoryResponseElement GetJobHistoryResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetJobHistoryRequest"):
						[Property.BDSRRGetJobHistorySummary = "GetJobHistory Request"]
						BDSRRdscGetJobHistoryRequestElement GetJobHistoryRequest;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.BDSRRGetJobHistorySummary = "Fault GetJobHistory Response"]
						SoapFaultElement FaultGetJobHistoryElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.BDSRRGetJobHistorySummary = "Encrypted GetJobHistory Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

struct BDSRRRepositoryElementsChangeEvent = FormatString("%s Message", Property.BDSRRRepositoryElementsChangeEventSummary)
{
	[Post.Local.BDSRRRepositoryElementsChangeEvent_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.BDSRRRepositoryElementsChangeEvent_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RepositoryElementsChangeEvent"):
						[Property.BDSRRRepositoryElementsChangeEventSummary = "RepositoryElementsChangeEvent Response"]
						BDSRRdscRepositoryElementsChangeEventElement RepositoryElementsChangeEvent;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.BDSRRRepositoryElementsChangeEventSummary = "Fault RepositoryElementsChangeEvent Response"]
						SoapFaultElement FaultRepositoryElementsChangeEventElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.BDSRRRepositoryElementsChangeEventSummary = "Encrypted RepositoryElementsChangeEvent Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

struct BDSRRRepositoryStatusSummaryEvent = FormatString("%s Message", Property.BDSRRRepositoryStatusSummaryEventSummary)
{
	[Post.Local.BDSRRRepositoryStatusSummaryEvent_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.BDSRRRepositoryStatusSummaryEvent_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RepositoryStatusSummaryEvent"):
						[Property.BDSRRRepositoryStatusSummaryEventSummary = "RepositoryStatusSummaryEvent Response"]
						BDSRRdscRepositoryStatusSummaryEventElement RepositoryStatusSummaryEvent;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.BDSRRRepositoryStatusSummaryEventSummary = "Fault RepositoryStatusSummaryEvent Response"]
						SoapFaultElement FaultRepositoryStatusSummaryEventElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.BDSRRRepositoryStatusSummaryEventSummary = "Encrypted RepositoryStatusSummaryEvent Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

struct BDSRRPostScanJobStatusEvent = FormatString("%s Message", Property.BDSRRPostScanJobStatusEventSummary)
{
	[Post.Local.BDSRRPostScanJobStatusEvent_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.BDSRRPostScanJobStatusEvent_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "PostScanJobStatusEvent"):
						[Property.BDSRRPostScanJobStatusEventSummary = "PostScanJobStatusEvent Response"]
						BDSRRdscPostScanJobStatusEventElement PostScanJobStatusEvent;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.BDSRRPostScanJobStatusEventSummary = "Fault PostScanJobStatusEvent Response"]
						SoapFaultElement FaultPostScanJobStatusEventElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.BDSRRPostScanJobStatusEventSummary = "Encrypted PostScanJobStatusEvent Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

struct BDSRRPostScanJobEndStateEvent = FormatString("%s Message", Property.BDSRRPostScanJobEndStateEventSummary)
{
	[Post.Local.BDSRRPostScanJobEndStateEvent_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.BDSRRPostScanJobEndStateEvent_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "PostScanJobEndStateEvent"):
						[Property.BDSRRPostScanJobEndStateEventSummary = "PostScanJobEndStateEvent Response"]
						BDSRRdscPostScanJobEndStateEventElement PostScanJobEndStateEvent;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.BDSRRPostScanJobEndStateEventSummary = "Fault PostScanJobEndStateEvent Response"]
						SoapFaultElement FaultPostScanJobEndStateEventElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.BDSRRPostScanJobEndStateEventSummary = "Encrypted PostScanJobEndStateEvent Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

//
// ComplexType FiltersType
//
Struct BDSRRdscFiltersType
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Filter") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct Filter= this.STag.ToString
		{
			[Post.Local.Filter_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("Filter") STag;
			switch
			{
				Case !Local.Filter_IsEmpty:
					struct
					{
						BDSRRdscFilterType Filter;
						XmlTag("Filter") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType FilterType
//
Struct BDSRRdscFilterType
{
	struct Dialect=this.Dialect
	{
		[Post.Local.Dialect_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("Dialect") STag;
		switch
		{
			Case !Local.Dialect_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) Dialect;
					XmlTag("Dialect") ETag;
				}
		}
	}
	
	struct FilterConfig= this.STag.ToString
	{
		[Post.Local.FilterConfig_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("FilterConfig") STag;
		switch
		{
			Case !Local.FilterConfig_IsEmpty:
				struct
				{
					BDSRRdscFilterConfigType FilterConfig;
					XmlTag("FilterConfig") ETag;
				}
		}
	}
	
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		XmlElement(true) OtherElement;
	}
}

//
// ComplexType FilterConfigType
//
Struct BDSRRdscFilterConfigType
{
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		XmlElement(true) OtherElement;
	}
}

//
// ComplexType RepositoryConfigurationType
//
Struct BDSRRdscRepositoryConfigurationType
{
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Filters") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Filters= this.STag.ToString
			{
				[Post.Local.Filters_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Filters") STag;
				switch
				{
					Case !Local.Filters_IsEmpty:
						struct
						{
							BDSRRdscFiltersType Filters;
							XmlTag("Filters") ETag;
						}
				}
			}
			
	}
	
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		XmlElement(true) OtherElement;
	}
}

//
// ComplexType RepositoryStateReasonsType
//
Struct BDSRRdscRepositoryStateReasonsType
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RepositoryStateReason") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct RepositoryStateReason= this.RepositoryStateReason
		{
			[Post.Local.RepositoryStateReason_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("RepositoryStateReason") STag;
			switch
			{
				Case !Local.RepositoryStateReason_IsEmpty:
					struct
					{
						StringTerm(Property.XMLEncoding, "<", true, false, false) RepositoryStateReason;
						XmlTag("RepositoryStateReason") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType RepositoryStatusType
//
Struct BDSRRdscRepositoryStatusType
{
	struct RepositoryState=this.RepositoryState
	{
		[Post.Local.RepositoryState_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("RepositoryState") STag;
		switch
		{
			Case !Local.RepositoryState_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) RepositoryState;
					XmlTag("RepositoryState") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RepositoryStateReasons") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct RepositoryStateReasons= this.STag.ToString
			{
				[Post.Local.RepositoryStateReasons_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("RepositoryStateReasons") STag;
				switch
				{
					Case !Local.RepositoryStateReasons_IsEmpty:
						struct
						{
							BDSRRdscRepositoryStateReasonsType RepositoryStateReasons;
							XmlTag("RepositoryStateReasons") ETag;
						}
				}
			}
			
	}
	
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		XmlElement(true) OtherElement;
	}
}

//
// ComplexType RequestedRepositoryElementsType
//
Struct BDSRRdscRequestedRepositoryElementsType
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Name") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct Name=this.Name
		{
			[Post.Local.Name_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("Name") STag;
			switch
			{
				Case !Local.Name_IsEmpty:
					struct
					{
						StringTerm(Property.XMLEncoding, "<", true, false, false) Name;
						XmlTag("Name") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType RepositoryElementDataType
//
Struct BDSRRdscRepositoryElementDataType
{
	Switch
	{
		Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RepositoryConfiguration"):
			struct RepositoryConfiguration= this.STag.ToString
			{
				[Post.Local.RepositoryConfiguration_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("RepositoryConfiguration") STag;
				switch
				{
					Case !Local.RepositoryConfiguration_IsEmpty:
						struct
						{
							BDSRRdscRepositoryConfigurationType RepositoryConfiguration;
							XmlTag("RepositoryConfiguration") ETag;
						}
				}
			}
			
		Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RepositoryStatus"):
			struct RepositoryStatus= this.STag.ToString
			{
				[Post.Local.RepositoryStatus_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("RepositoryStatus") STag;
				switch
				{
					Case !Local.RepositoryStatus_IsEmpty:
						struct 
						{
							BDSRRdscRepositoryStatusType RepositoryStatus;
							XmlTag("RepositoryStatus") ETag;
						}
				}
			}
			
		Default:
			While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
			{
				XmlElement(true) AnyChoice;
			}
	}
	
}

//
// ComplexType RepositoryElementsType
//
Struct BDSRRdscRepositoryElementsType
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ElementData") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct ElementData= this.STag.ToString
		{
			[Post.Local.ElementData_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("ElementData") STag;
			switch
			{
				Case !Local.ElementData_IsEmpty:
					struct
					{
						BDSRRdscRepositoryElementDataType ElementData;
						XmlTag("ElementData") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType JobStatusType
//
Struct BDSRRdscJobStatusType
{
	struct JobToken=this.JobToken
	{
		[Post.Local.JobToken_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("JobToken") STag;
		switch
		{
			Case !Local.JobToken_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) JobToken;
					XmlTag("JobToken") ETag;
				}
		}
	}
	
	struct JobState=this.JobState
	{
		[Post.Local.JobState_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("JobState") STag;
		switch
		{
			Case !Local.JobState_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) JobState;
					XmlTag("JobState") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "JobStateReasons") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct JobStateReasons= this.STag.ToString
			{
				[Post.Local.JobStateReasons_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("JobStateReasons") STag;
				switch
				{
					Case !Local.JobStateReasons_IsEmpty:
						struct
						{
							BDSRRdscJobStateReasonsType JobStateReasons;
							XmlTag("JobStateReasons") ETag;
						}
				}
			}
			
	}
	
	struct FilterStatuses= this.STag.ToString
	{
		[Post.Local.FilterStatuses_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("FilterStatuses") STag;
		switch
		{
			Case !Local.FilterStatuses_IsEmpty:
				struct
				{
					BDSRRdscFilterStatusesType FilterStatuses;
					XmlTag("FilterStatuses") ETag;
				}
		}
	}
	
	struct ImagesReceived=this.ImagesReceived
	{
		[Post.Local.ImagesReceived_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("ImagesReceived") STag;
		switch
		{
			Case !Local.ImagesReceived_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) ImagesReceived;
					XmlTag("ImagesReceived") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "JobCreatedTime") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct JobCreatedTime=this.JobCreatedTime
			{
				[Post.Local.JobCreatedTime_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("JobCreatedTime") STag;
				switch
				{
					Case !Local.JobCreatedTime_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) JobCreatedTime;
							XmlTag("JobCreatedTime") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "JobCompletedTime") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct JobCompletedTime=this.JobCompletedTime
			{
				[Post.Local.JobCompletedTime_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("JobCompletedTime") STag;
				switch
				{
					Case !Local.JobCompletedTime_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) JobCompletedTime;
							XmlTag("JobCompletedTime") ETag;
						}
				}
			}
			
	}
	
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		XmlElement(true) OtherElement;
	}
}

//
// ComplexType JobStateReasonsType
//
Struct BDSRRdscJobStateReasonsType
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "JobStateReason") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct JobStateReason=this.JobStateReason
		{
			[Post.Local.JobStateReason_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("JobStateReason") STag;
			switch
			{
				Case !Local.JobStateReason_IsEmpty:
					struct
					{
						StringTerm(Property.XMLEncoding, "<", true, false, false) JobStateReason;
						XmlTag("JobStateReason") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType JobDescriptionType
//
Struct BDSRRdscJobDescriptionType
{
	struct PSPIdentifier=this.PSPIdentifier
	{
		[Post.Local.PSPIdentifier_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("PSP_Identifier") STag;
		switch
		{
			Case !Local.PSPIdentifier_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) PSPIdentifier;
					XmlTag("PSP_Identifier") ETag;
				}
		}
	}
	
	struct PSPDisplayName=this.PSPDisplayName
	{
		[Post.Local.PSPDisplayName_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("PSP_DisplayName") STag;
		switch
		{
			Case !Local.PSPDisplayName_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) PSPDisplayName;
					XmlTag("PSP_DisplayName") ETag;
				}
		}
	}
	
	struct JobOriginatingUserName=this.JobOriginatingUserName
	{
		[Post.Local.JobOriginatingUserName_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("JobOriginatingUserName") STag;
		switch
		{
			Case !Local.JobOriginatingUserName_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) JobOriginatingUserName;
					XmlTag("JobOriginatingUserName") ETag;
				}
		}
	}
	
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		XmlElement(true) OtherElement;
	}
}

//
// ComplexType FilterStatusesType
//
Struct BDSRRdscFilterStatusesType
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FilterStatus") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct FilterStatus= this.STag.ToString
		{
			[Post.Local.FilterStatus_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("FilterStatus") STag;
			switch
			{
				Case !Local.FilterStatus_IsEmpty:
					struct
					{
						BDSRRdscFilterStatusType FilterStatus;
						XmlTag("FilterStatus") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType FilterStatusType
//
Struct BDSRRdscFilterStatusType
{
	struct Dialect=this.Dialect
	{
		[Post.Local.Dialect_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("Dialect") STag;
		switch
		{
			Case !Local.Dialect_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) Dialect;
					XmlTag("Dialect") ETag;
				}
		}
	}
	
	struct FilterState=this.FilterState
	{
		[Post.Local.FilterState_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("FilterState") STag;
		switch
		{
			Case !Local.FilterState_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) FilterState;
					XmlTag("FilterState") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FilterStateReasons") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct FilterStateReasons= this.STag.ToString
			{
				[Post.Local.FilterStateReasons_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("FilterStateReasons") STag;
				switch
				{
					Case !Local.FilterStateReasons_IsEmpty:
						struct
						{
							BDSRRdscFilterStateReasonsType FilterStateReasons;
							XmlTag("FilterStateReasons") ETag;
						}
				}
			}
			
	}
	
}

//
// ComplexType FilterStateReasonsType
//
Struct BDSRRdscFilterStateReasonsType
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FilterStateReason") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct FilterStateReason=this.FilterStateReason
		{
			[Post.Local.FilterStateReason_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("FilterStateReason") STag;
			switch
			{
				Case !Local.FilterStateReason_IsEmpty:
					struct
					{
						StringTerm(Property.XMLEncoding, "<", true, false, false) FilterStateReason;
						XmlTag("FilterStateReason") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType JobSummaryType
//
Struct BDSRRdscJobSummaryType
{
	struct JobToken=this.JobToken
	{
		[Post.Local.JobToken_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("JobToken") STag;
		switch
		{
			Case !Local.JobToken_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) JobToken;
					XmlTag("JobToken") ETag;
				}
		}
	}
	
	struct PSPIdentifier=this.PSPIdentifier
	{
		[Post.Local.PSPIdentifier_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("PSP_Identifier") STag;
		switch
		{
			Case !Local.PSPIdentifier_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) PSPIdentifier;
					XmlTag("PSP_Identifier") ETag;
				}
		}
	}
	
	struct PSPDisplayName=this.PSPDisplayName
	{
		[Post.Local.PSPDisplayName_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("PSP_DisplayName") STag;
		switch
		{
			Case !Local.PSPDisplayName_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) PSPDisplayName;
					XmlTag("PSP_DisplayName") ETag;
				}
		}
	}
	
	struct JobOriginatingUserName=this.JobOriginatingUserName
	{
		[Post.Local.JobOriginatingUserName_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("JobOriginatingUserName") STag;
		switch
		{
			Case !Local.JobOriginatingUserName_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) JobOriginatingUserName;
					XmlTag("JobOriginatingUserName") ETag;
				}
		}
	}
	
	struct JobState=this.JobState
	{
		[Post.Local.JobState_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("JobState") STag;
		switch
		{
			Case !Local.JobState_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) JobState;
					XmlTag("JobState") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "JobStateReasons") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct JobStateReasons= this.STag.ToString
			{
				[Post.Local.JobStateReasons_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("JobStateReasons") STag;
				switch
				{
					Case !Local.JobStateReasons_IsEmpty:
						struct
						{
							BDSRRdscJobStateReasonsType JobStateReasons;
							XmlTag("JobStateReasons") ETag;
						}
				}
			}
			
	}
	
	struct FilterStatuses= this.STag.ToString
	{
		[Post.Local.FilterStatuses_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("FilterStatuses") STag;
		switch
		{
			Case !Local.FilterStatuses_IsEmpty:
				struct
				{
					BDSRRdscFilterStatusesType FilterStatuses;
					XmlTag("FilterStatuses") ETag;
				}
		}
	}
	
	struct ImagesReceived=this.ImagesReceived
	{
		[Post.Local.ImagesReceived_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("ImagesReceived") STag;
		switch
		{
			Case !Local.ImagesReceived_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) ImagesReceived;
					XmlTag("ImagesReceived") ETag;
				}
		}
	}
	
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		XmlElement(true) OtherElement;
	}
}

//
// ComplexType ListOfSummarysType
//
Struct BDSRRdscListOfSummarysType
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "JobSummary") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct JobSummary= this.STag.ToString
		{
			[Post.Local.JobSummary_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("JobSummary") STag;
			switch
			{
				Case !Local.JobSummary_IsEmpty:
					struct
					{
						BDSRRdscJobSummaryType JobSummary;
						XmlTag("JobSummary") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType DocumentsType
//
Struct BDSRRdscDocumentsType
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Document") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct Document= this.STag.ToString
		{
			[Post.Local.Document_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("Document") STag;
			switch
			{
				Case !Local.Document_IsEmpty:
					struct
					{
						BDSRRdscDocumentType Document;
						XmlTag("Document") ETag;
					}
			}
		}
		
	}
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		XmlElement(true) OtherElement;
	}
}

//
// ComplexType DocumentType
//
Struct BDSRRdscDocumentType
{
	struct DocumentDescription= this.STag.ToString
	{
		[Post.Local.DocumentDescription_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("DocumentDescription") STag;
		switch
		{
			Case !Local.DocumentDescription_IsEmpty:
				struct
				{
					BDSRRdscDocumentDescriptionType DocumentDescription;
					XmlTag("DocumentDescription") ETag;
				}
		}
	}
	
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		XmlElement(true) OtherElement;
	}
}

//
// ComplexType DocumentDescriptionType
//
Struct BDSRRdscDocumentDescriptionType
{
	struct DocumentId=this.DocumentId
	{
		[Post.Local.DocumentId_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("DocumentId") STag;
		switch
		{
			Case !Local.DocumentId_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) DocumentId;
					XmlTag("DocumentId") ETag;
				}
		}
	}
	
	struct Format=this.Format
	{
		[Post.Local.Format_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("Format") STag;
		switch
		{
			Case !Local.Format_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) Format;
					XmlTag("Format") ETag;
				}
		}
	}
	
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		XmlElement(true) OtherElement;
	}
}

//
// ComplexType RequestedJobElementsType
//
Struct BDSRRdscRequestedJobElementsType
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Name") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct Name=this.Name
		{
			[Post.Local.Name_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("Name") STag;
			switch
			{
				Case !Local.Name_IsEmpty:
					struct
					{
						StringTerm(Property.XMLEncoding, "<", true, false, false) Name;
						XmlTag("Name") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType JobElementDataType
//
Struct BDSRRdscJobElementDataType
{
	Switch
	{
		Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "JobStatus"):
			struct JobStatus= this.STag.ToString
			{
				[Post.Local.JobStatus_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("JobStatus") STag;
				switch
				{
					Case !Local.JobStatus_IsEmpty:
						struct
						{
							BDSRRdscJobStatusType JobStatus;
							XmlTag("JobStatus") ETag;
						}
				}
			}
			
		Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "JobDescription"):
			struct JobDescription= this.STag.ToString
			{
				[Post.Local.JobDescription_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("JobDescription") STag;
				switch
				{
					Case !Local.JobDescription_IsEmpty:
						struct
						{
							BDSRRdscJobDescriptionType JobDescription;
							XmlTag("JobDescription") ETag;
						}
				}
			}
			
		Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Documents"):
			struct Documents= this.STag.ToString
			{
				[Post.Local.Documents_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Documents") STag;
				switch
				{
					Case !Local.Documents_IsEmpty:
						struct
						{
							BDSRRdscDocumentsType Documents;
							XmlTag("Documents") ETag;
						}
				}
			}
			
		Default:
			While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
			{
				XmlElement(true) AnyChoice;
			}
	}
	
}

//
// ComplexType JobElementsType
//
Struct BDSRRdscJobElementsType
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ElementData") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct ElementData= this.STag.ToString
		{
			[Post.Local.ElementData_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("ElementData") STag;
			switch
			{
				Case !Local.ElementData_IsEmpty:
					struct
					{
						BDSRRdscJobElementDataType ElementData;
						XmlTag("ElementData") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType GetRepositoryElementsRequestType
//
Struct BDSRRdscGetRepositoryElementsRequestType
{
	struct RequestedElements= this.STag.ToString
	{
		[Post.Local.RequestedElements_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("RequestedElements") STag;
		switch
		{
			Case !Local.RequestedElements_IsEmpty:
				struct
				{
					BDSRRdscRequestedRepositoryElementsType RequestedElements;
					XmlTag("RequestedElements") ETag;
				}
		}
	}
	
}

//
// Element GetRepositoryElementsRequest
//
struct BDSRRdscGetRepositoryElementsRequestElement
{
	[Post.Local.BDSRRdscGetRepositoryElementsRequestElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("GetRepositoryElementsRequest") STag;
	switch
	{
		Case !Local.BDSRRdscGetRepositoryElementsRequestElement_IsEmpty:
			struct
			{
				BDSRRdscGetRepositoryElementsRequestType GetRepositoryElementsRequestType;
				XmlTag("GetRepositoryElementsRequest") ETag;
			}
	}
}

//
// ComplexType GetRepositoryElementsResponseType
//
Struct BDSRRdscGetRepositoryElementsResponseType
{
	struct RepositoryElements= this.STag.ToString
	{
		[Post.Local.RepositoryElements_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("RepositoryElements") STag;
		switch
		{
			Case !Local.RepositoryElements_IsEmpty:
				struct
				{
					BDSRRdscRepositoryElementsType RepositoryElements;
					XmlTag("RepositoryElements") ETag;
				}
		}
	}
	
}

//
// Element GetRepositoryElementsResponse
//
struct BDSRRdscGetRepositoryElementsResponseElement= this.STag.ToString
{
	[Post.Local.BDSRRdscGetRepositoryElementsResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("GetRepositoryElementsResponse") STag;
	switch
	{
		Case !Local.BDSRRdscGetRepositoryElementsResponseElement_IsEmpty:
			struct
			{
				BDSRRdscGetRepositoryElementsResponseType GetRepositoryElementsResponseType;
				XmlTag("GetRepositoryElementsResponse") ETag;
			}
	}
}

//
// ComplexType CancelPostScanJobRequestType
//
Struct BDSRRdscCancelPostScanJobRequestType
{
	struct JobToken=this.JobToken
	{
		[Post.Local.JobToken_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("JobToken") STag;
		switch
		{
			Case !Local.JobToken_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) JobToken;
					XmlTag("JobToken") ETag;
				}
		}
	}
	
}

//
// Element CancelPostScanJobRequest
//
struct BDSRRdscCancelPostScanJobRequestElement= this.STag.ToString
{
	[Post.Local.BDSRRdscCancelPostScanJobRequestElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("CancelPostScanJobRequest") STag;
	switch
	{
		Case !Local.BDSRRdscCancelPostScanJobRequestElement_IsEmpty:
			struct
			{
				BDSRRdscCancelPostScanJobRequestType CancelPostScanJobRequestType;
				XmlTag("CancelPostScanJobRequest") ETag;
			}
	}
}

//
// ComplexType CancelPostScanJobResponseType
//
Struct BDSRRdscCancelPostScanJobResponseType
{
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		XmlElement(true) OtherElement;
	}
}

//
// Element CancelPostScanJobResponse
//
struct BDSRRdscCancelPostScanJobResponseElement= this.STag.ToString
{
	[Post.Local.BDSRRdscCancelPostScanJobResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("CancelPostScanJobResponse") STag;
	switch
	{
		Case !Local.BDSRRdscCancelPostScanJobResponseElement_IsEmpty:
			struct
			{
				BDSRRdscCancelPostScanJobResponseType CancelPostScanJobResponseType;
				XmlTag("CancelPostScanJobResponse") ETag;
			}
	}
}

//
// ComplexType GetPostScanJobElementsRequestType
//
Struct BDSRRdscGetPostScanJobElementsRequestType
{
	struct JobToken=this.JobToken
	{
		[Post.Local.JobToken_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("JobToken") STag;
		switch
		{
			Case !Local.JobToken_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) JobToken;
					XmlTag("JobToken") ETag;
				}
		}
	}
	
	struct RequestedElements= this.STag.ToString
	{
		[Post.Local.RequestedElements_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("RequestedElements") STag;
		switch
		{
			Case !Local.RequestedElements_IsEmpty:
				struct
				{
					BDSRRdscRequestedJobElementsType RequestedElements;
					XmlTag("RequestedElements") ETag;
				}
		}
	}
	
}

//
// Element GetPostScanJobElementsRequest
//
struct BDSRRdscGetPostScanJobElementsRequestElement= this.STag.ToString
{
	[Post.Local.BDSRRdscGetPostScanJobElementsRequestElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("GetPostScanJobElementsRequest") STag;
	switch
	{
		Case !Local.BDSRRdscGetPostScanJobElementsRequestElement_IsEmpty:
			struct
			{
				BDSRRdscGetPostScanJobElementsRequestType GetPostScanJobElementsRequestType;
				XmlTag("GetPostScanJobElementsRequest") ETag;
			}
	}
}

//
// ComplexType GetPostScanJobElementsResponseType
//
Struct BDSRRdscGetPostScanJobElementsResponseType
{
	struct JobElements= this.STag.ToString
	{
		[Post.Local.JobElements_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("JobElements") STag;
		switch
		{
			Case !Local.JobElements_IsEmpty:
				struct
				{
					BDSRRdscJobElementsType JobElements;
					XmlTag("JobElements") ETag;
				}
		}
	}
	
}

//
// Element GetPostScanJobElementsResponse
//
struct BDSRRdscGetPostScanJobElementsResponseElement= this.STag.ToString
{
	[Post.Local.BDSRRdscGetPostScanJobElementsResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("GetPostScanJobElementsResponse") STag;
	switch
	{
		Case !Local.BDSRRdscGetPostScanJobElementsResponseElement_IsEmpty:
			struct
			{
				BDSRRdscGetPostScanJobElementsResponseType GetPostScanJobElementsResponseType;
				XmlTag("GetPostScanJobElementsResponse") ETag;
			}
	}
}

//
// ComplexType GetActiveJobsRequestType
//
Struct BDSRRdscGetActiveJobsRequestType
{
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		XmlElement(true) OtherElement;
	}
}

//
// Element GetActiveJobsRequest
//
struct BDSRRdscGetActiveJobsRequestElement= this.STag.ToString
{
	[Post.Local.BDSRRdscGetActiveJobsRequestElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("GetActiveJobsRequest") STag;
	switch
	{
		Case !Local.BDSRRdscGetActiveJobsRequestElement_IsEmpty:
			struct
			{
				BDSRRdscGetActiveJobsRequestType GetActiveJobsRequestType;
				XmlTag("GetActiveJobsRequest") ETag;
			}
	}
}

//
// ComplexType GetActiveJobsResponseType
//
Struct BDSRRdscGetActiveJobsResponseType
{
	struct ActiveJobs= this.STag.ToString
	{
		[Post.Local.ActiveJobs_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("ActiveJobs") STag;
		switch
		{
			Case !Local.ActiveJobs_IsEmpty:
				struct
				{
					BDSRRdscListOfSummarysType ActiveJobs;
					XmlTag("ActiveJobs") ETag;
				}
		}
	}
	
}

//
// Element GetActiveJobsResponse
//
struct BDSRRdscGetActiveJobsResponseElement= this.STag.ToString
{
	[Post.Local.BDSRRdscGetActiveJobsResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("GetActiveJobsResponse") STag;
	switch
	{
		Case !Local.BDSRRdscGetActiveJobsResponseElement_IsEmpty:
			struct
			{
				BDSRRdscGetActiveJobsResponseType GetActiveJobsResponseType;
				XmlTag("GetActiveJobsResponse") ETag;
			}
	}
}

//
// ComplexType GetJobHistoryRequestType
//
Struct BDSRRdscGetJobHistoryRequestType
{
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		XmlElement(true) OtherElement;
	}
}

//
// Element GetJobHistoryRequest
//
struct BDSRRdscGetJobHistoryRequestElement= this.STag.ToString
{
	[Post.Local.BDSRRdscGetJobHistoryRequestElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("GetJobHistoryRequest") STag;
	switch
	{
		Case !Local.BDSRRdscGetJobHistoryRequestElement_IsEmpty:
			struct
			{
				BDSRRdscGetJobHistoryRequestType GetJobHistoryRequestType;
				XmlTag("GetJobHistoryRequest") ETag;
			}
	}
}

//
// ComplexType GetJobHistoryResponseType
//
Struct BDSRRdscGetJobHistoryResponseType
{
	struct JobHistory= this.STag.ToString
	{
		[Post.Local.JobHistory_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("JobHistory") STag;
		switch
		{
			Case !Local.JobHistory_IsEmpty:
				struct
				{
					BDSRRdscListOfSummarysType JobHistory;
					XmlTag("JobHistory") ETag;
				}
		}
	}
	
}

//
// Element GetJobHistoryResponse
//
struct BDSRRdscGetJobHistoryResponseElement= this.STag.ToString
{
	[Post.Local.BDSRRdscGetJobHistoryResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("GetJobHistoryResponse") STag;
	switch
	{
		Case !Local.BDSRRdscGetJobHistoryResponseElement_IsEmpty:
			struct
			{
				BDSRRdscGetJobHistoryResponseType GetJobHistoryResponseType;
				XmlTag("GetJobHistoryResponse") ETag;
			}
	}
}

//
// ComplexType ElementChangesType
//
Struct BDSRRdscElementChangesType
{
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RepositoryConfiguration") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct RepositoryConfiguration= this.STag.ToString
			{
				[Post.Local.RepositoryConfiguration_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("RepositoryConfiguration") STag;
				switch
				{
					Case !Local.RepositoryConfiguration_IsEmpty:
						struct
						{
							BDSRRdscRepositoryConfigurationType RepositoryConfiguration;
							XmlTag("RepositoryConfiguration") ETag;
						}
				}
			}
			
	}
	
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		XmlElement(true) OtherElement;
	}
}

//
// ComplexType RepositoryElementsChangeEventType
//
Struct BDSRRdscRepositoryElementsChangeEventType
{
	struct ElementChanges= this.STag.ToString
	{
		[Post.Local.ElementChanges_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("ElementChanges") STag;
		switch
		{
			Case !Local.ElementChanges_IsEmpty:
				struct
				{
					BDSRRdscElementChangesType ElementChanges;
					XmlTag("ElementChanges") ETag;
				}
		}
	}
	
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		XmlElement(true) OtherElement;
	}
}

//
// Element RepositoryElementsChangeEvent
//
struct BDSRRdscRepositoryElementsChangeEventElement= this.STag.ToString
{
	[Post.Local.BDSRRdscRepositoryElementsChangeEventElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("RepositoryElementsChangeEvent") STag;
	switch
	{
		Case !Local.BDSRRdscRepositoryElementsChangeEventElement_IsEmpty:
			struct
			{
				BDSRRdscRepositoryElementsChangeEventType RepositoryElementsChangeEventType;
				XmlTag("RepositoryElementsChangeEvent") ETag;
			}
	}
}

//
// ComplexType StatusSummaryType
//
Struct BDSRRdscStatusSummaryType
{
	struct RepositoryState=this.RepositoryState
	{
		[Post.Local.RepositoryState_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("RepositoryState") STag;
		switch
		{
			Case !Local.RepositoryState_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) RepositoryState;
					XmlTag("RepositoryState") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RepositoryStateReasons") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct RepositoryStateReasons= this.STag.ToString
			{
				[Post.Local.RepositoryStateReasons_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("RepositoryStateReasons") STag;
				switch
				{
					Case !Local.RepositoryStateReasons_IsEmpty:
						struct
						{
							BDSRRdscRepositoryStateReasonsType RepositoryStateReasons;
							XmlTag("RepositoryStateReasons") ETag;
						}
				}
			}
			
	}
	
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		XmlElement(true) OtherElement;
	}
}

//
// ComplexType RepositoryStatusSummaryEventType
//
Struct BDSRRdscRepositoryStatusSummaryEventType
{
	struct StatusSummary= this.STag.ToString
	{
		[Post.Local.StatusSummary_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("StatusSummary") STag;
		switch
		{
			Case !Local.StatusSummary_IsEmpty:
				struct
				{
					BDSRRdscStatusSummaryType StatusSummary;
					XmlTag("StatusSummary") ETag;
				}
		}
	}
	
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		XmlElement(true) OtherElement;
	}
}

//
// Element RepositoryStatusSummaryEvent
//
struct BDSRRdscRepositoryStatusSummaryEventElement= this.STag.ToString
{
	[Post.Local.BDSRRdscRepositoryStatusSummaryEventElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("RepositoryStatusSummaryEvent") STag;
	switch
	{
		Case !Local.BDSRRdscRepositoryStatusSummaryEventElement_IsEmpty:
			struct
			{
				BDSRRdscRepositoryStatusSummaryEventType RepositoryStatusSummaryEventType;
				XmlTag("RepositoryStatusSummaryEvent") ETag;
			}
	}
}

//
// ComplexType PostScanJobStatusEventType
//
Struct BDSRRdscPostScanJobStatusEventType
{
	struct JobStatus= this.STag.ToString
	{
		[Post.Local.JobStatus_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("JobStatus") STag;
		switch
		{
			Case !Local.JobStatus_IsEmpty:
				struct
				{
					BDSRRdscJobStatusType JobStatus;
					XmlTag("JobStatus") ETag;
				}
		}
	}
	
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		XmlElement(true) OtherElement;
	}
}

//
// Element PostScanJobStatusEvent
//
struct BDSRRdscPostScanJobStatusEventElement= this.STag.ToString
{
	[Post.Local.BDSRRdscPostScanJobStatusEventElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("PostScanJobStatusEvent") STag;
	switch
	{
		Case !Local.BDSRRdscPostScanJobStatusEventElement_IsEmpty:
			struct
			{
				BDSRRdscPostScanJobStatusEventType PostScanJobStatusEventType;
				XmlTag("PostScanJobStatusEvent") ETag;
			}
	}
}

//
// ComplexType PostScanJobEndStateType
//
Struct BDSRRdscPostScanJobEndStateType
{
	struct JobToken=this.JobToken
	{
		[Post.Local.JobToken_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("JobToken") STag;
		switch
		{
			Case !Local.JobToken_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) JobToken;
					XmlTag("JobToken") ETag;
				}
		}
	}
	
	struct PSPIdentifier=this.PSPIdentifier
	{
		[Post.Local.PSPIdentifier_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("PSP_Identifier") STag;
		switch
		{
			Case !Local.PSPIdentifier_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) PSPIdentifier;
					XmlTag("PSP_Identifier") ETag;
				}
		}
	}
	
	struct PSPDisplayName=this.PSPDisplayName
	{
		[Post.Local.PSPDisplayName_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("PSP_DisplayName") STag;
		switch
		{
			Case !Local.PSPDisplayName_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) PSPDisplayName;
					XmlTag("PSP_DisplayName") ETag;
				}
		}
	}
	
	struct JobOriginatingUserName=this.JobOriginatingUserName
	{
		[Post.Local.JobOriginatingUserName_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("JobOriginatingUserName") STag;
		switch
		{
			Case !Local.JobOriginatingUserName_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) JobOriginatingUserName;
					XmlTag("JobOriginatingUserName") ETag;
				}
		}
	}
	
	struct JobCompletedState=this.JobCompletedState
	{
		[Post.Local.JobCompletedState_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("JobCompletedState") STag;
		switch
		{
			Case !Local.JobCompletedState_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) JobCompletedState;
					XmlTag("JobCompletedState") ETag;
				}
		}
	}
	
	struct JobCompletedStateReasons= this.STag.ToString
	{
		[Post.Local.JobCompletedStateReasons_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("JobCompletedStateReasons") STag;
		switch
		{
			Case !Local.JobCompletedStateReasons_IsEmpty:
				struct
				{
					BDSRRdscJobStateReasonsType JobCompletedStateReasons;
					XmlTag("JobCompletedStateReasons") ETag;
				}
		}
	}
	
	struct FilterCompletedStatuses= this.STag.ToString
	{
		[Post.Local.FilterCompletedStatuses_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("FilterCompletedStatuses") STag;
		switch
		{
			Case !Local.FilterCompletedStatuses_IsEmpty:
				struct
				{
					BDSRRdscFilterStatusesType FilterCompletedStatuses;
					XmlTag("FilterCompletedStatuses") ETag;
				}
		}
	}
	
	struct ImagesReceived=this.ImagesReceived
	{
		[Post.Local.ImagesReceived_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("ImagesReceived") STag;
		switch
		{
			Case !Local.ImagesReceived_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) ImagesReceived;
					XmlTag("ImagesReceived") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "JobCompletedTime") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct JobCompletedTime=this.JobCompletedTime
			{
				[Post.Local.JobCompletedTime_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("JobCompletedTime") STag;
				switch
				{
					Case !Local.JobCompletedTime_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) JobCompletedTime;
							XmlTag("JobCompletedTime") ETag;
						}
				}
			}
			
	}
	
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		XmlElement(true) OtherElement;
	}
}

//
// ComplexType PostScanJobEndStateEventType
//
Struct BDSRRdscPostScanJobEndStateEventType
{
	struct PostScanJobEndState= this.STag.ToString
	{
		[Post.Local.PostScanJobEndState_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("PostScanJobEndState") STag;
		switch
		{
			Case !Local.PostScanJobEndState_IsEmpty:
				struct
				{
					BDSRRdscPostScanJobEndStateType PostScanJobEndState;
					XmlTag("PostScanJobEndState") ETag;
				}
		}
	}
	
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		XmlElement(true) OtherElement;
	}
}

//
// Element PostScanJobEndStateEvent
//
struct BDSRRdscPostScanJobEndStateEventElement= this.STag.ToString
{
	[Post.Local.BDSRRdscPostScanJobEndStateEventElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("PostScanJobEndStateEvent") STag;
	switch
	{
		Case !Local.BDSRRdscPostScanJobEndStateEventElement_IsEmpty:
			struct
			{
				BDSRRdscPostScanJobEndStateEventType PostScanJobEndStateEventType;
				XmlTag("PostScanJobEndStateEvent") ETag;
			}
	}
}

//
// Element PostScanProcess
//
struct BDSRRpspPostScanProcessElement= this.STag.ToString
{
	[Post.Local.BDSRRpspPostScanProcessElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("PostScanProcess") STag;
	switch
	{
		Case !Local.BDSRRpspPostScanProcessElement_IsEmpty:
			struct
			{
				BDSRRpspPostScanProcessType PostScanProcessType;
				XmlTag("PostScanProcess") ETag;
			}
	}
}

//
// ComplexType PostScanProcessType
//
Struct BDSRRpspPostScanProcessType
{
	struct ScanRepository=this.ScanRepository
	{
		[Post.Local.ScanRepository_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("ScanRepository") STag;
		switch
		{
			Case !Local.ScanRepository_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) ScanRepository;
					XmlTag("ScanRepository") ETag;
				}
		}
	}
	
	struct ScanTicket= this.STag.ToString
	{
		[Post.Local.ScanTicket_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("ScanTicket") STag;
		switch
		{
			Case !Local.ScanTicket_IsEmpty:
				struct
				{
					BDSRRwscnScanTicketType ScanTicket;
					XmlTag("ScanTicket") ETag;
				}
		}
	}
	
	struct PostScanInstructions= this.STag.ToString
	{
		[Post.Local.PostScanInstructions_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("PostScanInstructions") STag;
		switch
		{
			Case !Local.PostScanInstructions_IsEmpty:
				struct
				{
					BDSRRpspPostScanInstructionsType PostScanInstructions;
					XmlTag("PostScanInstructions") ETag;
				}
		}
	}
	
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		XmlElement(true) OtherElement;
	}
}

//
// ComplexType PostScanInstructionsType
//
Struct BDSRRpspPostScanInstructionsType
{
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ContinueOnError") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct ContinueOnError=this.ContinueOnError
			{
				[Post.Local.ContinueOnError_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("ContinueOnError") STag;
				switch
				{
					Case !Local.ContinueOnError_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) ContinueOnError;
							XmlTag("ContinueOnError") ETag;
						}
				}
			}
			
	}
	
	struct DocumentRootName=this.DocumentRootName
	{
		[Post.Local.DocumentRootName_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("DocumentRootName") STag;
		switch
		{
			Case !Local.DocumentRootName_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) DocumentRootName;
					XmlTag("DocumentRootName") ETag;
				}
		}
	}
	
	struct FiltersToProcess=this.Stag.ToString
	{
		[Post.Local.FiltersToProcess_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("FiltersToProcess") STag;
		switch
		{
			Case !Local.FiltersToProcess_IsEmpty:
				struct
				{
					BDSRRpspFilterToProcessListType FiltersToProcess;
					XmlTag("FiltersToProcess") ETag;
				}
		}
	}
	
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		XmlElement(true) OtherElement;
	}
}

//
// ComplexType FilterToProcessListType
//
Struct BDSRRpspFilterToProcessListType
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Filter") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct Filter=this.STag.ToString
		{
			[Post.Local.Filter_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("Filter") STag;
			switch
			{
				Case !Local.Filter_IsEmpty:
					struct
					{
						BDSRRpspFilterToProcessType Filter;
						XmlTag("Filter") ETag;
					}
			}
		}
		
	}
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		XmlElement(true) OtherElement;
	}
}

//
// ComplexType FilterToProcessType
//
Struct BDSRRpspFilterToProcessType
{
	struct Dialect=this.Dialect
	{
		[Post.Local.Dialect_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("Dialect") STag;
		switch
		{
			Case !Local.Dialect_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) Dialect;
					XmlTag("Dialect") ETag;
				}
		}
	}
	
	struct Instructions=this.STag.ToString
	{
		[Post.Local.Instructions_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("Instructions") STag;
		switch
		{
			Case !Local.Instructions_IsEmpty:
				struct
				{
					BDSRRpspFilterInstructionType Instructions;
					XmlTag("Instructions") ETag;
				}
		}
	}
	
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		XmlElement(true) OtherElement;
	}
}

//
// ComplexType FilterInstructionType
//
Struct BDSRRpspFilterInstructionType
{
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		XmlElement(true) OtherElement;
	}
}

//
// ComplexType ScanTicketType
//
Struct BDSRRwscnScanTicketType
{
	struct JobDescription=this.STag.ToString
	{
		[Post.Local.JobDescription_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("JobDescription") STag;
		switch
		{
			Case !Local.JobDescription_IsEmpty:
				struct
				{
					BDSRRwscnJobDescriptionType JobDescription;
					XmlTag("JobDescription") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "DocumentParameters") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct DocumentParameters=this.STag.ToString
			{
				[Post.Local.DocumentParameters_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("DocumentParameters") STag;
				switch
				{
					Case !Local.DocumentParameters_IsEmpty:
						struct
						{
							BDSRRwscnDocumentParametersType DocumentParameters;
							XmlTag("DocumentParameters") ETag;
						}
				}
			}
			
	}
	
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		XmlElement(true) OtherElement;
	}
}

//
// ComplexType JobDescriptionType
//
Struct BDSRRwscnJobDescriptionType
{
	struct JobName=this.JobName
	{
		[Post.Local.JobName_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("JobName") STag;
		switch
		{
			Case !Local.JobName_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) JobName;
					XmlTag("JobName") ETag;
				}
		}
	}
	
	struct JobOriginatingUserName=this.JobOriginatingUserName
	{
		[Post.Local.JobOriginatingUserName_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("JobOriginatingUserName") STag;
		switch
		{
			Case !Local.JobOriginatingUserName_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) JobOriginatingUserName;
					XmlTag("JobOriginatingUserName") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "JobInformation") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct JobInformation=this.JobInformation
			{
				[Post.Local.JobInformation_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("JobInformation") STag;
				switch
				{
					Case !Local.JobInformation_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) JobInformation;
							XmlTag("JobInformation") ETag;
						}
				}
			}
			
	}
	
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		XmlElement(true) OtherElement;
	}
}

//
// ComplexType DocumentParametersType
//
Struct BDSRRwscnDocumentParametersType
{
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Format") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Format=this.Format
			{
				[Post.Local.Format_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Format") STag;
				switch
				{
					Case !Local.Format_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) Format;
							XmlTag("Format") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "CompressionQualityFactor") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct CompressionQualityFactor
			{
				[Post.Local.CompressionQualityFactor_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("CompressionQualityFactor") STag;
				switch
				{
					Case !Local.CompressionQualityFactor_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) CompressionQualityFactor;
							XmlTag("CompressionQualityFactor") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ImagesToTransfer") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct ImagesToTransfer=this.ImagesToTransfer
			{
				[Post.Local.ImagesToTransfer_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("ImagesToTransfer") STag;
				switch
				{
					Case !Local.ImagesToTransfer_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) ImagesToTransfer;
							XmlTag("ImagesToTransfer") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "InputSource") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct InputSource=this.InputSource
			{
				[Post.Local.InputSource_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("InputSource") STag;
				switch
				{
					Case !Local.InputSource_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) InputSource;
							XmlTag("InputSource") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FilmScanMode") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct FilmScanMode=this.FilmScanMode
			{
				[Post.Local.FilmScanMode_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("FilmScanMode") STag;
				switch
				{
					Case !Local.FilmScanMode_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) FilmScanMode;
							XmlTag("FilmScanMode") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ContentType") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct ContentType=this.ContentType
			{
				[Post.Local.ContentType_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("ContentType") STag;
				switch
				{
					Case !Local.ContentType_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) ContentType;
							XmlTag("ContentType") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "InputSize") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct InputSize=this.STag.ToString
			{
				[Post.Local.InputSize_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("InputSize") STag;
				switch
				{
					Case !Local.InputSize_IsEmpty:
						struct
						{
							BDSRRwscnDocumentInputSizeType InputSize;
							XmlTag("InputSize") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Exposure") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Exposure=this.STag.ToString
			{
				[Post.Local.Exposure_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Exposure") STag;
				switch
				{
					Case !Local.Exposure_IsEmpty:
						struct
						{
							BDSRRwscnScanExposureType Exposure;
							XmlTag("Exposure") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Scaling") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Scaling=this.STag.ToString
			{
				[Post.Local.Scaling_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Scaling") STag;
				switch
				{
					Case !Local.Scaling_IsEmpty:
						struct
						{
							BDSRRwscnScalingType Scaling;
							XmlTag("Scaling") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Rotation") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Rotation=this.Rotation
			{
				[Post.Local.Rotation_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Rotation") STag;
				switch
				{
					Case !Local.Rotation_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) Rotation;
							XmlTag("Rotation") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "MediaSides") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct MediaSides=this.STag.ToString
			{
				[Post.Local.MediaSides_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("MediaSides") STag;
				switch
				{
					Case !Local.MediaSides_IsEmpty:
						struct
						{
							BDSRRwscnMediaSidesType MediaSides;
							XmlTag("MediaSides") ETag;
						}
				}
			}
			
	}
	
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		XmlElement(true) OtherElement;
	}
}

//
// ComplexType DocumentInputSizeType
//
Struct BDSRRwscnDocumentInputSizeType
{
	Switch
	{
		Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "DocumentSizeAutoDetect"):
			struct DocumentSizeAutoDetect=this.DocumentSizeAutoDetect
			{
				[Post.Local.DocumentSizeAutoDetect_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("DocumentSizeAutoDetect") STag;
				switch
				{
					Case !Local.DocumentSizeAutoDetect_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) DocumentSizeAutoDetect;
							XmlTag("DocumentSizeAutoDetect") ETag;
						}
				}
			}
			
		Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "InputMediaSize"):
			struct InputMediaSize=this.STag.ToString
			{
				[Post.Local.InputMediaSize_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("InputMediaSize") STag;
				switch
				{
					Case !Local.InputMediaSize_IsEmpty:
						struct
						{
							BDSRRwscnDimensionsType InputMediaSize;
							XmlTag("InputMediaSize") ETag;
						}
				}
			}
			
		Default:
			ReportParserError("ParserErrorProtocolClassMsOffice", "BDSRR", "There is no such choice") ChoiceError;
	}
	
}

//
// ComplexType DimensionsType
//
Struct BDSRRwscnDimensionsType
{
	struct Width=this.Width
	{
		[Post.Local.Width_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("Width") STag;
		switch
		{
			Case !Local.Width_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) Width;
					XmlTag("Width") ETag;
				}
		}
	}
	
	struct Height=this.Height
	{
		[Post.Local.Height_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("Height") STag;
		switch
		{
			Case !Local.Height_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) Height;
					XmlTag("Height") ETag;
				}
		}
	}
	
}

//
// ComplexType ScanExposureType
//
Struct BDSRRwscnScanExposureType
{
	Switch
	{
		Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "AutoExposure"):
			struct AutoExposure=this.AutoExposure
			{
				[Post.Local.AutoExposure_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("AutoExposure") STag;
				switch
				{
					Case !Local.AutoExposure_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) AutoExposure;
							XmlTag("AutoExposure") ETag;
						}
				}
			}
			
		Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ExposureSettings"):
			struct ExposureSettings=this.STag.ToString
			{
				[Post.Local.ExposureSettings_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("ExposureSettings") STag;
				switch
				{
					Case !Local.ExposureSettings_IsEmpty:
						struct
						{
							BDSRRwscnExposureSettingsType ExposureSettings;
							XmlTag("ExposureSettings") ETag;
						}
				}
			}
			
		Default:
			ReportParserError("ParserErrorProtocolClassMsOffice", "BDSRR", "There is no such choice") ChoiceError;
	}
	
}

//
// ComplexType ExposureSettingsType
//
Struct BDSRRwscnExposureSettingsType
{
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Contrast") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Contrast=this.Contrast
			{
				[Post.Local.Contrast_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Contrast") STag;
				switch
				{
					Case !Local.Contrast_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) Contrast;
							XmlTag("Contrast") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Brightness") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Brightness=this.Brightness
			{
				[Post.Local.Brightness_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Brightness") STag;
				switch
				{
					Case !Local.Brightness_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) Brightness;
							XmlTag("Brightness") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Sharpness") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Sharpness=this.Sharpness
			{
				[Post.Local.Sharpness_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Sharpness") STag;
				switch
				{
					Case !Local.Sharpness_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) Sharpness;
							XmlTag("Sharpness") ETag;
						}
				}
			}
			
	}
	
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		XmlElement(true) OtherElement;
	}
}

//
// ComplexType ScalingType
//
Struct BDSRRwscnScalingType
{
	struct ScalingWidth=this.ScalingWidth
	{
		[Post.Local.ScalingWidth_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("ScalingWidth") STag;
		switch
		{
			Case !Local.ScalingWidth_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) ScalingWidth;
					XmlTag("ScalingWidth") ETag;
				}
		}
	}
	
	struct ScalingHeight=this.ScalingHeight
	{
		[Post.Local.ScalingHeight_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("ScalingHeight") STag;
		switch
		{
			Case !Local.ScalingHeight_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) ScalingHeight;
					XmlTag("ScalingHeight") ETag;
				}
		}
	}
	
}

//
// ComplexType MediaSidesType
//
Struct BDSRRwscnMediaSidesType
{
	struct MediaFront=this.STag.ToString
	{
		[Post.Local.MediaFront_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("MediaFront") STag;
		switch
		{
			Case !Local.MediaFront_IsEmpty:
				struct
				{
					BDSRRwscnMediaSideType MediaFront;
					XmlTag("MediaFront") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "MediaBack") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct MediaBack=this.STag.ToString
			{
				[Post.Local.MediaBack_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("MediaBack") STag;
				switch
				{
					Case !Local.MediaBack_IsEmpty:
						struct
						{
							BDSRRwscnMediaSideType MediaBack;
							XmlTag("MediaBack") ETag;
						}
				}
			}
			
	}
	
}

//
// ComplexType MediaSideType
//
Struct BDSRRwscnMediaSideType
{
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ScanRegion") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct ScanRegion
			{
				[Post.Local.ScanRegion_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("ScanRegion") STag;
				switch
				{
					Case !Local.ScanRegion_IsEmpty:
						struct
						{
							BDSRRwscnScanRegionType ScanRegion;
							XmlTag("ScanRegion") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ColorProcessing") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct ColorProcessing
			{
				[Post.Local.ColorProcessing_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("ColorProcessing") STag;
				switch
				{
					Case !Local.ColorProcessing_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) ColorProcessing;
							XmlTag("ColorProcessing") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Resolution") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Resolution
			{
				[Post.Local.Resolution_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Resolution") STag;
				switch
				{
					Case !Local.Resolution_IsEmpty:
						struct
						{
							BDSRRwscnResolutionPairExtType Resolution;
							XmlTag("Resolution") ETag;
						}
				}
			}
			
	}
	
	While [!Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		XmlElement(true) OtherElement;
	}
}

//
// ComplexType ScanRegionType
//
Struct BDSRRwscnScanRegionType
{
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ScanRegionXOffset") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct ScanRegionXOffset
			{
				[Post.Local.ScanRegionXOffset_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("ScanRegionXOffset") STag;
				switch
				{
					Case !Local.ScanRegionXOffset_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) ScanRegionXOffset;
							XmlTag("ScanRegionXOffset") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ScanRegionYOffset") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct ScanRegionYOffset
			{
				[Post.Local.ScanRegionYOffset_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("ScanRegionYOffset") STag;
				switch
				{
					Case !Local.ScanRegionYOffset_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) ScanRegionYOffset;
							XmlTag("ScanRegionYOffset") ETag;
						}
				}
			}
			
	}
	
	struct ScanRegionWidth
	{
		[Post.Local.ScanRegionWidth_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("ScanRegionWidth") STag;
		switch
		{
			Case !Local.ScanRegionWidth_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) ScanRegionWidth;
					XmlTag("ScanRegionWidth") ETag;
				}
		}
	}
	
	struct ScanRegionHeight
	{
		[Post.Local.ScanRegionHeight_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("ScanRegionHeight") STag;
		switch
		{
			Case !Local.ScanRegionHeight_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) ScanRegionHeight;
					XmlTag("ScanRegionHeight") ETag;
				}
		}
	}
	
}

//
// ComplexType ResolutionPairExtType
//
Struct BDSRRwscnResolutionPairExtType
{
	struct Width
	{
		[Post.Local.Width_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("Width") STag;
		switch
		{
			Case !Local.Width_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) Width;
					XmlTag("Width") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Height") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Height
			{
				[Post.Local.Height_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Height") STag;
				switch
				{
					Case !Local.Height_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) Height;
							XmlTag("Height") ETag;
						}
				}
			}
			
	}
	
}

Table BDSRRSoapActionTable(value)
{
	Switch(value)
	{
		Case "http://schemas.microsoft.com/windows/2008/12/wdp/distributedscan/configuration/GetRepositoryElements": 
		Case "http://schemas.microsoft.com/windows/2008/12/wdp/distributedscan/configuration/GetRepositoryElementsResponse": 
		Case "http://schemas.microsoft.com/windows/2008/12/wdp/distributedscan/configuration/CancelPostScanJob": 
		Case "http://schemas.microsoft.com/windows/2008/12/wdp/distributedscan/configuration/CancelPostScanJobResponse": 
		Case "http://schemas.microsoft.com/windows/2008/12/wdp/distributedscan/configuration/GetPostScanJobElements": 
		Case "http://schemas.microsoft.com/windows/2008/12/wdp/distributedscan/configuration/GetPostScanJobElementsResponse": 
		Case "http://schemas.microsoft.com/windows/2008/12/wdp/distributedscan/configuration/GetActiveJobs": 
		Case "http://schemas.microsoft.com/windows/2008/12/wdp/distributedscan/configuration/GetActiveJobsResponse": 
		Case "http://schemas.microsoft.com/windows/2008/12/wdp/distributedscan/configuration/GetJobHistory": 
		Case "http://schemas.microsoft.com/windows/2008/12/wdp/distributedscan/configuration/GetJobHistoryResponse": 
		Case "http://schemas.microsoft.com/windows/2008/12/wdp/distributedscan/configuration/RepositoryElementsChangeEvent": 
		Case "http://schemas.microsoft.com/windows/2008/12/wdp/distributedscan/configuration/RepositoryStatusSummaryEvent": 
		Case "http://schemas.microsoft.com/windows/2008/12/wdp/distributedscan/configuration/PostScanJobStatusEvent": 
		Case "http://schemas.microsoft.com/windows/2008/12/wdp/distributedscan/configuration/PostScanJobEndStateEvent": true;
		Default:false;
	}
}
