//#  (c) 2009 CodePlex Foundation
//#
//#  Title:                  Resource ReserVation Protocol
//#
//#  Details:                
//#
//#  Public References:      RFC 2205, 2745, 2747, 2750, 2961, 3097, 3209, 3471, 3473, 3477
//#                          http://www.networksorcery.com/enp/default0701.htm   -->Protocols-->RSVP
//#                          http://www.networkdictionary.com/protocols/rsvp.php
//#                          http://www.javvin.com/protocolRSVP.html
//#
//#  Comments:               
//#
//#  Revision Class and Date:Minor, 11/26/2009
//#
//####

//  [ RFC 2205 Page 31  3. RSVP Functional Specification]
Protocol RSVP = FormatString("%s, Length = %d", RSVPMsgTypeTable(Property.RSVPMsgType), Property.RSVPLength )
{
	RSVPHeader Header;
	while Option[ Offset < Property.AllObjEndOffset ]
	{
		switch(UINT8( Framedata, Offset + 2 ))
		{
			case   1:RSVPSessionObject Session;
			case   3:RSVPHopObject Hop;
			case   4:RSVPIntegrityObject Integrity;
			case   5:RSVPTimeObject Time;
			case   6:RSVPErrorObject Error;
			case   7:RSVPScopeObject Scope;
			case   8:RSVPStyleObject Style;
			case   9:RSVPFlowSpecObject FlowSpec;
			case  10:RSVPFilterSpecObject FilterSpec;
			case  11:RSVPSenderTemplateObject SenderTemplate;
			case  12:RSVPSenderTspecObject SenderTspec;
			case  13:RSVPADSPECObject ADSPEC;
			case  14:RSVPPolicyObject Policy;
			case  15:RSVPResvConfirmObject Confirm;
			case  16:
			case  34:
			case  35:
			case 129:RSVPLabelObject Label;
			case  19:RSVPLabelRequestObject LabelRequest;
			case  20:RSVPExplicitRouteObject ExplicitRoute;
			case  21:RSVPRouteRecordObject RouteRecord;
			case  22:RSVPHelloObject Hello;
			case  23:RSVPMessageIDObject MessageID;
			case  24:RSVPMessageIDACKObject MessageIDACK;
			case  25:RSVPMessageIDListObject MessageIDList;
			case  30:RSVPDiagnosticObject Diagnostic;
			case  31:RSVPRouteObject Route;
			case  32:RSVPDiagResponseObject DiagResponse;
			case  33:RSVPDiagSelectObject DiagSelect;
			case  36:
			case 130:RSVPLabelSetObject LabelSet;
			case  37:RSVPPortectionObject Portection;
			case  42:RSVPDSBMObject DSBM;
			case  43:RSVPSBMPriorityObject SBMPriority;
			case  44:RSVPDSBMTimerObject DSBMTimer;
			case  45:RSVPNonResvSendLimitObject NonResvSendLimit;
			case  63:RSVPDetourObject Detour;
			case  64:RSVPChallengeObject Challenge;
			case  65:RSVPDiffServObject DiffServ;
			case  66:RSVPClassTypeObject ClassType;
			case 128:RSVPNodeCharObject NodeChar;
			case 131:RSVPRestartCapObject RestartCap;
			case 161:
			case 162:RSVPHOPL2Object HOPL2;
			case 163:
			case 164:RSVPLANObject LAN;
			case 165:RSVPTClassObject TClass;
			case 193:RSVPLSPTUNNELObject LSPTUNNEL;
			case 227:RSVPATMSERVICECLASSObject ATMSERVICECLASS;
			case 195:RSVPNotifyRequestObject NotifyRequest;
			case 196:RSVPAdminStatusObject AdminStatus;
			case 205:RSVPFastRerouteObject FastReroute;
			case 207:RSVPSessionAttributeObject SessionAttribute;
			case 228:RSVPCallOPSObject CallOPS;
			case 229:RSVPGenUNIObject GenUNI;
			case 230:RSVPCallIDObject CallID;
			default :RSVPDefaultObject DefaultObject;
		}
	}
}

// OIF-UNI-01.0-R2-RSVP.pdf page 28
Table RSVPGenUNISubobjectTypeTable(value)
{
	switch(value)
	{
		case  1:"Source TNA Address";
		case  2:"Destination TNA Address";
		case  3:"Diversity";
		case  4:"Egress Label";
		case  5:"Service Level";
		default:FormatString("%d(0x%X),value,value");
	}
}

Table RSVPGenUNISubobjectSubTypeTable(type,value)
{
	switch
	{
		case (type == 1 || type == 2) && value == 1:"IPv4";
		case (type == 1 || type == 2) && value == 2:"IPv6";
		case (type == 1 || type == 2) && value == 3:"NSAP";
		case type == 3 && value == 1:"Diversity";
		case type == 4 && value == 1:"Egress Label";
		case type == 4 && value == 2:"SPC_LABEL";
		case type == 5 && value == 1:"Service Level";
		default:FormatString("%d(0x%X),value,value");
	}
}

Table RSVPGenUNISubobjectDiversityDSTable(value)
{
	switch
	{
		case value == 1:"Node diverse";
		case value == 2:"Link Diverse";
		case value == 3:"Shared Risk Link Group diverse";
		case value == 4:"Shared Path";
		case value == 0 || (value >= 5 && value <= 15):"Reserved";
		default:"";
	}
}

//rfc3496 page 3
Table RSVPATMSERVICECLASSObjectSCTable(value)
{
	switch
	{
		case value == 0:"UBR (Unspecified Bit Rate)";
		case value == 1:"VBR-NRT (Variable Bit Rate, Non-Real Time)";
		case value == 2:"VBR-RT (Variable Bit Rate, Real Time)";
		case value == 3:"CBR (Constant Bit Rate)";
		case value >= 4 && value <= 7:"Reserved";
		default:"";
	}
}

Table RSVPErrorCode1ErrorValueTable(code,value)
{
	switch
	{
		case code ==  1 && value == 1:FormatString("Delay bound cannot be met, %d(0x%X)",value,value);
		case code ==  1 && value == 2:FormatString("Requested bandwidth unavailable, %d(0x%X)",value,value);
		case code ==  1 && value == 3:FormatString("MTU in flowspec larger than interface MTU, %d(0x%X)",value,value);
		case code == 21 && value == 1:FormatString("Service conflict, %d(0x%X)",value,value);
		case code == 21 && value == 2:FormatString("Service unsupported, %d(0x%X)",value,value);
		case code == 21 && value == 3:FormatString("Bad Flowspec value, %d(0x%X)",value,value);
		case code == 21 && value == 4:FormatString("Bad Tspec value, %d(0x%X)",value,value);
		case code == 21 && value == 5:FormatString("Bad Adspec value, %d(0x%X)",value,value);
		default:FormatString("Unknown SubCode, %d(0x%X)",value,value);
	}
}

Table RSVPErrorCode1ErrorValueSSTable(value)
{
	switch(value)
	{
		case  2:"Low order 12 bits contain a organization-specific subcode";
		case  3:"Low order 12 bits contain a service-specific sub-code";
		default:"";
	}
}

//http://www.iana.org/assignments/rsvp-parameters
Table RSVPPolicyErrorValueTable(code,value)
{
	switch
	{
		// [RFC 2750    Page 10    Appendix A: Policy Error Codes]
		case code == 2 && value ==   0:FormatString("ERR_INFO, %d(0x%X)",value,value);
		case code == 2 && value ==   1:FormatString("ERR_WARN, %d(0x%X)",value,value);
		case code == 2 && value ==   2:FormatString("ERR_UNKNOWN, %d(0x%X)",value,value);
		case code == 2 && value ==   3:FormatString("ERR_REJECT, %d(0x%X)",value,value);
		case code == 2 && value ==   4:FormatString("ERR_EXCEED, %d(0x%X)",value,value);
		case code == 2 && value ==   5:FormatString("ERR_PREEMPT, %d(0x%X)",value,value);
		case code == 2 && value ==   6:FormatString("ERR_EXPIRED, %d(0x%X)",value,value);
		case code == 2 && value ==   7:FormatString("ERR_REPLACED, %d(0x%X)",value,value);
		case code == 2 && value ==   8:FormatString("ERR_MERGE, %d(0x%X)",value,value);
		case code == 2 && value ==   9:FormatString("ERR_PDP, %d(0x%X)",value,value);
		case code == 2 && value ==  10:FormatString("ERR_SERVER, %d(0x%X)",value,value);
		case code == 2 && value ==  11:FormatString("ERR_PD_SYNTX, %d(0x%X)",value,value);
		case code == 2 && value ==  12:FormatString("ERR_PD_INTGR, %d(0x%X)",value,value);
		case code == 2 && value ==  13:FormatString("ERR_PE_BAD, %d(0x%X)",value,value);
		case code == 2 && value ==  14:FormatString("ERR_PD_MISS, %d(0x%X)",value,value);
		case code == 2 && value ==  15:FormatString("ERR_NO_RSC, %d(0x%X)",value,value);
		case code == 2 && value ==  16:FormatString("ERR_RSVP, %d(0x%X)",value,value);
		case code == 2 && value ==  17:FormatString("ERR_SERVICE, %d(0x%X)",value,value);
		case code == 2 && value ==  18:FormatString("ERR_STYLE, %d(0x%X)",value,value);
		case code == 2 && value ==  19:FormatString("ERR_FL_SPEC, %d(0x%X)",value,value);
		//http://www.iana.org/assignments/rsvp-parameters
		case code == 2 && value == 100:FormatString("Unauthorized sender, %d(0x%X)",value,value);
		case code == 2 && value == 101:FormatString("Unauthorized receiver, %d(0x%X)",value,value);
		//http://www.iana.org/assignments/rsvp-parameters
		case code == 24 && value ==   1:FormatString("Bad EXPLICIT_ROUTE object, %d(0x%X)",value,value);
		case code == 24 && value ==   2:FormatString("Bad strict node, %d(0x%X)",value,value);
		case code == 24 && value ==   3:FormatString("Bad loose node, %d(0x%X)",value,value);
		case code == 24 && value ==   4:FormatString("Bad initial subobject, %d(0x%X)",value,value);
		case code == 24 && value ==   5:FormatString("No route available toward destination, %d(0x%X)",value,value);
		case code == 24 && value ==   6:FormatString("Unacceptable label value, %d(0x%X)",value,value);
		case code == 24 && value ==   7:FormatString("RRO indicated routing loops, %d(0x%X)",value,value);
		case code == 24 && value ==   8:FormatString("MPLS being negotiated, but a non-RSVP-capable router stands in the path, %d(0x%X)",value,value);
		case code == 24 && value ==   9:FormatString("MPLS label allocation failure, %d(0x%X)",value,value);
		case code == 24 && value ==  10:FormatString("Unsupported L3PID, %d(0x%X)",value,value);
		case code == 24 && value ==  11:FormatString("Label Set, %d(0x%X)",value,value);
		case code == 24 && value ==  12:FormatString("Switching Type, %d(0x%X)",value,value);
		case code == 24 && value ==  13:FormatString("Unassigned, %d(0x%X)",value,value);
		case code == 24 && value ==  14:FormatString("Unsupported Encoding, %d(0x%X)",value,value);
		case code == 24 && value ==  15:FormatString("Unsupported Link Protection, %d(0x%X)",value,value);
		case code == 24 && value ==  16:FormatString("Unknown Interface Index, %d(0x%X)",value,value);
		case code == 24 && value >= 17 && value <= 99:  FormatString("Unassigned, %d(0x%X)",value,value);
		case code == 24 && value == 100:FormatString("Diversity not available, %d(0x%X)",value,value);
		case code == 24 && value == 101:FormatString("Service level not available, %d(0x%X)",value,value);
		case code == 24 && value == 102:FormatString("Invalid/Unknown connection ID, %d(0x%X)",value,value);
		case code == 24 && value == 103:FormatString("No route available toward source (ASON), %d(0x%X)",value,value);
		case code == 24 && value == 104:FormatString("Unacceptable interface ID (ASON), %d(0x%X)",value,value);
		case code == 24 && value == 105:FormatString("Invalid/unknown call ID (ASON), %d(0x%X)",value,value);
		case code == 24 && value == 106:FormatString("Invalid SPC interface ID/label (ASON), %d(0x%X)",value,value);
		case code == 25 && value ==   1:FormatString("RRO too large for MTU, %d(0x%X)",value,value);
		case code == 25 && value ==   2:FormatString("RRO Notification, %d(0x%X)",value,value);
		case code == 25 && value ==   3:FormatString("Tunnel locally repaired, %d(0x%X)",value,value);
		case code == 25 && value ==   4:FormatString("Control Channel Active State, %d(0x%X)",value,value);
		case code == 25 && value ==   5:FormatString("Control Channel Degraded State, %d(0x%X)",value,value);
		case code == 27 && value ==   1:FormatString("Unexpected DIFFSERV object, %d(0x%X)",value,value);
		case code == 27 && value ==   2:FormatString("Unsupported PHB, %d(0x%X)",value,value);
		case code == 27 && value ==   3:FormatString("Invalid EXP<-->PHB mapping, %d(0x%X)",value,value);
		case code == 27 && value ==   4:FormatString("Unsupported PSC, %d(0x%X)",value,value);
		case code == 27 && value ==   5:FormatString("Per-LSP context allocation failure, %d(0x%X)",value,value);
		case code == 28 && value ==   1:FormatString("Unexpected CLASSTYPE object, %d(0x%X)",value,value);
		case code == 28 && value ==   2:FormatString("Unsupported Class-Type, %d(0x%X)",value,value);
		case code == 28 && value ==   3:FormatString("Invalid Class-Type value, %d(0x%X)",value,value);
		case code == 28 && value ==   4:FormatString("Class-Type and setup priority do not form a configured TE-Class, %d(0x%X)",value,value);
		case code == 28 && value ==   5:FormatString("Class-Type and holding priority do not form a configured TE-Class, %d(0x%X)",value,value);
		case code == 28 && value ==   6:FormatString("Class-Type and setup priority do not form a configured TE-Class AND Class-Type and holding priority do not form a configured TE-Class, %d(0x%X)",value,value);
		case code == 28 && value ==   7:FormatString("Inconsistency between signaled PSC and signaled Class-Type, %d(0x%X)",value,value);
		case code == 28 && value ==   8:FormatString("Inconsistency between signaled PHBs and signaled Class-Type , %d(0x%X)",value,value);
		default:  FormatString("%d(0x%X)",value,value);
		
	}
}

//rfc3471, Page 26
Table RSVPTLVTypeTable(value)
{
	switch(value)
	{
		case  1:"IPv4";
		case  2:"IPv6";
		case  3:"IF_INDEX";
		case  4:"COMPONENT_IF_DOWNSTREAM";
		case  5:"COMPONENT_IF_UPSTREAM";
		default:"Unknown TLV Type";
	}
}

Table RSVPRolicyElementTable(value)
{
	switch
	{
		case value >= 0 && value <= 49151:"Standard policy elements";
		case value >= 49152 && value <= 53247:"Vendor specific";
		case value >= 53248 && value <= 65535:"Reserved";
	}
}

Table RSVPGPIDTable(value)
{
	switch(value)
	{
		case  0:"Unknown";
		case  1:"Reserved";
		case  2:"Reserved";
		case  3:"Reserved";
		case  4:"Reserved";
		case  5:"Asynchronous mapping of E3 (SDH)";
		case  6:"Asynchronous mapping of DS3/T3 (SDH)";
		case  7:"Asynchronous mapping of E3 (SDH)";
		case  8:"Bit synchronous mapping of E3 (SDH)";
		case  9:"UINT8 synchronous mapping of E3 (SDH)";
		case 10:"Asynchronous mapping of DS2/T2 (SDH)";
		case 11:"Bit synchronous mapping of DS2/T2 (SDH)";
		case 12:"Reserved";
		case 13:"Asynchronous mapping of E1 (SDH)";
		case 14:"UINT8 synchronous mapping of E1 (SDH)";
		case 15:"UINT8 synchronous mapping of 31 * DS0 (SDH)";
		case 16:"Asynchronous mapping of DS1/T1 (SDH)";
		case 17:"Bit synchronous mapping of DS1/T1 (SDH)";
		case 18:"UINT8 synchronous mapping of DS1/T1 (SDH)";
		case 19:"VC-11 in VC-12 (SDH)";
		case 20:"Reserved";
		case 21:"Reserved";
		case 22:"DS1 SF Asynchronous (SONET)";
		case 23:"DS1 ESF Asynchronous (SONET)";
		case 24:"DS3 M23 Asynchronous (SONET)";
		case 25:"DS3 C-Bit Parity Asynchronous (SONET)";
		case 26:"VT/LOVC (SDH)";
		case 27:"STS SPE/HOVC (SDH)";
		case 28:"POS - No Scrambling, 16 bit CRC (SDH)";
		case 29:"POS - No Scrambling, 32 bit CRC (SDH)";
		case 30:"POS - Scrambling, 16 bit CRC (SDH)";
		case 31:"POS - Scrambling, 32 bit CRC (SDH)";
		case 32:"ATM Mapping (SDH)";
		case 33:"Ethernet (SDH, Lambda, Fiber)";
		case 34:"SDH (Lambda, Fiber)";
		case 35:"SONET (Lambda, Fiber)";
		case 36:"Digital Wrapper (Lambda, Fiber)";
		case 37:"Lambda (Fiber)";
		case 38:"ANSI/ETSI PDH (SDH)";
		case 39:"Reserved (SDH)";
		case 40:"Link Access Protocol SDH: LAPS - X.85 and X.86 (SDH)";
		case 41:"FDDI (SDH, Lambda, Fiber)";
		case 42:"DQDB: ETSI ETS 300 216 (SDH)";
		case 43:"FiberChannel-3 (Services) (FiberChannel)";
		case 44:"HDLC";
		case 45:"Ethernet V2/DIX (only) (SDH, Lambda, Fiber)";
		case 46:"Ethernet 802.3 (only) (SDH, Lambda, Fiber)";
		default:FormatString("%u(0x%X)",value,value);
	}
	
}
Table RSVPSwitchingTypeTable(value)
{
	switch(value)
	{
		case   1:"Packet-Switch Capable-1 (PSC-1)";
		case   2:"Packet-Switch Capable-2 (PSC-2)";
		case   3:"Packet-Switch Capable-3 (PSC-3)";
		case   4:"Packet-Switch Capable-4 (PSC-4)";
		case  51:"Layer-2 Switch Capable (L2SC)";
		case 100:"Time-Division-Multiplex Capable (TDM)";
		case 150:"Lambda-Switch Capable (LSC)";
		case 200:"Fiber-Switch Capable (FSC)";
		default :FormatString("%u(0x%X)",value,value);
	}
}

Table RSVPLspEncodingTable(value)
{
	switch(value)
	{
		case  1:"Packet";
		case  2:"Ethernet";
		case  3:"ANSI/ETSI PDH";
		case  4:"Reserved";
		case  5:"SDH ITU-T G.707 / SONET ANSI T1.105";
		case  6:"Reserved";
		case  7:"Digital Wrapper";
		case  8:"Lambda (photonic)";
		case  9:"Fiber";
		case 10:"Reserved";
		case 11:"FiberChannel";
		default:FormatString("%u(0x%X)",value,value);
	}
}

Table RSVPSignalTypeTable(value)
{
	switch(value)
	{
		case  1:"VT1.5 SPE/VC-11";
		case  2:"VT2 SPE/VC-12";
		case  3:"VT3 SPE";
		case  4:"VT6 SPE/VC-2";
		case  5:"STS-1 SPE/VC-3";
		case  6:"STS-3C SPE/VC-4";
		case  7:"STS-1 /STM-0";
		case  8:"STS-3 /STM-1";
		case  9:"STS-12 /STM-4";
		case 10:"STS-48 /STM-16";
		case 11:"STS-192 /STM-64";
		case 12:"STS-768 /STM-256";
		default:"Unknown Signal Type";
	}
}
Table RSVPLabelActionTable(value)
{
	switch(value)
	{
		case  0:FormatString("Inclusive List %d(%#x)",value,value);
		case  1:FormatString("Exclusive List %d(%#x)",value,value);
		case  2:FormatString("Inclusive Range %d(%#x)",value,value);
		case  3:FormatString("Exclusive Range %d(%#x)",value,value);
		default:FormatString("%d(%#x)",value,value);
	}
}

Table RSVPLabelLinkFlgTable(value)
{
	switch(value)
	{
		case 0x20:FormatString("Enhanced %d(%#x)",value,value);
		case 0x10:FormatString("Dedicated 1+1 %d(%#x)",value,value);
		case 0x08:FormatString("Dedicated 1:1 %d(%#x)",value,value);
		case 0x04:FormatString("Shared %d(%#x)",value,value);
		case 0x02:FormatString("Unprotected %d(%#x)",value,value);
		case 0x01:FormatString("Extra Traffic %d(%#x)",value,value);
		default  :FormatString("Undefine %d(%#x)",value,value);
	}
}

/*
Table RSVPSubObjectFlagTable(value)
{
	switch(value)
	{
		case 0x01:"Local protection available";
		case 0x02:"Local protection in use";
		default  :FormatString("value is %d",value);
	}
}
*/
/*
Table RSVPSessionAttrFlgTable(value)
{
	switch(value)
	{
		case 0x01:FormatString("Local protection desired %d(%#x)",value,value);
		case 0x02:FormatString("Label recording desired %d(%#x)",value,value);
		case 0x04:FormatString("SE Style desired %d(%#x)",value,value);
		default  :FormatString("%d(%#x)",value,value);
	}
}
*/
/*
Table RSVPCALLOPSFlgTable(value)
{
	switch(value)
	{
		case 0x01:"Call without connection";
		case 0x02:"Synchronizing a call(for restart mechanism)";
		default  :FormatString("%d",value);
	}
}
*/
Table RSVPSvNumberTable(value)
{
	switch(value)
	{
		case 0x01:"General Information";
		case 0x02:"Guaranteed Service";
		case 0x03:"Predictive Service";
		case 0x04:"Controlled-Delay Service";
		case 0x05:"Controlled-Load Service";
		case 0x06:"Qualitative Service";
		default  :"Undefined Service";
	}
}

Table RSVPParamIDTable(value)
{
	switch(value)
	{
		case   4:"IS HOP COUNT";
		case   6:"PATH B/W ESTIMATE";
		case   8:"MINIMUM PATH LATENCY";
		case  10:"COMPOSED MTU";
		case 127:"Token bucket";
		case 130:"Guaranteed Service RSpec";
		case 131:"ERROR CHARACTERIZTION PARAMETER C";
		case 132:"ERROR CHARACTERIZTION PARAMETER D";
		case 133:"END-TO-END COMPOSED VALUE FOR C";
		case 134:"END-TO-END COMPOSED VALUE FOR D";
		case 135:"SINCE-LAST-RESHAPING POINT COMPOSED VALUE FOR C";
		case 136:"SINCE-LAST-RESHAPING POINT COMPOSED VALUE FOR D";
		default : FormatString("%d",value);
	}
}

Table RSVPMsgTypeTable( value )
{
	switch( value )
	{
		case  1:"Path Message";
		case  2:"Resv Message";
		case  3:"PathErr Message";
		case  4:"ResvErr Message";
		case  5:"PathTear Message";
		case  6:"ResvTear Message";
		case  7:"ResvConf Message";
		case  8:"Diagnostic Request Message";
		case  9:"Diagnostic Reply Message";
		case 10:"ResvTearConfirm Message";
		case 12:"Bundle Message";
		case 13:"ACK Message";
		case 15:"Srefresh Message";
		case 20:"Hello Message";
		case 21:"Notify Message";
		case 25:"Integrity Challenge Message";
		case 26:"Integrity Response Message";
		case 66:"DSBM willing Message";
		case 67:"I AM DSBM";
		default:"Undefined type";
	}
}

Table RSVPClassTable( value )
{
	switch( value )
	{
		case   0:"NULL";
		case   1:"SESSION";
		case   3:"RSVP HOP";
		case   4:"INTEGRITY";
		case   5:"TIME VALUES";
		case   6:"ERROR SPEC";
		case   7:"SCOPE";
		case   8:"STYLE";
		case   9:"FLOWSPEC";
		case  10:"FILTER SPEC";
		case  11:"SENDER TEMPLATE";
		case  12:"SENDER TSPEC";
		case  13:"ADSPEC";
		case  14:"POLICY DATA";
		case  15:"RESV CONFIRM";
		case  16:"RSVP LABEL";
		case  17:"HOP COUNT";
		case  18:"STRICT SOURCE_ROUTE";
		case  19:"LABEL REQUEST";
		case  20:"EXPLICIT ROUTE";
		case  21:"ROUTE RECORD";
		case  22:"HELLO";
		case  23:"MESSAGE ID";
		case  24:"MESSAGE ID ACK/NACK";
		case  25:"MESSAGE ID LIST";
		case  30:"DIAGNOSTIC";
		case  31:"ROUTE";
		case  32:"DIAG RESPONSE";
		case  33:"DIAG SELECT";
		case  34:"RECOVERY LABEL";
		case  35:"UPSTREAM LABEL";
		case  36:"LABEL SET";
		case  37:"PROTECTION";
		case  42:"DSBM IP ADDRESS";
		case  43:"SBM PRIORITY";
		case  44:"DSBM TIMER INTERVALS";
		case  45:"SBM INFO";
		case  63:"DETOUR";
		case  64:"CHALLENGE";
		case  65:"DIFF-SERV";
		case  66:"CLASSTYPE";
		case 128:"NODE CHAR";
		case 129:"SUGGESTED LABEL";
		case 130:"ACCEPTABLE LABEL SET";
		case 131:"RESTART CAP";
		case 161:"RSVP HOP L2";
		case 162:"LAN NHOP L2";
		case 163:"LAN NHOP L3";
		case 164:"LAN LOOPBACK";
		case 165:"TCLASS";
		case 192:"TUNNEL";
		case 193:"LSP TUNNEL INTERFACE ID";
		case 195:"NOTIFY REQUEST";
		case 196:"ADMIN-STATUS";
		case 205:"FAST REROUTE";
		case 207:"SESSION ATTRIBUTE";
		case 225:"DCLASS";
		case 226:"PACKETCABLE EXTENSIONS";
		case 227:"ATM SERVICECLASS";
		case 228:"CALL OPS (ASON)";
		case 229:"GENERALIZED UNI";
		case 230:"CALL ID";
		default : FormatString("Unknown Class(%u)",value);
	}
}
Table RSVPTypeTable(Class,Type)
{
	switch
	{
		case Class ==  1 && Type ==  1:"IPv4/UDP";
		case Class ==  1 && Type ==  2:"Ipv6/UDP";
		case Class ==  1 && Type ==  3:"IPv4/GPI";
		case Class ==  1 && Type ==  4:"IPv6/GPI";
		case Class ==  1 && Type ==  6:"Tagged_Tunnel_IPv4";
		case Class ==  1 && Type ==  7:"LSP Tunnel IPv4";
		case Class ==  1 && Type ==  8:"LSP Tunnel IPv6";
		case Class ==  1 && Type ==  9:"RSVP-Aggregate-IPv4";
		case Class ==  1 && Type == 10:"RSVP-Aggregate-IPv6";
		case Class ==  1 && Type == 11:"UNI_IPv4";
		case Class ==  1 && Type == 12:"UNI_IPv6(ASON)";
		case Class ==  1 && Type == 15:"ENNI_IPv4(ASON)";
		case Class ==  1 && Type == 16:"ENNI_IPv6(ASON)";
		case Class ==  3 && Type ==  1:"IPv4";
		case Class ==  3 && Type ==  2:"IPv6";
		case Class ==  3 && Type ==  3:"IPv4 IF-ID RSVP_HOP";
		case Class ==  3 && Type ==  4:"IPv6 IF-ID RSVP_HOP";
		case Class ==  4: FormatString("Type %d",Type);
		case Class ==  5 && Type ==  1:"Type 1";
		case Class ==  6 && Type ==  1:"IPV4";
		case Class ==  6 && Type ==  2:"IPV6";
		case Class ==  6 && Type ==  3:"IPv4 IF-ID ERROR_SPEC";
		case Class ==  6 && Type ==  4:"IPv6 IF-ID ERROR_SPEC";
		case Class ==  7 && Type ==  1:"IPv4";
		case Class ==  7 && Type ==  2:"IPv6";
		case Class ==  8 && Type ==  1:"Type 1";
		case Class ==  9 && Type ==  1:"Reserved(obsolete)";
		case Class ==  9 && Type ==  2:"Integrated Services";
		case Class ==  9 && Type ==  3:"Deprecated";
		case Class ==  9 && Type ==  4:"SONET/SDH";
		case Class ==  9 && Type ==  5:"G.709";
		case Class == 10 && Type ==  1:"IPV4";
		case Class == 10 && Type ==  2:"IPV6";
		case Class == 10 && Type ==  3:"IPV6 Flow-label";
		case Class == 10 && Type ==  4:"IPV4/GPI";
		case Class == 10 && Type ==  5:"IPV6/GPI";
		case Class == 10 && Type ==  6:"Tagged_Tunnel_IPv4";
		case Class == 10 && Type ==  7:"LSP Tunnel IPv4";
		case Class == 10 && Type ==  8:"LSP Tunnel IPv6";
		case Class == 10 && Type ==  9:"RSVP-Aggregate-IP4";
		case Class == 10 && Type == 10:"RSVP-Aggregate-IP6";
		case Class == 11 && Type ==  1:"IPV4";
		case Class == 11 && Type ==  2:"IPV6";
		case Class == 11 && Type ==  3:"IPV6 Flow-label";
		case Class == 11 && Type ==  4:"IPV4/GPI";
		case Class == 11 && Type ==  5:"IPV6/GPI";
		case Class == 11 && Type ==  6:"Tagged_Tunnel_IPv4";
		case Class == 11 && Type ==  7:"LSP Tunnel IPv4";
		case Class == 11 && Type ==  8:"LSP Tunnel IPv6";
		case Class == 11 && Type ==  9:"RSVP-Aggregate-IP4";
		case Class == 11 && Type == 10:"RSVP-Aggregate-IP6";
		case Class == 12 && Type ==  2:"Integrated Services";
		case Class == 12 && Type ==  3:"Deprecated";
		case Class == 12 && Type ==  4:"SONET/SDH";
		case Class == 12 && Type ==  5:"G.709";
		case Class == 13 && Type ==  2:"Integrated Services";
		case Class == 14 && Type ==  1:"Type 1";
		case Class == 15 && Type ==  1:"IPV4";
		case Class == 15 && Type ==  2:"IPV6";
		case Class == 16 && Type ==  1:"Packet Label";
		case Class == 16 && Type ==  2:"Generalized Label";
		case Class == 16 && Type ==  3:"Waveband Label";
		case Class == 17 && Type ==  1:"IPv4";
		case Class == 18 && Type ==  1:"Default";
		case Class == 19 && Type ==  1:"Label Request without Label Range";
		case Class == 19 && Type ==  2:"Label Request with ATM Label Range";
		case Class == 19 && Type ==  3:"Label Request with Frame Relay";
		case Class == 19 && Type ==  4:"Generalized Label Request";
		case Class == 20 && Type ==  1:"Type 1";
		case Class == 21 && Type ==  1:"Type 1";
		case Class == 22 && Type ==  1:"Request";
		case Class == 22 && Type ==  2:"ACK";
		case Class == 23 && Type ==  1:"Type 1";
		case Class == 24 && Type ==  1:"ACK";
		case Class == 24 && Type ==  2:"NACK";
		case Class == 25 && Type ==  1:"Message ID list";
		case Class == 25 && Type ==  2:"IPv4 Message ID Source list";
		case Class == 25 && Type ==  3:"IPv6 Message ID Source list";
		case Class == 25 && Type ==  4:"IPv4 Message ID Multicast list";
		case Class == 25 && Type ==  5:"IPv6 Message ID Multicast list";
		case Class == 30 && Type ==  1:"IPV4";
		case Class == 30 && Type ==  2:"IPV6";
		case Class == 31 && Type ==  1:"IPV4";
		case Class == 31 && Type ==  2:"IPV6";
		case Class == 32 && Type ==  1:"IPV4";
		case Class == 32 && Type ==  2:"IPV6";
		case Class == 33 && Type ==  1:"Type 1";
		case Class == 34 && Type ==  1:"Packet Label";
		case Class == 34 && Type ==  2:"Generalized Label";
		case Class == 34 && Type ==  3:"Waveband Label";
		case Class == 35 && Type ==  1:"Packet Label";
		case Class == 35 && Type ==  2:"Generalized Label";
		case Class == 35 && Type ==  3:"Waveband Label";
		case Class == 36: FormatString("Type %d",Type);
		case Class == 37 && Type ==  1:"IPv4";
		case Class == 42 && Type ==  1:"IPv4";
		case Class == 42 && Type ==  2:"IPv6";
		case Class == 43 && Type ==  1:"Default";
		case Class == 44 && Type ==  1:"Default";
		case Class == 45 && Type ==  1:"Media Type";
		case Class == 63 && Type ==  7:"IPv4";
		case Class == 63 && Type ==  8:"IPv6";
		case Class == 64 && Type ==  1:"Type 1";
		case Class == 65 && Type ==  1:"E-LSP";
		case Class == 65 && Type ==  2:"L-LSP";
		case Class == 66 && Type ==  1:"Type 1";
		case Class == 128:FormatString("Type %d",Type);
		case Class == 129 && Type == 1:"Packet Label";
		case Class == 129 && Type == 2:"Generalized Label";
		case Class == 129 && Type == 3:"Waveband Label";
		case Class == 130 && Type == 1:"ACCEPTABLE LABEL SET";
		case Class == 131 && Type == 1:"Type 1";
		case Class == 161 && Type == 1:"IEEE Canonical Address";
		case Class == 162 && Type == 1:"IEEE Canonical Address";
		case Class == 163 && Type == 1:"IPv4";
		case Class == 163 && Type == 2:"IPv6";
		case Class == 164 && Type == 1:"IPv4";
		case Class == 164 && Type == 2:"IPv6";
		case Class == 192 && Type == 1:"IPv4/UDP";
		case Class == 192 && Type == 2:"IPv6/UDP";
		case Class == 192 && Type == 3:"IPv4/GPI";
		case Class == 192 && Type == 4:"IPv6/GPI";
		case Class == 193 && Type == 1:"Forward/Reverse Interface ID";
		case Class == 195 && Type == 1:"IPv4 Notify Request";
		case Class == 195 && Type == 2:"IPv6 Notify Request";
		case Class == 196 && Type == 1:"Type 1";
		case Class == 205 && Type == 1:"Type 1";
		case Class == 205 && Type == 7:"Type 7";
		case Class == 207 && Type == 1:"LSP Tunnel(Resource Affinities)";
		case Class == 207 && Type == 7:"LSP Tunnel(No Resource Affinities)";
		case Class == 226 && Type == 1:"Reverse-Rspec";
		case Class == 226 && Type == 2:"Reverse-Session";
		case Class == 226 && Type == 3:"Reverse-Sender-Template";
		case Class == 226 && Type == 4:"Reverse-Sender-Tspec";
		case Class == 226 && Type == 5:"Forward-Rspec";
		case Class == 226 && Type == 6:"Component-Tspec";
		case Class == 226 && Type == 7:"Resource-ID";
		case Class == 226 && Type == 8:"Gate-ID";
		case Class == 226 && Type == 9:"Commit-Entity";
		case Class == 228 && Type == 1:"Type 1";
		case Class == 229 && Type == 1:"Type 1";
		case Class == 230 && Type == 1:"Operator specific";
		case Class == 230 && Type == 2:"Globally unique";
		case Class == 231 && Type == 1:"Component";
		default :FormatString("Type %d", Type);
	}
}


// [RFC 2205    Page 80    APPENDIX A. Object Definitions]

// [RFC 2205    Page 83    APPENDIX A. Object Definitions]
Table RSVP0X0801Table1( value )
{
	switch( value )
	{
		case  1:"Wildcard ";
		case  2:"Explicit ";
		default:"Reserved";
	}
}

// [RFC 2205    Page 83    APPENDIX A. Object Definitions]
Table RSVP0X0801Table2( value )
{
	switch( value )
	{
		case  1:"Distinct reservations ";
		case  2:"Shared reservations ";
		default:"Reserved ";
	}
}



// [RFC 2205    Page 91    APPENDIX B. Error Codes and Values]
Table RSVPErrorCodeTable( value )
{
	switch( value )
	{
		case  0:FormatString("Confirmation, %d(0x%X)",value,value);
		case  1:FormatString("Admission Control Failure, %d(0x%X)",value,value);
		case  2:FormatString("Policy Control Failure, %d(0x%X)",value,value);
		case  3:FormatString("No path information for this Resv message, %d(0x%X)",value,value);
		case  4:FormatString("No sender information for this Resv message, %d(0x%X)",value,value);
		case  5:FormatString("Conflicting reservation style, %d(0x%X)",value,value);
		case  6:FormatString("Unknown reservation style, %d(0x%X)",value,value);
		case  7:FormatString("Conflicting dest ports, %d(0x%X)",value,value);
		case  8:FormatString("Conflicting sender ports, %d(0x%X)",value,value);
		case  9:FormatString("Reserved, %d(0x%X)",value,value);
		case 10:FormatString("Reserved, %d(0x%X)",value,value);
		case 11:FormatString("Reserved, %d(0x%X)",value,value);
		case 12:FormatString("Service preempted, %d(0x%X)",value,value);
		case 13:FormatString("Unknown object class, %d(0x%X)",value,value);
		case 14:FormatString("Unknown object C-Type, %d(0x%X)",value,value);
		case 15:FormatString("Reserved, %d(0x%X)",value,value);
		case 16:FormatString("Reserved, %d(0x%X)",value,value);
		case 17:FormatString("Reserved, %d(0x%X)",value,value);
		case 18:FormatString("Reserved, %d(0x%X)",value,value);
		case 19:FormatString("Reserved, %d(0x%X)",value,value);
		case 20:FormatString("Reserved for API, %d(0x%X)",value,value);
		case 21:FormatString("Traffic Control Error, %d(0x%X)",value,value);
		case 22:FormatString("Traffic Control System Error, %d(0x%X)",value,value);
		case 23:FormatString("RSVP System Error, %d(0x%X)",value,value);
		//below: http://www.iana.org/assignments/rsvp-parameters
		case 24:FormatString("Routing Problem, %d(0x%X)",value,value);
		case 25:FormatString("Notify Error, %d(0x%X)",value,value);
		case 26:FormatString("New-Aggregate-Needed, %d(0x%X)",value,value);
		case 27:FormatString("Diffserv Error, %d(0x%X)",value,value);
		case 28:FormatString("Diff-Serv-Aware TE Error, %d(0x%X)",value,value);
		default:FormatString("Reserved, %d(0x%X)",value,value);
	}
}



// [RFC 3209    Page 24    4.3. Explicit Route Object]
Table  RSVPExplicitRouteObjectTypeTable( value )
{
	switch( value )
	{
		case  1:"IPv4";
		case  2:"IPv6";
		case  3:"Label";
		case  4:"Unnumbered Interface-ID";
		case 32:"Autonomous system number";
		default: FormatString("Undefined (%d)",value);
	}
}

Table RSVPRecordRouteObjectTypeTable( value )
{
	switch( value )
	{
		case  1:FormatString("IPv4 prefix, %d(0x%X)",value,value);
		case  2:FormatString("IPv6 prefix, %d(0x%X)",value,value);
		case  3:FormatString("Label, %d(0x%X)",value,value);
		default:FormatString("Undefined, %d(0x%X)",value,value);
	}
}

// [RFC 2745    Page 10    3.6.  DIAG_RESPONSE Object]
Table RSVPObj0X32ErrorTable( value )
{
	switch( value )
	{
		case  0:FormatString("No error, %d(0x%X)",value,value);
		case  1:FormatString("No PATH state, %d(0x%X)",value,value);
		case  2:FormatString("Packet too big, %d(0x%X)",value,value);
		case  4:FormatString("ROUTE object too big, %d(0x%X)",value,value);
		default:FormatString("Undefined, %d(0x%X)",value,value);
	}
}

// [RFC 3477    Page 2    3.1. LSP_TUNNEL_INTERFACE_ID Object]
Table  RSVPObj0X227SCTable( value )
{
	switch( value )
	{
		case  0:FormatString("Unspecified Bit Rate, %d(0x%X)",value,value);
		case  1:FormatString("Variable Bit Rate, Non-Real Time, %d(0x%X)",value,value);
		case  2:FormatString("Variable Bit Rate, Real Time, %d(0x%X)",value,value);
		case  3:FormatString("Constant Bit Rate, %d(0x%X)",value,value);
		default:FormatString("Reserved, %d(0x%X)",value,value);
	}
}

Table  RSVPCallIDTypeTable(value)
{
	switch( value )
	{
		case   1:FormatString("Ipv4Address, %d(0x%X)",value,value);
		case   2:FormatString("Ipv6Address, %d(0x%X)",value,value);
		case   3:FormatString("ATMAddress, %d(0x%X)",value,value);
		case   4:FormatString("MacAddress, %d(0x%X)",value,value);
		case 127:FormatString("Vender defined, %d(0x%X)",value,value);
		default :FormatString("Undefined, %d(0x%X)",value,value);
	}
}
Table  RSVPDLCILengthTable(value1,value2)
{
	switch
	{
		case (value1 & 0x01)==0 && (value2 & 0x80)==0:"10 bits";
		case (value1 & 0x01)==1 && (value2 & 0x80)==0:"23 bits";
		default:"0 bits";
	}
}

Table RSVPStyleTable(SharingCtrl,SenderSelCtrl)
{
	switch
	{
		case (SharingCtrl == 2) && (SenderSelCtrl == 1):"WildCard Filter";
		case (SharingCtrl == 1) && (SenderSelCtrl == 2):"Fixed Filter";
		case (SharingCtrl == 2) && (SenderSelCtrl == 2):"Sharing-Explicit";
		default:"Unknown";
	}
}
struct ParamHeader = FormatString("ID: %d, Length: %d",ParameterID,ParameterLen)
{
	[ParamID]
	UINT8 ParameterID = RSVPParamIDTable(this);
	UINT8 ParameterFlg
	{
		UINT8 Flag:1 = FormatString("    (%s) %s",this.ToBitString,this  ? "Parameter value is invalid"
							: "Parameter value is valid");
		UINT8 Reserved:7 = FormatString("(%s)",this.ToBitString);
	};
	[ParamLength]
	UINT16 ParameterLen = FormatString("%d words,not including header",this);
}

struct AdspecParams = FormatString("ID: %d, Length: %d",Property.ParamID,Property.ParamLength)
{
	ParamHeader Header;
	FLOAT ParamValue = FormatString("%e",this);
}

struct RSVPGuaranteedService = "Guaranteed Service Fragment"
{
	UINT8 SvNumber = RSVPSvNumberTable(this);
	UINT8 Break
	{
		UINT8 Break:1 = FormatString("   (%s) %s",this.ToBitString,this ? "Break is set"
							: "Break is not set");
		UINT8 Reserved:7 = FormatString("(%s)",this.ToBitString);
	};
	UINT16 SvLength = FormatString("%d words,not including header",this);
	ParamHeader CTOTHeader;
	UINT32 ComposedCTOT[Property.ParamLength];
	ParamHeader DTOTHeader;
	UINT32 ComposedDTOT[Property.ParamLength];
	ParamHeader CSUMHeader;
	UINT32 ComposedCSUM[Property.ParamLength];
	ParamHeader DSUM;
	UINT32 ComposedDSUM[Property.ParamLength];
}

struct RSVPControlledLoadService = "Controlled-Load Service Fragment"
{
	UINT8 SvNumber = RSVPSvNumberTable(this);
	UINT8 Break
	{
		UINT8 Break:1 = FormatString("   (%s) %s",this.ToBitString,this ? "Break is set"
							 : "Break is not set");
		UINT8 Reserved:7 = FormatString("(%s)",this.ToBitString);
	};
	UINT16 SvLength = FormatString("%d words,not including header",this);
	[RSVPoffset = Offset]
	while cond[Property.RSVPoffset + SvLength > Offset]
	{
		AdspecParams Param;
	}
}

struct RSVPGeneralParameters = "Default general parameters fragment"
{
	UINT8 SvNumber = RSVPSvNumberTable(this);
	UINT8 Break
	{
		UINT8 Break:1 = FormatString("   (%s) %s",this.ToBitString,this ? "Break is set"
							 : "Break is not set");
		UINT8 Reserved:7 = FormatString("(%s)",this.ToBitString);
	};
	UINT16 SvLength = FormatString("%d words,not including header",this);
	ParamHeader HopHeader;
	UINT32 HopCount[Property.ParamLength];
	ParamHeader PathHeader;
	Float PathBWstuff[Property.ParamLength] = FormatString( "%e", this );
	ParamHeader MinpathHeader;
	UINT32 Minpathlatency[Property.ParamLength];
	ParamHeader MTUHeader;
	UINT32 ComposedMTU[Property.ParamLength];
}

struct RSVPTLV
{
	UINT16 Type = FormatString("%s, %d(0x%X)",RSVPTLVTypeTable(this),this,this);
	UINT16 Length;
	switch
	{
		case Type == 1 && Length == 8:  Ipv4Address Ip4Add;
		case Type == 2 && Length == 20: Ipv6Address Ip6Add;
		case (Type == 3 || Type == 4 || Type == 5) && Length == 12 :
			_struct TLV
			{
				Ipv4Address Ipv4Add;
				UINT32 InterfaceID;
			};
	}
}

// [RFC 2961    Page 18    5.1. MESSAGE_ID LIST, SRC_LIST and MCAST_LIST Objects]
struct  IPv4SrcMsgIDTuple
{
	UINT32  MessageID;
	IPv4Address  SrcIPv4Addr;
}

// [RFC 2961    Page 19    5.1. MESSAGE_ID LIST, SRC_LIST and MCAST_LIST Objects]
struct  IPv6SrcMsgIDTuple
{
	UINT32  MessageID;
	IPv6Address  SrcIPv6Addr;
}

// [RFC 2961    Page 20    5.1. MESSAGE_ID LIST, SRC_LIST and MCAST_LIST Objects]
struct  IPv4MulticastMsgIDTuple
{
	UINT32  MessageID;
	IPv4Address  SrcIPv4Addr;
	IPv4Address  DstIPv4Addr;
}

// [RFC 2961    Page 21    5.1. MESSAGE_ID LIST, SRC_LIST and MCAST_LIST Objects]
struct  IPv6MulticastMsgIDTuple
{
	UINT32  MessageID;
	IPv6Address  SrcIPv6Addr;
	IPv6Address  DstIPv6Addr;
}


struct RSVPSessionObject = FormatString("%s%s%s%s%s%s",
										ClassType.Type.ToString,
										Property.SessionDstAddr ? "," + Property.SessionDstAddr : "",
										Property.SessionProtocolID ? "," +  Property.SessionProtocolID : "",
										Property.SessionDstPort ? "," +  Property.SessionDstPort : "",
										Property.SessionTunnelID ? "," +  Property.SessionTunnelID : "",
										Property.ExtendSessionTunnelID ? "," +  Property.ExtendSessionTunnelID : ""
										)
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16  Length;
	UINT16  ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8  Class = RSVPClassTable( this );
		UINT8  Type  = RSVPTypeTable(Class, this);
	};
	switch(ClassType.Type)
	{
		case 1:
		case 3:
			_struct IPv4GPISession
			{
				[SessionDstAddr = " Destination " + this.ToString]
				IPv4Address  DestAddress;
				[SessionProtocolID = " Protocol ID " + FormatString("%u",this)]
				UINT8  ProtocolID;
				UINT8  Flags
				{
					UINT8 Reserved1:2 = FormatString("    (%s)",this.ToBitString);
					UINT8 RouterUnable:1 = FormatString(" (%s) %s",this.ToBitString,this  ? "Unable to detect non-RSVP router"
										 : "No non-RSVP router detected");
					UINT8 NonRSVPRouter:1 = FormatString("(%s) %s",this.ToBitString,this  ? "Non-RSVP router detected"
										 : "No non-RSVP router detected");
					UINT8 Reserved:3 = FormatString("     (%s)",this.ToBitString);
					UINT8 Flag:1 = FormatString("         (%s) %s",this.ToBitString,this  ? "E_Police flag set"
										 : "E_Police flag not set");
				};
				[SessionDstPort = " Port " + FormatString("%u",this)]
				UINT16  DstPort;
			};
		case 2:
		case 4:
			_struct IPv6GPISession
			{
				[SessionDstAddr = " Destination " + this.ToString]
				IPv6Address  DestAddress;
				[SessionProtocolID = " Protocol ID " + FormatString("%u",this)]
				UINT8  ProtocolID;
				UINT8  Flags
				{
					UINT8 Reserved1:2 = FormatString("    (%s)",this.ToBitString);
					UINT8 RouterUnable:1 = FormatString(" (%s) %s",this.ToBitString,this  ? "Unable to detect non-RSVP router"
										 : "No non-RSVP router detected");
					UINT8 NonRSVPRouter:1 = FormatString("(%s) %s",this.ToBitString,this  ? "Non-RSVP router detected"
										 : "No non-RSVP router detected");
					UINT8 Reserved:3 = FormatString("     (%s)",this.ToBitString);
					UINT8 Flag:1 = FormatString("         (%s) %s",this.ToBitString,this  ? "E_Police flag set"
										 : "E_Police flag not set");
				};
				[SessionDstPort = " Port " + FormatString("%u",this)]
				UINT16  DstPort;
			};
		case 7:
			_struct LSPTunnelIPv4Session
			{
				[SessionDstAddr = " Destination " + this.ToString]
				Ipv4Address TunnelEndPointAddress;
				UINT16 Reserved;
				[SessionTunnelID = " Tunnel ID " + FormatString("0x%X",this)]
				UINT16 TunnelID;
				[ExtendSessionTunnelID = " Ext ID " + FormatString("0x%X",this)]
				UINT32 ExtendTunnelID;
			};
		case 8:
			_struct LSPTunnelIPv6Session
			{
				[SessionDstAddr = " Destination " + this.ToString]
				Ipv6Address TunnelEndPointAddress;
				UINT16 Reserved;
				[SessionTunnelID = " Tunnel ID " + FormatString("0x%X",this)]
				UINT16 TunnelID;
				[ExtendSessionTunnelID = " Ext ID " + this.ToString]
				Ipv6Address ExtendTunnelID;
			};
		case 9:
			_struct RSVPAggregateIPv4Session
			{
				[SessionDstAddr = " Destination " + this.ToString]
				Ipv4Address SessionAddress;
				UINT8 Reserved1;
				UINT8 Flags
				{
					UINT8 Reserved3:2 = FormatString("    (%s)",this.ToBitString);
					UINT8 RouterUnable:1 = FormatString(" (%s) %s",this.ToBitString,this  ? "Unable to detect non-RSVP router"
										 : "No non-RSVP router detected");
					UINT8 NonRSVPRouter:1 = FormatString("(%s) %s",this.ToBitString,this  ? "Non-RSVP router detected"
										 : "No non-RSVP router detected");
					UINT8 Reserved:3 = FormatString("     (%s)",this.ToBitString);
					UINT8 Flag:1 = FormatString("         (%s) %s",this.ToBitString,this  ? "E_Police flag set"
										 : "E_Police flag not set");
				};
				UINT8 Reserved2;
				UINT8 DSCP;
			};
		case 10:
			_struct RSVPAggregateIPv6Session
			{
				[SessionDstAddr = " Destination " + this.ToString]
				Ipv6Address SessionAddress;
				UINT8 Reserved1;
				UINT8 Flags
				{
					UINT8 Reserved3:2 = FormatString("    (%s)",this.ToBitString);
					UINT8 RouterUnable:1 = FormatString(" (%s) %s",this.ToBitString,this  ? "Unable to detect non-RSVP router"
										 : "No non-RSVP router detected");
					UINT8 NonRSVPRouter:1 = FormatString("(%s) %s",this.ToBitString,this ? "Non-RSVP router detected"
										: "No non-RSVP router detected");
					UINT8 Reserved:3 = FormatString("     (%s)",this.ToBitString);
					UINT8 Flag:1 = FormatString("         (%s) %s",this.ToBitString,this ? "E_Police flag set"
										: "E_Police flag not set");
				};
				UINT8 Reserved2;
				UINT8 DSCP;
			};
		case 11:
		case 15:
			_struct UNIOrENNIIPv4Session
			{
				[SessionDstAddr = " Destination " + this.ToString]
				Ipv4Address DestAddress;
				UINT16 Reserved;
				[SessionTunnelID = " Tunnel ID " + FormatString("0x%X",this)]
				UINT16 TunnelID;
				[ExtendSessionTunnelID = " Ext ID " + FormatString("0x%X",this)]
				UINT32 ExtendedTunnelID;
			};
		case 12:
		case 16:
			_struct UNIOrENNIIPv6Session
			{
				[SessionDstAddr = " Destination " + this.ToString]
				Ipv6Address DestAddress;
				UINT16 Reserved;
				[SessionTunnelID = " Tunnel ID " + FormatString("0x%X",this)]
				UINT16 TunnelID;
				[ExtendSessionTunnelID = " Ext ID" + this.ToString]
				Ipv6Address ExtendedTunnelID;
			};
		default:
			switch
			{
				case offset < Property.ObjEndOffset:
					AsciiString(Property.ObjEndOffset - offset) UnknownSessionObject;
			}
	}
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset - offset) LeftSessionData;
	}
}


struct RSVPHopObject = FormatString("%s%s",
									ClassType.Type.ToString,
									Property.NeighborHopAddress ? "," + Property.NeighborHopAddress : ""
									)
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16  Length;
	UINT16  ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8  Class = RSVPClassTable( this );
		UINT8  Type  = RSVPTypeTable(Class,this);
	};
	switch(ClassType.Type)
	{
		case 1:
			_struct IPv4Hop
			{
				[NeighborHopAddress = " Next/Previous Hop " + this.ToString]
				IPv4Address NeighborHopAddress;
				UINT32 LogicalInterface;
			};
		case 2:
			_struct IPv6Hop
			{
				[NeighborHopAddress = " Next/Previous Hop " + this.ToString]
				IPv6Address NeighborHopAddress;
				UINT32 LogicalInterface;
			};
		case 3:
			_struct IPv4IFIDHop
			{
				[NeighborHopAddress = " Next/Previous Hop " + this.ToString]
				Ipv4Address NeighborHopAddress;
				UINT32 LogicalInterface;
				while option[ offset < Property.ObjEndOffset ]
				{
					RSVPTLV TLV;
				}
			};
		case 4:
			_struct IPv6IFIDHop
			{
				[NeighborHopAddress = " Next/Previous Hop " + this.ToString]
				Ipv6Address NeighborHopAddress;
				UINT32 LogicalInterface;
				while option[ offset < Property.ObjEndOffset ]
				{
					RSVPTLV TLV;
				}
			};
		default:
			switch
			{
				case offset < Property.ObjEndOffset:
					AsciiString(Property.ObjEndOffset - offset) UnknownHopObject;
			}
	}
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset - offset) LeftHopData;
	}
}

//RFC 2747
struct RSVPIntegrityObject = ClassType.Type.ToString
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	switch(ClassType.Type)
	{
		case 1:
			_struct Type1Integrity
			{
				UINT8 Flags
				{
					UINT8 H:1 = FormatString("       (%s) %s",this.ToBitString,this ? "Handshake Flag concerns the integrity handshake mechanism"
									 : "Reject integrity handshake messages");
					UINT8 Reserved:7 = FormatString("(%s)",this.ToBitString);
				};
				UINT8 Reseved;
				INT48 KeyIdentifier;
				INT64 SequenceNumber;
				switch
				{
					case offset < Property.ObjEndOffset:
						AsciiString( Property.ObjEndOffset - offset ) KeyedMessageDigest = FormatString("%d bytes INT32",Property.ObjEndOffset - offset);
				}
			};
		default:
			switch
			{
				case offset < Property.ObjEndOffset:
					AsciiString( Property.ObjEndOffset - offset ) UnknownIntegrityObject;
			}
	}
}

struct RSVPTimeObject = FormatString("Refresh Period %u ms", RefreshPeriod)
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type  = RSVPTypeTable(Class,this);
	};
	UINT32  RefreshPeriod = FormatString("%u(0x%X)",this,this);
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset - offset) LeftTimeData;
	}
}
struct RSVPErrorValue(ErrorCode)
{
	switch
	{
		case (UINT16(FrameData,Offset) & 0xC000) == 0:
		case (UINT16(FrameData,Offset) & 0xC000) == 0:
		case (UINT16(FrameData,Offset) & 0xF000) == 0:
			_struct ErrorValueWithSubCode
			{
				UINT16 SS:2 = FormatString("     (%s) %s",this.ToBitString,"Low order 12 bits contain a globally-defined sub-code");
				UINT16 U:1 = FormatString("      (%s) %s",this.ToBitString,this ? "RSVP may use message to update local state and forward the message"
								  : "RSVP rejects the message without updating local state");
				UINT16 R:1 = FormatString("      (%s) %s",this.ToBitString,"Reserved");
				UINT16 SubCode:12 = FormatString("(%s) %s",this.ToBitString,(ErrorCode == 1 || ErrorCode == 21) ? RSVPErrorCode1ErrorValueTable(ErrorCode,this)
																		: this);
			};
		default:
			_struct ErrorValueWithoutsSubCode
			{
				UINT16 SS:2 = FormatString(" (%s) %s",this.ToBitString,RSVPErrorCode1ErrorValueSSTable(this));
				UINT16 U:1 = FormatString("  (%s) %s",this.ToBitString,this ? "RSVP may use message to update local state and forward the message"
								  : "RSVP rejects the message without updating local state");
				UINT16 R:1 = FormatString("  (%s) %s",this.ToBitString,"Reserved");
				UINT16 BIT:12 = FormatString("(%s) %s",this.ToBitString,this);
			};
	}
}

struct RSVPErrorObject = FormatString("%s%s%s%s",
									  ClassType.Type.ToString,
									  Property.ErrAddr ? "," + Property.ErrAddr : "",
									  Property.ErrorCode ? "," + Property.ErrorCode : "",
									  Property.ErrorValue ? "," + Property.ErrorValue : ""
									 )
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	switch(ClassType.Type )
	{
		case 1:
		case 2:
			_struct IPv4OrIPv6ErrorSpec
			{
				
				switch(ClassType.Type)
				{
					case 1:
						[ErrAddr = " Error Node " + this.ToString]
						IPv4Address  IPv4ErrorNodeAddress;
					case 2:
						[ErrAddr = " Error Node " + this.ToString]
						IPv6Address  IPv6ErrorNodeAddress;
				};
				UINT8  Flags = FormatString("%s %s",
											Flags.Reservation ? "InPlace" : "",
											Flags.Requested ? "NotGuilty" : ""
										   )
				{
					UINT8 Reserved:6 = FormatString("   (%s)",this.ToBitString);
					UINT8 Requested:1 = FormatString("  (%s) %s",this.ToBitString,this ? "Failed FLOWSPEC was greater than requested FLOWSPEC"
											 : "No Error");
					UINT8 Reservation:1 = FormatString("(%s) %s",this.ToBitString,this ? "Reservation existent at point of failure"
											   : "No Error");
					
				};
				[ErrorCode = " Error code " + this.ToString]
				UINT8  ErrorCode = RSVPErrorCodeTable( this );
				[ErrorValue = " Error Value " + FormatString("%u",UINT16(FrameData,offset))]
				switch(ErrorCode)
				{
					
					case  1:
					case 12:
					case 21:
						RSVPErrorValue(ErrorCode) ErrorValue;
					default:
						_struct OtherError
						{
							UINT16  ErrorValue = RSVPPolicyErrorValueTable(ErrorCode,this);
						};
				}
			};
		case 3:
		case 4:
			_struct IPv4OrIPv6IFIDErrorSpec
			{
				
				switch(ClassType.Type)
				{
					case 3:
						[ErrAddr = " Error Node " + this.ToString]
						IPv4Address IPv4ErrorNodeAddress;
					case 4:
						[ErrAddr = " Error Node " + this.ToString]
						IPv6Address IPv6ErrorNodeAddress;
				};
				UINT8  Flags = FormatString("%s %s",
											Flags.Reservation ? "InPlace" : "",
											Flags.Requested ? "NotGuilty" : ""
											)
				{
					UINT8 Reserved:6 = FormatString("   (%s)",this.ToBitString);
					UINT8 Requested:1 = FormatString("  (%s) %s",this.ToBitString,this ? "Failed FLOWSPEC was greater than requested FLOWSPEC"
											 : "No Error");
					UINT8 Reservation:1 = FormatString("(%s) %s",this.ToBitString,this ? "Reservation existent at point of failure"
											   : "No Error");
				};
				[ErrorCode = " Error code " + this.ToString]
				UINT8 ErrorCode =  RSVPErrorCodeTable( this );
				[ErrorValue = " Error Value " + FormatString("%u",UINT16(FrameData,offset))]
				switch(ErrorCode)
				{
					case  1:
					case 12:
					case 21:
						RSVPErrorValue(ErrorCode) ErrorValue;
					default:
						_struct Error
						{
							UINT16  ErrorValue = RSVPPolicyErrorValueTable(ErrorCode,this);
						};
				}
				while option[ offset < Property.ObjEndOffset ]
				{
					RSVPTLV TLV;
				}
			};
		default:
			switch
			{
				case offset < Property.ObjEndOffset:
					AsciiString(Property.ObjEndOffset - offset) UnknownErrorObject;
			}
	}
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset - offset) LeftErrorData;
	}
}


struct RSVPScopeObject = ClassType.Type.ToString
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type  = RSVPTypeTable(Class,this);
	};
	switch(ClassType.Type)
	{
		case  1:IPv4Address  IPv4SrcAddress[ (Length-4)/4 ];
		case  2:IPv6Address  IPv6SrcAddress[ (Length-4)/16 ];
		default:
		switch
		{
			case offset < Property.ObjEndOffset:
				AsciiString(Property.ObjEndOffset - offset) UnknownScopeObject;
		}
	}
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset - offset) LeftScopeData;
	}
}

struct RSVPStyleObject = FormatString("%s: %s",ClassType.Type.ToString,RSVPStyleTable(SharingCtrl,SenderCtrl))
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type  = RSVPTypeTable(Class,this);
	};
	switch(ClassType.Type)
	{
		case 1:
			_struct Type1Style
			{
				UINT8  Flags;
				UINT24  OptionVector = FormatString("Style = %s",RSVPStyleTable(SharingCtrl,SenderCtrl))
				{
					UINT24 Reserved:19 = FormatString("        (%s)",this.ToBitString);
					[SharingCtrl]
					UINT24 SharingControl:2 = FormatString("  (%s) %s",this.ToBitString,RSVP0X0801Table2( this ));
					[SenderCtrl]
					UINT24 SenderSelControl:3 = FormatString("(%s) %s",this.ToBitString,RSVP0X0801Table1( this ));
				};
			};
		default:
			switch
			{
				case offset < Property.ObjEndOffset:
					AsciiString(Property.ObjEndOffset - offset) UnknownStyleObject;
			}
	}
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset - offset) LeftStyleData;
	}
}


struct RSVPFlowSpecObject = ClassType.Type.ToString
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type  = RSVPTypeTable(Class,this);
	};
	switch(ClassType.Type)
	{
		case 2:
			_struct IntegratedServiceFlowSpec
			{
				struct MainHeader  = FormatString("Version is %d, Length is %d",Property.Ver,Length)
				{
					UINT16 Version
					{
						[Ver]
						UINT16 Version:4 = FormatString(" (%s) %d",this.ToBitString,this);
						UINT16 Reserved:12 = FormatString("(%s)",this.ToBitString);
					};
					UINT16 Length;
				};
				while condition[ offset < Property.ObjEndOffset ]
				{
					struct ServiceElementHeader = FormatString("%s, Service Length %d ",RSVPSvNumberTable(ServiceNumber),ServiceLength)
					{
						UINT8 ServiceNumber = RSVPSvNumberTable(this);
						UINT8 Reserved;
						[ParamEndOffset = ( offset + this*4 + 2 ) < Property.ObjEndOffset ?  ( offset + this*4 + 2 ) : Property.ObjEndOffset]
						UINT16 ServiceLength = FormatString("%d words,not including header",this);
					};
					while cond[offset < Property.ParamEndOffset]
					{
						switch(UINT8( Framedata, Offset ))
						{
							case 127:
								struct TokenBucket
								{
									ParamHeader Header;
									Float TokenBucketRate = FormatString( "%e", this );
									Float TokenBucketSize = FormatString( "%e", this );
									Float PeakDataRate = FormatString( "%e", this );
									UINT32 MinimumPolicedUnit;
									UINT32 MaximumPacketSize;
								};
							case 130:
								struct GuaranteedRate
								{
									ParamHeader Header;
									Float Rate = FormatString( "%e", this );
									UINT32 SlackTerm;
								};
							case 128:
								struct NullService
								{
									ParamHeader Header;
									UINT32 MaximumPacketSize;
								};
							default:
								_struct UnknownParameter
								{
									ParamHeader Header;
									AsciiString(Property.ParamLength * 4) UnknownParamData;
								};
						}
					};
				};
			};
		case 4:
			_struct SONETOrSDHFlowSpec
			{
				UINT8 SignalType = RSVPSignalTypeTable(this);
				UINT8 Reserved:7 = FormatString("(%s)",this.ToBitString);
				UINT8 RCC:1 = FormatString("     (%s) %s",this.ToBitString,this ? "Standard contiguous concatenation"
								   : "Not standard contiguous concatenation");
				UINT16 NCC;
				UINT16 NVC;
				UINT16 MT;
			 /* UINT32 Transparency
				{
					UINT32 E1:1 = FormatString("(%s) %s",this.ToBitString,this ? "E1 transparency"
										  : "No E1 transparency");
					UINT32 K1OrK2:1 = FormatString("(%s) %s",this.ToBitString,this ? "K1/K2 transparency"
										  : "No K1/K2 transparency");
					UINT32 LOHOrMSOH:1 = FormatString("(%s) %s",this.ToBitString,this ? "LOH/MSOH Extended DCC transparency"
										  : "No LOH/MSOH Extended DCC transparency");
					UINT32 LOHOrMSOHDCC:1 = FormatString("(%s) %s",this.ToBitString,this ? "LOH/MSOH DCC transparency"
										  : "No LOH/MSOH DCC transparency");
					UINT32 SOHOrRSOHDCC:1 = FormatString("(%s) %s",this.ToBitString,this ? "SOH/RSOH DCC transparency"
										  : "No SOH/RSOH DCC transparency");
					UINT32 J0:1 = FormatString("(%s) %s",this.ToBitString,this ? "J0 transparency"
										  : "No J0 transparency");
					UINT32 LineOrMultiplex:1 = FormatString("(%s) %s",this.ToBitString,this ? "Line/Multiplex Section layer transparency"
										  : "No Line/Multiplex Section layer transparency");
					UINT32 SectionOrRegenerator:1 = FormatString("(%s) %s",this.ToBitString,this ? "Section/Regenerator Section layer transparency"
										  : "No Section/Regenerator Section layer transparency");
					UINT32 Reserved1:2 = FormatString("(%s)",this.ToBitString);
					UINT32 M1:1 = FormatString("(%s) %s",this.ToBitString,this ? "M1 transparency"
										  : "No M1 transparency");
					UINT32 M0:1 = FormatString("(%s) %s",this.ToBitString,this ? "M0 transparency"
										  : "No M0 transparency");
					UINT32 B2:1 = FormatString("(%s) %s",this.ToBitString,this ? "B2 transparency"
										  : "No B2 transparency");
					UINT32 B1:1 = FormatString("(%s) %s",this.ToBitString,this ? "B1 transparency"
										  : "No B1 transparency");
					UINT32 E2:1 = FormatString("(%s) %s",this.ToBitString,this ? "E2 transparency"
										  : "No E2 transparency");
					UINT32 F1:1 = FormatString("(%s) %s",this.ToBitString,this ? "F1 transparency"
										  : "No F1 transparency");
					UINT32 Reserved2:16 = FormatString("(%s)",this.ToBitString);
				};*/
				UINT32 Transparency
				{
					UINT32 Reserved:30 = FormatString("            (%s)",this.ToBitString);
					UINT32 LineOrMultiplex:1 = FormatString("     (%s) %s",this.ToBitString,this ? "Line/Multiplex Section layer transparency"
										 : "No Line/Multiplex Section layer transparency");
					UINT32 SectionOrRegenerator:1 = FormatString("(%s) %s",this.ToBitString,this ? "Section/Regenerator Section layer transparency"
										 : "No Section/Regenerator Section layer transparency");
				};
				UINT32 Profile;
			};
		default:
			switch
			{
				case offset < Property.ObjEndOffset:
					AsciiString(Property.ObjEndOffset - offset) UnknownFlowSpecObject;
			}
	}
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset - offset) LeftFlowSpecData;
	}
}

struct RSVPFilterSpecObject = FormatString("%s%s%s%s%s",
											ClassType.Type.ToString,
											Property.FilterSrcAddr ? "," + Property.FilterSrcAddr : "",
											Property.FilterSrcPort ? "," + Property.FilterSrcPort : "",
											Property.FilterGPI ? "," + Property.FilterGPI : "",
											Property.FilterLSPID ? "," + Property.FilterLSPID : ""
											)
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	switch(ClassType.Type)
	{
		case 1:
			_struct IPv4FilterSpec
			{
				[FilterSrcAddr = " SrcAddress " + this.ToString]
				IPv4Address SrcAddress;
				UINT16  Reserved;
				[FilterSrcPort = " SrcPort " + FormatString("%u",this)]
				UINT16  SrcPort;
			};
		case 2:
			_struct IPv6FilterSpec
			{
				[FilterSrcAddr = " SrcAddress " + this.ToString]
				IPv6Address SrcAddress;
				UINT16  Reserved;
				[FilterSrcPort = " SrcPort " + FormatString("%u",this)]
				UINT16  SrcPort;
			};
		case 3:
			_struct IPv6FlowLabelFilterSpec
			{
				[FilterSrcAddr = " SrcAddress " + this.ToString]
				IPv6Address SrcAddress;
				UINT8  Reserved;
				UINT24 FlowLabel;
			};
		case 4:
			_struct IPv4GPIFilterSpec
			{
				[FilterSrcAddr = " SrcAddress " + this.ToString]
				IPv4Address SrcAddress;
				[FilterGPI = " GPI " + FormatString("%u",this)]
				UINT32  GPI;
			};
		case 5:
			_struct IPv6GPIFilterSpec
			{
				[FilterSrcAddr = " SrcAddress " + this.ToString]
				IPv6Address SrcAddress;
				[FilterGPI = " GPI " + FormatString("%u",this)]
				UINT32  GPI;
			};
		case 7:
			_struct LSPTunnelIPv4FilterSpec
			{
				[FilterSrcAddr = " SrcAddress " + this.ToString]
				Ipv4Address TunnelSenderAddress;
				UINT16 Reserved;
				[FilterLSPID = " LSP ID " + FormatString("%u",this)]
				UINT16 LSPID;
			};
		case 8:
			_struct LSPTunnelIPv6FilterSpec
			{
				[FilterSrcAddr = " SrcAddress " + this.ToString]
				Ipv6Address TunnelSenderAddress;
				UINT16 Reserved;
				[FilterLSPID = " LSP ID " + FormatString("%u",this)]
				UINT16 LSPID;
			};
		case 9:
			_struct RSVPAggregateIPv4FilterSpec
			{
				[FilterSrcAddr = " SrcAddress " + this.ToString]
				Ipv4Address IPv4AggregatorAddress;
			};
		case 10:
			_struct RSVPAggregateIPv6FilterSpec
			{
				[FilterSrcAddr = " SrcAddress " + this.ToString]
				Ipv6Address IPv6AggregatorAddress;
			}
		default:
			switch
			{
				case offset < Property.ObjEndOffset: AsciiString(Property.ObjEndOffset - offset) UnknownFilterSpecObject;
			}
	}
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset - offset) LeftFilterSpecData;
	}
}


struct RSVPSenderTemplateObject = FormatString("%s%s%s%s%s",
												ClassType.Type.ToString,
												Property.FilterSrcAddr ? "," + Property.FilterSrcAddr : "",
												Property.FilterSrcPort ? "," + Property.FilterSrcPort : "",
												Property.FilterGPI ? "," + Property.FilterGPI : "",
												Property.FilterLSPID ? "," + Property.FilterLSPID : ""
												)
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	switch(ClassType.Type)
	{
		case 1:
			_struct IPv4SenderTemplate
			{
				[FilterSrcAddr = " SrcAddress " + this.ToString]
				IPv4Address SrcAddress;
				UINT16  Reserved;
				[FilterSrcPort = " SrcPort " + FormatString("%u",this)]
				UINT16  SrcPort;
			};
		case 2:
			_struct IPv6SenderTemplate
			{
				[FilterSrcAddr = " SrcAddress " + this.ToString]
				IPv6Address SrcAddress;
				UINT16  Reserved;
				[FilterSrcPort = " SrcPort " + FormatString("%u",this)]
				UINT16  SrcPort;
			};
		case 3:
			_struct IPv6FlowLabel
			{
				[FilterSrcAddr = " SrcAddress " + this.ToString]
				IPv6Address SrcAddress;
				UINT8  Reserved;
				UINT24 FlowLabel;
			};
		case 4:
			_struct IPv4GPISenderTemplate
			{
				[FilterSrcAddr = " SrcAddress " + this.ToString]
				IPv4Address SrcAddress;
				[FilterGPI = " GPI " + FormatString("%u",this)]
				UINT32  GPI;
			};
		case 5:
			_struct IPv6GPISenderTemplate
			{
				[FilterSrcAddr = " SrcAddress " + this.ToString]
				IPv6Address SrcAddress;
				[FilterGPI = " GPI " + FormatString("%u",this)]
				UINT32  GPI;
			};
		case 7:
			_struct LSPTunnelIPv4SenderTemplate
			{
				[FilterSrcAddr = " SrcAddress " + this.ToString]
				Ipv4Address TunnelSenderAddress;
				UINT16 Reserved;
				[FilterLSPID = " LSP ID " + FormatString("%u",this)]
				UINT16 LSPID;
			};
		case 8:
			_struct LSPTunnelIPv6SenderTemplate
			{
				[FilterSrcAddr = " SrcAddress " + this.ToString]
				Ipv6Address TunnelSenderAddress;
				UINT16 Reserved;
				[FilterLSPID = " LSP ID " + FormatString("%u",this)]
				UINT16 LSPID;
			};
		case 9:
			_struct RSVPAggregateIPv4SenderTemplate
			{
				[FilterSrcAddr = " SrcAddress " + this.ToString]
				Ipv4Address IPv4AggregatorAddress;
			};
		case 10:
			_struct RSVPAggregateIPv6SenderTemplate
			{
				[FilterSrcAddr = " SrcAddress " + this.ToString]
				Ipv6Address IPv6AggregatorAddress;
			};
		default:
			switch
			{
				case offset < Property.ObjEndOffset:
					AsciiString(Property.ObjEndOffset - offset) UnknownFilterSpecObject;
			}
	}
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset - offset) LeftFilterSpecData;
	}
}


struct RSVPSenderTspecObject = ClassType.Type.ToString
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	switch(ClassType.Type)
	{
		case 2:
			_struct IntegratedServiceSenderTSpec
			{
				struct MailHeader  = FormatString("Version is %d, Length is %d",Property.Ver,Length)
				{
					UINT16 Version
					{
						[Ver]
						UINT16 Version:4   = FormatString(" (%s) %d",this.ToBitString,this);
						UINT16 Reserved:12 = FormatString("(%s)",this.ToBitString);
					};
					UINT16 Length = FormatString("%d words,not including header",this);
				};
				while condition[offset < Property.ObjEndOffset]
				{
					struct ServiceElementHeader = FormatString("%s,Service Length is %d ",
																RSVPSvNumberTable(ServiceNumber),
																ServiceLength
																)
					{
						UINT8 ServiceNumber = RSVPSvNumberTable(this);
						UINT8 Reserved;
						[ParamEndOffset = ( offset + this*4 + 2) < Property.ObjEndOffset ? ( offset + this*4 + 2 ) : Property.ObjEndOffset]
						UINT16 ServiceLength = FormatString("%d words,not including header",this);
					};
					while cond[offset < Property.ParamEndOffset]
					{
						switch(UINT8( Framedata, Offset ))
						{
							case 127:
								struct TokenBucket
								{
									ParamHeader Header;
									Float TokenBucketRate = FormatString( "%e", this );
									Float TokenBucketSize = FormatString( "%e", this );
									Float PeakDataRate = FormatString( "%e", this );
									UINT32 MinimumPolicedUnit;
									UINT32 MaximumPacketSize;
								};
							case 128:
								struct NullService
								{
									ParamHeader Header;
									UINT32 MaximumPacketSize;
								};
							case 126:
								// rfc 3006
								struct CompressionHint
								{
									ParamHeader Header;
									UINT32 Hint;
									UINT32 CopressionFactor;
								};
							default:
								_struct UnknownParameter
								{
									ParamHeader Header;
									AsciiString(Property.ParamLength * 4) UnknownParamData;
								};
						}
					};
				};
			};
		case 4:
			_struct SONETOrSDHSenderTSpec
			{
				UINT8 SignalType = RSVPSignalTypeTable(this);
				UINT8 Reserved:7 = FormatString("(%s)",this.ToBitString);
				UINT8 RCC:1 = FormatString("     (%s) %s",this.ToBitString,this ? "Standard contiguous concatenation"
								   : "Not standard contiguous concatenation");
				UINT16 NCC;
				UINT16 NVC;
				UINT16 MT;
				UINT32 Transparency
				{
					UINT32 Reserved:30 = FormatString("            (%s)",this.ToBitString);
					UINT32 LineOrMultiplex:1 = FormatString("     (%s) %s",this.ToBitString,this ? "Line/Multiplex Section layer transparency"
										 : "No Line/Multiplex Section layer transparency");
					UINT32 SectionOrRegenerator:1 = FormatString("(%s) %s",this.ToBitString,this ? "Section/Regenerator Section layer transparency"
										 : "No Section/Regenerator Section layer transparency");
				};
				UINT32 Profile;
			};
		default:
			switch
			{
				case offset < Property.ObjEndOffset:
					AsciiString(Property.ObjEndOffset - offset) UnknownSenderTspecObject;
			}
	}
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset - offset) LeftSenderTspecObject;
	}
}

struct RSVPADSPECObject = ClassType.Type.ToString
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	struct Header = FormatString("Version: %d, Length: %d", Version, MsgLength)
	{
		UINT16 Version:4 = FormatString(" (%s) %d",this.ToBitString,this);
		UINT16 Reserved:12 = FormatString("(%s)",this.ToBitString);
		UINT16 MsgLength;
	};
	RSVPGeneralParameters GeneralParam;
	switch
	{
		case (offset < Property.ObjEndOffset) && (UINT8( Framedata, Offset ) == 2):
			RSVPGuaranteedService GuarantSv;
	}
	switch
	{
		case (offset < Property.ObjEndOffset) && (UINT8( Framedata, Offset ) == 5):
			RSVPControlledLoadService ControlSv;
	}
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset - offset) LeftADSPECData;
	}
}


struct RSVPPolicyObject = ClassType.Type.ToString
{
	[RolicyEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	switch(ClassType.Type)
	{
		case 1:
			_struct Type1PolicyData
			{
				UINT16  DataOffset;
				UINT16  Reserved;
				while condition[ UINT8( Framedata, Offset + 2 ) == 3 || UINT8( Framedata, Offset + 2 ) == 4 || UINT8( Framedata, Offset + 2 ) == 5 || UINT8( Framedata, Offset + 2 ) == 10 ]
				{
					switch
					{
						case UINT8( Framedata, Offset + 2 ) == 10:RSVPFilterSpecObject FilterSpecObject;
						case UINT8( Framedata, Offset + 2 ) ==  3:RSVPHopObject HopObject;
						case UINT8( Framedata, Offset + 2 ) ==  4:RSVPIntegrityObject IntegrityObject;
						case UINT8( Framedata, Offset + 2 ) ==  5:RSVPTimeObject TimeObject;
					}
				}
				while option[offset < Property.RolicyEndOffset]
				{
					//policy element list
					_struct PolicyElementList
					{
						[ElementEndOffset = offset + this]
						UINT16 ElementListLen;
						UINT16 PType = FormatString("%s, %d(0x%X)",RSVPRolicyElementTable(this),this,this);
						while option[offset < Property.ElementEndOffset]
						{
							//policy element,the source below is according to netmon2
							_struct PolicyElementList
							{
								[ElementLength = (this%4) != 0?(this/4+1)*4:this]
								UINT16 ElementLen;
								UINT16 AType;
								switch( AType )
								{
									case  1:UINT32 Value;
									default:AsciiString(Property.ElementLength) ValueAscii;
								}
							};
						}
					};
				}
			};
		default:
			switch
			{
				case offset < Property.RolicyEndOffset:
					AsciiString(Property.RolicyEndOffset - offset) UnknownPolicyObject;
			}
	}
	switch
	{
		case offset < Property.RolicyEndOffset:
			AsciiString(Property.RolicyEndOffset - offset) LeftPolicyData;
	}
}


struct RSVPResvConfirmObject = ClassType.Type.ToString
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type  = RSVPTypeTable(Class,this);
	};
	switch(ClassType.Type)
	{
		case  1:IPv4Address IPv4ReceiverAddress;
		case  2:IPv6Address IPv6ReceiverAddress;
		default:
			switch
			{
				case offset < ObjEndOffset:
					AsciiString(Property.ObjEndOffset - offset) UnknownConfirmObject;
			}
	}
	switch
	{
		case offset < ObjEndOffset:
			AsciiString(Property.ObjEndOffset - offset) LeftConfirmData;
	}
}

//RFC 3473
struct RSVPLabelObject = FormatString("%s%s",
									  ClassType.Type.ToString,
									  RSVPLabelObjectSummary
									 )
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	switch(ClassType.Type)
	{
		case 1:
			[RSVPLabelObjectSummary = FormatString(", %u", this)]
			UINT32 TopLabel;
		case 2:
			[RSVPLabelObjectSummary = FormatString(", %u ...", this)]
			UINT32 GeneralizedLabel[(Property.ObjEndOffset - offset)/4];
		case 3://RFC 3471
			_struct WavebandSwitchingLabel
			{
				UINT32 WavebandID;
				UINT32 StartLabel;
				[RSVPLabelObjectSummary = FormatString("WavebandID: %u, Label: %u ~ %u", WavebandID, StartLabel, EndLabel)]
				UINT32 EndLabel;
			};
		default:
			switch
			{
				case offset < Property.ObjEndOffset:
					[RSVPLabelObjectSummary = ""]
					AsciiString(Property.ObjEndOffset - offset) UnknownLabelObject;
			}
	}
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset - offset) LeftLabelData;
	}
}


struct RSVPLabelRequestObject = FormatString("%s%s%s%s%s%s%s%s%s",
											ClassType.Type.ToString,
											Property.L3PID ? "," + Property.L3PID : "",
											Property.VPIVCI ? "," + Property.VPIVCI : "",
											Property.Merger ? "," + Property.Merger : "",
											Property.MinDLCI ? "," + Property.MinDLCI : "",
											Property.MaxDLCI ? "," + Property.MaxDLCI : "",
											Property.LSPEncoding ? "," + Property.LSPEncoding : "",
											Property.Switching ? "," + Property.Switching : "",
											Property.GPID ? "," + Property.GPID : ""
											)
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	switch(ClassType.Type)
	{
		case 1:
			_struct LabelRequestWithoutLabelRange
			{
				UINT16  Reserved;
				[L3PID = " L3PID " + this.ToString]
				UINT16  L3PID = ProtocolTable(this);
			};
		case 2:
			_struct LabelRequestWithATMLabelRange
			{
				UINT16  Reserved;
				[L3PID = " L3PID " + this.ToString]
				UINT16  L3PID = ProtocolTable(this);
				UINT16  MinVPI
				{
					[Merger = " Merge : " + this ? "can merge in the data plane" : "can not merge in the data plane"]
					UINT16  Merger:1 = FormatString("    (%s) %s",this.ToBitString,this ? "can merge in the data plane "
										 : "can not merge in the data plane");
					UINT16  Reserved:3 = FormatString("  (%s)",this.ToBitString);
					[VPIVCI = " VPI/VCI : Min : " + FormatString("%d/",this)]
					UINT16  MinimumVPI:12 = FormatString("(%s) %d",this.ToBitString,this);
				};
				[VPIVCI = Property.VPIVCI + FormatString("%d",this) + ","]
				UINT16  MinimumVCI;
				UINT16  MaxVPI
				{
					UINT16  Merger:1 =FormatString("    (%s) %s",this.ToBitString,this ? "can merge in the data plane "
										 : "can not merge in the data plane");
					UINT16  Reserved:3 = FormatString("  (%s)",this.ToBitString);
					[VPIVCI = Property.VPIVCI + " Max: " + FormatString("%d/",this)]
					UINT16  MaximumVPI:12 = FormatString("(%s) %d",this.ToBitString,this);
				};
				[VPIVCI = Property.VPIVCI + FormatString("%d",this)]
				UINT16  MaximumVCI;
			};
		case 3:
			_struct LabelRequestWithFrameRelay
			{
				UINT16  Reserved;
				[L3PID = " L3PID " + this.ToString]
				UINT16  L3PID = ProtocolTable(this);
				/*UINT8  Reserved1
				{
					UINT8  Reserved:6 = FormatString("(%s)",this.ToBitString)
					UINT8  DLI:2 = FormatString("(%s) %d",this.ToBitString,this);
				};
				[MinDLCI = " Min DLCI " + FormatString("%u",this)]
				UINT24  MinimumDLCI;
				UINT8  Reserved2;
				[MaxDLCI = " Max DLCI " + FormatString("%u",this)]
				UINT24  MaximumDLCI;*/
				UINT8 DLCILength = RSVPDLCILengthTable(this,UINT8( Framedata, Offset + 1 ));
				Switch(DLCILength.ToString)
				{
					case "10 bits":
						_struct TenBitsDLCI
						{
							[MinDLCI = " Min DLCI " + FormatString("%u",this & 0x3FF)]
							UINT24  MinimumDLCI = FormatString("%u(0x%X)",this & 0x3FF,this & 0x3FF);
							UINT8 Reserved;
							[MaxDLCI = " Max DLCI " + FormatString("%u",this & 0x3FF)]
							UINT24  MaximumDLCI = FormatString("%u(0x%X)",this & 0x3FF,this & 0x3FF);
						}
					case "23 bits":
						_struct TwentythreeDLCI
						{
							[MinDLCI = " Min DLCI " + FormatString("%u",this & 0x7FFFFF)]
							UINT24  MinimumDLCI = FormatString("%u(0x%X)",this & 0x7FFFFF,this & 0x7FFFFF);
							UINT8 Reserved;
							[MaxDLCI = " Max DLCI " + FormatString("%u",this & 0x7FFFFF)]
							UINT24  MaximumDLCI = FormatString("%u(0x%X)",this & 0x7FFFFF,this & 0x7FFFFF);
						}
					default:
						_struct UnknownDLCI
						{
							[MinDLCI = " Min DLCI 0"]
							UINT24  MinimumDLCI = "0(0x0)";
							UINT8 Reserved;
							[MaxDLCI = " Max DLCI 0"]
							UINT24  MaximumDLCI = "0(0x0)";
						}
				}
			};
		case 4:
			_struct GeneralizedLabelRequest
			{
				[LSPEncoding = " LSP Encoding " + this.ToString]
				UINT8 LSPEncodingType = RSVPLspEncodingTable(this);
				[Switching = " Switching Type " + this.ToString]
				UINT8 SwitchingType = RSVPSwitchingTypeTable(this);
				[GPID = " G-PID " + this.ToString]
				UINT16 GPID = RSVPGPIDTable(this);
			};
		default:
			switch
			{
				case offset < Property.ObjEndOffset:
					AsciiString(Property.ObjEndOffset - offset) UnknownLabelRequestObject;
			}
	}
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset - offset) LeftLabelRequestData;
	}
}


struct RSVPExplicitRouteObject = Formatstring("%s", RSVPExplicitRouteSummary )
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	[RSVPExplicitRouteCnt = 0, RSVPExplicitRouteSummary = ""]
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	switch(ClassType.Type)
	{
		case 1:
			while condition[offset < Property.ObjEndOffset]
			{
				[RSVPExplicitRouteCnt = RSVPExplicitRouteCnt + 1]
				switch(UINT8( Framedata, Offset ) & 0x7F)
				{
					case 1:
						[
						 RSVPExplicitRouteSummary = RSVPExplicitRouteCnt == 1 ? this.ToString
												  : RSVPExplicitRouteCnt <= 3 ? RSVPExplicitRouteSummary + ", " +  this.ToString
												  : RSVPExplicitRouteCnt == 4 ? RSVPExplicitRouteSummary + " ..."
												  : RSVPExplicitRouteSummary
						]
						struct IPv4PrefixSubObject = Type.ToString + " " + Address.ToString
						{
							UINT8  Loose:1 = FormatString("(%s) %s",this.ToBitString,this ? "A loose hop"
												  : "A strict hop ");
							UINT8  Type:7 = FormatString(" (%s) %s",this.ToBitString,RSVPExplicitRouteObjectTypeTable( this ));
							[SubObjEndOffset = ( offset + this - 1 ) < Property.ObjEndOffset ? ( offset + this - 1 ) : Property.ObjEndOffset ]
							UINT8  Length;
							IPv4Address  Address;
							UINT8  PrefixLength;
							UINT8  Reserved;
						};
					case 2:
						[
						 RSVPExplicitRouteSummary = RSVPExplicitRouteCnt == 1 ? this.ToString
												  : RSVPExplicitRouteCnt <= 3 ? RSVPExplicitRouteSummary + ", " +  this.ToString
												  : RSVPExplicitRouteCnt == 4 ? RSVPExplicitRouteSummary + " ..."
												  : RSVPExplicitRouteSummary
						]
						struct IPv6PrefixSubObject = Type.ToString + " " + Address.ToString
						{
							UINT8  Loose:1 = FormatString("(%s) %s",this.ToBitString,this ? "A loose hop"
												  : "A strict hop ");
							UINT8  Type:7 = FormatString(" (%s) %s",this.ToBitString,RSVPExplicitRouteObjectTypeTable( this ));
							[SubObjEndOffset = ( offset + this - 1 ) < Property.ObjEndOffset ? ( offset + this - 1 ) : Property.ObjEndOffset ]
							UINT8  Length;
							IPv6Address  Address;
							UINT8  PrefixLength;
							UINT8  Reserved;
						};
					case 3:
						[
						 RSVPExplicitRouteSummary = RSVPExplicitRouteCnt == 1 ? this.ToString
												  : RSVPExplicitRouteCnt <= 3 ? RSVPExplicitRouteSummary + ", " +  this.ToString
												  : RSVPExplicitRouteCnt == 4 ? RSVPExplicitRouteSummary + " ..."
												  : RSVPExplicitRouteSummary
						]
						struct LabelSubObject = Type.ToString + " " + Label
						{
							UINT8  Loose:1 = FormatString("(%s) %s",this.ToBitString,this ? "A loose hop"
												 : "A strict hop ");
							UINT8  Type:7 = FormatString(" (%s) %s",this.ToBitString,RSVPExplicitRouteObjectTypeTable( this ));
							[SubObjEndOffset = ( offset + this - 1 ) < Property.ObjEndOffset ? ( offset + this - 1 ) : Property.ObjEndOffset ]
							UINT8 Length;
							UINT8 Reserved;
							UINT8 CType;
							UINT32 Label;
						};
					case 4:
						[
						 RSVPExplicitRouteSummary = RSVPExplicitRouteCnt == 1 ? this.ToString
												  : RSVPExplicitRouteCnt <= 3 ? RSVPExplicitRouteSummary + ", " +  this.ToString
												  : RSVPExplicitRouteCnt == 4 ? RSVPExplicitRouteSummary + " ..."
												  : RSVPExplicitRouteSummary
						]
						struct UnnumberedInterfaceIDSubObject = Type.ToString + " " + RouterID.ToString
						{
							UINT8  Loose:1 = FormatString("(%s) %s",this.ToBitString,this ? "A loose hop"
												  : "A strict hop ");
							UINT8  Type:7 = FormatString(" (%s) %s",this.ToBitString,RSVPExplicitRouteObjectTypeTable( this ));
							[SubObjEndOffset = ( offset + this - 1 ) < Property.ObjEndOffset ? ( offset + this - 1 ) : Property.ObjEndOffset ]
							UINT8 Length;
							UINT16 Reserved;
							Ipv4Address RouterID;
							UINT32 InterfaceID;
						};
					case 32:
						struct AutonomousSystem = Type.ToString + " " + AutonomousSystem
						{
							UINT8  Loose:1 = FormatString("(%s) %s",this.ToBitString,this ? "A loose hop"
												  : "A strict hop ");
							UINT8  Type:7 = FormatString(" (%s) %s",this.ToBitString,RSVPExplicitRouteObjectTypeTable( this ));
							[SubObjEndOffset = ( offset + this - 1 ) < Property.ObjEndOffset ? ( offset + this - 1 ) : Property.ObjEndOffset ]
							UINT8 Length;
							UINT16 AutonomousSystem;
						};
					default:
						struct UnknownSubObject
						{
							UINT8  Loose:1 = FormatString("(%s) %s",this.ToBitString,this ? "A loose hop"
												  : "A strict hop ");
							UINT8  Type:7 = FormatString(" (%s) %s",this.ToBitString,RSVPExplicitRouteObjectTypeTable( this ));
							[SubObjEndOffset = ( offset + this - 1 ) < Property.ObjEndOffset ? ( offset + this - 1 ) : Property.ObjEndOffset ]
							UINT8 Length;
							switch
							{
								case offset < Property.SubObjEndOffset:
									AsciiString(Property.SubObjEndOffset - offset) UnknownSubObject;
							}
						};
				}
				switch
				{
					case offset < Property.SubObjEndOffset:
						AsciiString(Property.SubObjEndOffset - offset) Padding = FormatString("%d bytes",Property.SubObjEndOffset - offset);
				}
			}
		default:
			switch
			{
				case offset < Property.ObjEndOffset:
					AsciiString(Property.ObjEndOffset - offset) UnknownExplicitRouteObject;
			}
	}
}


struct RSVPRouteRecordObject = ClassType.Type.ToString
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	switch(ClassType.Type)
	{
		case 1:
			while condition[offset < Property.ObjEndOffset]
			{
				switch(UINT8( Framedata, Offset ))
				{
					case 1:
						struct IPv4AddrSubObject
						{
							UINT8 Type = FormatString("IPv4 address, %d(0x%X)",this,this);
							[SubObjEndOffset = ( offset + this - 1 ) < Property.ObjEndOffset ? ( offset + this - 1 ) : Property.ObjEndOffset ]
							UINT8  Length;
							IPv4Address  Ipv4Addr;
							UINT8  PrefixLength;
							//UINT8  Flags = RSVPSubObjectFlagTable(this);
							UINT8  Flags
							{
								UINT8 Reserved:6 = FormatString("   (%s)",this.ToBitString);
								UINT8 LPInUse:1 = FormatString("    (%s) %s",this.ToBitString,this  ? "Local protection in use"
													 : "Local protection not in use");
								UINT8 LPAvailable:1 = FormatString("(%s) %s",this.ToBitString,this  ? "Local protection available"
													 : "Local protection not available");
							};
						};
					// [RFC 3209    Page 33    ]
					case 2:
						struct IPv6AddrSubObject
						{
							UINT8 Type = FormatString("IPv6 address, %d(0x%X)",this,this);
							[SubObjEndOffset = ( offset + this - 1 ) < Property.ObjEndOffset ? ( offset + this - 1 ) : Property.ObjEndOffset ]
							UINT8  Length;
							IPv6Address  Ipv6Addr;
							UINT8  PrefixLength;
							//UINT8  Flags = RSVPSubObjectFlagTable(this);
							UINT8  Flags
							{
								UINT8 Reserved:6 = FormatString("   (%s)",this.ToBitString);
								UINT8 LPInUse:1 = FormatString("    (%s) %s",this.ToBitString,this  ? "Local protection in use"
													 : "Local protection not in use");
								UINT8 LPAvailable:1 = FormatString("(%s) %s",this.ToBitString,this  ? "Local protection available"
													 : "Local protection not available");
							};
						};
					//rfc3209          page 34
					case 3:
						struct LabelSubObject
						{
							UINT8 Type = FormatString("Label, %d(0x%X)",this,this);
							[SubObjEndOffset = ( offset + this - 1 ) < Property.ObjEndOffset ? ( offset + this - 1 ) : Property.ObjEndOffset ]
							UINT8 Length;
							UINT8 Flags = (this == 1)?"Global label":FormatString("%d",this) ;
							UINT8 CType;
							UINT32 LabelObject;
						};
					//rfc3477   page5
					case 4:
						struct UnnumberedInterfaceIDSubObject
						{
							UINT8 Type = FormatString("Unnumbered interface ID, %d(0x%X)",this,this);
							[SubObjEndOffset = ( offset + this - 1 ) < Property.ObjEndOffset ? ( offset + this - 1 ) : Property.ObjEndOffset ]
							UINT8 Length;
							UINT8 Flags
							{
								UINT8 Reserved:6 = FormatString(" (%s)",this.ToBitString);
								UINT8 Mechanism:1 = FormatString("(%s) %s",this.ToBitString,this  ? "A local repair mechanism is in use to maintain this tunnel"
													 : "No local repair mechanism is in use to maintain this tunnel");
								UINT8 Downstram:1 = FormatString("(%s) %s",this.ToBitString,this  ? "The link downstream this node is protected via a local repair mechanism"
													 : "This link downstream this not is not protected");
							};
							UINT8 Reserved;
							IPv4Address RouterID;
							UINT32 InterfaceID;
						};
					default:
						_struct UnknownSubObject
						{
							UINT8 Type = FormatString("Undefined, %d(0x%X)",this,this);
							[SubObjEndOffset = ( offset + this - 1 ) < Property.ObjEndOffset ? ( offset + this - 1 ) : Property.ObjEndOffset ]
							UINT8 Length;
							switch
							{
								case offset < Property.SubObjEndOffset:
									AsciiString(Property.SubObjEndOffset - offset) UnknownSubObject;
							}
						};
				}
				switch
				{
					case offset < Property.SubObjEndOffset:
						AsciiString(Property.SubObjEndOffset - offset) Padding = FormatString("%d bytes",Property.SubObjEndOffset - offset);
				}
			};
		default:
			switch
			{
				case offset < Property.ObjEndOffset:
					AsciiString(Property.ObjEndOffset - offset) UnknownRouteRecordObject;
			}
	}
}

struct RSVPHelloObject = ClassType.Type.ToString
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	switch(ClassType.Type)
	{
		case  1:
		case  2:
			_struct HelloRequestOrACK
			{
				UINT32  SrcInstance;
				UINT32  DstInstance;
			};
		default:
			switch
			{
				case offset < Property.ObjEndOffset:
					AsciiString(Property.ObjEndOffset - offset) UnknownHelloObject;
			}
	}
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset - offset) HelloObjectPadding = FormatString("%d bytes",Property.ObjEndOffset - offset);
	}
}

struct RSVPMessageIDObject = ClassType.Type.ToString
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	switch(ClassType.Type)
	{
		case 1:
			_struct Type1MessageID
			{
				UINT8  Flags
				{
					UINT8 Reserved:7 = FormatString("(%s)",this.ToBitString);
					UINT8 Flag:1 = FormatString("    (%s) %s",this.ToBitString,this  ? "The sender requests the receiver to send an acknowledgment for the message"
										 : FormatString("%d",this));
				};
				UINT24  Epoch;
				UINT32  MessageID;
			};
		default:
			switch
			{
				case offset < Property.ObjEndOffset:
					AsciiString(Property.ObjEndOffset - offset) UnknownMessageIDObject;
			}
	}
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset - offset) MessageIDObjectPadding = FormatString("%d bytes",Property.ObjEndOffset - offset);
	}
}


struct RSVPMessageIDACKObject = ClassType.Type.ToString
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type  = RSVPTypeTable(Class,this);
	};
	switch(ClassType.Type)
	{
		case 1:
		case 2:
			_struct MessageIDACKOrNACK
			{
				UINT8   Flags;
				UINT24  Epoch;
				UINT32  MessageID;
			};
		default:
			switch
			{
				case offset < Property.ObjEndOffset:
					AsciiString(Property.ObjEndOffset - offset) UnknownMessageIDACKObject;
			}
	}
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset - offset) MessageIDACKObjectPadding = FormatString("%d bytes",Property.ObjEndOffset - offset);
	}
}

struct RSVPMessageIDListObject = ClassType.Type.ToString
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	switch(ClassType.Type)
	{
		case 1:
			_struct Type1MessageIDList
			{
				UINT8   Flags;
				UINT24  Epoch;
				UINT32  MessageID[ (Property.ObjEndOffset - offset)/4 ];
			};
		case 2:
			_struct IPv4MessageIDSrcList
			{
				UINT8   Flags;
				UINT24  Epoch;
				IPv4SrcMsgIDTuple  SrcMsgIDTuple[ (Property.ObjEndOffset - offset)/8 ];
			};
		case 3:
			_struct IPv6MessageIDSrcList
			{
				UINT8   Flags;
				UINT24  Epoch;
				IPv6SrcMsgIDTuple  SrcMsgIDTuple[ (Property.ObjEndOffset - offset)/20 ];
			};
		case 4:
			_struct IPv4MessageIDMulticaseList
			{
				UINT8   Flags;
				UINT24  Epoch;
				IPv4MulticastMsgIDTuple  MulticastMsgIDTuple[ (Property.ObjEndOffset - offset)/12 ];
			};
		case 5:
			_struct IPv6MessageIDMulticaseList
			{
				UINT8  Flags;
				UINT24  Epoch;
				IPv6MulticastMsgIDTuple  MulticastMsgIDTuple[ (Property.ObjEndOffset - offset)/36 ];
			};
		default:
			switch
			{
				case offset < Property.ObjEndOffset:
					AsciiString(Property.ObjEndOffset - offset) UnknownMessageIDListObject;
			}
	}
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset - offset) MessageIDListObjectPadding = FormatString("%d bytes",Property.ObjEndOffset - offset);
	}
}

struct RSVPDiagnosticObject = ClassType.Type.ToString
{
	[DiagnosticEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	switch(ClassType.Type)
	{
		case 1:
			_struct IPv4Diagnostic
			{
				UINT8 MaxRSVPhops;
				UINT8 RSVPhopcount;
				UINT16 MFFlg
				{
					UINT16 Reserved:15 = FormatString("(%s)",this.ToBitString);
					UINT16 MF:1 = FormatString("      (%s) %s",this.ToBitString,this ? "More fragments"
									   : "No more fragments");
				};
				UINT32 RequestID;
				UINT16 PathMTU;
				UINT16 FragmentOffset;
				Ipv4Address LastHopAddress;
				RSVPSenderTemplateObject TemplateObject;
				RSVPFilterSpecObject FilterObject;
			};
		case 2:
			_struct IPv6Diagnostic
			{
				UINT8 MaxRSVPhops;
				UINT8 RSVPhopcount;
				UINT16 MFFlg
				{
					UINT16 Reserved:15 = FormatString("(%s)",this.ToBitString);
					UINT16 MF:1 = FormatString("      (%s) %s",this.ToBitString,this ? "More fragments"
									   : "No more fragments");
				};
				UINT32 RequestID;
				UINT16 PathMTU;
				UINT16 FragmentOffset;
				Ipv6Address LastHopAddress;
				RSVPSenderTemplateObject TemplateObject;
				RSVPFilterSpecObject FilterObject;
			};
		default:
			switch
			{
				case offset < Property.DiagnosticEndOffset:
					AsciiString(Property.DiagnosticEndOffset - offset) UnknownDiagnosticObject;
			}
	}
	switch
	{
		case offset < Property.DiagnosticEndOffset:
			AsciiString(Property.DiagnosticEndOffset - offset) DiagnosticObjectPadding = FormatString("%d bytes",Property.DiagnosticEndOffset - offset);
	}
}

struct RSVPRouteObject = ClassType.Type.ToString
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	switch(ClassType.Type)
	{
		case 1:
			_struct IPv4Route
			{
				UINT24  Reserved;
				UINT8   RPointer;
				IPv4Address  RSVPNode[ (Property.ObjEndOffset  - offset)/4 ];
			};
		case 2:
			_struct IPv6Route
			{
				UINT24  Reserved;
				UINT8   RPointer;
				IPv6Address  RSVPNode[ (Property.ObjEndOffset  - offset)/16 ];
			};
		default:
			switch
			{
				case offset < Property.ObjEndOffset:
					AsciiString(Property.ObjEndOffset - offset) UnknownRouteObject;
			}
	}
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset - offset) RouteObjectPadding = FormatString("%d bytes",Property.ObjEndOffset - offset);
	}
}


struct RSVPDiagResponseObject
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	switch(ClassType.Type)
	{
		case 1:
			_struct IPv4DiagResponse
			{
				NTPTimeValue  DREQArrivalTime = UINT32( FrameData, Offset ) > 0 ? FormatString( "%T{MM/dd/yyyy}, %t{hh':'mm':'ss'}.%t{ffff}", this, this, this ) : "NULL";
				IPv4Address  IncomingInterfaceAddress;
				IPv4Address  OutgoingInterfaceAddress;
				IPv4Address  PreviousRSVPHopRouterAddress;
				UINT8   DTTL;
				UINT8   Flag = RSVPObj0X32ErrorTable(Err)
				{
					UINT8  M:1 = FormatString("  (%s) %d",this.ToBitString,this);
					UINT8  Err:3 = FormatString("(%s) %s",this.ToBitString,RSVPObj0X32ErrorTable( this ));
					UINT8  K:4 = FormatString("  (%s) %d",this.ToBitString,this);
				};
				UINT16   TimerValue = FormatString("%d seconds (0x%X)",this,this);
			};
		case 2:
			_struct IPv6DiagResponse
			{
				NTPTimeValue  DREQArrivalTime = UINT32( FrameData, Offset ) > 0 ? FormatString( "%T{MM/dd/yyyy}, %t{hh':'mm':'ss'}.%t{ffff}", this, this, this ) : "NULL";
				IPv6Address  IncomingInterfaceAddress;
				IPv6Address  OutgoingInterfaceAddress;
				IPv6Address  PreviousRSVPHopRouterAddress;
				UINT8   DTTL;
				UINT8   Flag = RSVPObj0X32ErrorTable(Err)
				{
					UINT8  M:1 = FormatString("  (%s) %d",this.ToBitString,this);
					UINT8  Err:3 = FormatString("(%s) %s",this.ToBitString,RSVPObj0X32ErrorTable( this ));
					UINT8  K:4 = FormatString("  (%s) %d",this.ToBitString,this);
				};
				UINT16   TimerValue;
			};
		default:
			switch
			{
				case offset < Property.ObjEndOffset:
					AsciiString(Property.ObjEndOffset - offset) UnknownDiagResponseObject;
			}
	}
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset - offset) DiagResponseObjectPadding = FormatString("%d bytes",Property.ObjEndOffset - offset);
	}
}

struct RSVPDiagSelectObject = ClassType.Type.ToString
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	switch(ClassType.Type)
	{
		case 1:
			while condition[offset < Property.ObjEndOffset]
			{
				UINT16 ClassType = Class.ToString + ", " +Type
				{
					UINT8  Class = RSVPClassTable( this );
					UINT8  Type = RSVPTypeTable(Class,this);
				};
			};
		default:
			switch
			{
				case offset < Property.ObjEndOffset:
					AsciiString(Property.ObjEndOffset-offset) UnknownDiagSelectObject;
			}
	}
}


struct RSVPLabelSetObject = ClassType.Type.ToString
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	switch(ClassType.Type)
	{
		case 1:
			_struct Type1LabelSet
			{
				UINT8 Action = RSVPLabelActionTable(this);
				UINT24 LabelType
				{
					UINT24 Reserved:10 = FormatString("(%s)",this.ToBitString);
					UINT24 Type:14 = FormatString("    (%s) %d",this.ToBitString,this);
				};
				UINT32 Subchannel[(Property.ObjEndOffset - offset)/4];
			};
		default:
			switch
			{
				case offset < Property.ObjEndOffset:
					AsciiString(Property.ObjEndOffset - offset) UnknownLabelSetObject;
			}
	}
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset - offset) LabelSetObjectPadding = FormatString("%d bytes",Property.ObjEndOffset - offset);
	}
}

struct RSVPPortectionObject = ClassType.Type.ToString
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	switch(ClassType.Type)
	{
		case 1:
			UINT32  ProtectionObj = "LinkFlg = "+RSVPLabelLinkFlgTable(LinkFlg)
			{
				UINT32 Secondary:1 = FormatString("(%s) %s",this.ToBitString,this ? "requested LSP is a secondary LSP"
										  : "requested LSP is not a secondary LSP");
				UINT32 Reserved:25 = FormatString(" (%s)",this.ToBitString);
				UINT32 LinkFlg:6 = FormatString("  (%s) %s",this.ToBitString,RSVPLabelLinkFlgTable(this));
			};
		default:
			switch
			{
				case offset < Property.ObjEndOffset:
					AsciiString(Property.ObjEndOffset - offset) UnknownProtectionObject;
			}
	}
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset - offset) ProtectionObjectPadding = FormatString("%d bytes",Property.ObjEndOffset - offset);
	}
}


struct RSVPDSBMObject = FormatString("DSBM %s Address: %s",ClassType.Type.ToString, DSBMAddress)
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("DSBM %s Address",Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	switch(ClassType.Type)
	{
		case 1:[
			DSBMAddress = this.ToString]
			IPv4Address DSBMIP4Address;
		case 2:
			[DSBMAddress = this.ToString]
			IPv6Address DSBMIP6Address;
	}
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset - offset) DSBMAddressObjectPadding = FormatString("%d bytes",Property.ObjEndOffset - offset);
	}
}

struct RSVPSBMPriorityObject = FormatString(" Priority %d", Priority)
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	UINT24 Reserved;
	UINT8 Priority;
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset - offset) SBMPriorityObjectPadding = FormatString("%d bytes",Property.ObjEndOffset - offset);
	}
}

struct RSVPDSBMTimerObject = FormatString("DeadInterval %d , RefreshInterval %d", DeadInterval, RefreshInterval)
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	UINT16 Reserved;
	UINT8 DeadInterval = FormatString("%d seconds",this,this);
	UINT8 RefreshInterval = FormatString("%d seconds",this,this);
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset-offset) DSBMTimerObjectPadding = FormatString("%d bytes",Property.ObjEndOffset - offset);
	}
}
// RFC 2814, page 55
struct RSVPNonResvSendLimitObject = FormatString("NonResvResvSendLimit %u",NonResvSendLimit)
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	UINT32 NonResvSendLimit;
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset-offset) NonResvSendLimitObjectPadding = FormatString("%d bytes",Property.ObjEndOffset - offset);
	}
}

/*
struct RSVPSBMInfoObject = FormatString("%s%s" , ClassType.Type.ToString , Property.Media ? FormatString(", %d",Property.Media) : "")
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	switch(Length)
	{
		case 44:
			_struct MediaTypeSBMInfo
			{
				UINT24 Reserved;
				[Media]
				UINT8 MediaType;
			};
	}
}
*/
//RFC 2747 page 11
struct RSVPChallengeObject = FormatString("%s%s%s",
										  ClassType.Type.ToString,
										  Property.KeyID ? "," + Property.KeyID : "",
										  Property.Challenge ? "," + Property.Challenge : ""
										 )
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	switch(ClassType.Type)
	{
		case 1:
			_struct Type1ChallengeValue
			{
				UINT16 Reserved;
				[KeyID = " Key ID " + this.ToString]
				INT48 KeyID;
				[Challenge = " Challenge Cookie " + FormatString("%u",this)]
				UINT32 ChallengeCookie;
			};
		default:
			switch
			{
				case offset < Property.ObjEndOffset:
					AsciiString(Property.ObjEndOffset - offset) UnknownChallengeObject;
			}
	}
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset - offset) ChallengeObjectPadding = FormatString("%d bytes",Property.ObjEndOffset - offset);
	}
}

struct RSVPDiffServObject = ClassType.Type.ToString
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	switch(ClassType.Type)
	{
		case 1:
			_struct ELSPDiffServ
			{
				UINT32 MAPnbDW
				{
					UINT32 Reserved:28 = FormatString("(%s)",this.ToBitString);
					UINT32 MAPnb:4 = FormatString("   (%s) %d",this.ToBitString,this);
				};
				[countdata = 0]
				while condition[ Offset < FrameLength && Property.countdata < MAPnbDW.MAPnb ]
				{
					switch
					{
						case (UINT32(FrameData,Offset) & 0x000003FD) == 0:
							_struct MapEntry
							{
								[countdata = countdata + 1]
								struct MAP
								{
									UINT16 EXP
									{
										UINT16 Reserved:13 = FormatString("(%s)",this.ToBitString);
										UINT16 EXP:3 = FormatString("     (%s) %d",this.ToBitString,this);
									};
									UINT16 PHBID
									{
										UINT16 DSCP:6 = FormatString("         (%s) %s",this.ToBitString,this);
										UINT16 Reserved:8 = FormatString("     (%s)",this.ToBitString);
										UINT16 PHB:1 = FormatString("          (%s) %s",this.ToBitString,this ? "A set of PHBs"
															 : "A single PHB");
										UINT16 StandardsFlag:1 = FormatString("(%s) %s",this.ToBitString,this ? "PHBs not defined by standards action"
															 : "PHBs defined by standards action");
									};
								};
							};
						case (UINT32(FrameData,Offset) & 0x0000000D) == 1:
							struct MAP
							{
								[countdata = countdata + 1]
								UINT16 EXP
								{
									UINT16 Reserved:13 = FormatString("(%s)",this.ToBitString);
									UINT16 EXP:3 = FormatString("     (%s) %s",this.ToBitString,this);
								};
								UINT16 PHBID
								{
									UINT16 PHBID:12 = FormatString("        (%s) %s",this.ToBitString,this);
									UINT16 Reserved:2 = FormatString("     (%s)",this.ToBitString);
									UINT16 PHB:1 = FormatString("          (%s) %s",this.ToBitString,this ? "A set of PHBs"
														 : "A single PHB");
									UINT16 StandardsFlag:1 = FormatString("(%s) %s",this.ToBitString,this ? "PHBs not defined by standards action"
														 : "PHBs defined by standards action");
								};
							};
						// avoid dead-cycle
						default:
							[countdata = MAPnbDW.MAPnb]
							struct DoNothing {};
					}
				}
			};
		case 2:
			switch
			{
				case (UINT32(FrameData,Offset) & 0x000003FD) == 0:
					_struct ELSPDiffServ
					{
						struct LLSP
						{
							UINT16 Reserved1;
							UINT16 PSC
							{
								UINT16 DSCP:6 = FormatString("         (%s) %s",this.ToBitString,this);
								UINT16 Reserved2:8 = FormatString("    (%s)",this.ToBitString);
								UINT16 PHB:1 = FormatString("          (%s) %s",this.ToBitString,this ? "A set of PHBs"
													 : "A single PHB");
								UINT16 StandardsFlag:1 = FormatString("(%s) %s",this.ToBitString,this ? "PHBs not defined by standards action"
													 : "PHBs defined by standards action");
							};
						};
					}
				case (UINT32(FrameData,Offset) & 0x0000000D) == 1:
					struct LLSP
					{
						UINT16 Reserved1;
						UINT16 PSC
						{
							UINT16 PHBID:12 = FormatString("       (%s) %s",this.ToBitString,this);
							UINT16 Reserved2:2 = FormatString("   (%s)",this.ToBitString);
							UINT16 PHB:1 = FormatString("         (%s) %s",this.ToBitString,this ? "A set of PHBs"
												 : "A single PHB");
							UINT16 StandarsFlag:1 = FormatString("(%s) %s",this.ToBitString,this ? "PHBs not defined by standards action"
												 : "PHBs defined by standards action");
						};
					};
			}
		default:
			switch
			{
				case offset < Property.ObjEndOffset:
					AsciiString(Property.ObjEndOffset - offset) UnknownDiffServObject;
			}
	}
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset - offset) DiffServObjectPadding = FormatString("%d bytes",Property.ObjEndOffset - offset);
	}
}

struct RSVPClassTypeObject = ClassType.Type.ToString
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	switch(ClassType.Type)
	{
		case 1:
			UINT32 CTDW
			{
				UINT32 Reserved:29 = FormatString("(%s)",this.ToBitString);
				UINT32 CT:3 = FormatString("      (%s) %s",this.ToBitString,this);
			};
		default:
			switch
			{
				case offset < Property.ObjEndOffset:
					AsciiString(Property.ObjEndOffset - offset) UnknownClassTypeObject;
			}
	}
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset - offset) ClassTypeObjectPadding = FormatString("%d bytes",Property.ObjEndOffset - offset);
	}
}

struct RSVPNodeCharObject = ClassType.Type.ToString
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	UINT32 NodeCharObject
	{
		UINT32 Reserved:31 = FormatString("(%s)",this.ToBitString);
		UINT32 T:1 = FormatString("       (%s) %s",this.ToBitString,this ? "The node is a RSVP-tunnel capable node"
						 :"The node is not a RSVP-tunnel capable node");
	};
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset - offset) NodeCharObjectPadding = FormatString("%d bytes",Property.ObjEndOffset - offset);
	}
}

struct RSVPRestartCapObject = FormatString("%s%s%s",
											ClassType.Type.ToString,
											Property.RestartTime ? "," + Property.RestartTime : "",
											Property.RecoveryTime ? "," + Property.RecoveryTime : ""
											)
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	switch(ClassType.Type)
	{
		case 1:
			_struct Type1RestartCapability
			{
				[RestartTime = " Restart time " + FormatString("%u ms",this)]
				UINT32 RestartTime = FormatString("%u ms",this);
				[RecoveryTime = " Recovery time " + FormatString("%u ms",this)]
				UINT32 RecoveryTime = FormatString("%u ms",this);
			};
		default:
			switch
			{
				case offset < Property.ObjEndOffset:
					AsciiString(Property.ObjEndOffset - offset) UnknownRestartCapObject;
			}
	}
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset - offset) RestartCapObjectPadding = FormatString("%d bytes",Property.ObjEndOffset - offset);
	}
}

struct RSVPHOPL2Object = FormatString("%s, Mac Address %s", ClassType.Type.ToString, HopL2.Address.ToString)
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	switch(ClassType.Type)
	{
		case 1:
			_struct HopL2
			{
				MacAddress Address;
				UINT16 Unused;
			}
		default:
			switch
			{
				case offset < Property.ObjEndOffset:
					AsciiString(Property.ObjEndOffset - offset) UnknownHopL2Object;
			}
	}
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset - offset) HopL2ObjectPadding = FormatString("%d bytes",Property.ObjEndOffset - offset);
	}
}


struct RSVPLANObject = ClassType.Type.ToString + ", " + LANAddr
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	switch
	{
		case ClassType.Class == 163 && ClassType.Type == 1:[LANAddr = this.ToString]IPv4Address NHOPIPv4Address;
		case ClassType.Class == 163 && ClassType.Type == 2:[LANAddr = this.ToString]IPv6Address NHOPIPv6Address;
		case ClassType.Class == 164 && ClassType.Type == 1:[LANAddr = this.ToString]IPv4Address LoopBackIPv4Address;
		case ClassType.Class == 164 && ClassType.Type == 2:[LANAddr = this.ToString]IPv6Address LoopBackIPv6Address;
		default:
			switch
			{
				case offset < Property.ObjEndOffset:
					AsciiString(Property.ObjEndOffset - offset) UnknownLanObject;
			}
	}
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset - offset) LanObjectPadding = FormatString("%d bytes",Property.ObjEndOffset - offset);
	}
}


struct RSVPTClassObject = FormatString("%s, Priority = %d",ClassType.Type.ToString,Priority)
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8  Type = RSVPTypeTable(Class,this);
	};
	UINT24 Unused;
	UINT8 Reserved:5 = FormatString("(%s)",this.ToBitString);
	UINT8 Priority:3 = FormatString("(%s) %d",this.ToBitString,this);
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset - offset) TClassObjectPadding = FormatString("%d bytes",Property.ObjEndOffset - offset);
	}
}

struct RSVPLSPTUNNELObject =FormatString("%s%s%s",
										ClassType.Type.ToString,
										Property.RouterID ? "," + Property.RouterID : "",
										Property.InterfaceID ? "," + Property.InterfaceID : ""
										)
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	switch(ClassType.Type)
	{
		case 1:
			_struct ForwardOrReverseInterfaceID
			{
				[RouterID = " Router ID " + this.ToString]
				IPv4Address  RouterID;
				[InterfaceID = " Interface ID " + FormatString("%u",this)]
				UINT32  InterfaceID;
			};
		default:
			switch
			{
				case offset < Property.ObjEndOffset:
					AsciiString(Property.ObjEndOffset - offset) UnknownLSPTUNNELObject;
			}
	}
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset - offset) LSPTUNNELObjectPadding = FormatString("%d bytes",Property.ObjEndOffset - offset);
	}
}

struct RSVPATMSERVICECLASSObject =FormatString("%s,%s",ClassType.Type.ToString,RSVPATMSERVICECLASSObjectSCTable(SCWD.SC))
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	switch(ClassType.Type)
	{
		case 1:
			UINT32 SCWD
			{
				UINT32 Reserved:29 = FormatString("(%s)",this.ToBitString);
				UINT32 SC:3 = FormatString("      (%s) %s",this.ToBitString,RSVPATMSERVICECLASSObjectSCTable(this));
			};
		default:
			switch
			{
				case offset < Property.ObjEndOffset:
					AsciiString(Property.ObjEndOffset - offset) UnknownATMSERVICECLASSObject;
			}
	}
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset - offset) ATMSERVICECLASSObjectPadding = FormatString("%d bytes",Property.ObjEndOffset - offset);
	}
}

struct RSVPNotifyRequestObject = FormatString("%s, %s",
											  ClassType.Type.ToString,
											  Property.NotifyAddr ? "," + Property.NotifyAddr : ""
											 )
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	switch(ClassType.Type)
	{
		case  1:[NotifyAddr]IPv4Address NotifyIP4Addess;
		case  2:[NotifyAddr]IPv6Address NotifyIP6Address;
		default:
			switch
			{
				case offset < Property.ObjEndOffset:
					AsciiString(Property.ObjEndOffset - offset) UnknownNotifyRequestObject;
			}
	}
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset - offset) NotifyRequestObjectPadding = FormatString("%d bytes",Property.ObjEndOffset - offset);
	}
}


struct RSVPAdminStatusObject = ClassType.Type.ToString
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	switch(ClassType.Type)
	{
		case  1:
			UINT32 AdminStatus
			{
				UINT32 R:1 = FormatString("       (%s) %s",this.ToBitString,this ? "The edge node should reflect the object/TLV back in the appropriate message"
								  : "The edge node should not reflect the object/TLV back");
				UINT32 Reserved:28 = FormatString("(%s)",this.ToBitString);
				UINT32 T:1 = FormatString("       (%s) %s",this.ToBitString,this ? "Local actions related to the 'testing' mode should be taken"
								  : "Local actions related to the 'testing' mode should not be taken");
				UINT32 A:1 = FormatString("       (%s) %s",this.ToBitString,this ? "local actions related to the 'administratively down' state should be taken"
								  : "Local actions related to the 'administratively down' state should not be taken");
				UINT32 D:1 = FormatString("       (%s) %s",this.ToBitString,this ? "Local actions related to LSP teardown should be taken"
								  : "Local actions related to LSP teardown should not be taken");
			};
		default:
			switch
			{
				case offset < Property.ObjEndOffset:
					AsciiString(Property.ObjEndOffset - offset) UnknownAdminStatusObject;
			}
	}
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset - offset) AdminStatusObjectPadding = FormatString("%d bytes",Property.ObjEndOffset - offset);
	}
}

struct RSVPSessionAttributeObject = FormatString("%s%s%s%s",
												ClassType.Type.ToString,
												Property.SetupPriority ? "," + Property.SetupPriority : "",
												Property.HoldingPriority ? "," + Property.HoldingPriority : "",
												Property.SAName ? "," + Property.SAName : ""
												)
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s ",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	switch(ClassType.Type)
	{
		case 1:
			_struct LSPTunnelRASession
			{
				UINT32 ExcludeAny;
				UINT32 IncludeAny;
				UINT32 IncludeAll;
				[SetupPriority = " Setup Priority " + FormatString("%u",this)]
				UINT8 SetupPriority;
				[HoldingPriority = " Holding Priority " + FormatString("%u",this)]
				UINT8 HoldingPriority;
				//UINT8 Flags = RSVPSessionAttrFlgTable(this);
				UINT8 Flags
				{
					UINT8 Reserved:5 = FormatString("(%s)",this.ToBitString);
					UINT8 SE:1 = FormatString("      (%s) %s",this.ToBitString,this ? "SE Style desired"
										: "SE Style not desired");
					UINT8 Label:1 = FormatString("   (%s) %s",this.ToBitString,this ? "Label recording desired"
										: "Label recording not desired");
					UINT8 Local:1 = FormatString("   (%s) %s",this.ToBitString,this ? "Local protection desired"
										: "Local protection not desired");
				};
				UINT8 NameLength;
				[SAName = " Name " + this.ToString]
				AsciiString(NameLength + 4 - NameLength%4) Name;
			};
		case 7:
			_struct LSPTunnelNoRASession
			{
				[SetupPriority = " Setup Priority " + FormatString("%u",this)]
				UINT8 SetupPriority;
				[HoldingPriority = " Holding Priority " + FormatString("%u",this)]
				UINT8 HoldingPriority;
				//UINT8 Flags = RSVPSessionAttrFlgTable(this);
				UINT8 Flags
				{
					UINT8 Reserved:5 = FormatString("(%s)",this.ToBitString);
					UINT8 SE:1 = FormatString("      (%s) %s",this.ToBitString,this ? "SE Style desired"
										: "SE Style not desired");
					UINT8 Label:1 = FormatString("   (%s) %s",this.ToBitString,this ? "Label recording desired"
										: "Label recording not desired");
					UINT8 Local:1 = FormatString("   (%s) %s",this.ToBitString,this ? "Local protection desired"
										: "Local protection not desired");
				};
				UINT8 NameLength;
				[SAName = " Name " + this.ToString]
				AsciiString(NameLength + 4 - NameLength%4) Name;
			};
		default:
			switch
			{
				case offset < Property.ObjEndOffset:
					AsciiString(Property.ObjEndOffset - offset) UnknownSessionAttributeObject;
			}
	}
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset - offset) SessionAttributeObjectPadding = FormatString("%d UINT8",Property.ObjEndOffset - offset);
	}
}

struct RSVPCallOPSObject
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	switch(ClassType.Type)
	{
		case 1:
			struct CallOPS
			{
				UINT8 CallOPSFlg
				{
					UINT8 Reserved:6 = FormatString("             (%s)",this.ToBitString);
					UINT8 Synchronizing:1 = FormatString("        (%s) %s",this.ToBitString,this ? "Synchronizing a call"
										: "Synchronizing is not set");
				//# I am not very sure with the explaintion of the bits below when their values are 0.
					UINT8 CallWithoutConnection:1 = FormatString("(%s) %s",this.ToBitString,this ? "Call without connection"
										: "CallWithoutConnection is not set");
				};
				UINT24 Reserved;
			}
		default:
			switch
			{
				case offset < Property.ObjEndOffset:
					AsciiString(Property.ObjEndOffset - offset) UnknownCallOPSObject;
			}
	}
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset - offset) CallOPSObjectPadding = FormatString("%d bytes",Property.ObjEndOffset - offset);
	}
}


struct RSVPCallIDObject = ClassType.Type.ToString
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	switch(ClassType.Type)
	{
		case 1:
			_struct OperatorSpecificCallID
			{
				UINT8  LSRAddressType = RSVPCallIDTypeTable(this);
				UINT24  Reserved;
				switch( LSRAddressType )
				{
					case 0X01:Ipv4Address  SourceLSRaddress4;
					case 0X02:Ipv6Address  SourceLSRaddress16;
					case 0X03:ATMAddress   SourceLSRaddress20;
					case 0X04:MacAddress   SourceLSRaddress6;
					// case 0X7f:the source LSR address has the length defined by the vendor;
					case 0X7f:AsciiString(length - 28) LSRAddress;
				};
				INT64  LocalID;
			};
		case 2:
			_struct GloballyUniqueCallID
			{
				UINT8   LSRAddressType = RSVPCallIDTypeTable(this);
				UINT24  InternationalSegment;
				struct  RSVPNationalSegment
				{
					AsciiString(6) ITUCarrierCode;
					AsciiString(6) UniqueAccessPointCode;
				}
				//UINT16  ITUCarrierCode[3];
				//UINT16  UniqueAccessPointCode[3];
				switch( LSRAddressType )
				{
					case 0X01:Ipv4Address  SourceLSRaddress4;
					case 0X02:Ipv6Address  SourceLSRaddress16;
					case 0X03:ATMAddress   SourceLSRaddress20;
					case 0X04:MacAddress   SourceLSRaddress6;
					// case 0X7f:the source LSR address has the length defined by the vendor;
					case 0X7f:AsciiString(length - 28) LSRAddress;
					default: Blob(length - 28) UnknownAddress;
				};
				INT64  LocalID;
			};
		default:
			switch
			{
				case offset < Property.ObjEndOffset:
					AsciiString(Property.ObjEndOffset - offset) UnknownCallIDObject;
			}
	}
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset - offset) CallIDObjectPadding = FormatString("%d bytes",Property.ObjEndOffset - offset);
	}
}

struct RSVPFastRerouteObject = ClassType.Type.ToString
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	switch
	{
		case ClassType.Type == 1 && Length == 24:
			_struct Type1FastReroute
			{
				UINT8 SetupPriority;
				UINT8 HoldPriority;
				UINT8 HopLimit;
				UINT8 Flags
				{
					UINT8 Reserved:6 = FormatString("(%s)",this.ToBitString);
					UINT8 Facility:1 = FormatString("(%s) %s",this.ToBitString,this ? "Facility Backup Desired"
										: "Facility Backup NOT Desired");
					UINT8 OneToOne:1 = FormatString("(%s) %s",this.ToBitString,this ? "One-to-One Backup Desired"
										: "One-to-One Backup NOT Desired");
				};
				Float  Bandwidth = FormatString( "%e", this );
				UINT32 ExcludeAny;
				UINT32 IncludeAny;
				UINT32 IncludeAll;
			};
		case ClassType.Type == 7 && Length == 20:
			_struct Type7FastReroute
			{
				UINT8  SetupPriority;
				UINT8  HoldPriority;
				UINT8  HopLimit;
				UINT8  Reserved;
				Float  Bandwidth = FormatString( "%e", this );
				UINT32 ExcludeAny;
				UINT32 IncludeAny;
			};
		default:
			switch
			{
				case offset < Property.ObjEndOffset:
					AsciiString(Property.ObjEndOffset - offset) UnknownObject;
			};
	}
}

struct RSVPDetourObject = ClassType.Type.ToString
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	switch(ClassType.Type)
	{
		case 7:
			while condition1[offset + 8 <= Property.ObjEndOffset]
			{
				IPv4Address PLRID;
				IPv4Address AvoidNodeID;
			};
		case 8:
			while condition2[offset + 8 <= Property.ObjEndOffset]
			{
				IPv6Address PLRID;
				IPv6Address AvoidNodeID;
			};
		default:
			switch
			{
				case offset < Property.ObjEndOffset:
					AsciiString(Property.ObjEndOffset - offset) UnknownDetourObject;
			}
	}
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset - offset) DetourObjectPadding = FormatString("%d bytes",Property.ObjEndOffset - offset);
	}
}

// OIF-UNI-01.0-R2-RSVP.pdf page 28
struct RSVPGenUNISubobject = FormatString("%s,%s",Type.ToString,SubType.ToString)
{
	UINT16 SubobjectLength;
	UINT8 Type = RSVPGenUNISubobjectTypeTable(this);
	UINT8 SubType = RSVPGenUNISubobjectSubTypeTable(Type,this);
	switch
	{
		case Type == 1 && SubType == 1:
			IPv4Address SourceUNICIPv4TNAAddress;
		case Type == 1 && SubType == 2:
			IPv6Address SourceUNICIPv6TNAAddress;
		case Type == 1 && SubType == 3:
			_struct SourceNSAPTNA
			{
				UINT8 NSAPLength;
				UINT24 Reserved;
				Blob(NSAPLength) NSAPFormatTNAaddress;
				switch
				{
					case  NSAPLength % 4 != 0:
						Blob(4 - (NSAPLength  % 4)) Padding;
				}
			};
		case Type == 2 && SubType == 1:
			IPv4Address DestinationUNICIPv4TNAAddress;
		case Type == 2 && SubType == 2:
			IPv6Address DestinationUNICIPv6TNAAddress;
		case Type == 2 && SubType == 3:
			_struct DestinationNASPTNA
			{
				UINT8 NSAPLength;
				UINT24 Reserved;
				Blob(NSAPLength) NSAPFormatTNAaddress;
				switch
				{
					case  NSAPLength % 4 != 0:
						Blob(4 - (NSAPLength  % 4)) Padding;
				}
			};
		case Type == 3 && SubType == 1:
			_struct Diversity
			{
				UINT32 DSWD
				{
					UINT32 DS:4 = FormatString("      (%s) %s",this.ToBitString,RSVPGenUNISubobjectDiversityDSTable(this));
					UINT32 Reserved:28 = FormatString("(%s)",this.ToBitString);
				};
				RSVPSessionObject UNIIPv4SESSION;
				RSVPSenderTemplateObject LSPTUNNELIPv4SENDERTEMPLATE;
			};
		case Type == 4 && SubType == 1:
		case Type == 4 && SubType == 2:
			_struct EgressLabel
			{
				UINT24 UBitTR
				{
					UINT24 U:1 = FormatString("       (%s) %s",this.ToBitString,this ? "Upstream label and port ID"
									  : "Downstream label and port ID");
					UINT24 Reserved:23 = FormatString("(%s)",this.ToBitString);
				};
				UINT8 LabelType;
				UINT32 LogicalPortIdentifier;
				UINT32 Label;
			};
		case Type == 5 && SubType == 1:
			_struct ServiceLevelSubType
			{
				UINT8 ServiceLevel;
				UINT24 Reserved;
			};
		default:
			switch
			{
				case offset < Property.ObjEndOffset:
					AsciiString(Property.ObjEndOffset - offset) UnknownSubobject;
			}
	}
}

struct RSVPGenUNIObject = FormatString("%s,%s,%s",ClassType.Type.ToString,Subobject.Type.ToString,Subobject.SubType.ToString)
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("%s, %s",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	RSVPGenUNISubobject Subobject;
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset - offset) GenUNIObjectPadding;
	}
}

struct RSVPDefaultObject = ClassType.ToString
{
	[ObjEndOffset = ( offset + this ) < FrameLength ? ( offset + this ) : FrameLength]
	UINT16 Length;
	UINT16 ClassType = FormatString("Class(%s), C-Type(%s)",Class.ToString,Type.ToString )
	{
		UINT8 Class = RSVPClassTable( this );
		UINT8 Type = RSVPTypeTable(Class,this);
	};
	switch
	{
		case offset < Property.ObjEndOffset:
			AsciiString(Property.ObjEndOffset - offset) Data;
	}
}

struct RSVPHeader = FormatString("Version %d, %s, TotalLength %d", Information.Version, RSVPMsgTypeTable( MsgType ), TotalLength)
{
	UINT8  Information = FormatString("Version is %d, Refresh Flag is %d",Version,Refresh)
	{
		UINT8 Version:4 = FormatString(" (%s) %d",this.ToBitString,this);
		UINT8 Reserved:3 = FormatString("(%s)",this.ToBitString);
		UINT8 Refresh:1 = FormatString(" (%s) %s",this.ToBitString,this  ? "Refresh reduction capable"
								: "Not refresh reduction capable");
	};
	[RSVPMsgType]
	UINT8  MsgType = FormatString("%s, %d(%#x)", RSVPMsgTypeTable( this ), this, this);
	UINT16  Checksum;
	UINT8  TTL;
	UINT8  Reserved;
	[AllObjEndOffset = ( offset + this - 6 ) < FrameLength ? ( offset + this - 6 ) : FrameLength , RSVPLength]
	UINT16  TotalLength;
}

