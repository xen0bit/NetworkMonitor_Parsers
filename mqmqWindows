//#  (c) 2009 CodePlex Foundation
//#
//#  Title:                  Message Queuing (MSMQ): Data Structures
//#
//#  Details:                the RPC portion of MSMQ
//#
//#  Microsoft References:   [MS-MQMQ]: Message Queuing (MSMQ): Data Structures
//#
//#  Comments:               
//#
//#  Revision Class and Date:Major, 10/15/2009
//#                          Minor, 4/23/2010
//#
//####

//========= TABLES ==========================================================================================
table MQMQCommonQueueFormatTypeTable( value )
{
	switch( value )
	{
	case 0: "QueueFormatTypeUnknown";
	case 1: "QueueFormatTypePublic";
	case 2: "QueueFormatTypePrivate";
	case 3: "QueueFormatTypeDirect";
	case 4: "QueueFormatTypeMachine";
	case 5: "QueueFormatTypeConnector";
	case 6: "QueueFormatTypeDistributionList";
	case 7: "QueueFormatTypeMultiCast";
	case 8: "QueueFormatTypeSubQueue";
	}
}

table MQMQCommonSuffixTypesTable( value )
{
	switch( value )
	{
	case 0: "NoSuffixSpecified - Flags subfield must indicate that the queue is not a system queue";
	case 1: "JournalSuffix - Format type cannot indicate that the queue is a connector, a distribution list, or a multicast queue";
	case 2: "DeadLetterSuffix - Flags subfield must indicate that the queue is a system queue";
	case 3: "DeadTransactionSuffix - Flags subfield must indicate that the queue is a system queue";
	case 4: "TransactionOnlySuffix - Format type must indicate that the queue is a connector queue";
	case 5: "SubQueueSuffix - Flags subfield indicate unknown, Format type must indicate SubQueue";
	}
}

table MQMQCommonSuffixFlagsTable( value )
{
	switch( value )
	{
	case 0: "QueueFormatFlagNotSystem - Not a system queue";
	case 8: "QueueFormatFlagSystem - System queue";
	}
}

//2.2.12   PROPVARIANT Type Constants
table MQMQCommonDirectoryObjectPropertyValueTypeTable( value )
{
	switch( value )
	{
	case 0x0000: "VtEmpty - No data";
	case 0x0001: "VtNull - No data";
	case 0x0002: "VtI2 - 2 byte signed integer";
	case 0x0003: "VtI4 - 4 byte signed integer";
	case 0x000B: "VtBool - Variant Bool";
	case 0x000C: "VtVariant - Property variant array";
	case 0x0010: "VtI1 - 1 byte signed integer";
	case 0x0011: "VtUI1 - 1 byte unsigned integer";
	case 0x0012: "VtUI2 - 2 byte unsigned integer";
	case 0x0013: "VtUI4 - 4 byte unsigned integer";
	case 0x0014: "VtI8 - 8 byte signed integer";
	case 0x0015: "VtUI8 - 8 byte unsigned integer";
	case 0x001F: "VtLPWSTR - Null terminated Unicode string";
	case 0x0041: "VtBLOB - Unsigned character array";
	case 0x0048: "VtCLSID - Pointer to GUID";
	case 0x1003: "CAL - Array of long integers";
	case 0x100C: "CAPROPVARIANT - Array of PROPVARIANT values";
	case 0x1011: "CAUB - Array of unsigned characters";
	case 0x1012: "CAUI - Array of unsigned short integers";
	case 0x1013: "CAUL - Array of unsigned long integers";
	case 0x1015: "CAUH - Array of ulonglong integers";
	case 0x1048: "CACLSID - Array of GUIDs";
	case 0x101F: "CALPWSTR - Array of widestrings";
	}
}

table MQMQCommonDirectoryObjectPROPIDTable( value )
{
	switch( value )
	{
	// MQDS-QUEUE DIRECTORY OBJECTS
	case 101: "PropIdQInstance - GUID for the queue";
	case 102: "PropIdQType - User-defined type of service the queue provides";
	case 103: "PropIdQPathname - The path of the queue";
	case 104: "PropIdQJournal - How MSMQ tracks messages removed from the queue";
	case 105: "PropIdQQuota - Maximum kilobyte size of the queue";
	case 106: "PropIdQBasePriority - Priority level of the queue";
	case 107: "PropIdQJournalQuota - Maximum kilobyte size of the queue journal";
	case 108: "PropIdQLabel - A descriptive label for the queue";
	case 109: "PropIdQCreateTime - Time when the queue was created";
	case 110: "PropIdQModifyTime - Time when the queue properties were last modified";
	case 111: "PropIdQAuthenticate - Authentication level of the queue";
	case 112: "PropIdQPrivLevel - Privacy level of the queue";
	case 113: "PropIdQTransaction - Transaction level of the queue";
	case 115: "PropIdQQmid - GUID of the queue manager that hosts the queue";
	case 116: "PropIdQMasterId - Guid of the Message Queue Information Store server that owns the queue";
	case 121: "PropIdQFullPath - Distinguished name of the queue object in Active Directory";
	case 123: "PropIdQNameSuffix - Suffix of the queue name if the name exceeds 64 characters";
	case 124: "PropIdQPathNameDns - Domain Name Systems name prefixed path of the queue";
	case 125: "PropIdQMulticastAddress - IP multicast address associated with the queue";
	case 126: "PropIdQAdsPath - Active Directory path to the public queue object stored in Active Directory";
	// MQDS-MACHINE DIRECTORY OBJECTS
	case 201: "PropIdQMSiteId - Guid of the site in which the queue manager is located";
	case 202: "PropIdQMMachineId - Guid that uniquely identifies the queue manager for the computer";
	case 203: "PropIdQMPathName - Name of the computer where the queue manager is located";
	case 205: "PropIdQMEncryptionPk - The public encryption key of the computer";
	case 207: "PropIdQmCns - An array of connected network identifiers that the queue manager supports";
	case 208: "PropIdQmOutFrs - An array of outgoing-interface routing-server Guids for all messages the machine sends";
	case 209: "PropIdQmInFrs - An array of incoming-interface routing-server Guids for all messages the machine receives";
	case 210: "PropIdQmService - The type of service the machine supports";
	case 214: "PropIdQmQuota - Disk quota for all queues located at the queue manager";
	case 215: "PropIdQmJournalQuota - System-wide journal kilobyte storage quota";
	case 216: "PropIdQmMachineType - Operating system and MSMQ version";
	case 217: "PropIdQmCreateTime - Time when the directory object was created";
	case 218: "PropIdQmModifyTime - Time when the directory object was last modified";
	case 219: "PropIdQmForeign - Whether the queue manager is a foreign system that services foreign queues";
	case 220: "PropIdQmOs - Operating system type of the queue manager";
	case 221: "PropIdQmFullPath - Distinguished name for the MSMQ configuration object";
	case 222: "PropIdQmSiteIds - An array of site identifiers for sites to which the computer belongs";
	case 223: "PropIdQmOutFrsDn - Array of distinguished names for outgoing-traffic routing-servers for this computer";
	case 224: "PropIdQmInfrsDn - Array of distinguished names for incoming-traffic routing-servers for this computer";
	case 227: "PropidQmServiceRouting - Whether the queue manager is configured as a routing server";
	case 231: "PropIdQMEncryptionPKBase - Public encryption key of the computer";
	case 232: "PropIdQMEncryptionPKEnhanced - The enhanced (128-bit) public encryption key of the computer";
	case 233: "PropIdQMPathNameDns - The Domain Name System name of the computer";
	case 234: "PropIdQMObjSecurity - The security descriptor of the MSMQ configuration object";
	case 237: "PropIdQMSecurityInformation - Security descriptor option information";
	case 238: "PropIdQMEncryptPks - The computer's public key certificates in MQDSPublicKeys format";
	case 239: "PropIdQMSignPks - The computer's public key certificates in MQDSPublicKeys format";
	case 241: "PropIdQMOwnerSid - The setup-program user-SID to add to the new object's DACL";
	case 242: "PropIdQMGroupInCluster - Whether the MSMQ installation is in a group that is part of a cluster";
	// MQDS-SITE DIRECTORY OBJECTS
	case 301: "PropIdSPathName - Name of the site";
	case 302: "PropIdSSiteId - Identifier of the site";
	case 303: "PropIdSGates - Configuration object guids of the MSMQ servers that are the gates for the site";
	case 304: "PropIdSPsc - Computer name of the Primary Site Controller for the site";
	case 309: "PropIdSFullName - Distinguished name of the site in Active Directory";
	case 310: "PropIdSNt4Stub - Whether the site was migrated from a Windows NT 4.0 MQIS database";
	case 311: "PropIdSForeign - Whether the site is used as a definition of an external messaging system";
	// MQDS-ENTERPRISE DIRECTORY OBJECTS
	case 602: "PropIdENameStyle - Whether weakened security is enabled";
	case 609: "PropIdEId - Guid identifier for the directory object instance";
	case 616: "PropIdELongLive - Default time a sent message has to reach a queue in seconds";
	// MQDS-USER DIRECTORY OBJECTS
	case 701: "PropIdUSid - User's security identifier (SID)";
	case 702: "PropIdUSignCert - An X.509 encoded certificate for the user object";
	case 705: "PropIdUDigest - An array of certificate digests as the MD5 hash of the encoded certificate";
	case 706: "PropIdUId - Guid identifying the user object";
	// MQDS-SITELINK DIRECTORY OBJECTS
	case 801: "PropIdLNeighbor1 - The guid of one of the routing sites";
	case 802: "PropIdLNeighbor2 - The guid of the other routing site";
	case 803: "PropIdLCost - The relative cost of the link in units of speed or money";
	case 806: "PropIdLId - Guid of the site link object";
	case 807: "PropIdLGatesDn - MSMQ Configuration object distinguished names of the link site gate computers";
	case 808: "PropIdLNeighbor1Dn - Distinguished name of one site on the link";
	case 809: "PropIdLNeighbor2Dn - Distinguished name of the other site on the link";
	case 810: "PropIdLDescription - The description of the routing link";
	case 811: "PropIdLFullPath - Distinguished name of the routing link object in Active Directory";
	case 812: "PropIdLActualCost - Untranslated link cost";
	case 813: "PropIdLGates - MSMQ configuration object guids of the site gate computers on the link";

	case 1101: "PropIdQSecurity - Security object in Windows NT 4.0 format";
	case 1102: "PropIdQObjSecurity - Security object in Windows NT 4.0 format";
	case 1103: "PropIdQSecurityInformation - Security descriptor option information";

	case 1201: "PropIdQmSecurity - Security information in Windows NT 4.0 format";
	case 1202: "PropIdQmSignPk - Computer's signing public key certificate formatted as MQDSPublicKeys";
	case 1203: "PropIdQmEncryptPk - Computer's encryption public key certificate formatted as MQDSPublicKeys";
	case 1205: "PropIdQmUpgradeDacl - Dummy PROPID used in set property operation to request PEC update DACL";

	case 1301: "PropIdSSecurity - Security object in Windows NT 4.0 format";
	case 1302: "PropIdSPscSignPk - The signing key of the Primary Site Controller formatted as MQDSPublicKeys";
	case 1303: "PropIdSSecurityInformation - Security information for setting/reading a security descriptor";

	case 1501: "PropIdCnSecurity - Security object in Windows NT 4.0 format";

	case 1601: "PropIdESecurity - Security descriptor of the MSMQ services object in Windows NT 4.0 format";

	case 5101: "PropIdSetName - Common name attribute";
	case 5102: "PropIdSetService - The type of service";
	case 5103: "PropIdSetQmId - Guid of the computer's MSMQ configuration object";
	case 5105: "PropIdSetFullPath - Distinguished name of the MSMQ settings object in Active Directory";
	case 5106: "PropIdSetNt4 - Whether the server is MSMQ 1.0";
	case 5107: "PropIdSetMasterId - Guid of the site";
	case 5108: "PropIdSetSiteName - The site name";
	case 5109: "PropIdSetServiceRouting - Whether the server is a routing server";
	case 5110: "PropIdSetServiceDsServer - Whether the MSMQ server provides Active Directory access for MSMQ server 2.0 clients";
	case 5111: "PropIdSetServiceDepClients - Whether the server can be a supporting server for dependent clients";
	case 5112: "PropIdSetOldService - The type of service";

	case 5201: "PropIdComFullPath - Distinguished name of the computer";
	case 5202: "PropIdComSamAccount - The property that contains the name of the computer account in Active Directory";
	case 5204: "PropIdCOMAccountControl - User account control attributes";
	case 5205: "PropIdCOMDNSHostName - DNS host name attribute of the computer object";
	case 5206: "PropIdCOMSid - Computer object Active Directory SID for addition to the MSMQ server configuration DACL";
	case 5207: "PropIdCOMSignCert - An X.509 encoded certificate for the computer object";
	case 5208: "PropIdCOMDigest - An array of certificate digests computed as the MD5 hash of the encoded certficate";
	case 5209: "PropIdCOMId - Guid of the computer object";

	case 5401: "PropIdMquSid - The migrated user's SID";
	case 5402: "PropIdMquSignCert - An X.509 encoded certificate for the migrated user object";
	case 5405: "PropIdMquDigest - An array of certificate digests computed as the MD5 hash of the encoded certificate";
	case 5406: "PropIdMquId - Guid of the MQUser object";
	case 5407: "PropIdMquSecurity - Security object in Windows NT 4.0 format";
	}
}

//========= Structs =========================================================================================

//
// Queue_Format
// alignment: None
//
struct MQMQCommonQueueFormat
{
	NdrAlign Pad;
	UINT8 FormatType = MQMQCommonQueueFormatTypeTable( this );
	MQMQCommonQueueFormatSuffixAndFlags SuffixAndFlags;
	UINT16 Reserved;
	MQMQCommonQueueFormatUnion Format;
	Switch
	{
		case Property.MSRPCNdr64:
		Align8 padEnd;
	}
}

struct MQMQCommonQueueFormatSuffixAndFlags
{
	UINT8 SuffixAndFlags
	{
		switch( Property.MSRPCByteOrder )
		{
		case LittleEndian:
			_struct LittleEndian
			{
				UINT8 SuffixTypes:4 = MQMQCommonSuffixTypesTable( this );
				UINT8  Flags:4 = MQMQCommonSuffixFlagsTable( this );
			}
		default:
			_struct BigEndian
			{
				UINT8 Flags:4 = MQMQCommonSuffixFlagsTable( this );
				UINT8 SuffixTypes:4 = MQMQCommonSuffixTypesTable( this );
			}
		}
	}
}

//
// OBJECTID
// alignment: 4
//
struct MQMQCommonObjectID
{
	GUID(TRUE) Lineage;
	UINT32 Uniquifier;
}

//2.2.9   DL_ID
//alignment: NDR
struct MQMQCommonDistributionListID
{
	GUID(TRUE)		DistributionListID;
	[Property.MQMQCommonDomainPtr=this.ReferentID]
	NdrPtr DomainPtr;
	//NdrWIDESTRINGPtr	Domain;
}

Struct MQMQCommonDistributionListIDRef
{
	Switch
	{
		Case Property.MQMQCommonDomainPtr!=0:
		NdrWideString Domain;
	}
}

//2.2.10   MULTICAST_ID
struct MQMQCommonMultiCastID
{
	IpV4Address		Address;
	UINT32		Port;
}

//2.2.13.1   tag_inner_PROPVARIANT
struct MQMQCommonPropVariant
{
	Align8 Pad;
	UINT16 VariantType = MQMQCommonDirectoryObjectPropertyValueTypeTable( this );
	UINT8 Reserved1;
	UINT8 Reserved2;
	UINT32 Reserved3;
	MQMQCommonPropVariantUnion Value;
}

struct MQMQCommonPropVariantUnion
{
	Switch
	{
		case Property.MSRPCNdr64:
		Align8 pad1;
	}
	UINT16		VariantType = MQMQCommonDirectoryObjectPropertyValueTypeTable( this );
	Switch
	{
		case Property.MSRPCNdr64:
		Align8 padUnion;
	}
	switch( VariantType )
	{
		case 0x0000: //VT_EMPTY
		case 0x0001: //VT_NULL
				struct {};
		case 0x0010: // VT_I1
				Int8 cVal;
		case 0x0011: // VT_UI1
				UINT8 bValue;
		case 0x0002: // VT_I2
				INT16 iValue;
		case 0x0012: // VT_UI2
				UINT16 uiValue;
		case 0x0003: // VT_I4
			struct
			{
				ALIGN4 Pad;
				INT32 Value;
			}
		case 0x0014: // VT_I8
				Int64 hVal;
		case 0x0015: // VT_UI8
				UInt64 uhVal;
		case 0x0013: // VT_UI4
			struct
			{
				ALIGN4 Pad;
				UINT32 lValue;
			}
		case 0x000B: // VT_BOOL
			Struct
			{
				INT16 BoolValue=MQMQCommonPropVariantUnionBoolTable(this);
			}
			
		case 0x0048: // VT_CLSID
			struct
			{
				[MQMQCommonPropVariantPointerReferenceArray$[MQMQCommonPropVariantPointerReferenceCount] = VariantType, MQMQCommonPropVariantPointerReferenceCount = MQMQCommonPropVariantPointerReferenceCount + (UuidPtr.ReferentID>0?1:0)]
				NdrPtr UuidPtr;
			}
		case 0x0041: // VT_BLOB
			struct 
			{
				NdrAlign PadHeader;
				[MQMQCommonPropVariantPointerReferenceArray$[MQMQCommonPropVariantPointerReferenceCount] = VariantType, MQMQCommonPropVariantPointerReferenceCount = MQMQCommonPropVariantPointerReferenceCount + (this.BlobPtr.ReferentID>0?1:0)]
				MQMQBlob blob;
			}
		case 0x001F: // VT_LPWSTR
			struct
			{	
				[MQMQCommonPropVariantPointerReferenceArray$[MQMQCommonPropVariantPointerReferenceCount] = VariantType, MQMQCommonPropVariantPointerReferenceCount = MQMQCommonPropVariantPointerReferenceCount + (WSTRPtr.ReferentID>0?1:0)]
				NdrPtr WSTRPtr;
			}
		case 0x1011: // CAUB
			struct 
			{
				NdrAlign Pad;
				[MQMQCommonPropVariantPointerReferenceArray$[MQMQCommonPropVariantPointerReferenceCount] = VariantType, MQMQCommonPropVariantPointerReferenceCount = MQMQCommonPropVariantPointerReferenceCount + (this.CAUBPtr.ReferentID>0?1:0)]
				MQMQCAUB CAUB;
			}
		case 0x1012: // CAUI
			struct 
			{
				NdrAlign Pad;
				[MQMQCommonPropVariantPointerReferenceArray$[MQMQCommonPropVariantPointerReferenceCount] = VariantType, MQMQCommonPropVariantPointerReferenceCount = MQMQCommonPropVariantPointerReferenceCount + (this.CAUBPtr.ReferentID>0?1:0)]
				MQMQCAUI CAUB;
			}
		case 0x1003: // CAL
			struct 
			{
				NdrAlign Pad;
				[MQMQCommonPropVariantPointerReferenceArray$[MQMQCommonPropVariantPointerReferenceCount] = VariantType, MQMQCommonPropVariantPointerReferenceCount = MQMQCommonPropVariantPointerReferenceCount + (this.CALPtr.ReferentID>0?1:0)]
				MQMQCAL CAL;
			}
		case 0x1013: // CAUL
			struct 
			{
				NdrAlign Pad;
				[MQMQCommonPropVariantPointerReferenceArray$[MQMQCommonPropVariantPointerReferenceCount] = VariantType, MQMQCommonPropVariantPointerReferenceCount = MQMQCommonPropVariantPointerReferenceCount + (this.CAULPtr.ReferentID>0?1:0)]
				MQMQCAUL CAUL;
			}
		case 0x1015: // CAUH
			struct 
			{
				NdrAlign Pad;
				[MQMQCommonPropVariantPointerReferenceArray$[MQMQCommonPropVariantPointerReferenceCount] = VariantType, MQMQCommonPropVariantPointerReferenceCount = MQMQCommonPropVariantPointerReferenceCount + (this.CAUHPtr.ReferentID>0?1:0)]
				MQMQCAUH CAUH;
			}
		case 0x1048: // CACLSID
			struct 
			{
				NdrAlign Pad;
				[MQMQCommonPropVariantPointerReferenceArray$[MQMQCommonPropVariantPointerReferenceCount] = VariantType, MQMQCommonPropVariantPointerReferenceCount = MQMQCommonPropVariantPointerReferenceCount + (this.CACLSIDPtr.ReferentID>0?1:0)]
				MQMQCACLSID CACLSID;
			}
		case 0x101F: // CALPWSTR
			struct MQMQCALPQSTR
			{
				NdrAlign Pad;
				[MQMQCommonPropVariantPointerReferenceArray$[MQMQCommonPropVariantPointerReferenceCount] = VariantType, MQMQCommonPropVariantPointerReferenceCount = MQMQCommonPropVariantPointerReferenceCount + (this.CALPWSTRPtr.ReferentID>0?1:0)]
				MQMQCALPQSTR CALPWSTR;
			}
		case 0x100C: // CAPROPVARIANT
			struct MQMQCAPRROPVARIANT
			{
				NdrAlign Pad;
				[MQMQCommonPropVariantPointerReferenceArray$[MQMQCommonPropVariantPointerReferenceCount] = VariantType, MQMQCommonPropVariantPointerReferenceCount = MQMQCommonPropVariantPointerReferenceCount + (this.CAPROPVARIANTPtr.ReferentID>0?1:0)]
				MQMQCAPRROPVARIANT CAPROPVARIANTPtr;
			}
		Default:
			ReportParserError( ParserErrorProtocolClassWindows, "MQMR", "Unknown Union Switch Value" ) UnknownMQMQUnionValue;
	}
}

struct MQMQCommonQueueFormatUnion
{
	Switch
	{
		case Property.MSRPCNdr64:
		Align8 pad1;
	}
	UINT8			FormatTypeValue;
	Switch
	{
		case Property.MSRPCNdr64:
		Align8 padUnion;
	}
	switch( FormatTypeValue )
	{
		case 0:
			Struct{}
		case 1:
		struct
		{
			Align4 Pad;
			GUID(TRUE) PublicID;
		}
		case 2:
		struct
		{
			Align4 Pad;
			MQMQCommonObjectID PrivateID;
		}
		case 3:
			//NdrWIDESTRINGPtr	DirectID;
			[Property.MQMQDiretIDPtr=this.ReferentID]
			NdrPtr DiretIDPtr;
		case 4:
		struct
		{
			Align4 Pad;
			GUID(TRUE) MachineID;
		}
		case 5:
		struct
		{
			Align4 Pad;
			GUID(TRUE) ConnectorID;
		}
		case 6:
		struct
		{
			NdrAlign Pad2;
			[Property.DomainPtr=this.DomainPtr.ReferentID]
			MQMQCommonDistributionListID DistributionListID;
		}
		case 7:
		struct
		{
			Align4 Pad;
			MQMQCommonMultiCastID MulticastID;
		}
		case 8:
			[Property.MQMQSubQueueIDPtr=this.ReferentID]
			NdrPtr SubQueueIDPtr;
		Default:
			ReportParserError( ParserErrorProtocolClassWindows, "MQMQ", "Unknown Union Switch Value" ) ParserError;
	}
}

Struct MQMQCommonQueueFormatRef
{
	Switch
	{
		Case Property.MQMQDiretIDPtr!=0:
		NdrWideString DirectID;
	}
	Switch
	{
		Case Property.MQMQCommonDomainPtr!=0:
		MQMQCommonDistributionListIDRef DistributionListIDRef;
	}	
	Switch
	{
		Case Property.MQMQSubQueueIDPtr!=0:
		NdrWideString DirectSubqueueID;
	}
}

struct MQMQCommonConfPropVariant
{
	NdrConformant Size;
	[local.count=0,MaxLoopCount=Size.MaxCount]
	While[local.count<Size.MaxCount]
	{
		[local.count=local.count+1]
		MQMQCommonPropVariant CommonPropVariant;
	}
}

struct MQMQCommonPropVariantReferencedValues( inputVt ) = MQMQCommonDirectoryObjectPropertyValueTypeTable(inputVt)
{//These are for property-values that have a pointer-reference
	switch( inputVt )
	{
	case 0x0048: // VtCLSID
		GUID(TRUE)		puuid;
	case 0x0041: // VtBlob
		struct
		{
			NdrConformant Size;
			switch
			{
			case Size.MaxCount > 0:
				BLOB( Size.MaxCount ) Value;
			}
		}
	case 0x001F: // VtLPWSTR
		struct
		{	
			NdrWideString	StringValue;
		}
	case 0x1011: // CAUB
		struct
		{
			NdrConformant		Size;
			[local.CAUBCount=0,MaxLoopCount=Size.MaxCount]
			While[local.CAUBCount<Size.MaxCount]
			{
				[local.CAUBCount=local.CAUBCount+1]
				UINT8 Vaule;
			}
		}
	case 0x1012: // CAUI
		struct
		{
			NdrConformant Size;
			[local.Count=0,MaxLoopCount=Size.MaxCount]
			While[local.Count<Size.MaxCount]
			{
				[local.Count=local.Count+1]
				UINT16 Value;
			}
		}
	case 0x1003: // CAL
		struct
		{
			NdrConformant		Size;
			[local.Count=0,MaxLoopCount=Size.MaxCount]
			While[local.Count<Size.MaxCount]
			{
				[local.Count=local.Count+1]
				UINT32 Value;
			}
		}
	case 0x1013: // CAUL
		struct
		{
			NdrConformant Size;
			[local.Count=0,MaxLoopCount=Size.MaxCount]
			While[local.Count<Size.MaxCount]
			{
				[local.Count=local.Count+1]
				UINT32 Value;
			}
		}
	case 0x1015: // CAUH
		struct
		{
			NdrConformant		Size;
			[local.Count=0,MaxLoopCount=Size.MaxCount]
			While[local.Count<Size.MaxCount]
			{
				[local.Count=local.Count+1]
				UINT64 Value;
			}
		}
	case 0x1048: // CACLSID
		struct
		{
			NdrConformant Size;
			[local.Count=0,MaxLoopCount=Size.MaxCount]
			While[local.Count<Size.MaxCount]
			{
				[local.Count=local.Count+1]
				GUID(TRUE) Value;
			}
		}
	case 0x101F: // CALPWSTR
		struct
		{
			NdrConformant Size;
			switch
			{
			case Size.MaxCount > 0:
				struct
				{
					[local.count = 0]
					while[local.count < Size.MaxCount]
					{
						[local.count = local.count + 1]
						[MQDSCALPWSTRPtr.AddToProperty(Ptr.ReferentID, 0)]
						NdrPtr Ptr;
					}
					[local.count = 0]
					while[local.count < Size.MaxCount]
					{
						[post.local.count = local.count + 1]
						switch
						{
							case MQDSCALPWSTRPtr[local.count] > 0:
								NdrWideString Values;
						}
					}
				}
			}
		}
	case 0x100C: // CAPROPVARIANT
		struct
		{
			MQMQCommonConfPropVariant Value;
		}
	}
}

//2.2.1   MQDSPUBLICKEY
Struct MQMQDSPublicKey
{
	UINT32 KeyLen;
	UINT32 ProviderLen;
	UINT32 ProviderType=FormatString("The value MUST be PROV_RSA_FULL (0x00000001).");
	UnicodeString ProviderName;
	RDPBCGRRsaPublicKey Buffer;
}

//2.2.2   MQDSPUBLICKEYS   VT_BLOB
Struct MQMQDSPulbicKeys
{
	UINT32 ulLen;
	[local.KeyCount=this]
	UINT32 NumofKeys;
	while[local.KeyCount>0]
	{
		[local.KeyCount=local.KeyCount-1]
		MQMQDSPublicKey PublicKey;
	}
}

//2.2.3   SECURITY_INFORMATION
Struct MQMQSecurityInformation
{
	Switch( Property.MSRPCByteOrder )
	{
		case LittleEndian:
		Struct LittleEndian
		{
			UINT32 OSI:1  = FormatString("     %s (OWNER_SECURITY_INFORMATION) %sretrieve/update Owner identifier of the object", this.ToBitString, this ? "" : "Do NOT");
			UINT32 GSI:1  = FormatString("     %s (GROUP_SECURITY_INFORMATION) %sretrieve/update Primary group identifier.", this.ToBitString, this ? "" : "Do NOT");
			UINT32 DSI:1  = FormatString("     %s (DACL_SECURITY_INFORMATION) %sretrieve/update Discretionary ACL of the object", this.ToBitString, this ? "" : "Do NOT");
			UINT32 SSI:1  = FormatString("     %s (SACL_SECURITY_INFORMATION) %sretrieve/update System ACL of the object", this.ToBitString, this ? "" : "Do NOT");
			UINT32 Reserved:28 = FormatString(" %s (Reserved)", this.ToBitString);
		};
		Default:
		Struct BigEndian
		{
			UINT32 Reserved:28 = FormatString(" %s (Reserved)", this.ToBitString);
			UINT32 SSI:1  = FormatString("     %s (SACL_SECURITY_INFORMATION) %sretrieve/update System ACL of the object", this.ToBitString, this ? "" : "Do NOT");
			UINT32 DSI:1  = FormatString("     %s (DACL_SECURITY_INFORMATION) %sretrieve/update Discretionary ACL of the object", this.ToBitString, this ? "" : "Do NOT");
			UINT32 GSI:1  = FormatString("     %s (GROUP_SECURITY_INFORMATION) %sretrieve/update Primary group identifier.", this.ToBitString, this ? "" : "Do NOT");
			UINT32 OSI:1  = FormatString("     %s (OWNER_SECURITY_INFORMATION) %sretrieve/update Owner identifier of the object", this.ToBitString, this ? "" : "Do NOT");
		}
	}
}

//2.2.4   TA_ADDRESS    VT_BLOB
Struct MQMQTAAddress
{
	UINT16 AddressLength;
	UINT16 AddressType=MQMQAddressTypeTable(this);
	Switch(AddressLength)
	{
		Case 4:
		Ipv4Address Ipv4Address;
		Case 10:
		MQMQIPXAddress IPXAddress;
		Case 16:
		GUID(True) FOREIGNAddress;
		Default:
		Blob(AddressLength) BlobAddress;
	}	
}

Struct MQMQIPXAddress
{
	UINT32 NetNum;
	IPXNodeAddress nodenum;
}

Table MQMQAddressTypeTable(value)
{
	Switch(value)
	{
		case 0x0001:"IP_ADDRESS_TYPE";
		Case 0x0002:"IP_RAS_ADDRESS_TYPE ";
		Case 0x0003:"IPX_ADDRESS_TYPE";
		Case 0x0004:"FOREIGN_ADDRESS_TYPE";
		default: "Unkown Address Type";
	}
}

//2.2.5   SEQUENCE_INFO   VT_BLOB
//alignment align8
Struct MQMQSquenceInfo
{
	INT64 SeqID;
	UINT32 SeqNo;
	UINT32 PrevNo;
}

//2.2.19.1.2   TxSequenceID
Struct MQMQTxSequenceID
{
	UINT32 Ordinal;
	TIMESTAMP TimeStamp;
}

//2.2.19.1.3   MessageIdentifier    ref in MSQB
Struct MQMQMessageIdentifier
{
	GUID(True) QueueManagerGuid;
	UINT32 Ordinal;
}

//MQMSG_CLASS_NORMAL
Struct MQMQBaseHeader
{
	UINT8 VersionName=MQMQBaseHeaderVersionNumberTable(this);
	UINT8 Reserved;
	UINT16 Flags
	{
		Switch( Property.MSRPCByteOrder )
		{
			Case littleEndian:
			Struct littleEndian
			{
				UINT16 Reserved2:7 = FormatString( "       ( %s ) - %s", this.ToBitString, "Reserved bits" );
				UINT16 MessageTraceable:1 = FormatString( "( %s ) - %s", this.ToBitString, this ? "Message is traceable" : "Message is not traceable" );
				UINT16 Reserved1:2 = FormatString( "       ( %s ) - %s", this.ToBitString, "Reserved bits" );
				[Property.MQMQDebugHeaderFlag=this]
				UINT16 DebugHeader:1 = FormatString( "     ( %s ) - %s", this.ToBitString, this ? "Debug header included" : "No Debug header" );
				[Property.MQMQSessionHeaderFlag=this]
				UINT16 SessionHeader:1 = FormatString( "   ( %s ) - %s", this.ToBitString, this ? "Session header included" : "No Session header" );
				[Property.MQMQBaseHeaderInternalMessageFlag=this]
				UINT16 InternalMessage:1 = FormatString( " ( %s ) - %s", this.ToBitString, this ? "This is an Internal message" : "This is a User message" );
				UINT16 MessagePriority:3 = FormatString( " ( %s ) - Message priority = %u (7 is highest)", this.ToBitString, this );
			}
			default:
			Struct BigEndian
			{
				UINT16 MessagePriority:3 = FormatString( " ( %s ) - Message priority = %u (7 is highest)", this.ToBitString, this );
				[Property.MQMQBaseHeaderInternalMessageFlag=this]
				UINT16 InternalMessage:1 = FormatString( " ( %s ) - %s", this.ToBitString, this ? "This is an Internal message" : "This is a User message" );
				[Property.MQMQSessionHeaderFlag=this]
				UINT16 SessionHeader:1 = FormatString( "   ( %s ) - %s", this.ToBitString, this ? "Session header included" : "No Session header" );
				[Property.MQMQDebugHeaderFlag=this]
				UINT16 DebugHeader:1 = FormatString( "     ( %s ) - %s", this.ToBitString, this ? "Debug header included" : "No Debug header" );
				UINT16 Reserved1:2 = FormatString( "       ( %s ) - %s", this.ToBitString, "Reserved bits" );
				UINT16 MessageTraceable:1 = FormatString( "( %s ) - %s", this.ToBitString, this ? "Message is traceable" : "Message is not traceable" );
				UINT16 Reserved2:7 = FormatString( "       ( %s ) - %s", this.ToBitString, "Reserved bits" );
			}
		}
	}
	UINT32 Signature=MQMQBaseHeaderSignatureTable(this);
	[Property.MQMQPacketSize]
	UINT32 PacketSize;
	UINT32 TimeToReachQueue=MQMQBaseHeaderTimeToReachTable( this );
}

Table MQMQBaseHeaderVersionNumberTable( Value )
{
	Switch( Value )
	{
		Case 0x10: "V1 - Possible value.";
		Default: "Unknown";
	}
}

Table MQMQBaseHeaderSignatureTable( Value )
{
	Switch( Value )
	{
		Case 0x524F494C: "V1 - Possible value.";
		Default: "Unknown";
	}
}

Table MQMQBaseHeaderTimeToReachTable( Value )
{
	switch( value )
	{
	case 0xFFFFFFFF: "Message can reach destination queue at any time (infinite)";
	default: FormatString( "Message must reach destination queue in %u seconds", value );
	}
}

//2.2.20.2   UserHeader
Struct MQMQUserHeader
{
	GUID(True) SourceQueueManager;
	GUID(True) QueueManagerAddress;
	TIMESTAMP TImeToBeReceived = MQMQUsrHdrTimeToBeReceivedTable( this );
	UNIXTIMESTAMP SendTime;
	UINT32 MessageID;
	UINT32 Flags
	{
		Switch( Property.MSRPCByteOrder )
		{
			Case littleEndian:
			Struct littleEndian
			{
				UINT32		Reserved3:3 = FormatString( "               ( %s ) - %s", this.ToBitString, "Reserved bits" );
				[MQMQSoapHeaderFlag]
				UINT32		SoapHeader:1 = FormatString( "              ( %s ) - %s", this.ToBitString, this ? "Soap header included" : "No Soap header" );
				UINT32		Reserved2:4 = FormatString( "               ( %s ) - %s", this.ToBitString, "Reserved bits" );
				[MQMQMultiQueueFormatHeaderFlag]
				UINT32		MultiQueueFormatHeader:1 = FormatString( "  ( %s ) - %s", this.ToBitString, this ? "MultiQueueFormat header included" : "No MultiQueueFormat header" );
				[MQMQUserHeaderConnectorType]
				UINT32		ConnectorType:1 = FormatString( "           ( %s ) - %s", this.ToBitString, this ? "ConnectorType field included" : "No ConnectorType field" );
				[MQMQMessagePropertiesHeaderFlag]
				UINT32		MessagePropertiesHeader:1 = FormatString( " ( %s ) - %s", this.ToBitString, this ? "MessageProperty header included" : "No MessageProperty header" );
				[MQMQTransactionHeaderFlag]
				UINT32		TransactionHeader:1 = FormatString( "       ( %s ) - %s", this.ToBitString, this ? "Transaction header included" : "No Transaction header" );
				[MQMQSecurityHeaderFlag]
				UINT32		SecurityHeader:1 = FormatString( "          ( %s ) - %s", this.ToBitString, this ? "Security header included" : "No Security header" );
				[MQMQUserHeaderResponseQueueFlag]
				UINT32		ResponseQueue:3 = FormatString( "           ( %s ) - %s", this.ToBitString, MQMQUserHeaderResponseQueueTable(this) );
				[MQMQUserHeaderAdminQueueFlag]
				UINT32		AdminQueue:3 = FormatString( "              ( %s ) - %s", this.ToBitString, MQMQUserHeaderAdminQueueTable( this ) );
				[MQMQUserHeaderDestinationQueueFlag]
				UINT32		DestinationQueue:3 = FormatString( "        ( %s ) - %s", this.ToBitString, MQMQUserHeaderDestinationQueueTable( this ) );
				UINT32		PositiveSourceJournaling:1 = FormatString( "( %s ) - %s", this.ToBitString, this ? "Positive source journaling enabled" : "Positive source journaling not enabled" );
				UINT32		NegativeSourceJournaling:1 = FormatString( "( %s ) - %s", this.ToBitString, this ? "Negative source journaling enabled" : "Negative source journaling not enabled" );
				UINT32		Reserved1:1 = FormatString( "               ( %s ) - %s", this.ToBitString, "Reserved bit" );
				UINT32		DeliveryMode:2 = FormatString( "            ( %s ) - %s", this.ToBitString, this ? "Recoverable (persistent) messaging" : "Express (non-persistent) messaging" );
				UINT32		RoutingServerCount:5 = FormatString( "      ( %s ) - %u routing servers have processed this packet", this.ToBitString, this );
			}
			Default:
			Struct BigEndian
			{
				UINT32		RoutingServerCount:5 = FormatString( "      ( %s ) - %u routing servers have processed this packet", this.ToBitString, this );
				UINT32		DeliveryMode:2 = FormatString( "            ( %s ) - %s", this.ToBitString, this ? "Recoverable (persistent) messaging" : "Express (non-persistent) messaging" );
				UINT32		Reserved1:1 = FormatString( "               ( %s ) - %s", this.ToBitString, "Reserved bit" );
				UINT32		NegativeSourceJournaling:1 = FormatString( "( %s ) - %s", this.ToBitString, this ? "Negative source journaling enabled" : "Negative source journaling not enabled" );
				UINT32		PositiveSourceJournaling:1 = FormatString( "( %s ) - %s", this.ToBitString, this ? "Positive source journaling enabled" : "Positive source journaling not enabled" );
				[MQMQUserHeaderDestinationQueueFlag]
				UINT32		DestinationQueue:3 = FormatString( "        ( %s ) - %s", this.ToBitString, MQMQUserHeaderDestinationQueueTable( this ) );
				[MQMQUserHeaderAdminQueueFlag]
				UINT32		AdminQueue:3 = FormatString( "              ( %s ) - %s", this.ToBitString, MQMQUserHeaderAdminQueueTable( this ) );
				[MQMQUserHeaderResponseQueueFlag]
				UINT32		ResponseQueue:3 = FormatString( "           ( %s ) - %s", this.ToBitString, MQMQUserHeaderResponseQueueTable(this) );
				[MQMQSecurityHeaderFlag]
				UINT32		SecurityHeader:1 = FormatString( "          ( %s ) - %s", this.ToBitString, this ? "Security header included" : "No Security header" );
				[MQMQTransactionHeaderFlag]
				UINT32		TransactionHeader:1 = FormatString( "       ( %s ) - %s", this.ToBitString, this ? "Transaction header included" : "No Transaction header" );
				[MQMQMessagePropertiesHeaderFlag]
				UINT32		MessagePropertiesHeader:1 = FormatString( " ( %s ) - %s", this.ToBitString, this ? "MessageProperty header included" : "No MessageProperty header" );
				[MQMQUserHeaderConnectorType]
				UINT32		ConnectorType:1 = FormatString( "           ( %s ) - %s", this.ToBitString, this ? "ConnectorType field included" : "No ConnectorType field" );
				[MQMQMultiQueueFormatHeaderFlag]
				UINT32		MultiQueueFormatHeader:1 = FormatString( "  ( %s ) - %s", this.ToBitString, this ? "MultiQueueFormat header included" : "No MultiQueueFormat header" );
				UINT32		Reserved2:4 = FormatString( "               ( %s ) - %s", this.ToBitString, "Reserved bits" );
				[MQMQSoapHeaderFlag]
				UINT32		SoapHeader:1 = FormatString( "              ( %s ) - %s", this.ToBitString, this ? "Soap header included" : "No Soap header" );
				UINT32		Reserved3:3 = FormatString( "               ( %s ) - %s", this.ToBitString, "Reserved bits" );
			}
		}
	}
	MQMQDestinationQueue DestinationQueue;
	switch
	{
	case Property.MQMQUserHeaderAdminQueueFlag!= 0:
			MQMQAdminQueue AdminQueue;
	}
	switch
	{
	case Property.MQMQUserHeaderResponseQueueFlag != 0:
			MQMQResponseQueue ResponseQueue;
    }
	switch
	{
	case Property.MQMQUserHeaderConnectorType != 0:
			GUID(true) ConnectorType;

	}
}

Table MQMQUsrHdrTimeToBeReceivedTable( Value )
{
	switch( value )
	{
		case 0xFFFFFFFF: "Message can be received from destination queue at any time (infinite)";
		default: FormatString( "Message must be received from destination queue in %u seconds", value );
	}
}

Table MQMQUserHeaderDestinationQueueTable ( value )
{
	Switch( value )
	{
		case 0x3: "Destination private queue";
		case 0x5: "Public queue";
		case 0x6: "Private queue";
		case 0x7: "Direct queue";
		default: FormatString( "Value Unknown (0x%02X)", value );
	}
}

Table MQMQUserHeaderAdminQueueTable( value )
{
	switch( value )
	{
		case 0x0: "None";
		case 0x2: "Private queue on source host";
		case 0x3: "Private queue on destination host";
		case 0x5: "Public queue";
		case 0x6: "Private queue on host other than source or destination host";
		case 0x7: "Direct queue";
		default: FormatString( "Value Unknown (0x%02X)", value );
	}
}

Table MQMQUserHeaderResponseQueueTable( Value )
{
	switch( value )
	{
	case 0x0: "None";
	case 0x1: "Same as administration queue";
	case 0x2: "Private queue on source host";
	case 0x3: "Private queue on destination host";
	case 0x4: "Private";
	case 0x5: "Public queue";
	case 0x7: "Direct queue";
	default: FormatString( "Value Unknown (0x%02X)", value );
	}
}

//2.2.20.3   MessagePropertiesHeader
Struct MQMQMessagePropertiesHeader
{
	UINT8 Flags = MQMQMessagePropertiesHeaderFlagsTable( this )
	{
		Switch( Property.MSRPCByteOrder )
		{
			Case littleEndian:
			Struct littleEndian
			{
				UINT8 Unused: 4 = FormatString( "                ( %s ) - %s", this.ToBitString, "Unused bits" );
				UINT8 NackApplNotRecvMsg: 1 = FormatString( "    ( %s ) - %s", this.ToBitString, this ? "Send acknowledgment if message not received from destination queue" : "Event not acknowledged" );
				UINT8 NackMsgNotArrivesQueue: 1 = FormatString( "( %s ) - %s", this.ToBitString, this ? "Send acknowledgment if message is not delivered to destination queue" : "Event not acknowledged" );
				UINT8 AckApplRecvMsg: 1 = FormatString( "        ( %s ) - %s", this.ToBitString, this ? "Send acknowledgment if message received from destination queue" : "Event not acknowledged" );
				UINT8 AckMsgArrivesQueue: 1 = FormatString( "    ( %s ) - %s", this.ToBitString, this ? "Send acknowledgment if message delivered to destination queue" : "Event not acknowledged" );
			}
			Default:
			Struct BingEndian
			{
				UINT8 AckMsgArrivesQueue: 1 = FormatString( "    ( %s ) - %s", this.ToBitString, this ? "Send acknowledgment if message delivered to destination queue" : "Event not acknowledged" );
				UINT8 AckApplRecvMsg: 1 = FormatString( "        ( %s ) - %s", this.ToBitString, this ? "Send acknowledgment if message received from destination queue" : "Event not acknowledged" );
				UINT8 NackMsgNotArrivesQueue: 1 = FormatString( "( %s ) - %s", this.ToBitString, this ? "Send acknowledgment if message is not delivered to destination queue" : "Event not acknowledged" );
				UINT8 NackApplNotRecvMsg: 1 = FormatString( "    ( %s ) - %s", this.ToBitString, this ? "Send acknowledgment if message not received from destination queue" : "Event not acknowledged" );
				UINT8 Unused: 4 = FormatString( "                ( %s ) - %s", this.ToBitString, "Unused bits" );
			}
		}
		
	}	
	UINT8 LabelLength = FormatString( "Number of elements in MessageData Label = %u", this );
	UINT16 MessageClass = MQMQMessageClassIdentifiersTable( this );
	switch(Flags)
	{
		case 0:	BLOB( 20 ) CorrelationID;
		default:MQMQMessageIdentifier MessageIdentifier;
	}
	UINT32 BodyType = MQMQMessagePropertiesHeaderBodyTypeTable( this );
	UINT32 ApplicationTag;
	UINT32 MessageSize = FormatString( "MessageBody size %u bytes", this );
	UINT32 AllocationBodySize = FormatString( "MessageBody allocated size %u bytes", this );
	UINT32 PrivacyLevel = MQMQMessagePropertiesHeaderPrivacyLevelTable(this);
	UINT32 HashAlgorithm = MQMQMessagePropertiesHeaderHashAlgorithmTable(this);
	UINT32 EncryptionAlgorithm = MQMQMessagePropertiesHeaderEncryptionAlgorithmTable(this);
	UINT32 ExtensionSize = FormatString( "MessageData ExtensionData size %u bytes", this );
	UnicodeString( LabelLength > 250 ? 250 : labelLength ) Label;
	BLOB( ExtensionSize ) ExtensionData;
	switch(Label)
	{
		case "QM Final Ack":
		case "QM Order Ack": //OrderAck and FinalAck
		[MQQBSummary = MQQBSummary + ", Acknowledgement Packet"]
		struct AcknowledgmentPacket
		{
			MQMQTxSequenceID TxSequenceID;
			UINT32 TxSequenceNumber;
			UINT32 TxPreviousSequenceNumber;
			GUID(true) SourceGUID;
			UINT32 MessageID;
		}
		default: //User Message
		switch(Property.MQQBDestQueue)
		{
			case 3:
				Struct
				{
					MQCNNotificationHeader MQCNNotificationHeader;
					ALIGN4 Pad1;
				}
			default:
				struct MQQBMessage
				{
					BLOB( AllocationBodySize ) MessageBody;
					ALIGN4 Pad;
				}
		}
	}
}

Table MQMQMessagePropertiesHeaderFlagsTable( value )
{
	switch( value )
	{
	case 0x00: "No acknowledgment sent";
	default: "Acknowledgment sent";	
	}
}

Table MQMQMessageClassIdentifiersTable( value )
{
	switch( value )
	{
	case 0x0000: "MqMsgClassNormal - Message sent by higher-layer messaging application";
	case 0x0001: "MqMsgClassReport - Report message to track delivery of sent message";
	case 0x0002: "MqMsgClassAckReachQueue - Original message delivered to destination queue";
	case 0x4000: "MqMsgClassAckReceive - Original message retrieved from destination queue";
	case 0x8000: "MqMsgClassNackBadDstQ - Destination queue not available to sender";
	case 0x8001: "MqMsgClassNackDeleted - Message deleted by admin action before reaching destination queue";
	case 0x8002: "MqMsgClassNackReachQueueTimeout - Message did not reach destination queue before time expired";
	case 0x8003: "MqMsgClassNackQExceedQuota - Message not delivered due to full destination queue";
	case 0x8004: "MqMsgClassNackAccessDenied - Inadequate destination queue access rights for sender";
	case 0x8005: "MQMSGClassNacKHopCountExceeded - Original message was rejected because it exceeded the maximum routing hop count";
	case 0x8006: "MqMsgClassNackBadSignature - Invalid message digital signature not authenticated";
	case 0x8007: "MqMsgClassNackBadEncryption - Destination queue manager cannot decrypt private message";
	case 0x8009: "MqMsgClassNackNotTransactionalQ - Transactional message sent to non-transactional queue";
	case 0x800A: "MqMsgClassNackNotTransactionalMsg - Non-transactional message sent to transactional queue";
	case 0x800B: "MqMsgClassNackUnsupportedCryptoProvider - Unsupported cryptographic provider";
	case 0xC000: "MqMsgClassNackQDeleted - Queue deleted before message read from queue";
	case 0xC001: "MqMsgClassNackQPurged - Message does not exist because queue deleted";
	case 0xC002: "MqMsgClassNackReceiveTimeout - Message in destination queue not retrieved before time expired";
	default: FormatString( "Value Unknown (0x%02X)", value );
 	}
}

Table MQMQMessagePropertiesHeaderBodyTypeTable ( value )
{
	switch( value )
	{
	case 0: "VTEMPTY [default]"; 
 	case 1: "VTI1 [character (char) 1 byte in size]"; 
 	case 2: "VTI2 [Short integer]";
	case 3: "VTI4 [Long integer]";
	case 4: "VTR4 [Float, 4 bytes in size]";
	case 5: "VTR8 [Double float, 8 bytes in size]";
	case 6: "VTCY [CURRENCY, 8 bytes in size]";
	case 7: "VTDATE [OLE DATE type, 8 bytes in size]";
	case 8: "VTBSTR [String data in unicode]";
	case 9: "VTDISPATCH [COM Automation (IDispatch) object]";
	case 11: "VTBOOL [VARIANT BOOL type, 2 bytes in size]"; 
	case 12: "CAPROPVARIANT MUST appear with the bit flag VT_VECTOR.";
	case 13: "VTUNKNOWN [COM object (IUnknown interface)]";
	case 16: "VT_I1 [MUST be a 1-byte integer]";
	case 17: "VTUI1 [character type, 1 byte in size]";
	case 18: "VTUI2 [Short integer]";
	case 19: "VTUI4 [Long integer]";
	case 20: "VT_I8 [MUST be an 8-byte signed integer]";
	case 21: "VT_UI8 [MUST be an 8-byte unsigned integer]";
	case 30: "VTLPSTR [Null-terminated ANSI string]";
	case 31: "VTLPWSTR [Null-terminated Unicode string]";
	case 41: "VT_BLOB [MUST be a binary large object (BLOB)]";
	case 68: "VTSTREAMEDOBJECT [Persistent, serialized object whose format is the output of a call to OleSaveToStream using the IPersistStream interface]";
	case 69: "VTSTOREDOBJECT [Persistent, serialized object whose format is the output of a call to OleSave using the IPersistStorage interface]";
	case 72: "VT_CLSID [A pointer to a GUID]";
	case 0x1000: "VT_VECTOR";
	case 0x2017: "VTARRAY | VTUI1 [Array of bytes]";
	default: FormatString( "Value Unknown (0x%02X)", value );
	}
}

Table MQMQMessagePropertiesHeaderPrivacyLevelTable( Value )
{
	Switch( Value )
	{
		Case 0x00000000: "V1 - No encryption. The message body is sent as clear text.";
		Case 0x00000001: "V2 - The  MessageBody field is encrypted using 40-bit end-to-end encryption.";
		Case 0x00000003: "V3 - The  MessageBody field is encrypted using 128-bit end-to-end encryption.";
		Case 0x00000005: "V4 - The  MessageBody field is encrypted using Advanced Encryption Standard (AES).";
		Default: "Unknown";
	}
}

Table MQMQMessagePropertiesHeaderHashAlgorithmTable( Value )
{
	Switch( Value )
	{
		Case 0x00008001: "V1 - Specifies the MD2 hash algorithm. Details about the algorithm  are as specified in  [RFC1319].";
		Case 0x00008002: "V2 - Specifies the MD4 hash algorithm. Details about the algorithm are as specified in [RFC1320].";
		Case 0x00008003: "V3 - Specifies the MD5 hash algorithm. Details about the algorithm are as specified in [RFC1321].";
		Case 0x00008004: "V4 - Specifies the SHA1 hash algorithm. For more details, the algorithm specification can be found at [RFC3110].";
		Default: "Unknown";
	}
}

Table MQMQMessagePropertiesHeaderEncryptionAlgorithmTable( Value )
{
	Switch( Value )
	{
		Case 0x00006602: "V1 - Specifies the RC2 algorithm. Details about the algorithm are as specified in [RFC2268].";
		Case 0x00006610: "V2 - Specifies the AES 256 algorithm. Details about the algorithm are as specified in [FIPS197].";
		Case 0x0000660E: "V3 - Specifies the AES 128 algorithm. Details about the algorithm are as specified in [FIPS197].";
		Case 0x0000660F: "V4 - Specifies the AES 192 algorithm. Details about the algorithm are as specified in [FIPS197].";
		Case 0x00006801: "V5 - Specifies the RC4 algorithm. Details about the algorithm are as specified in [RFC4757].";
		Default: "Unknown";
	}
}

//2.2.21.1   MultiQueueFormatHeader
Struct MQMQMultiQueueFormatHeader
{
	MQMQFAddressHeader Destination;
	MQMQFAddressHeader Administration;
	MQMQFAddressHeader Response;
	MQMQFSignatureHeader Signature;
}

//2.2.21.2   MQFAddressHeader
Struct MQMQFAddressHeader
{
	[Property.MQMQMStartOffset = FrameOffset]
	UINT32 HeaderSize = FormatString( "Structure total size = %u", this );
	UINT16 HeaderID = MQMQFAddressHeaderHeaderIDTable(this);
	UINT16 Reserved;
	UINT32 ElementCount;
	MQMQFFormatNameElement FormatNameList[ElementCount];
	Switch
	{
		case FrameOffset < Property.MQMQMStartOffset + Size:
			BLOB(Property.MQMQMStartOffset + Size - FrameOffset) Pad;
	}
}

Table MQMQFAddressHeaderHeaderIDTable( Value )
{
	Switch( Value )
	{
		Case 0x0064: "V1 - Destination";
		Case 0x00C8: "V2 - Admin";
		Case 0x012C: "V3 - Response";
		Case 0x015E: "V4 - Signature";
		Default: "Unknown";
	}
}

//2.2.19.1.4   MQFFormatNameElement
Struct MQMQFFormatNameElement
{
	UINT16 FormatType = MQMQFFormatNameElementFormatTypeTable(this);
	struct FormatName
	{
		switch( FormatType )
		{
		case 1:
			Struct
			{
				Align4 Pad;
				MQMQPublicQueue pubilicQueueFormatName;
			}
		case 2:
			struct 
			{
				ALIGN4 Pad;
				MQMQPrivateQueue privateQueueFormatName;
			}
		case 3:
			struct DirectQueue
			{
				ALIGN2 Pad;
				MQMQDirectQueue directQueueFormatName;
			}
		case 6:
			MQMQDistributionQueue DistributionQueueFormatName;
		}
	}
}

Table MQMQFFormatNameElementFormatTypeTable( Value )
{
	Switch( Value )
	{
		Case 0x0001: "V1 - Public queue";
		Case 0x0002: "V2 - Private queue";
		Case 0x0003: "V3 - Direct queue";
		Case 0x0006: "V4 - Distribution list";
		Default: "Unknown";
	}
}

//2.2.21.3   MQFSignatureHeader
Struct MQMQFSignatureHeader
{
	UINT16 ID = MQMQFSignatureHeaderIDTable(this);
	UINT16 Reserved;
	UINT32 Size = MQMQFSignatureHeaderSizeTable(this);
	Blob(Size) Signature;
	Align4 Pad;
}

Table MQMQFSignatureHeaderIDTable( Value )
{
	Switch( Value )
	{
		Case 0x015E: "V1 - Possible value.";
		Default: "Unknown";
	}
}

Table MQMQFSignatureHeaderSizeTable( Value )
{
	Switch( Value )
	{
		Case 0x00000000: "V1 - Possible value.";
		Default: "Unknown";
	}
}

//2.2.21.4   SessionHeader
Struct MQMQSessionHeader
{
	UINT16 AckSequenceNumber = FormatString( "%u messages received", this );
	UINT16 RecoverableMsgAckSeqNumber = FormatString( "Lowest unacknowledged recoverable message sequence number = %u", this );
	UINT32 RecoverableMsgAckFlags
	{
		UINT32	Message0:1 = this ? "RecoverableMsgAckSequenceNumber unacknowledged message recoverable" : "Message not recoverable";
		UINT32	Message1:1 = this ? "RecoverableMsgAckSequenceNumber + 1 unacknowledged message recoverable" : "Message not recoverable";
		UINT32	Message2:1 = this ? "RecoverableMsgAckSequenceNumber + 2 unacknowledged message recoverable" : "Message not recoverable";
		UINT32	Message3:1 = this ? "RecoverableMsgAckSequenceNumber + 3 unacknowledged message recoverable" : "Message not recoverable";
		UINT32	Message4:1 = this ? "RecoverableMsgAckSequenceNumber + 4 unacknowledged message recoverable" : "Message not recoverable";
		UINT32	Message5:1 = this ? "RecoverableMsgAckSequenceNumber + 5 unacknowledged message recoverable" : "Message not recoverable";
		UINT32	Message6:1 = this ? "RecoverableMsgAckSequenceNumber + 6 unacknowledged message recoverable" : "Message not recoverable";
		UINT32	Message7:1 = this ? "RecoverableMsgAckSequenceNumber + 7 unacknowledged message recoverable" : "Message not recoverable";
		UINT32	Message8:1 = this ? "RecoverableMsgAckSequenceNumber + 8 unacknowledged message recoverable" : "Message not recoverable";
		UINT32	Message9:1 = this ? "RecoverableMsgAckSequenceNumber + 9 unacknowledged message recoverable" : "Message not recoverable";
		UINT32	Message10:1 = this ? "RecoverableMsgAckSequenceNumber + 10 unacknowledged message recoverable" : "Message not recoverable";
		UINT32	Message11:1 = this ? "RecoverableMsgAckSequenceNumber + 11 unacknowledged message recoverable" : "Message not recoverable";
		UINT32	Message12:1 = this ? "RecoverableMsgAckSequenceNumber + 12 unacknowledged message recoverable" : "Message not recoverable";
		UINT32	Message13:1 = this ? "RecoverableMsgAckSequenceNumber + 13 unacknowledged message recoverable" : "Message not recoverable";
		UINT32	Message14:1 = this ? "RecoverableMsgAckSequenceNumber + 14 unacknowledged message recoverable" : "Message not recoverable";
		UINT32	Message15:1 = this ? "RecoverableMsgAckSequenceNumber + 15 unacknowledged message recoverable" : "Message not recoverable";
		UINT32	Message16:1 = this ? "RecoverableMsgAckSequenceNumber + 16 unacknowledged message recoverable" : "Message not recoverable";
		UINT32	Message17:1 = this ? "RecoverableMsgAckSequenceNumber + 17 unacknowledged message recoverable" : "Message not recoverable";
		UINT32	Message18:1 = this ? "RecoverableMsgAckSequenceNumber + 18 unacknowledged message recoverable" : "Message not recoverable";
		UINT32	Message19:1 = this ? "RecoverableMsgAckSequenceNumber + 19 unacknowledged message recoverable" : "Message not recoverable";
		UINT32	Message20:1 = this ? "RecoverableMsgAckSequenceNumber + 20 unacknowledged message recoverable" : "Message not recoverable";
		UINT32	Message21:1 = this ? "RecoverableMsgAckSequenceNumber + 21 unacknowledged message recoverable" : "Message not recoverable";
		UINT32	Message22:1 = this ? "RecoverableMsgAckSequenceNumber + 22 unacknowledged message recoverable" : "Message not recoverable";
		UINT32	Message23:1 = this ? "RecoverableMsgAckSequenceNumber + 23 unacknowledged message recoverable" : "Message not recoverable";
		UINT32	Message24:1 = this ? "RecoverableMsgAckSequenceNumber + 24 unacknowledged message recoverable" : "Message not recoverable";
		UINT32	Message25:1 = this ? "RecoverableMsgAckSequenceNumber + 25 unacknowledged message recoverable" : "Message not recoverable";
		UINT32	Message26:1 = this ? "RecoverableMsgAckSequenceNumber + 26 unacknowledged message recoverable" : "Message not recoverable";
		UINT32	Message27:1 = this ? "RecoverableMsgAckSequenceNumber + 27 unacknowledged message recoverable" : "Message not recoverable";
		UINT32	Message28:1 = this ? "RecoverableMsgAckSequenceNumber + 28 unacknowledged message recoverable" : "Message not recoverable";
		UINT32	Message29:1 = this ? "RecoverableMsgAckSequenceNumber + 29 unacknowledged message recoverable" : "Message not recoverable";
		UINT32	Message30:1 = this ? "RecoverableMsgAckSequenceNumber + 30 unacknowledged message recoverable" : "Message not recoverable";
		UINT32	Message31:1 = this ? "RecoverableMsgAckSequenceNumber + 31 unacknowledged message recoverable" : "Message not recoverable";
	}
	UINT16 UserMsgSequenceNumber = FormatString( "%u user messages sent on this session", this );
	UINT16 RecoverableMsgSeqNumber = FormatString( "%u recoverable messages sent on this session", this );
	UINT16 WindowSize = FormatString( "Acknowledgment packets sent at frequency of %u", this );
	UINT16 Reserved = MQMQSessionHeaderReservedTable(this);
}

Table MQMQSessionHeaderReservedTable( Value )
{
	Switch( Value )
	{
		Case 0x0000: "V1 - Possible value.";
		Default: "Unknown";
	}
}

//2.2.21.5   TransactionHeader
Struct MQMQTransactionHeader
{
	UINT32 Flags
	{
		Switch( Property.MSRPCByteOrder )
		{
			Case littleEndian:
				Struct littleEndian
				{
					UINT32		Unused:8 = FormatString( "          ( %s ) - %s", this.ToBitString, "Unused bits" );
					UINT32		TransactionIndex:20 = FormatString( "( %s ) - %u = Transaction ID", this.ToBitString, this );
					UINT32		LastMsg:1 = FormatString( "         ( %s ) - %s", this.ToBitString, this ? "This is the last message in the transaction" : "This is not the last message in the transaction" );
					UINT32		FirstMsg:1 = FormatString( "        ( %s ) - %s", this.ToBitString, this ? "This is the first message in the transaction" : "This is not the first message in the transaction" );
					UINT32		FinalAck:1 = FormatString( "        ( %s ) - %s", this.ToBitString, this ? "FinalAck packet required" : "FinalAck packet not required" );
					[MQMQTransactionHeaderConnectorQMGuidFlag]
					UINT32		ConnectorQMGuid:1 = FormatString( " ( %s ) - %s", this.ToBitString, this ? "Connection queue manager used" : "Connection queue manager not used" );
				}
			Default:
				Struct BigEndian
				{
					[MQMQTransactionHeaderConnectorQMGuidFlag]
					UINT32		ConnectorQMGuid:1 = FormatString( " ( %s ) - %s", this.ToBitString, this ? "Connection queue manager used" : "Connection queue manager not used" );
					UINT32		FinalAck:1 = FormatString( "        ( %s ) - %s", this.ToBitString, this ? "FinalAck packet required" : "FinalAck packet not required" );
					UINT32		FirstMsg:1 = FormatString( "        ( %s ) - %s", this.ToBitString, this ? "This is the first message in the transaction" : "This is not the first message in the transaction" );
					UINT32		LastMsg:1 = FormatString( "         ( %s ) - %s", this.ToBitString, this ? "This is the last message in the transaction" : "This is not the last message in the transaction" );
					UINT32		TransactionIndex:20 = FormatString( "( %s ) - %u = Transaction ID", this.ToBitString, this );
					UINT32		Unused:8 = FormatString( "          ( %s ) - %s", this.ToBitString, "Unused bits" );
				}
		}
	}	
	MQMQTxSequenceID TxSequenceID;
	UINT32 TxSequenceNumber;
	UINT32 PreviousTxSequenceNumber;
	switch
	{
		case Property.MQMQTransactionHeaderConnectorQMGuidFlag== 1:
		GUID(true)		ConnectorQMGuid;
	}	
}

//2.2.21.6   SecurityHeader
Struct MQMQSecurityHeader
{
	UINT16 Flags
	{
		Switch( Property.MSRPCByteOrder )
		{
			Case littleEndian:
				Struct littleEndian
				{
					UINT16 Unused:4 = FormatString( "                     ( %s ) - %s", this.ToBitString, "Unused bits" );
					UINT16 AuthenticationSignatureType:4 = FormatString( "( %s ) - %s", this.ToBitString, MQMQSecurityHeaderAuthenticationSignatureTypeTable( this ) );
					UINT16 SecurityData:1 = FormatString( "               ( %s ) - %s", this.ToBitString, this ? "SecurityData field present" : "SecurityData field not present" );
					UINT16 DefaultEncrypted:1 = FormatString( "           ( %s ) - %s", this.ToBitString, this ? "Default encryption provider used" : "Default encryption provider not used" );
					UINT16 Encrypted:1 = FormatString( "                  ( %s ) - %s", this.ToBitString, this ? "Message encrypted" : "Message not encrypted" );
					UINT16 Authenticated:1 = FormatString( "              ( %s ) - %s", this.ToBitString, this ? "Message authenticated" : "Message not authenticated" );
					UINT16 SenderIDType:4 = FormatString( "               ( %s ) - %s", this.ToBitString, MQMQSecurityHeaderSenderIDTypeTable( this ) );
				}
			Default:
				Struct BigEndian
				{
					UINT16 SenderIDType:4 = FormatString( "               ( %s ) - %s", this.ToBitString, MQMQSecurityHeaderSenderIDTypeTable( this ) );
					UINT16 Authenticated:1 = FormatString( "              ( %s ) - %s", this.ToBitString, this ? "Message authenticated" : "Message not authenticated" );
					UINT16 Encrypted:1 = FormatString( "                  ( %s ) - %s", this.ToBitString, this ? "Message encrypted" : "Message not encrypted" );
					UINT16 DefaultEncrypted:1 = FormatString( "           ( %s ) - %s", this.ToBitString, this ? "Default encryption provider used" : "Default encryption provider not used" );
					UINT16 SecurityData:1 = FormatString( "               ( %s ) - %s", this.ToBitString, this ? "SecurityData field present" : "SecurityData field not present" );
					UINT16 AuthenticationSignatureType:4 = FormatString( "( %s ) - %s", this.ToBitString, MQMQSecurityHeaderAuthenticationSignatureTypeTable( this ) );
					UINT16 Unused:4 = FormatString( "                     ( %s ) - %s", this.ToBitString, "Unused bits" );
				}
		}
		
	}	
	UINT16 SenderIdSize;
	UINT16 EncryptionKeySize;
	UINT16 SignatureSize;
	UINT32 SenderCertSize;
	UINT32 ProviderInfoSize;
	struct SecurityData
	{
		switch
		{
		case SenderIDSize > 0:
			struct SenderID
			{
				BLOB( SenderIDSize ) SecurityID;
			}
		}
		switch
		{
		case EncryptionKeySize > 0:
			struct SenderEncryptionKey
			{
				BLOB( EncryptionKeySize ) EncryptionKey;
			}
		}
		switch
		{
		case SignatureSize > 0:
			struct PacketDigitalSignature
			{
				BLOB( SignatureSize ) DigitalSignature;
			}
		}
		switch
		{
		case SenderCertSize > 0:
			struct SenderDigitalCertificate
			{
				BLOB( SenderCertSize ) DigitalCertificate;
			}
		}
		switch
		{
		case ProviderInfoSize > 0:
			struct ProviderName
			{
				BLOB( ProviderInfoSize ) Name;
			}
		}		
		Align4 Pad;
	}

}

Table MQMQSecurityHeaderSenderIDTypeTable( value )
{
	switch( value )
	{
	case 0x0: "MQMSG_SENDERID_TYPE_NONE - SecurityID field is not present and SenderIdSize must be 0";
	case 0x1: "MQMSG_SENDERID_TYPE_SID - SecurityID field must contain the sender application SID";
	case 0x2: "MQMSG_SENDERID_TYPE_QM - SecurityID field must contain the queue manager GUID";
	default: FormatString( "Value Unknown (0x%02X)", value );
	}
}

Table MQMQSecurityHeaderAuthenticationSignatureTypeTable( value )
{
	switch( value )
	{
	case 0x0: "None";
	case 0x1: "Hash recipe 1";
	case 0x3: "Hash recipe 3";
	case 0x5: "Hash recipe 5";
	case 0xB: "Hash recipe 11";
	}
}

//2.2.21.7   SoapHeader
Struct MQMQSoapHeader
{
	UINT16 HeaderSectionID = MQMQSoapHeaderHeaderSectionIDTable(this);
	UINT16 Reserved;
	UINT32 HeaderDataLength;
	UnicodeString Header;
	UINT16 BodySectionID = MQMQSoapHeaderBodySectionIDTable(this);
	UINT16 Reserved1;
	UINT32 BodyDataLength;
	UnicodeString Body;
	Align4 Pad;
}

Table MQMQSoapHeaderHeaderSectionIDTable( Value )
{
	Switch( Value )
	{
		Case 0x0320: "V1 - Possible value.";
		Default: "Unknown";
	}
}
Table MQMQSoapHeaderBodySectionIDTable( Value )
{
	Switch( Value )
	{
		Case 0x0384: "V1 - Possible value.";
		Default: "Unknown";
	}
}

//2.2.21.8   DebugHeader
Struct MQMQDebugHeader
{
	UINT16 Flags
	{
		Switch( Property.MSRPCByteOrder )
		{
			Case littleEndian:
			Struct littleEndian
			{
				UINT16 Unused:14 = "(" + this.ToBitString + ") - Unused bits";
				[Property.MQMQDebugHeaderQueueType=this]
				UINT16 QueueType:2 = MQMQDebugFlagsQueueTypeTable(this);
			}
			Default:
			Struct BigEndian
			{
				[Property.MQMQDebugHeaderQueueType=this]
				UINT16 QueueType:2 = MQMQDebugFlagsQueueTypeTable(this);
				UINT16 Unused:14 = "(" + this.ToBitString + ") - Unused bits";
			}
		}
	}
	UINT16 Reserved;
	switch( Property.MQMQDebugHeaderQueueType)
	{
	//case 0: NO queue.
	case 1: // Public queue.
		GUID(true) QueueIdentifier;
	}
}

Table MQMQDebugFlagsQueueTypeTable( value )
{
	switch( value )
	{
	case 0x0: "No queue";
	case 0x1: "Public queue";
	default: FormatString( "Value Unknown (0x%02X)", value );	
	}
}

//2.2.22   MQUSERSIGNCERTS
Struct MQMQuserSigncerts
{
	[Post.Property.MQMQCertificateCount=this]
	UINT32 CertificateCount;
	[local.count=0,MaxLoopCount=CertificateCount]
	while[local.count<CertificateCount]
	{
		[local.count=local.count+1]
		MQMQuserSigncert userSigncert;
	}
}

//2.2.23   MQUSERSIGNCERT
Struct MQMQuserSigncert
{
	Blob(16) Digest;
	Guid(True) Identifier;
	UINT32 CertificateLength;
	X509Certificate Certificate;
	//Blob(CertificateLength) Certificate;
}

//2.2.25   MQQUEUEACCESSMASK
Struct MQMQQUEUEACCESSMASK
{
	UINT32 AccessMask=MQMQQUEUEACCESSMASKTable(this);
}

Table MQMQQUEUEACCESSMASKTable(value)
{
	Switch(value)
	{
		Case 0x00000001:"MQSEC_DELETE_MESSAGE, Specifies the permission required by a security principal to delete messages from the queue.";
		Case 0x00000002:"MQSEC_PEEK_MESSAGE, Specifies the permission required by a security principal to peek messages from the queue.";
		Case 0x00000004:"MQSEC_WRITE_MESSAGE, Specifies the permission required by a security principal to insert messages into the queue.";
		Case 0x00000008:"MQSEC_DELETE_JOURNAL_MESSAGE, Specifies the permission required by a security principal to delete messages from the queue journal associated with the queue.";
		Case 0x00000010:"MQSEC_SET_QUEUE_PROPERTIES, Specifies the permission required by a security principal to modify the properties of the queue.";
		Case 0x00000020:"MQSEC_GET_QUEUE_PROPERTIES, Specifies the permission required by a security principal to read the properties of the queue.";
		Case 0x00010000:"MQSEC_DELETE_QUEUE, Specifies the permission required by a security principal to delete a queue.";
		Case 0x00020000:"MQSEC_GET_QUEUE_PERMISSIONS, Specifies the permission required by a security principal to read the permissions for the queue.";
		Case 0x00040000:"MQSEC_CHANGE_QUEUE_PERMISSIONS ,Specifies the permission required by a security principal to modify the permissions for the queue.";
		Case 0x00080000:"MQSEC_TAKE_QUEUE_OWNERSHIP, Specifies the permission required by a security principal to change the owner for the queue.";
		Case 0x00000003:"MQSEC_RECEIVE_MESSAGE ,Specifies the permission required by a security principal to destructively read a message from the queue.";
		Case 0x0000000A:"MQSEC_RECEIVE_JOURNAL_MESSAGE Specifies the permission required by a security principal to destructively read a message from the queue journal associated with the queue.";
		Case 0x0000003D:"MQSEC_QUEUE_GENERIC_READ, Specifies the permission required by a security principal to read the queue properties, read the queue permissions, and destructively receive messages from the queue or the associated queue journal.";
		Case 0x00000034:"MQSEC_QUEUE_GENERIC_WRITE, Specifies the permission required by a security principal to read the queue properties, read the queue permissions, and insert messages into the queue.";
		Case 0x000F003F:"MQSEC_QUEUE_GENERIC_ALL,  Specifies the permission required by a security principal to perform all of the operations listed previously.";
	}
}

//2.2.26   MQSITEACCESSMASK
Struct MQMQSITEACCESSMASK
{
	UINT32 SITEACCESSMASK=MQMQSITEACCESSMASKTable(this);
}

Table MQMQSITEACCESSMASKTable(value)
{
	Switch(value)
	{
		Case 0x00000001:"MQSEC_CREATE_FRS, Specifies the permission required by a security principal to add a routing server to the site.";
		Case 0x00000002:"MQSEC_CREATE_BSC, Specifies the permission required by a security principal to create a Backup Site Controller (BSC) for the site.";
		Case 0x00000004:"MQSEC_CREATE_MACHINE, Specifies the permission required by a security principal to add a queue manager to the site.";
		Case 0x00000010:"MQSEC_SET_SITE_PROPERTIES, Specifies the permission required by a security principal to modify properties of the site.";
		Case 0x00000020:"MQSEC_GET_SITE_PROPERTIES, Specifies the permission required by a security principal to read properties of the site.";
		Case 0x00010000:"MQSEC_DELETE_SITE, Specifies the permission required by a security principal to delete the site.";
		Case 0x00020000:"MQSEC_GET_SITE_PERMISSIONS,  Specifies the permission required by a security principal to read permissions for the site.";
		Case 0x00040000:"MQSEC_CHANGE_SITE_PERMISSIONS, Specifies the permission required by a security principal to modify permissions for the site.";
		Case 0x00080000:"MQSEC_TAKE_SITE_OWNERSHIP, Specifies the permission required by a security principal to modify the owner of the site.";
		Case 0x00020020:"MQSEC_SITE_GENERIC_READ, Specifies the permission required by a security principal to read the properties and permissions for the site.";
		Case 0x00020024:"MQSEC_SITE_GENERIC_WRITE,  Specifies the permission required by a security principal to read properties, read permissions, and add queue managers to the site.";
		Case 0x000F0037:"MQSEC_SITE_GENERIC_ALL, Specifies the permission required by a security principal to perform all of the operations listed previously.";
	}
}

//2.2.27   MQENTACCESSMASK
Struct MQMQENTACCESSMASK
{
	UINT32 EntAccessMask=MQMQENTACCESSMASKTable(this);
}

Table MQMQENTACCESSMASKTable(value)
{
	Switch(value)
	{
		Case 0x00000001:"MQSEC_CREATE_USER, pecifies the permission required by a security principal to add a user to the enterprise.";
		Case 0x00000002:"MQSEC_CREATE_SITE, Specifies the permission required by a security principal to create a site in the enterprise.";
		Case 0x00000004:"MQSEC_CREATE_CN, Specifies the permission required by a security principal to create a connected network in the enterprise.";
		Case 0x00000010:"MQSEC_SET_ENTERPRISE_PROPERTIES, Specifies the permission required by a security principal to modify properties of the enterprise.";
		Case 0x00000020:"MQSEC_GET_ENTERPRISE_PROPERTIES, Specifies the permission required by a security principal to read properties of the enterprise.";
		Case 0x00010000:"MQSEC_DELETE_ENTERPRISE,  Specifies the permission required by a security principal to delete the enterprise.";
		Case 0x00020000:"MQSEC_GET_ENTERPRISE_PERMISSIONS, Specifies the permission required by a security principal to read permissions for the enterprise.";
		Case 0x00040000:"MQSEC_CHANGE_ENTERPRISE_PERMISSIONS, Specifies the permission required by a security principal to modify the owner of the enterprise.";
		Case 0x00080000:"MQSEC_TAKE_ENTERPRISE_OWNERSHIP, Specifies the permission required by a security principal to modify the owner of the enterprise.";
		Case 0x00020021:" MQSEC_ENTERPRISE_GENERIC_READ,  Specifies the permission required by a security principal to read the properties and permissions for the enterprise, and create users.";
		Case 0x00020027:" MQSEC_ENTERPRISE_GENERIC_WRITE, Specifies the permission required by a security principal to read properties and permissions, and to add users, connected networks, and sites to the enterprise.";
		Case 0x000F0037:"MQSEC_ENTERPRISE_GENERIC_ALL, Specifies the permission required by a security principal to perform all of the operations listed previously.";
	}
}

//2.2.28   MQCNACCESSMASK
Struct MQMQCNACCESSMASK
{
	UINT32 CnAccessMask=MQMQCNACCESSMASKTable(this);
}

Table MQMQCNACCESSMASKTable(value)
{
	Switch(value)
	{
		Case 0x00000001:"MQSEC_CN_OPEN_CONNECTOR, Specifies the permission required by a security principal to open a connector queue in the connected network.";
		Case 0x00000010:"MQSEC_SET_CN_PROPERTIES, Specifies the permission required by a security principal to modify properties of the connected network.";
		Case 0x00000020:"MQSEC_GET_CN_PROPERTIES, Specifies the permission required by a security principal to read permissions for the connected network.";
		Case 0x00010000:"MQSEC_DELETE_CN, Specifies the permission required by a security principal to delete the connected network.";
		Case 0x00020000:"MQSEC_GET_CN_PERMISSIONS, Specifies the permission required by a security principal to read permissions for the connected network.";
		Case 0x00040000:"MQSEC_CHANGE_CN_PERMISSIONS, Specifies the permission required by a security principal to modify permissions for the site.";
		Case 0x00080000:"MQSEC_TAKE_CN_OWNERSHIP, Specifies the permission required by a security principal to modify the owner of the connected network.";
		Case 0x00020020:"MQSEC_CN_GENERIC_READ, Specifies the permission required by a security principal to read properties and permissions of the connected network.";
		Case 0x00020030:"EC_CN_GENERIC_WRITE, Specifies the permission required by a security principal to read properties and permissions of the connected network.";//tdi 
		Case 0x000F0030:"SEC_CN_GENERIC_ALL, Specifies the permission required by a security principal to perform all of the operations listed previously.";
	}
}

//2.2.15   BLOB
struct MQMQBlob
{
	UINT32 Size;
	NdrPtr BlobPtr;
}

//2.2.16.1   CAUB
struct MQMQCAUB
{
	UINT32 Size;
	NdrPtr CAUBPtr;
}

//2.2.16.2   CAUI
struct MQMQCAUI
{
	UINT32 Size;
	NdrPtr CAUBPtr;
}

//2.2.16.3   CAL
struct MQMQCAL
{
	UINT32 Size;
	NdrPtr CALPtr;
}

//2.2.16.4   CAUL
struct MQMQCAUL
{
	UINT32 Size;
	NdrPtr CAULPtr;
}

//2.2.16.5   CAUH
struct MQMQCAUH
{
	UINT32 Size;
	NdrPtr CAUHPtr;
}

//2.2.16.6   CACLSID
struct MQMQCACLSID
{
	UINT32 Size;
	NdrPtr CACLSIDPtr;
}

//2.2.16.7   CALPWSTR
struct MQMQCALPQSTR
{
	UINT32 Size;
	NdrPtr CALPWSTRPtr;
}

//2.2.16.8   CAPROPVARIANT
struct MQMQCAPRROPVARIANT
{
	UINT32 Size;
	NdrPtr CAPROPVARIANTPtr;
}

struct MQMQDestinationQueue
{
	switch( MQMQUserHeaderDestinationQueueFlag )
	{
	case 3:
		[Property.MQQBDestQueue]
		UINT32					DestinationPrivateQueue;
	case 5:
		[Conversation.MQQBDestQueueGUID]
		GUID(true)				PublicQueue;
	case 6:
		[Property.MQQBDestQueue]
		UINT32					PrivateQueue;
	case 7:
		MQMQDirectQueue			DirectQueue;
	}
}

struct MQMQResponseQueue
{
	switch( MQMQUserHeaderResponseQueueFlag )
	{
	//case 1: No data consumed (Response queue is the same as the administration queue for this case).
	case 2:
		UINT32						PrivateSourceQueue;
	case 3:
		UINT32						PrivateDestinationQueue;
	case 4:
		MQMQPrivateQueue		PrivateOtherQueue;
	case 5:
		GUID(true)					PublicQueue;
	case 7:
		MQMQDirectQueue				DirectQueue;
	}
}

struct MQMQAdminQueue
{
	switch( MQMQUserHeaderAdminQueueFlag )
	{
	case 2:
		UINT32 PrivateSourceQueue;
	case 3:
		UINT32 PrivateDestinationQueue;
	case 5:
		GUID(true) PublicQueue;
	case 6:
		MQMQPrivateQueue PrivateOtherQueue;
	case 7:
		MQMQDirectQueue DirectQueue;
	}
}

//2.2.19.1.7.2   PrivateQueueFormatName
struct MQMQPrivateQueue
{
	GUID(true)		SourceQueueManager;
	UINT32			PrivateQueueIdentifier;
}

//2.2.19.1.5.2   DirectQueueFormatName
struct MQMQDirectQueue
{
	UINT16 Length;
	[Conversation.MQQBDestQueueName]
	UnicodeString	QueueName;
	Align4 PadEnd;
}

//2.2.19.1.7.1   PublicQueueFormatName
Struct MQMQPublicQueue
{
	GUID(true) PublicQueue;
}

//2.2.19.1.4.2   MQFDistributionQueueFormatName
Struct MQMQDistributionQueue
{
	Align4 Pad;
	Guid(True) DistributionListIdentifier;
}

Table MQMQCommonPropVariantUnionBoolTable( Value )
{
	Switch( Value )
	{
		Case 0xFFFF:"VARIANT_TRUE - MUST indicate a Boolean value of TRUE.";
		Case 0x000: "VARIANT_FALSE - MUST indicate a Boolean value of FALSE.";
		Default : "Unkown bool value.";
	}
}
