//#  (c) 2009 CodePlex Foundation
//#
//#  Title:                  Windows Update Services: Client-Server Protocol
//#
//#  Details:                
//#
//#  Microsoft References:   [MS-WUSP]: Windows Update Services: Client-Server Protocol Specification (8.0)
//#
//#  Comments:               
//#
//#  Revision Class and Date:Major, 3/5/2009
//#                          Minor, 3/11/2009
//#
//####

[Property.SoapBodySummary = "WUSP Payload"]
[RegisterBefore(SoapBody.DefaultSoapBody, WUSP, WUSPsawsSoapActionTable(Property.SOAPAction) || WUSPcwsSoapActionTable(Property.SOAPAction) || WUSPsdSoapActionTable(Property.SOAPAction))]
Protocol WUSP = Property.WUSPSummary
{
	Switch
	{
		Case WUSPsawsSoapActionTable(Property.SOAPAction):
			[Property.WUSPSummary = this.ToString]
			WUSPsaws WUSPsaws;
		Case WUSPcwsSoapActionTable(Property.SOAPAction):
			[Property.WUSPSummary = this.ToString]
			WUSPcws WUSPcws;
		Case WUSPsdSoapActionTable(Property.SOAPAction):
			[Property.WUSPSummary = this.ToString]
			WUSPsd WUSPsd;
	}
	
}

//
// Element GetAuthorizationCookie
// Embedded ComplexType 
//
struct WUSPsawsGetAuthorizationCookieElement = this.STag.ToString
{
	[Post.Local.WUSPsawsGetAuthorizationCookieElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("GetAuthorizationCookie") STag;
	switch
	{
		Case !Local.WUSPsawsGetAuthorizationCookieElement_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "clientId") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct ClientId = this.ClientId
						{
							[Post.Local.ClientId_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("clientId") STag;
							switch
							{
								Case !Local.ClientId_IsEmpty:
									struct
									{
										StringTerm(Property.XMLEncoding, "<", true, false, false) ClientId;
										XmlTag("clientId") ETag;
									}
							}
						}
						
				}
				
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "targetGroupName") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct TargetGroupName = this.TargetGroupName
						{
							[Post.Local.TargetGroupName_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("targetGroupName") STag;
							switch
							{
								Case !Local.TargetGroupName_IsEmpty:
									struct
									{
										StringTerm(Property.XMLEncoding, "<", true, false, false) TargetGroupName;
										XmlTag("targetGroupName") ETag;
									}
							}
						}
						
				}
				
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "dnsName") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct DnsName = this.DnsName
						{
							[Post.Local.DnsName_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("dnsName") STag;
							switch
							{
								Case !Local.DnsName_IsEmpty:
									struct
									{
										StringTerm(Property.XMLEncoding, "<", true, false, false) DnsName;
										XmlTag("dnsName") ETag;
									}
							}
						}
						
				}
				
				XmlTag("GetAuthorizationCookie") ETag;
			}
	}
}

//
// Element GetAuthorizationCookieResponse
// Embedded ComplexType 
//
struct WUSPsawsGetAuthorizationCookieResponseElement = this.STag.ToString
{
	[Post.Local.WUSPsawsGetAuthorizationCookieResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("GetAuthorizationCookieResponse") STag;
	switch
	{
		Case !Local.WUSPsawsGetAuthorizationCookieResponseElement_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetAuthorizationCookieResult") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct GetAuthorizationCookieResult = this.STag.ToString
						{
							[Post.Local.GetAuthorizationCookieResult_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("GetAuthorizationCookieResult") STag;
							switch
							{
								Case !Local.GetAuthorizationCookieResult_IsEmpty:
									struct
									{
										WUSPsawsAuthorizationCookie GetAuthorizationCookieResult;
										XmlTag("GetAuthorizationCookieResult") ETag;
									}
							}
						}
						
				}
				
				XmlTag("GetAuthorizationCookieResponse") ETag;
			}
	}
}

//
// ComplexType AuthorizationCookie
//
Struct WUSPsawsAuthorizationCookie
{
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "PlugInId") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct PlugInId = this.PlugInId
			{
				[Post.Local.PlugInId_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("PlugInId") STag;
				switch
				{
					Case !Local.PlugInId_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) PlugInId;
							XmlTag("PlugInId") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "CookieData") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct CookieData = this.CookieData
			{
				[Post.Local.CookieData_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("CookieData") STag;
				switch
				{
					Case !Local.CookieData_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) CookieData;
							XmlTag("CookieData") ETag;
						}
				}
			}
			
	}
	
}

Struct WUSPsaws = Property.WUSPsawsSummary
{
	Switch(Property.SOAPAction)
	{
		Case "http://www.microsoft.com/SoftwareDistribution/Server/SimpleAuthWebService/GetAuthorizationCookie":
			[Property.WUSPsawsSummary = this.ToString]
			WUSPGetAuthorizationCookie WUSPGetAuthorizationCookie;
		Default:
			While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
			{
				XmlElement(true) AnyNode;
			}
	}
	
}

struct WUSPGetAuthorizationCookie = FormatString("%s Message", Property.WUSPGetAuthorizationCookieSummary)
{
	[Post.Local.WUSPGetAuthorizationCookie_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.WUSPGetAuthorizationCookie_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetAuthorizationCookieResponse"):
						[Property.WUSPGetAuthorizationCookieSummary = "GetAuthorizationCookie Response"]
						WUSPsawsGetAuthorizationCookieResponseElement GetAuthorizationCookieResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetAuthorizationCookie"):
						[Property.WUSPGetAuthorizationCookieSummary = "GetAuthorizationCookie Request"]
						WUSPsawsGetAuthorizationCookieElement GetAuthorizationCookie;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.WUSPGetAuthorizationCookieSummary = "Fault GetAuthorizationCookie Response"]
						SoapFaultElement FaultGetAuthorizationCookieElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WUSPGetAuthorizationCookieSummary = "Encrypted GetAuthorizationCookie Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

//
// Element GetConfig
// Embedded ComplexType 
//
struct WUSPcwsGetConfigElement = this.STag.ToString
{
	[Post.Local.WUSPcwsGetConfigElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("GetConfig") STag;
	switch
	{
		Case !Local.WUSPcwsGetConfigElement_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "protocolVersion") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct ProtocolVersion = this.ProtocolVersion
						{
							[Post.Local.ProtocolVersion_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("protocolVersion") STag;
							switch
							{
								Case !Local.ProtocolVersion_IsEmpty:
									struct
									{
										StringTerm(Property.XMLEncoding, "<", true, false, false) ProtocolVersion;
										XmlTag("protocolVersion") ETag;
									}
							}
						}
						
				}
				
				XmlTag("GetConfig") ETag;
			}
	}
}

//
// Element GetConfigResponse
// Embedded ComplexType 
//
struct WUSPcwsGetConfigResponseElement = this.STag.ToString
{
	[Post.Local.WUSPcwsGetConfigResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("GetConfigResponse") STag;
	switch
	{
		Case !Local.WUSPcwsGetConfigResponseElement_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetConfigResult") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct GetConfigResult = this.STag.ToString
						{
							[Post.Local.GetConfigResult_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("GetConfigResult") STag;
							switch
							{
								Case !Local.GetConfigResult_IsEmpty:
									struct
									{
										WUSPcwsConfig GetConfigResult;
										XmlTag("GetConfigResult") ETag;
									}
							}
						}
						
				}
				
				XmlTag("GetConfigResponse") ETag;
			}
	}
}

//
// ComplexType Config
//
Struct WUSPcwsConfig
{
	struct LastChange = this.LastChange
	{
		[Post.Local.LastChange_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("LastChange") STag;
		switch
		{
			Case !Local.LastChange_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) LastChange;
					XmlTag("LastChange") ETag;
				}
		}
	}
	
	struct IsRegistrationRequired = this.IsRegistrationRequired
	{
		[Post.Local.IsRegistrationRequired_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("IsRegistrationRequired") STag;
		switch
		{
			Case !Local.IsRegistrationRequired_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) IsRegistrationRequired;
					XmlTag("IsRegistrationRequired") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "AuthInfo") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct AuthInfo = this.STag.ToString
			{
				[Post.Local.AuthInfo_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("AuthInfo") STag;
				switch
				{
					Case !Local.AuthInfo_IsEmpty:
						struct
						{
							WUSPcwsArrayOfAuthPlugInInfo AuthInfo;
							XmlTag("AuthInfo") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "AllowedEventIds") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct AllowedEventIds = this.STag.ToString
			{
				[Post.Local.AllowedEventIds_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("AllowedEventIds") STag;
				switch
				{
					Case !Local.AllowedEventIds_IsEmpty:
						struct
						{
							WUSPcwsArrayOfInt AllowedEventIds;
							XmlTag("AllowedEventIds") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Properties") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Properties = this.STag.ToString
			{
				[Post.Local.Properties_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Properties") STag;
				switch
				{
					Case !Local.Properties_IsEmpty:
						struct
						{
							WUSPcwsArrayOfConfigurationProperty Properties;
							XmlTag("Properties") ETag;
						}
				}
			}
			
	}
	
}

//
// ComplexType ArrayOfAuthPlugInInfo
//
Struct WUSPcwsArrayOfAuthPlugInInfo
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "AuthPlugInInfo") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct AuthPlugInInfo = this.STag.ToString
		{
			[Post.Local.AuthPlugInInfo_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("AuthPlugInInfo") STag;
			switch
			{
				Case !Local.AuthPlugInInfo_IsEmpty:
					struct
					{
						WUSPcwsAuthPlugInInfo AuthPlugInInfo;
						XmlTag("AuthPlugInInfo") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType AuthPlugInInfo
//
Struct WUSPcwsAuthPlugInInfo
{
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "PlugInID") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct PlugInID = this.PlugInID
			{
				[Post.Local.PlugInID_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("PlugInID") STag;
				switch
				{
					Case !Local.PlugInID_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) PlugInID;
							XmlTag("PlugInID") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ServiceUrl") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct ServiceUrl = this.ServiceUrl
			{
				[Post.Local.ServiceUrl_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("ServiceUrl") STag;
				switch
				{
					Case !Local.ServiceUrl_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) ServiceUrl;
							XmlTag("ServiceUrl") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Parameter") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Parameter = this.Parameter
			{
				[Post.Local.Parameter_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Parameter") STag;
				switch
				{
					Case !Local.Parameter_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) Parameter;
							XmlTag("Parameter") ETag;
						}
				}
			}
			
	}
	
}

//
// ComplexType ArrayOfInt
//
Struct WUSPcwsArrayOfInt
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "int") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct Int = this.Int
		{
			[Post.Local.Int_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("int") STag;
			switch
			{
				Case !Local.Int_IsEmpty:
					struct
					{
						StringTerm(Property.XMLEncoding, "<", true, false, false) Int;
						XmlTag("int") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType ArrayOfConfigurationProperty
//
Struct WUSPcwsArrayOfConfigurationProperty
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ConfigurationProperty") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct ConfigurationProperty = this.STag.ToString
		{
			[Post.Local.ConfigurationProperty_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("ConfigurationProperty") STag;
			switch
			{
				Case !Local.ConfigurationProperty_IsEmpty:
					struct
					{
						WUSPcwsConfigurationProperty ConfigurationProperty;
						XmlTag("ConfigurationProperty") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType ConfigurationProperty
//
Struct WUSPcwsConfigurationProperty
{
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Name") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Name = this.Name
			{
				[Post.Local.Name_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Name") STag;
				switch
				{
					Case !Local.Name_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) Name;
							XmlTag("Name") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Value") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Value = this.Value
			{
				[Post.Local.Value_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Value") STag;
				switch
				{
					Case !Local.Value_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) Value;
							XmlTag("Value") ETag;
						}
				}
			}
			
	}
	
}

//
// Element GetCookie
// Embedded ComplexType 
//
struct WUSPcwsGetCookieElement = this.STag.ToString
{
	[Post.Local.WUSPcwsGetCookieElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("GetCookie") STag;
	switch
	{
		Case !Local.WUSPcwsGetCookieElement_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "authCookies") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct AuthCookies = this.STag.ToString
						{
							[Post.Local.AuthCookies_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("authCookies") STag;
							switch
							{
								Case !Local.AuthCookies_IsEmpty:
									struct
									{
										WUSPcwsArrayOfAuthorizationCookie AuthCookies;
										XmlTag("authCookies") ETag;
									}
							}
						}
						
				}
				
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "oldCookie") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct OldCookie = this.STag.ToString
						{
							[Post.Local.OldCookie_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("oldCookie") STag;
							switch
							{
								Case !Local.OldCookie_IsEmpty:
									struct
									{
										WUSPcwsCookie OldCookie;
										XmlTag("oldCookie") ETag;
									}
							}
						}
						
				}
				
				struct LastChange = this.LastChange
				{
					[Post.Local.LastChange_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("lastChange") STag;
					switch
					{
						Case !Local.LastChange_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) LastChange;
								XmlTag("lastChange") ETag;
							}
					}
				}
				
				struct CurrentTime = this.CurrentTime
				{
					[Post.Local.CurrentTime_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("currentTime") STag;
					switch
					{
						Case !Local.CurrentTime_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) CurrentTime;
								XmlTag("currentTime") ETag;
							}
					}
				}
				
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "protocolVersion") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct ProtocolVersion = this.ProtocolVersion
						{
							[Post.Local.ProtocolVersion_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("protocolVersion") STag;
							switch
							{
								Case !Local.ProtocolVersion_IsEmpty:
									struct
									{
										StringTerm(Property.XMLEncoding, "<", true, false, false) ProtocolVersion;
										XmlTag("protocolVersion") ETag;
									}
							}
						}
						
				}
				
				XmlTag("GetCookie") ETag;
			}
	}
}

//
// ComplexType ArrayOfAuthorizationCookie
//
Struct WUSPcwsArrayOfAuthorizationCookie
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "AuthorizationCookie") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct AuthorizationCookie = this.STag.ToString
		{
			[Post.Local.AuthorizationCookie_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("AuthorizationCookie") STag;
			switch
			{
				Case !Local.AuthorizationCookie_IsEmpty:
					struct
					{
						WUSPcwsAuthorizationCookie AuthorizationCookie;
						XmlTag("AuthorizationCookie") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType AuthorizationCookie
//
Struct WUSPcwsAuthorizationCookie
{
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "PlugInId") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct PlugInId = this.PlugInId
			{
				[Post.Local.PlugInId_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("PlugInId") STag;
				switch
				{
					Case !Local.PlugInId_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) PlugInId;
							XmlTag("PlugInId") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "CookieData") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct CookieData = this.CookieData
			{
				[Post.Local.CookieData_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("CookieData") STag;
				switch
				{
					Case !Local.CookieData_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) CookieData;
							XmlTag("CookieData") ETag;
						}
				}
			}
			
	}
	
}

//
// ComplexType Cookie
//
Struct WUSPcwsCookie
{
	struct Expiration = this.Expiration
	{
		[Post.Local.Expiration_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("Expiration") STag;
		switch
		{
			Case !Local.Expiration_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) Expiration;
					XmlTag("Expiration") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct EncryptedData = this.EncryptedData
			{
				[Post.Local.EncryptedData_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("EncryptedData") STag;
				switch
				{
					Case !Local.EncryptedData_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) EncryptedData;
							XmlTag("EncryptedData") ETag;
						}
				}
			}
			
	}
	
}

//
// Element GetCookieResponse
// Embedded ComplexType 
//
struct WUSPcwsGetCookieResponseElement = this.STag.ToString
{
	[Post.Local.WUSPcwsGetCookieResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("GetCookieResponse") STag;
	switch
	{
		Case !Local.WUSPcwsGetCookieResponseElement_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetCookieResult") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct GetCookieResult = this.STag.ToString
						{
							[Post.Local.GetCookieResult_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("GetCookieResult") STag;
							switch
							{
								Case !Local.GetCookieResult_IsEmpty:
									struct
									{
										WUSPcwsCookie GetCookieResult;
										XmlTag("GetCookieResult") ETag;
									}
							}
						}
						
				}
				
				XmlTag("GetCookieResponse") ETag;
			}
	}
}

//
// Element RegisterComputer
// Embedded ComplexType 
//
struct WUSPcwsRegisterComputerElement = this.STag.ToString
{
	[Post.Local.WUSPcwsRegisterComputerElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("RegisterComputer") STag;
	switch
	{
		Case !Local.WUSPcwsRegisterComputerElement_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "cookie") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct Cookie = this.STag.ToString
						{
							[Post.Local.Cookie_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("cookie") STag;
							switch
							{
								Case !Local.Cookie_IsEmpty:
									struct
									{
										WUSPcwsCookie Cookie;
										XmlTag("cookie") ETag;
									}
							}
						}
						
				}
				
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "computerInfo") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct ComputerInfo = this.STag.ToString
						{
							[Post.Local.ComputerInfo_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("computerInfo") STag;
							switch
							{
								Case !Local.ComputerInfo_IsEmpty:
									struct
									{
										WUSPcwsComputerInfo ComputerInfo;
										XmlTag("computerInfo") ETag;
									}
							}
						}
						
				}
				
				XmlTag("RegisterComputer") ETag;
			}
	}
}

//
// ComplexType ComputerInfo
//
Struct WUSPcwsComputerInfo
{
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "DnsName") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct DnsName = this.DnsName
			{
				[Post.Local.DnsName_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("DnsName") STag;
				switch
				{
					Case !Local.DnsName_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) DnsName;
							XmlTag("DnsName") ETag;
						}
				}
			}
			
	}
	
	struct OSMajorVersion = this.OSMajorVersion
	{
		[Post.Local.OSMajorVersion_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("OSMajorVersion") STag;
		switch
		{
			Case !Local.OSMajorVersion_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) OSMajorVersion;
					XmlTag("OSMajorVersion") ETag;
				}
		}
	}
	
	struct OSMinorVersion = this.OSMinorVersion
	{
		[Post.Local.OSMinorVersion_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("OSMinorVersion") STag;
		switch
		{
			Case !Local.OSMinorVersion_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) OSMinorVersion;
					XmlTag("OSMinorVersion") ETag;
				}
		}
	}
	
	struct OSBuildNumber = this.OSBuildNumber
	{
		[Post.Local.OSBuildNumber_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("OSBuildNumber") STag;
		switch
		{
			Case !Local.OSBuildNumber_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) OSBuildNumber;
					XmlTag("OSBuildNumber") ETag;
				}
		}
	}
	
	struct OSServicePackMajorNumber = this.OSServicePackMajorNumber
	{
		[Post.Local.OSServicePackMajorNumber_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("OSServicePackMajorNumber") STag;
		switch
		{
			Case !Local.OSServicePackMajorNumber_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) OSServicePackMajorNumber;
					XmlTag("OSServicePackMajorNumber") ETag;
				}
		}
	}
	
	struct OSServicePackMinorNumber = this.OSServicePackMinorNumber
	{
		[Post.Local.OSServicePackMinorNumber_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("OSServicePackMinorNumber") STag;
		switch
		{
			Case !Local.OSServicePackMinorNumber_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) OSServicePackMinorNumber;
					XmlTag("OSServicePackMinorNumber") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "OSLocale") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct OSLocale = this.OSLocale
			{
				[Post.Local.OSLocale_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("OSLocale") STag;
				switch
				{
					Case !Local.OSLocale_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) OSLocale;
							XmlTag("OSLocale") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ComputerManufacturer") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct ComputerManufacturer = this.ComputerManufacturer
			{
				[Post.Local.ComputerManufacturer_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("ComputerManufacturer") STag;
				switch
				{
					Case !Local.ComputerManufacturer_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) ComputerManufacturer;
							XmlTag("ComputerManufacturer") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ComputerModel") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct ComputerModel = this.ComputerModel
			{
				[Post.Local.ComputerModel_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("ComputerModel") STag;
				switch
				{
					Case !Local.ComputerModel_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) ComputerModel;
							XmlTag("ComputerModel") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "BiosVersion") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct BiosVersion = this.BiosVersion
			{
				[Post.Local.BiosVersion_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("BiosVersion") STag;
				switch
				{
					Case !Local.BiosVersion_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) BiosVersion;
							XmlTag("BiosVersion") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "BiosName") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct BiosName = this.BiosName
			{
				[Post.Local.BiosName_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("BiosName") STag;
				switch
				{
					Case !Local.BiosName_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) BiosName;
							XmlTag("BiosName") ETag;
						}
				}
			}
			
	}
	
	struct BiosReleaseDate = this.BiosReleaseDate
	{
		[Post.Local.BiosReleaseDate_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("BiosReleaseDate") STag;
		switch
		{
			Case !Local.BiosReleaseDate_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) BiosReleaseDate;
					XmlTag("BiosReleaseDate") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ProcessorArchitecture") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct ProcessorArchitecture = this.ProcessorArchitecture
			{
				[Post.Local.ProcessorArchitecture_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("ProcessorArchitecture") STag;
				switch
				{
					Case !Local.ProcessorArchitecture_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) ProcessorArchitecture;
							XmlTag("ProcessorArchitecture") ETag;
						}
				}
			}
			
	}
	
	struct SuiteMask = this.SuiteMask
	{
		[Post.Local.SuiteMask_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("SuiteMask") STag;
		switch
		{
			Case !Local.SuiteMask_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) SuiteMask;
					XmlTag("SuiteMask") ETag;
				}
		}
	}
	
	struct OldProductType = this.OldProductType
	{
		[Post.Local.OldProductType_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("OldProductType") STag;
		switch
		{
			Case !Local.OldProductType_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) OldProductType;
					XmlTag("OldProductType") ETag;
				}
		}
	}
	
	struct NewProductType = this.NewProductType
	{
		[Post.Local.NewProductType_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("NewProductType") STag;
		switch
		{
			Case !Local.NewProductType_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) NewProductType;
					XmlTag("NewProductType") ETag;
				}
		}
	}
	
	struct SystemMetrics = this.SystemMetrics
	{
		[Post.Local.SystemMetrics_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("SystemMetrics") STag;
		switch
		{
			Case !Local.SystemMetrics_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) SystemMetrics;
					XmlTag("SystemMetrics") ETag;
				}
		}
	}
	
	struct ClientVersionMajorNumber = this.ClientVersionMajorNumber
	{
		[Post.Local.ClientVersionMajorNumber_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("ClientVersionMajorNumber") STag;
		switch
		{
			Case !Local.ClientVersionMajorNumber_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) ClientVersionMajorNumber;
					XmlTag("ClientVersionMajorNumber") ETag;
				}
		}
	}
	
	struct ClientVersionMinorNumber = this.ClientVersionMinorNumber
	{
		[Post.Local.ClientVersionMinorNumber_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("ClientVersionMinorNumber") STag;
		switch
		{
			Case !Local.ClientVersionMinorNumber_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) ClientVersionMinorNumber;
					XmlTag("ClientVersionMinorNumber") ETag;
				}
		}
	}
	
	struct ClientVersionBuildNumber = this.ClientVersionBuildNumber
	{
		[Post.Local.ClientVersionBuildNumber_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("ClientVersionBuildNumber") STag;
		switch
		{
			Case !Local.ClientVersionBuildNumber_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) ClientVersionBuildNumber;
					XmlTag("ClientVersionBuildNumber") ETag;
				}
		}
	}
	
	struct ClientVersionQfeNumber = this.ClientVersionQfeNumber
	{
		[Post.Local.ClientVersionQfeNumber_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("ClientVersionQfeNumber") STag;
		switch
		{
			Case !Local.ClientVersionQfeNumber_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) ClientVersionQfeNumber;
					XmlTag("ClientVersionQfeNumber") ETag;
				}
		}
	}
	
}

//
// Element RegisterComputerResponse
// Embedded ComplexType 
//
struct WUSPcwsRegisterComputerResponseElement = this.STag.ToString
{
	[Post.Local.WUSPcwsRegisterComputerResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("RegisterComputerResponse") STag;
	switch
	{
		Case !Local.WUSPcwsRegisterComputerResponseElement_IsEmpty:
			struct
			{
				XmlTag("RegisterComputerResponse") ETag;
			}
	}
}

//
// Element StartCategoryScan
// Embedded ComplexType 
//
struct WUSPcwsStartCategoryScanElement = this.STag.ToString
{
	[Post.Local.WUSPcwsStartCategoryScanElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("StartCategoryScan") STag;
	switch
	{
		Case !Local.WUSPcwsStartCategoryScanElement_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "requestedCategories") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct RequestedCategories = this.STag.ToString
						{
							[Post.Local.RequestedCategories_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("requestedCategories") STag;
							switch
							{
								Case !Local.RequestedCategories_IsEmpty:
									struct
									{
										WUSPcwsArrayOfCategoryRelationship RequestedCategories;
										XmlTag("requestedCategories") ETag;
									}
							}
						}
						
				}
				
				XmlTag("StartCategoryScan") ETag;
			}
	}
}

//
// ComplexType ArrayOfCategoryRelationship
//
Struct WUSPcwsArrayOfCategoryRelationship
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "CategoryRelationship") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct CategoryRelationship = this.STag.ToString
		{
			[Post.Local.CategoryRelationship_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("CategoryRelationship") STag;
			switch
			{
				Case !Local.CategoryRelationship_IsEmpty:
					struct
					{
						WUSPcwsCategoryRelationship CategoryRelationship;
						XmlTag("CategoryRelationship") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType CategoryRelationship
//
Struct WUSPcwsCategoryRelationship
{
	struct IndexOfAndGroup = this.IndexOfAndGroup
	{
		[Post.Local.IndexOfAndGroup_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("IndexOfAndGroup") STag;
		switch
		{
			Case !Local.IndexOfAndGroup_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) IndexOfAndGroup;
					XmlTag("IndexOfAndGroup") ETag;
				}
		}
	}
	
	struct CategoryId = this.STag.ToString
	{
		[Post.Local.CategoryId_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("CategoryId") STag;
		switch
		{
			Case !Local.CategoryId_IsEmpty:
				struct
				{
					WUSPs1Guid CategoryId;
					XmlTag("CategoryId") ETag;
				}
		}
	}
	
}

//
// Element StartCategoryScanResponse
// Embedded ComplexType 
//
struct WUSPcwsStartCategoryScanResponseElement = this.STag.ToString
{
	[Post.Local.WUSPcwsStartCategoryScanResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("StartCategoryScanResponse") STag;
	switch
	{
		Case !Local.WUSPcwsStartCategoryScanResponseElement_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "preferredCategoryIds") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct PreferredCategoryIds = this.STag.ToString
						{
							[Post.Local.PreferredCategoryIds_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("preferredCategoryIds") STag;
							switch
							{
								Case !Local.PreferredCategoryIds_IsEmpty:
									struct
									{
										WUSPcwsArrayOfGuid PreferredCategoryIds;
										XmlTag("preferredCategoryIds") ETag;
									}
							}
						}
						
				}
				
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "requestedCategoryIdsInError") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct RequestedCategoryIdsInError = this.STag.ToString
						{
							[Post.Local.RequestedCategoryIdsInError_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("requestedCategoryIdsInError") STag;
							switch
							{
								Case !Local.RequestedCategoryIdsInError_IsEmpty:
									struct
									{
										WUSPcwsArrayOfGuid RequestedCategoryIdsInError;
										XmlTag("requestedCategoryIdsInError") ETag;
									}
							}
						}
						
				}
				
				XmlTag("StartCategoryScanResponse") ETag;
			}
	}
}

//
// ComplexType ArrayOfGuid
//
Struct WUSPcwsArrayOfGuid
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "guid") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct Guid = this.STag.ToString
		{
			[Post.Local.Guid_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("guid") STag;
			switch
			{
				Case !Local.Guid_IsEmpty:
					struct
					{
						WUSPs1Guid Guid;
						XmlTag("guid") ETag;
					}
			}
		}
		
	}
}

//
// Element SyncUpdates
// Embedded ComplexType 
//
struct WUSPcwsSyncUpdatesElement = this.STag.ToString
{
	[Post.Local.WUSPcwsSyncUpdatesElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("SyncUpdates") STag;
	switch
	{
		Case !Local.WUSPcwsSyncUpdatesElement_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "cookie") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct Cookie = this.STag.ToString
						{
							[Post.Local.Cookie_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("cookie") STag;
							switch
							{
								Case !Local.Cookie_IsEmpty:
									struct
									{
										WUSPcwsCookie Cookie;
										XmlTag("cookie") ETag;
									}
							}
						}
						
				}
				
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "parameters") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct Parameters = this.STag.ToString
						{
							[Post.Local.Parameters_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("parameters") STag;
							switch
							{
								Case !Local.Parameters_IsEmpty:
									struct
									{
										WUSPcwsSyncUpdateParameters Parameters;
										XmlTag("parameters") ETag;
									}
							}
						}
						
				}
				
				XmlTag("SyncUpdates") ETag;
			}
	}
}

//
// ComplexType SyncUpdateParameters
//
Struct WUSPcwsSyncUpdateParameters
{
	struct ExpressQuery = this.ExpressQuery
	{
		[Post.Local.ExpressQuery_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("ExpressQuery") STag;
		switch
		{
			Case !Local.ExpressQuery_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) ExpressQuery;
					XmlTag("ExpressQuery") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "InstalledNonLeafUpdateIDs") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct InstalledNonLeafUpdateIDs = this.STag.ToString
			{
				[Post.Local.InstalledNonLeafUpdateIDs_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("InstalledNonLeafUpdateIDs") STag;
				switch
				{
					Case !Local.InstalledNonLeafUpdateIDs_IsEmpty:
						struct
						{
							WUSPcwsArrayOfInt InstalledNonLeafUpdateIDs;
							XmlTag("InstalledNonLeafUpdateIDs") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "OtherCachedUpdateIDs") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct OtherCachedUpdateIDs = this.STag.ToString
			{
				[Post.Local.OtherCachedUpdateIDs_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("OtherCachedUpdateIDs") STag;
				switch
				{
					Case !Local.OtherCachedUpdateIDs_IsEmpty:
						struct
						{
							WUSPcwsArrayOfInt OtherCachedUpdateIDs;
							XmlTag("OtherCachedUpdateIDs") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "SystemSpec") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct SystemSpec = this.STag.ToString
			{
				[Post.Local.SystemSpec_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("SystemSpec") STag;
				switch
				{
					Case !Local.SystemSpec_IsEmpty:
						struct
						{
							WUSPcwsArrayOfDevice SystemSpec;
							XmlTag("SystemSpec") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "CachedDriverIDs") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct CachedDriverIDs = this.STag.ToString
			{
				[Post.Local.CachedDriverIDs_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("CachedDriverIDs") STag;
				switch
				{
					Case !Local.CachedDriverIDs_IsEmpty:
						struct
						{
							WUSPcwsArrayOfInt CachedDriverIDs;
							XmlTag("CachedDriverIDs") ETag;
						}
				}
			}
			
	}
	
	struct SkipSoftwareSync = this.SkipSoftwareSync
	{
		[Post.Local.SkipSoftwareSync_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("SkipSoftwareSync") STag;
		switch
		{
			Case !Local.SkipSoftwareSync_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) SkipSoftwareSync;
					XmlTag("SkipSoftwareSync") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FilterCategoryIds") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct FilterCategoryIds = this.STag.ToString
			{
				[Post.Local.FilterCategoryIds_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("FilterCategoryIds") STag;
				switch
				{
					Case !Local.FilterCategoryIds_IsEmpty:
						struct
						{
							WUSPcwsArrayOfCategoryIdentifier FilterCategoryIds;
							XmlTag("FilterCategoryIds") ETag;
						}
				}
			}
			
	}
	
	struct NeedTwoGroupOutOfScopeUpdates = this.NeedTwoGroupOutOfScopeUpdates
	{
		[Post.Local.NeedTwoGroupOutOfScopeUpdates_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("NeedTwoGroupOutOfScopeUpdates") STag;
		switch
		{
			Case !Local.NeedTwoGroupOutOfScopeUpdates_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) NeedTwoGroupOutOfScopeUpdates;
					XmlTag("NeedTwoGroupOutOfScopeUpdates") ETag;
				}
		}
	}
	
}

//
// ComplexType ArrayOfDevice
//
Struct WUSPcwsArrayOfDevice
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Device") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct Device = this.STag.ToString
		{
			[Post.Local.Device_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("Device") STag;
			switch
			{
				Case !Local.Device_IsEmpty:
					struct
					{
						WUSPcwsDevice Device;
						XmlTag("Device") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType Device
//
Struct WUSPcwsDevice
{
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "HardwareIDs") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct HardwareIDs = this.STag.ToString
			{
				[Post.Local.HardwareIDs_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("HardwareIDs") STag;
				switch
				{
					Case !Local.HardwareIDs_IsEmpty:
						struct
						{
							WUSPcwsArrayOfString HardwareIDs;
							XmlTag("HardwareIDs") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "CompatibleIDs") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct CompatibleIDs = this.STag.ToString
			{
				[Post.Local.CompatibleIDs_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("CompatibleIDs") STag;
				switch
				{
					Case !Local.CompatibleIDs_IsEmpty:
						struct
						{
							WUSPcwsArrayOfString CompatibleIDs;
							XmlTag("CompatibleIDs") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "installedDriver") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct InstalledDriver = this.STag.ToString
			{
				[Post.Local.InstalledDriver_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("installedDriver") STag;
				switch
				{
					Case !Local.InstalledDriver_IsEmpty:
						struct
						{
							WUSPcwsInstalledDriver InstalledDriver;
							XmlTag("installedDriver") ETag;
						}
				}
			}
			
	}
	
}

//
// ComplexType ArrayOfString
//
Struct WUSPcwsArrayOfString
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "string") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct String = this.String
		{
			[Post.Local.String_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("string") STag;
			switch
			{
				Case !Local.String_IsEmpty:
					struct
					{
						StringTerm(Property.XMLEncoding, "<", true, false, false) String;
						XmlTag("string") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType InstalledDriver
//
Struct WUSPcwsInstalledDriver
{
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "MatchingID") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct MatchingID = this.MatchingID
			{
				[Post.Local.MatchingID_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("MatchingID") STag;
				switch
				{
					Case !Local.MatchingID_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) MatchingID;
							XmlTag("MatchingID") ETag;
						}
				}
			}
			
	}
	
	struct DriverVerDate = this.DriverVerDate
	{
		[Post.Local.DriverVerDate_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("DriverVerDate") STag;
		switch
		{
			Case !Local.DriverVerDate_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) DriverVerDate;
					XmlTag("DriverVerDate") ETag;
				}
		}
	}
	
	struct DriverVerVersion = this.DriverVerVersion
	{
		[Post.Local.DriverVerVersion_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("DriverVerVersion") STag;
		switch
		{
			Case !Local.DriverVerVersion_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) DriverVerVersion;
					XmlTag("DriverVerVersion") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Class") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Class = this.Class
			{
				[Post.Local.Class_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Class") STag;
				switch
				{
					Case !Local.Class_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) Class;
							XmlTag("Class") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Manufacturer") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Manufacturer = this.Manufacturer
			{
				[Post.Local.Manufacturer_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Manufacturer") STag;
				switch
				{
					Case !Local.Manufacturer_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) Manufacturer;
							XmlTag("Manufacturer") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Provider") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Provider = this.Provider
			{
				[Post.Local.Provider_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Provider") STag;
				switch
				{
					Case !Local.Provider_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) Provider;
							XmlTag("Provider") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Model") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Model = this.Model
			{
				[Post.Local.Model_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Model") STag;
				switch
				{
					Case !Local.Model_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) Model;
							XmlTag("Model") ETag;
						}
				}
			}
			
	}
	
}

//
// ComplexType ArrayOfCategoryIdentifier
//
Struct WUSPcwsArrayOfCategoryIdentifier
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "CategoryIdentifier") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct CategoryIdentifier = this.STag.ToString
		{
			[Post.Local.CategoryIdentifier_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("CategoryIdentifier") STag;
			switch
			{
				Case !Local.CategoryIdentifier_IsEmpty:
					struct
					{
						WUSPcwsCategoryIdentifier CategoryIdentifier;
						XmlTag("CategoryIdentifier") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType CategoryIdentifier
//
Struct WUSPcwsCategoryIdentifier
{
	struct Id = this.STag.ToString
	{
		[Post.Local.Id_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("Id") STag;
		switch
		{
			Case !Local.Id_IsEmpty:
				struct
				{
					WUSPs1Guid Id;
					XmlTag("Id") ETag;
				}
		}
	}
	
}

//
// Element SyncUpdatesResponse
// Embedded ComplexType 
//
struct WUSPcwsSyncUpdatesResponseElement = this.STag.ToString
{
	[Post.Local.WUSPcwsSyncUpdatesResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("SyncUpdatesResponse") STag;
	switch
	{
		Case !Local.WUSPcwsSyncUpdatesResponseElement_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "SyncUpdatesResult") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct SyncUpdatesResult = this.STag.ToString
						{
							[Post.Local.SyncUpdatesResult_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("SyncUpdatesResult") STag;
							switch
							{
								Case !Local.SyncUpdatesResult_IsEmpty:
									struct
									{
										WUSPcwsSyncInfo SyncUpdatesResult;
										XmlTag("SyncUpdatesResult") ETag;
									}
							}
						}
						
				}
				
				XmlTag("SyncUpdatesResponse") ETag;
			}
	}
}

//
// ComplexType SyncInfo
//
Struct WUSPcwsSyncInfo
{
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "NewUpdates") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct NewUpdates = this.STag.ToString
			{
				[Post.Local.NewUpdates_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("NewUpdates") STag;
				switch
				{
					Case !Local.NewUpdates_IsEmpty:
						struct
						{
							WUSPcwsArrayOfUpdateInfo NewUpdates;
							XmlTag("NewUpdates") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "OutOfScopeRevisionIDs") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct OutOfScopeRevisionIDs = this.STag.ToString
			{
				[Post.Local.OutOfScopeRevisionIDs_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("OutOfScopeRevisionIDs") STag;
				switch
				{
					Case !Local.OutOfScopeRevisionIDs_IsEmpty:
						struct
						{
							WUSPcwsArrayOfInt OutOfScopeRevisionIDs;
							XmlTag("OutOfScopeRevisionIDs") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ChangedUpdates") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct ChangedUpdates = this.STag.ToString
			{
				[Post.Local.ChangedUpdates_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("ChangedUpdates") STag;
				switch
				{
					Case !Local.ChangedUpdates_IsEmpty:
						struct
						{
							WUSPcwsArrayOfUpdateInfo ChangedUpdates;
							XmlTag("ChangedUpdates") ETag;
						}
				}
			}
			
	}
	
	struct Truncated = this.Truncated
	{
		[Post.Local.Truncated_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("Truncated") STag;
		switch
		{
			Case !Local.Truncated_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) Truncated;
					XmlTag("Truncated") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "NewCookie") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct NewCookie = this.STag.ToString
			{
				[Post.Local.NewCookie_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("NewCookie") STag;
				switch
				{
					Case !Local.NewCookie_IsEmpty:
						struct
						{
							WUSPcwsCookie NewCookie;
							XmlTag("NewCookie") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "DeployedOutOfScopeRevisionIds") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct DeployedOutOfScopeRevisionIds = this.STag.ToString
			{
				[Post.Local.DeployedOutOfScopeRevisionIds_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("DeployedOutOfScopeRevisionIds") STag;
				switch
				{
					Case !Local.DeployedOutOfScopeRevisionIds_IsEmpty:
						struct
						{
							WUSPcwsArrayOfInt DeployedOutOfScopeRevisionIds;
							XmlTag("DeployedOutOfScopeRevisionIds") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "DriverSyncNotNeeded") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct DriverSyncNotNeeded = this.DriverSyncNotNeeded
			{
				[Post.Local.DriverSyncNotNeeded_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("DriverSyncNotNeeded") STag;
				switch
				{
					Case !Local.DriverSyncNotNeeded_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) DriverSyncNotNeeded;
							XmlTag("DriverSyncNotNeeded") ETag;
						}
				}
			}
			
	}
	
}

//
// ComplexType ArrayOfUpdateInfo
//
Struct WUSPcwsArrayOfUpdateInfo
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "UpdateInfo") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct UpdateInfo = this.STag.ToString
		{
			[Post.Local.UpdateInfo_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("UpdateInfo") STag;
			switch
			{
				Case !Local.UpdateInfo_IsEmpty:
					struct
					{
						WUSPcwsUpdateInfo UpdateInfo;
						XmlTag("UpdateInfo") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType UpdateInfo
//
Struct WUSPcwsUpdateInfo
{
	struct ID = this.ID
	{
		[Post.Local.ID_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("ID") STag;
		switch
		{
			Case !Local.ID_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) ID;
					XmlTag("ID") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Deployment") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Deployment = this.STag.ToString
			{
				[Post.Local.Deployment_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Deployment") STag;
				switch
				{
					Case !Local.Deployment_IsEmpty:
						struct
						{
							WUSPcwsDeployment Deployment;
							XmlTag("Deployment") ETag;
						}
				}
			}
			
	}
	
	struct IsLeaf = this.IsLeaf
	{
		[Post.Local.IsLeaf_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("IsLeaf") STag;
		switch
		{
			Case !Local.IsLeaf_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) IsLeaf;
					XmlTag("IsLeaf") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Xml") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Xml = this.Xml
			{
				[Post.Local.Xml_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Xml") STag;
				switch
				{
					Case !Local.Xml_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) Xml;
							XmlTag("Xml") ETag;
						}
				}
			}
			
	}
	
}

//
// ComplexType Deployment
//
Struct WUSPcwsDeployment
{
	struct ID = this.ID
	{
		[Post.Local.ID_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("ID") STag;
		switch
		{
			Case !Local.ID_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) ID;
					XmlTag("ID") ETag;
				}
		}
	}
	
	struct Action = this.STag.ToString
	{
		[Post.Local.Action_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("Action") STag;
		switch
		{
			Case !Local.Action_IsEmpty:
				struct
				{
					WUSPcwsDeploymentAction Action;
					XmlTag("Action") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Deadline") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Deadline = this.Deadline
			{
				[Post.Local.Deadline_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Deadline") STag;
				switch
				{
					Case !Local.Deadline_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) Deadline;
							XmlTag("Deadline") ETag;
						}
				}
			}
			
	}
	
	struct IsAssigned = this.IsAssigned
	{
		[Post.Local.IsAssigned_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("IsAssigned") STag;
		switch
		{
			Case !Local.IsAssigned_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) IsAssigned;
					XmlTag("IsAssigned") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "LastChangeTime") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct LastChangeTime = this.LastChangeTime
			{
				[Post.Local.LastChangeTime_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("LastChangeTime") STag;
				switch
				{
					Case !Local.LastChangeTime_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) LastChangeTime;
							XmlTag("LastChangeTime") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "DownloadPriority") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct DownloadPriority = this.DownloadPriority
			{
				[Post.Local.DownloadPriority_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("DownloadPriority") STag;
				switch
				{
					Case !Local.DownloadPriority_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) DownloadPriority;
							XmlTag("DownloadPriority") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "HardwareIds") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct HardwareIds = this.STag.ToString
			{
				[Post.Local.HardwareIds_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("HardwareIds") STag;
				switch
				{
					Case !Local.HardwareIds_IsEmpty:
						struct
						{
							WUSPcwsArrayOfString HardwareIds;
							XmlTag("HardwareIds") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "AutoSelect") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct AutoSelect = this.AutoSelect
			{
				[Post.Local.AutoSelect_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("AutoSelect") STag;
				switch
				{
					Case !Local.AutoSelect_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) AutoSelect;
							XmlTag("AutoSelect") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "AutoDownload") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct AutoDownload = this.AutoDownload
			{
				[Post.Local.AutoDownload_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("AutoDownload") STag;
				switch
				{
					Case !Local.AutoDownload_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) AutoDownload;
							XmlTag("AutoDownload") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "SupersedenceBehavior") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct SupersedenceBehavior = this.SupersedenceBehavior
			{
				[Post.Local.SupersedenceBehavior_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("SupersedenceBehavior") STag;
				switch
				{
					Case !Local.SupersedenceBehavior_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) SupersedenceBehavior;
							XmlTag("SupersedenceBehavior") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FlagBitmask") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct FlagBitmask = this.FlagBitmask
			{
				[Post.Local.FlagBitmask_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("FlagBitmask") STag;
				switch
				{
					Case !Local.FlagBitmask_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) FlagBitmask;
							XmlTag("FlagBitmask") ETag;
						}
				}
			}
			
	}
	
}

//
// Element SyncPrinterCatalog
// Embedded ComplexType 
//
struct WUSPcwsSyncPrinterCatalogElement = this.STag.ToString
{
	[Post.Local.WUSPcwsSyncPrinterCatalogElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("SyncPrinterCatalog") STag;
	switch
	{
		Case !Local.WUSPcwsSyncPrinterCatalogElement_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "cookie") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct Cookie = this.STag.ToString
						{
							[Post.Local.Cookie_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("cookie") STag;
							switch
							{
								Case !Local.Cookie_IsEmpty:
									struct
									{
										WUSPcwsCookie Cookie;
										XmlTag("cookie") ETag;
									}
							}
						}
						
				}
				
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "installedNonLeafUpdateIDs") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct InstalledNonLeafUpdateIDs = this.STag.ToString
						{
							[Post.Local.InstalledNonLeafUpdateIDs_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("installedNonLeafUpdateIDs") STag;
							switch
							{
								Case !Local.InstalledNonLeafUpdateIDs_IsEmpty:
									struct
									{
										WUSPcwsArrayOfInt InstalledNonLeafUpdateIDs;
										XmlTag("installedNonLeafUpdateIDs") ETag;
									}
							}
						}
						
				}
				
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "printerUpdateIDs") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct PrinterUpdateIDs = this.STag.ToString
						{
							[Post.Local.PrinterUpdateIDs_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("printerUpdateIDs") STag;
							switch
							{
								Case !Local.PrinterUpdateIDs_IsEmpty:
									struct
									{
										WUSPcwsArrayOfInt PrinterUpdateIDs;
										XmlTag("printerUpdateIDs") ETag;
									}
							}
						}
						
				}
				
				XmlTag("SyncPrinterCatalog") ETag;
			}
	}
}

//
// Element SyncPrinterCatalogResponse
// Embedded ComplexType 
//
struct WUSPcwsSyncPrinterCatalogResponseElement = this.STag.ToString
{
	[Post.Local.WUSPcwsSyncPrinterCatalogResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("SyncPrinterCatalogResponse") STag;
	switch
	{
		Case !Local.WUSPcwsSyncPrinterCatalogResponseElement_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "SyncPrinterCatalogResult") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct SyncPrinterCatalogResult = this.STag.ToString
						{
							[Post.Local.SyncPrinterCatalogResult_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("SyncPrinterCatalogResult") STag;
							switch
							{
								Case !Local.SyncPrinterCatalogResult_IsEmpty:
									struct
									{
										WUSPcwsSyncInfo SyncPrinterCatalogResult;
										XmlTag("SyncPrinterCatalogResult") ETag;
									}
							}
						}
						
				}
				
				XmlTag("SyncPrinterCatalogResponse") ETag;
			}
	}
}

//
// Element RefreshCache
// Embedded ComplexType 
//
struct WUSPcwsRefreshCacheElement = this.STag.ToString
{
	[Post.Local.WUSPcwsRefreshCacheElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("RefreshCache") STag;
	switch
	{
		Case !Local.WUSPcwsRefreshCacheElement_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "cookie") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct Cookie = this.STag.ToString
						{
							[Post.Local.Cookie_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("cookie") STag;
							switch
							{
								Case !Local.Cookie_IsEmpty:
									struct
									{
										WUSPcwsCookie Cookie;
										XmlTag("cookie") ETag;
									}
							}
						}
						
				}
				
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "globalIDs") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct GlobalIDs = this.STag.ToString
						{
							[Post.Local.GlobalIDs_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("globalIDs") STag;
							switch
							{
								Case !Local.GlobalIDs_IsEmpty:
									struct
									{
										WUSPcwsArrayOfUpdateIdentity GlobalIDs;
										XmlTag("globalIDs") ETag;
									}
							}
						}
						
				}
				
				XmlTag("RefreshCache") ETag;
			}
	}
}

//
// ComplexType ArrayOfUpdateIdentity
//
Struct WUSPcwsArrayOfUpdateIdentity
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "UpdateIdentity") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct UpdateIdentity = this.STag.ToString
		{
			[Post.Local.UpdateIdentity_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("UpdateIdentity") STag;
			switch
			{
				Case !Local.UpdateIdentity_IsEmpty:
					struct
					{
						WUSPcwsUpdateIdentity UpdateIdentity;
						XmlTag("UpdateIdentity") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType UpdateIdentity
//
Struct WUSPcwsUpdateIdentity
{
	struct UpdateID = this.STag.ToString
	{
		[Post.Local.UpdateID_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("UpdateID") STag;
		switch
		{
			Case !Local.UpdateID_IsEmpty:
				struct
				{
					WUSPs1Guid UpdateID;
					XmlTag("UpdateID") ETag;
				}
		}
	}
	
	struct RevisionNumber = this.RevisionNumber
	{
		[Post.Local.RevisionNumber_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("RevisionNumber") STag;
		switch
		{
			Case !Local.RevisionNumber_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) RevisionNumber;
					XmlTag("RevisionNumber") ETag;
				}
		}
	}
	
}

//
// Element RefreshCacheResponse
// Embedded ComplexType 
//
struct WUSPcwsRefreshCacheResponseElement = this.STag.ToString
{
	[Post.Local.WUSPcwsRefreshCacheResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("RefreshCacheResponse") STag;
	switch
	{
		Case !Local.WUSPcwsRefreshCacheResponseElement_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RefreshCacheResult") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct RefreshCacheResult = this.STag.ToString
						{
							[Post.Local.RefreshCacheResult_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("RefreshCacheResult") STag;
							switch
							{
								Case !Local.RefreshCacheResult_IsEmpty:
									struct
									{
										WUSPcwsArrayOfRefreshCacheResult RefreshCacheResult;
										XmlTag("RefreshCacheResult") ETag;
									}
							}
						}
						
				}
				
				XmlTag("RefreshCacheResponse") ETag;
			}
	}
}

//
// ComplexType ArrayOfRefreshCacheResult
//
Struct WUSPcwsArrayOfRefreshCacheResult
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RefreshCacheResult") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct RefreshCacheResult = this.STag.ToString
		{
			[Post.Local.RefreshCacheResult_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("RefreshCacheResult") STag;
			switch
			{
				Case !Local.RefreshCacheResult_IsEmpty:
					struct
					{
						WUSPcwsRefreshCacheResult RefreshCacheResult;
						XmlTag("RefreshCacheResult") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType RefreshCacheResult
//
Struct WUSPcwsRefreshCacheResult
{
	struct RevisionID = this.RevisionID
	{
		[Post.Local.RevisionID_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("RevisionID") STag;
		switch
		{
			Case !Local.RevisionID_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) RevisionID;
					XmlTag("RevisionID") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GlobalID") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct GlobalID = this.STag.ToString
			{
				[Post.Local.GlobalID_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("GlobalID") STag;
				switch
				{
					Case !Local.GlobalID_IsEmpty:
						struct
						{
							WUSPcwsUpdateIdentity GlobalID;
							XmlTag("GlobalID") ETag;
						}
				}
			}
			
	}
	
	struct IsLeaf = this.IsLeaf
	{
		[Post.Local.IsLeaf_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("IsLeaf") STag;
		switch
		{
			Case !Local.IsLeaf_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) IsLeaf;
					XmlTag("IsLeaf") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Deployment") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Deployment = this.STag.ToString
			{
				[Post.Local.Deployment_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Deployment") STag;
				switch
				{
					Case !Local.Deployment_IsEmpty:
						struct
						{
							WUSPcwsDeployment Deployment;
							XmlTag("Deployment") ETag;
						}
				}
			}
			
	}
	
}

//
// Element GetExtendedUpdateInfo
// Embedded ComplexType 
//
struct WUSPcwsGetExtendedUpdateInfoElement = this.STag.ToString
{
	[Post.Local.WUSPcwsGetExtendedUpdateInfoElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("GetExtendedUpdateInfo") STag;
	switch
	{
		Case !Local.WUSPcwsGetExtendedUpdateInfoElement_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "cookie") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct Cookie = this.STag.ToString
						{
							[Post.Local.Cookie_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("cookie") STag;
							switch
							{
								Case !Local.Cookie_IsEmpty:
									struct
									{
										WUSPcwsCookie Cookie;
										XmlTag("cookie") ETag;
									}
							}
						}
						
				}
				
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "revisionIDs") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct RevisionIDs = this.STag.ToString
						{
							[Post.Local.RevisionIDs_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("revisionIDs") STag;
							switch
							{
								Case !Local.RevisionIDs_IsEmpty:
									struct
									{
										WUSPcwsArrayOfInt RevisionIDs;
										XmlTag("revisionIDs") ETag;
									}
							}
						}
						
				}
				
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "infoTypes") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct InfoTypes = this.STag.ToString
						{
							[Post.Local.InfoTypes_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("infoTypes") STag;
							switch
							{
								Case !Local.InfoTypes_IsEmpty:
									struct
									{
										WUSPcwsArrayOfXmlUpdateFragmentType InfoTypes;
										XmlTag("infoTypes") ETag;
									}
							}
						}
						
				}
				
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "locales") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct Locales = this.STag.ToString
						{
							[Post.Local.Locales_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("locales") STag;
							switch
							{
								Case !Local.Locales_IsEmpty:
									struct
									{
										WUSPcwsArrayOfString Locales;
										XmlTag("locales") ETag;
									}
							}
						}
						
				}
				
				XmlTag("GetExtendedUpdateInfo") ETag;
			}
	}
}

//
// ComplexType ArrayOfXmlUpdateFragmentType
//
Struct WUSPcwsArrayOfXmlUpdateFragmentType
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "XmlUpdateFragmentType") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct XmlUpdateFragmentType = this.STag.ToString
		{
			[Post.Local.XmlUpdateFragmentType_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("XmlUpdateFragmentType") STag;
			switch
			{
				Case !Local.XmlUpdateFragmentType_IsEmpty:
					struct
					{
						WUSPcwsXmlUpdateFragmentType XmlUpdateFragmentType;
						XmlTag("XmlUpdateFragmentType") ETag;
					}
			}
		}
		
	}
}

//
// Element GetExtendedUpdateInfoResponse
// Embedded ComplexType 
//
struct WUSPcwsGetExtendedUpdateInfoResponseElement = this.STag.ToString
{
	[Post.Local.WUSPcwsGetExtendedUpdateInfoResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("GetExtendedUpdateInfoResponse") STag;
	switch
	{
		Case !Local.WUSPcwsGetExtendedUpdateInfoResponseElement_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetExtendedUpdateInfoResult") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct GetExtendedUpdateInfoResult = this.STag.ToString
						{
							[Post.Local.GetExtendedUpdateInfoResult_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("GetExtendedUpdateInfoResult") STag;
							switch
							{
								Case !Local.GetExtendedUpdateInfoResult_IsEmpty:
									struct
									{
										WUSPcwsExtendedUpdateInfo GetExtendedUpdateInfoResult;
										XmlTag("GetExtendedUpdateInfoResult") ETag;
									}
							}
						}
						
				}
				
				XmlTag("GetExtendedUpdateInfoResponse") ETag;
			}
	}
}

//
// ComplexType ExtendedUpdateInfo
//
Struct WUSPcwsExtendedUpdateInfo
{
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Updates") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Updates = this.STag.ToString
			{
				[Post.Local.Updates_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Updates") STag;
				switch
				{
					Case !Local.Updates_IsEmpty:
						struct
						{
							WUSPcwsArrayOfUpdateData Updates;
							XmlTag("Updates") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FileLocations") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct FileLocations = this.STag.ToString
			{
				[Post.Local.FileLocations_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("FileLocations") STag;
				switch
				{
					Case !Local.FileLocations_IsEmpty:
						struct
						{
							WUSPcwsArrayOfFileLocation FileLocations;
							XmlTag("FileLocations") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "OutOfScopeRevisionIDs") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct OutOfScopeRevisionIDs = this.STag.ToString
			{
				[Post.Local.OutOfScopeRevisionIDs_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("OutOfScopeRevisionIDs") STag;
				switch
				{
					Case !Local.OutOfScopeRevisionIDs_IsEmpty:
						struct
						{
							WUSPcwsArrayOfInt OutOfScopeRevisionIDs;
							XmlTag("OutOfScopeRevisionIDs") ETag;
						}
				}
			}
			
	}
	
}

//
// ComplexType ArrayOfUpdateData
//
Struct WUSPcwsArrayOfUpdateData
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Update") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct Update = this.STag.ToString
		{
			[Post.Local.Update_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("Update") STag;
			switch
			{
				Case !Local.Update_IsEmpty:
					struct
					{
						WUSPcwsUpdateData Update;
						XmlTag("Update") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType UpdateData
//
Struct WUSPcwsUpdateData
{
	struct ID = this.ID
	{
		[Post.Local.ID_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("ID") STag;
		switch
		{
			Case !Local.ID_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) ID;
					XmlTag("ID") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Xml") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Xml = this.Xml
			{
				[Post.Local.Xml_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Xml") STag;
				switch
				{
					Case !Local.Xml_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) Xml;
							XmlTag("Xml") ETag;
						}
				}
			}
			
	}
	
}

//
// ComplexType ArrayOfFileLocation
//
Struct WUSPcwsArrayOfFileLocation
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FileLocation") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct FileLocation = this.STag.ToString
		{
			[Post.Local.FileLocation_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("FileLocation") STag;
			switch
			{
				Case !Local.FileLocation_IsEmpty:
					struct
					{
						WUSPcwsFileLocation FileLocation;
						XmlTag("FileLocation") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType FileLocation
//
Struct WUSPcwsFileLocation
{
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FileDigest") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct FileDigest = this.FileDigest
			{
				[Post.Local.FileDigest_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("FileDigest") STag;
				switch
				{
					Case !Local.FileDigest_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) FileDigest;
							XmlTag("FileDigest") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Url") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Url = this.Url
			{
				[Post.Local.Url_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Url") STag;
				switch
				{
					Case !Local.Url_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) Url;
							XmlTag("Url") ETag;
						}
				}
			}
			
	}
	
}

//
// Element GetFileLocations
// Embedded ComplexType 
//
struct WUSPcwsGetFileLocationsElement = this.STag.ToString
{
	[Post.Local.WUSPcwsGetFileLocationsElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("GetFileLocations") STag;
	switch
	{
		Case !Local.WUSPcwsGetFileLocationsElement_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "cookie") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct Cookie = this.STag.ToString
						{
							[Post.Local.Cookie_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("cookie") STag;
							switch
							{
								Case !Local.Cookie_IsEmpty:
									struct
									{
										WUSPcwsCookie Cookie;
										XmlTag("cookie") ETag;
									}
							}
						}
						
				}
				
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "fileDigests") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct FileDigests = this.STag.ToString
						{
							[Post.Local.FileDigests_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("fileDigests") STag;
							switch
							{
								Case !Local.FileDigests_IsEmpty:
									struct
									{
										WUSPcwsArrayOfBase64Binary FileDigests;
										XmlTag("fileDigests") ETag;
									}
							}
						}
						
				}
				
				XmlTag("GetFileLocations") ETag;
			}
	}
}

//
// ComplexType ArrayOfBase64Binary
//
Struct WUSPcwsArrayOfBase64Binary
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "base64Binary") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct Base64Binary = this.Base64Binary
		{
			[Post.Local.Base64Binary_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("base64Binary") STag;
			switch
			{
				Case !Local.Base64Binary_IsEmpty:
					struct
					{
						StringTerm(Property.XMLEncoding, "<", true, false, false) Base64Binary;
						XmlTag("base64Binary") ETag;
					}
			}
		}
		
	}
}

//
// Element GetFileLocationsResponse
// Embedded ComplexType 
//
struct WUSPcwsGetFileLocationsResponseElement = this.STag.ToString
{
	[Post.Local.WUSPcwsGetFileLocationsResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("GetFileLocationsResponse") STag;
	switch
	{
		Case !Local.WUSPcwsGetFileLocationsResponseElement_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetFileLocationsResult") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct GetFileLocationsResult = this.STag.ToString
						{
							[Post.Local.GetFileLocationsResult_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("GetFileLocationsResult") STag;
							switch
							{
								Case !Local.GetFileLocationsResult_IsEmpty:
									struct
									{
										WUSPcwsGetFileLocationsResults GetFileLocationsResult;
										XmlTag("GetFileLocationsResult") ETag;
									}
							}
						}
						
				}
				
				XmlTag("GetFileLocationsResponse") ETag;
			}
	}
}

//
// ComplexType GetFileLocationsResults
//
Struct WUSPcwsGetFileLocationsResults
{
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FileLocations") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct FileLocations = this.STag.ToString
			{
				[Post.Local.FileLocations_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("FileLocations") STag;
				switch
				{
					Case !Local.FileLocations_IsEmpty:
						struct
						{
							WUSPcwsArrayOfFileLocation FileLocations;
							XmlTag("FileLocations") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "NewCookie") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct NewCookie = this.STag.ToString
			{
				[Post.Local.NewCookie_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("NewCookie") STag;
				switch
				{
					Case !Local.NewCookie_IsEmpty:
						struct
						{
							WUSPcwsCookie NewCookie;
							XmlTag("NewCookie") ETag;
						}
				}
			}
			
	}
	
}

Struct WUSPcws = Property.WUSPcwsSummary
{
	Switch(Property.SOAPAction)
	{
		Case "http://www.microsoft.com/SoftwareDistribution/Server/ClientWebService/GetConfig":
			[Property.WUSPcwsSummary = this.ToString]
			WUSPGetConfig WUSPGetConfig;
		Case "http://www.microsoft.com/SoftwareDistribution/Server/ClientWebService/GetCookie":
			[Property.WUSPcwsSummary = this.ToString]
			WUSPGetCookie WUSPGetCookie;
		Case "http://www.microsoft.com/SoftwareDistribution/Server/ClientWebService/RegisterComputer":
			[Property.WUSPcwsSummary = this.ToString]
			WUSPRegisterComputer WUSPRegisterComputer;
		Case "http://www.microsoft.com/SoftwareDistribution/Server/ClientWebService/StartCategoryScan":
			[Property.WUSPcwsSummary = this.ToString]
			WUSPStartCategoryScan WUSPStartCategoryScan;
		Case "http://www.microsoft.com/SoftwareDistribution/Server/ClientWebService/SyncUpdates":
			[Property.WUSPcwsSummary = this.ToString]
			WUSPSyncUpdates WUSPSyncUpdates;
		Case "http://www.microsoft.com/SoftwareDistribution/Server/ClientWebService/SyncPrinterCatalog":
			[Property.WUSPcwsSummary = this.ToString]
			WUSPSyncPrinterCatalog WUSPSyncPrinterCatalog;
		Case "http://www.microsoft.com/SoftwareDistribution/Server/ClientWebService/RefreshCache":
			[Property.WUSPcwsSummary = this.ToString]
			WUSPRefreshCache WUSPRefreshCache;
		Case "http://www.microsoft.com/SoftwareDistribution/Server/ClientWebService/GetExtendedUpdateInfo":
			[Property.WUSPcwsSummary = this.ToString]
			WUSPGetExtendedUpdateInfo WUSPGetExtendedUpdateInfo;
		Case "http://www.microsoft.com/SoftwareDistribution/Server/ClientWebService/GetFileLocations":
			[Property.WUSPcwsSummary = this.ToString]
			WUSPGetFileLocations WUSPGetFileLocations;
		Default:
			While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
			{
				XmlElement(true) AnyNode;
			}
	}
	
}

struct WUSPGetConfig = FormatString("%s Message", Property.WUSPGetConfigSummary)
{
	[Post.Local.WUSPGetConfig_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.WUSPGetConfig_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetConfigResponse"):
						[Property.WUSPGetConfigSummary = "GetConfig Response"]
						WUSPcwsGetConfigResponseElement GetConfigResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetConfig"):
						[Property.WUSPGetConfigSummary = "GetConfig Request"]
						WUSPcwsGetConfigElement GetConfig;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.WUSPGetConfigSummary = "Fault GetConfig Response"]
						SoapFaultElement FaultGetConfigElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WUSPGetConfigSummary = "Encrypted GetConfig Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

struct WUSPGetCookie = FormatString("%s Message", Property.WUSPGetCookieSummary)
{
	[Post.Local.WUSPGetCookie_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.WUSPGetCookie_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetCookieResponse"):
						[Property.WUSPGetCookieSummary = "GetCookie Response"]
						WUSPcwsGetCookieResponseElement GetCookieResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetCookie"):
						[Property.WUSPGetCookieSummary = "GetCookie Request"]
						WUSPcwsGetCookieElement GetCookie;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.WUSPGetCookieSummary = "Fault GetCookie Response"]
						SoapFaultElement FaultGetCookieElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WUSPGetCookieSummary = "Encrypted GetCookie Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

struct WUSPRegisterComputer = FormatString("%s Message", Property.WUSPRegisterComputerSummary)
{
	[Post.Local.WUSPRegisterComputer_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.WUSPRegisterComputer_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RegisterComputerResponse"):
						[Property.WUSPRegisterComputerSummary = "RegisterComputer Response"]
						WUSPcwsRegisterComputerResponseElement RegisterComputerResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RegisterComputer"):
						[Property.WUSPRegisterComputerSummary = "RegisterComputer Request"]
						WUSPcwsRegisterComputerElement RegisterComputer;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.WUSPRegisterComputerSummary = "Fault RegisterComputer Response"]
						SoapFaultElement FaultRegisterComputerElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WUSPRegisterComputerSummary = "Encrypted RegisterComputer Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

struct WUSPStartCategoryScan = FormatString("%s Message", Property.WUSPStartCategoryScanSummary)
{
	[Post.Local.WUSPStartCategoryScan_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.WUSPStartCategoryScan_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "StartCategoryScanResponse"):
						[Property.WUSPStartCategoryScanSummary = "StartCategoryScan Response"]
						WUSPcwsStartCategoryScanResponseElement StartCategoryScanResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "StartCategoryScan"):
						[Property.WUSPStartCategoryScanSummary = "StartCategoryScan Request"]
						WUSPcwsStartCategoryScanElement StartCategoryScan;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.WUSPStartCategoryScanSummary = "Fault StartCategoryScan Response"]
						SoapFaultElement FaultStartCategoryScanElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WUSPStartCategoryScanSummary = "Encrypted StartCategoryScan Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

struct WUSPSyncUpdates = FormatString("%s Message", Property.WUSPSyncUpdatesSummary)
{
	[Post.Local.WUSPSyncUpdates_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.WUSPSyncUpdates_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "SyncUpdatesResponse"):
						[Property.WUSPSyncUpdatesSummary = "SyncUpdates Response"]
						WUSPcwsSyncUpdatesResponseElement SyncUpdatesResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "SyncUpdates"):
						[Property.WUSPSyncUpdatesSummary = "SyncUpdates Request"]
						WUSPcwsSyncUpdatesElement SyncUpdates;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.WUSPSyncUpdatesSummary = "Fault SyncUpdates Response"]
						SoapFaultElement FaultSyncUpdatesElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WUSPSyncUpdatesSummary = "Encrypted SyncUpdates Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

struct WUSPSyncPrinterCatalog = FormatString("%s Message", Property.WUSPSyncPrinterCatalogSummary)
{
	[Post.Local.WUSPSyncPrinterCatalog_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.WUSPSyncPrinterCatalog_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "SyncPrinterCatalogResponse"):
						[Property.WUSPSyncPrinterCatalogSummary = "SyncPrinterCatalog Response"]
						WUSPcwsSyncPrinterCatalogResponseElement SyncPrinterCatalogResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "SyncPrinterCatalog"):
						[Property.WUSPSyncPrinterCatalogSummary = "SyncPrinterCatalog Request"]
						WUSPcwsSyncPrinterCatalogElement SyncPrinterCatalog;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.WUSPSyncPrinterCatalogSummary = "Fault SyncPrinterCatalog Response"]
						SoapFaultElement FaultSyncPrinterCatalogElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WUSPSyncPrinterCatalogSummary = "Encrypted SyncPrinterCatalog Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

struct WUSPRefreshCache = FormatString("%s Message", Property.WUSPRefreshCacheSummary)
{
	[Post.Local.WUSPRefreshCache_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.WUSPRefreshCache_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RefreshCacheResponse"):
						[Property.WUSPRefreshCacheSummary = "RefreshCache Response"]
						WUSPcwsRefreshCacheResponseElement RefreshCacheResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RefreshCache"):
						[Property.WUSPRefreshCacheSummary = "RefreshCache Request"]
						WUSPcwsRefreshCacheElement RefreshCache;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.WUSPRefreshCacheSummary = "Fault RefreshCache Response"]
						SoapFaultElement FaultRefreshCacheElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WUSPRefreshCacheSummary = "Encrypted RefreshCache Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

struct WUSPGetExtendedUpdateInfo = FormatString("%s Message", Property.WUSPGetExtendedUpdateInfoSummary)
{
	[Post.Local.WUSPGetExtendedUpdateInfo_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.WUSPGetExtendedUpdateInfo_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetExtendedUpdateInfoResponse"):
						[Property.WUSPGetExtendedUpdateInfoSummary = "GetExtendedUpdateInfo Response"]
						WUSPcwsGetExtendedUpdateInfoResponseElement GetExtendedUpdateInfoResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetExtendedUpdateInfo"):
						[Property.WUSPGetExtendedUpdateInfoSummary = "GetExtendedUpdateInfo Request"]
						WUSPcwsGetExtendedUpdateInfoElement GetExtendedUpdateInfo;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.WUSPGetExtendedUpdateInfoSummary = "Fault GetExtendedUpdateInfo Response"]
						SoapFaultElement FaultGetExtendedUpdateInfoElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WUSPGetExtendedUpdateInfoSummary = "Encrypted GetExtendedUpdateInfo Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

struct WUSPGetFileLocations = FormatString("%s Message", Property.WUSPGetFileLocationsSummary)
{
	[Post.Local.WUSPGetFileLocations_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.WUSPGetFileLocations_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetFileLocationsResponse"):
						[Property.WUSPGetFileLocationsSummary = "GetFileLocations Response"]
						WUSPcwsGetFileLocationsResponseElement GetFileLocationsResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetFileLocations"):
						[Property.WUSPGetFileLocationsSummary = "GetFileLocations Request"]
						WUSPcwsGetFileLocationsElement GetFileLocations;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.WUSPGetFileLocationsSummary = "Fault GetFileLocations Response"]
						SoapFaultElement FaultGetFileLocationsElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WUSPGetFileLocationsSummary = "Encrypted GetFileLocations Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

//
// Element ReportEventBatch
// Embedded ComplexType 
//
struct WUSPsdReportEventBatchElement = this.STag.ToString
{
	[Post.Local.WUSPsdReportEventBatchElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("ReportEventBatch") STag;
	switch
	{
		Case !Local.WUSPsdReportEventBatchElement_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "cookie") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct Cookie = this.STag.ToString
						{
							[Post.Local.Cookie_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("cookie") STag;
							switch
							{
								Case !Local.Cookie_IsEmpty:
									struct
									{
										WUSPsdCookie Cookie;
										XmlTag("cookie") ETag;
									}
							}
						}
						
				}
				
				struct ClientTime = this.ClientTime
				{
					[Post.Local.ClientTime_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("clientTime") STag;
					switch
					{
						Case !Local.ClientTime_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) ClientTime;
								XmlTag("clientTime") ETag;
							}
					}
				}
				
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "eventBatch") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct EventBatch = this.STag.ToString
						{
							[Post.Local.EventBatch_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("eventBatch") STag;
							switch
							{
								Case !Local.EventBatch_IsEmpty:
									struct
									{
										WUSPsdArrayOfReportingEvent EventBatch;
										XmlTag("eventBatch") ETag;
									}
							}
						}
						
				}
				
				XmlTag("ReportEventBatch") ETag;
			}
	}
}

//
// ComplexType Cookie
//
Struct WUSPsdCookie
{
	struct Expiration = this.Expiration
	{
		[Post.Local.Expiration_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("Expiration") STag;
		switch
		{
			Case !Local.Expiration_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) Expiration;
					XmlTag("Expiration") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct EncryptedData = this.EncryptedData
			{
				[Post.Local.EncryptedData_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("EncryptedData") STag;
				switch
				{
					Case !Local.EncryptedData_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) EncryptedData;
							XmlTag("EncryptedData") ETag;
						}
				}
			}
			
	}
	
}

//
// ComplexType ArrayOfReportingEvent
//
Struct WUSPsdArrayOfReportingEvent
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ReportingEvent") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct ReportingEvent = this.STag.ToString
		{
			[Post.Local.ReportingEvent_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("ReportingEvent") STag;
			switch
			{
				Case !Local.ReportingEvent_IsEmpty:
					struct
					{
						WUSPsdReportingEvent ReportingEvent;
						XmlTag("ReportingEvent") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType ReportingEvent
//
Struct WUSPsdReportingEvent
{
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "BasicData") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct BasicData = this.STag.ToString
			{
				[Post.Local.BasicData_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("BasicData") STag;
				switch
				{
					Case !Local.BasicData_IsEmpty:
						struct
						{
							WUSPsdBasicData BasicData;
							XmlTag("BasicData") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ExtendedData") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct ExtendedData = this.STag.ToString
			{
				[Post.Local.ExtendedData_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("ExtendedData") STag;
				switch
				{
					Case !Local.ExtendedData_IsEmpty:
						struct
						{
							WUSPsdExtendedData ExtendedData;
							XmlTag("ExtendedData") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "PrivateData") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct PrivateData = this.STag.ToString
			{
				[Post.Local.PrivateData_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("PrivateData") STag;
				switch
				{
					Case !Local.PrivateData_IsEmpty:
						struct
						{
							WUSPsdPrivateData PrivateData;
							XmlTag("PrivateData") ETag;
						}
				}
			}
			
	}
	
}

//
// ComplexType BasicData
//
Struct WUSPsdBasicData
{
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "TargetID") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct TargetID = this.STag.ToString
			{
				[Post.Local.TargetID_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("TargetID") STag;
				switch
				{
					Case !Local.TargetID_IsEmpty:
						struct
						{
							WUSPsdComputerTargetIdentifier TargetID;
							XmlTag("TargetID") ETag;
						}
				}
			}
			
	}
	
	struct SequenceNumber = this.SequenceNumber
	{
		[Post.Local.SequenceNumber_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("SequenceNumber") STag;
		switch
		{
			Case !Local.SequenceNumber_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) SequenceNumber;
					XmlTag("SequenceNumber") ETag;
				}
		}
	}
	
	struct TimeAtTarget = this.TimeAtTarget
	{
		[Post.Local.TimeAtTarget_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("TimeAtTarget") STag;
		switch
		{
			Case !Local.TimeAtTarget_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) TimeAtTarget;
					XmlTag("TimeAtTarget") ETag;
				}
		}
	}
	
	struct EventInstanceID = this.STag.ToString
	{
		[Post.Local.EventInstanceID_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("EventInstanceID") STag;
		switch
		{
			Case !Local.EventInstanceID_IsEmpty:
				struct
				{
					WUSPs1Guid EventInstanceID;
					XmlTag("EventInstanceID") ETag;
				}
		}
	}
	
	struct NamespaceID = this.NamespaceID
	{
		[Post.Local.NamespaceID_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("NamespaceID") STag;
		switch
		{
			Case !Local.NamespaceID_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) NamespaceID;
					XmlTag("NamespaceID") ETag;
				}
		}
	}
	
	struct EventID = this.EventID
	{
		[Post.Local.EventID_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("EventID") STag;
		switch
		{
			Case !Local.EventID_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) EventID;
					XmlTag("EventID") ETag;
				}
		}
	}
	
	struct SourceID = this.SourceID
	{
		[Post.Local.SourceID_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("SourceID") STag;
		switch
		{
			Case !Local.SourceID_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) SourceID;
					XmlTag("SourceID") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "UpdateID") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct UpdateID = this.STag.ToString
			{
				[Post.Local.UpdateID_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("UpdateID") STag;
				switch
				{
					Case !Local.UpdateID_IsEmpty:
						struct
						{
							WUSPsdUpdateRevisionIdentifier UpdateID;
							XmlTag("UpdateID") ETag;
						}
				}
			}
			
	}
	
	struct Win32HResult = this.Win32HResult
	{
		[Post.Local.Win32HResult_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("Win32HResult") STag;
		switch
		{
			Case !Local.Win32HResult_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) Win32HResult;
					XmlTag("Win32HResult") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "AppName") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct AppName = this.AppName
			{
				[Post.Local.AppName_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("AppName") STag;
				switch
				{
					Case !Local.AppName_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) AppName;
							XmlTag("AppName") ETag;
						}
				}
			}
			
	}
	
}

//
// ComplexType ComputerTargetIdentifier
//
Struct WUSPsdComputerTargetIdentifier
{
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Sid") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Sid = this.Sid
			{
				[Post.Local.Sid_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Sid") STag;
				switch
				{
					Case !Local.Sid_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) Sid;
							XmlTag("Sid") ETag;
						}
				}
			}
			
	}
	
}

//
// ComplexType UpdateRevisionIdentifier
//
Struct WUSPsdUpdateRevisionIdentifier
{
	struct UpdateID = this.STag.ToString
	{
		[Post.Local.UpdateID_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("UpdateID") STag;
		switch
		{
			Case !Local.UpdateID_IsEmpty:
				struct
				{
					WUSPs1Guid UpdateID;
					XmlTag("UpdateID") ETag;
				}
		}
	}
	
	struct RevisionNumber = this.RevisionNumber
	{
		[Post.Local.RevisionNumber_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("RevisionNumber") STag;
		switch
		{
			Case !Local.RevisionNumber_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) RevisionNumber;
					XmlTag("RevisionNumber") ETag;
				}
		}
	}
	
}

//
// ComplexType ExtendedData
//
Struct WUSPsdExtendedData
{
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ReplacementStrings") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct ReplacementStrings = this.STag.ToString
			{
				[Post.Local.ReplacementStrings_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("ReplacementStrings") STag;
				switch
				{
					Case !Local.ReplacementStrings_IsEmpty:
						struct
						{
							WUSPsdArrayOfString ReplacementStrings;
							XmlTag("ReplacementStrings") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "MiscData") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct MiscData = this.STag.ToString
			{
				[Post.Local.MiscData_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("MiscData") STag;
				switch
				{
					Case !Local.MiscData_IsEmpty:
						struct
						{
							WUSPsdArrayOfString MiscData;
							XmlTag("MiscData") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ComputerBrand") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct ComputerBrand = this.ComputerBrand
			{
				[Post.Local.ComputerBrand_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("ComputerBrand") STag;
				switch
				{
					Case !Local.ComputerBrand_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) ComputerBrand;
							XmlTag("ComputerBrand") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ComputerModel") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct ComputerModel = this.ComputerModel
			{
				[Post.Local.ComputerModel_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("ComputerModel") STag;
				switch
				{
					Case !Local.ComputerModel_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) ComputerModel;
							XmlTag("ComputerModel") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "BiosRevision") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct BiosRevision = this.BiosRevision
			{
				[Post.Local.BiosRevision_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("BiosRevision") STag;
				switch
				{
					Case !Local.BiosRevision_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) BiosRevision;
							XmlTag("BiosRevision") ETag;
						}
				}
			}
			
	}
	
	struct ProcessorArchitecture = this.STag.ToString
	{
		[Post.Local.ProcessorArchitecture_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("ProcessorArchitecture") STag;
		switch
		{
			Case !Local.ProcessorArchitecture_IsEmpty:
				struct
				{
					WUSPsdProcessorArchitecture ProcessorArchitecture;
					XmlTag("ProcessorArchitecture") ETag;
				}
		}
	}
	
	struct OSVersion = this.STag.ToString
	{
		[Post.Local.OSVersion_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("OSVersion") STag;
		switch
		{
			Case !Local.OSVersion_IsEmpty:
				struct
				{
					WUSPsdDetailedVersion OSVersion;
					XmlTag("OSVersion") ETag;
				}
		}
	}
	
	struct OSLocaleID = this.OSLocaleID
	{
		[Post.Local.OSLocaleID_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("OSLocaleID") STag;
		switch
		{
			Case !Local.OSLocaleID_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) OSLocaleID;
					XmlTag("OSLocaleID") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "DeviceID") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct DeviceID = this.DeviceID
			{
				[Post.Local.DeviceID_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("DeviceID") STag;
				switch
				{
					Case !Local.DeviceID_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) DeviceID;
							XmlTag("DeviceID") ETag;
						}
				}
			}
			
	}
	
}

//
// ComplexType ArrayOfString
//
Struct WUSPsdArrayOfString
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "string") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct String = this.String
		{
			[Post.Local.String_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("string") STag;
			switch
			{
				Case !Local.String_IsEmpty:
					struct
					{
						StringTerm(Property.XMLEncoding, "<", true, false, false) String;
						XmlTag("string") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType DetailedVersion
//
Struct WUSPsdDetailedVersion
{
	struct Major = this.Major
	{
		[Post.Local.Major_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("Major") STag;
		switch
		{
			Case !Local.Major_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) Major;
					XmlTag("Major") ETag;
				}
		}
	}
	
	struct Minor = this.Minor
	{
		[Post.Local.Minor_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("Minor") STag;
		switch
		{
			Case !Local.Minor_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) Minor;
					XmlTag("Minor") ETag;
				}
		}
	}
	
	struct Build = this.Build
	{
		[Post.Local.Build_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("Build") STag;
		switch
		{
			Case !Local.Build_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) Build;
					XmlTag("Build") ETag;
				}
		}
	}
	
	struct Revision = this.Revision
	{
		[Post.Local.Revision_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("Revision") STag;
		switch
		{
			Case !Local.Revision_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) Revision;
					XmlTag("Revision") ETag;
				}
		}
	}
	
	struct ServicePackMajor = this.ServicePackMajor
	{
		[Post.Local.ServicePackMajor_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("ServicePackMajor") STag;
		switch
		{
			Case !Local.ServicePackMajor_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) ServicePackMajor;
					XmlTag("ServicePackMajor") ETag;
				}
		}
	}
	
	struct ServicePackMinor = this.ServicePackMinor
	{
		[Post.Local.ServicePackMinor_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("ServicePackMinor") STag;
		switch
		{
			Case !Local.ServicePackMinor_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) ServicePackMinor;
					XmlTag("ServicePackMinor") ETag;
				}
		}
	}
	
}

//
// ComplexType PrivateData
//
Struct WUSPsdPrivateData
{
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ComputerDnsName") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct ComputerDnsName = this.ComputerDnsName
			{
				[Post.Local.ComputerDnsName_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("ComputerDnsName") STag;
				switch
				{
					Case !Local.ComputerDnsName_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) ComputerDnsName;
							XmlTag("ComputerDnsName") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "UserAccountName") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct UserAccountName = this.UserAccountName
			{
				[Post.Local.UserAccountName_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("UserAccountName") STag;
				switch
				{
					Case !Local.UserAccountName_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) UserAccountName;
							XmlTag("UserAccountName") ETag;
						}
				}
			}
			
	}
	
}

//
// Element ReportEventBatchResponse
// Embedded ComplexType 
//
struct WUSPsdReportEventBatchResponseElement = this.STag.ToString
{
	[Post.Local.WUSPsdReportEventBatchResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("ReportEventBatchResponse") STag;
	switch
	{
		Case !Local.WUSPsdReportEventBatchResponseElement_IsEmpty:
			struct
			{
				struct ReportEventBatchResult = this.ReportEventBatchResult
				{
					[Post.Local.ReportEventBatchResult_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("ReportEventBatchResult") STag;
					switch
					{
						Case !Local.ReportEventBatchResult_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) ReportEventBatchResult;
								XmlTag("ReportEventBatchResult") ETag;
							}
					}
				}
				
				XmlTag("ReportEventBatchResponse") ETag;
			}
	}
}

Struct WUSPsd = Property.WUSPsdSummary
{
	Switch(Property.SOAPAction)
	{
		Case "http://www.microsoft.com/SoftwareDistribution/ReportEventBatch":
			[Property.WUSPsdSummary = this.ToString]
			WUSPReportEventBatch WUSPReportEventBatch;
		Default:
			While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
			{
				XmlElement(true) AnyNode;
			}
	}
	
}

struct WUSPReportEventBatch = FormatString("%s Message", Property.WUSPReportEventBatchSummary)
{
	[Post.Local.WUSPReportEventBatch_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.WUSPReportEventBatch_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ReportEventBatchResponse"):
						[Property.WUSPReportEventBatchSummary = "ReportEventBatch Response"]
						WUSPsdReportEventBatchResponseElement ReportEventBatchResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ReportEventBatch"):
						[Property.WUSPReportEventBatchSummary = "ReportEventBatch Request"]
						WUSPsdReportEventBatchElement ReportEventBatch;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.WUSPReportEventBatchSummary = "Fault ReportEventBatch Response"]
						SoapFaultElement FaultReportEventBatchElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WUSPReportEventBatchSummary = "Encrypted ReportEventBatch Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

//
// SimpleType guid
//
Struct WUSPs1Guid
{
	StringTerm(Property.XMLEncoding, "<", true, false, false) Guid;
}

//
// SimpleType DeploymentAction
//
Struct WUSPcwsDeploymentAction
{
	StringTerm(Property.XMLEncoding, "<", true, false, false) DeploymentAction;
}

//
// SimpleType XmlUpdateFragmentType
//
Struct WUSPcwsXmlUpdateFragmentType
{
	StringTerm(Property.XMLEncoding, "<", true, false, false) XmlUpdateFragment;
}

//
// SimpleType ProcessorArchitecture
//
Struct WUSPsdProcessorArchitecture
{
	StringTerm(Property.XMLEncoding, "<", true, false, false) ProcessorArchitecture;
}

Table WUSPsawsSoapActionTable(value)
{
	Switch(value)
	{
		Case "http://www.microsoft.com/SoftwareDistribution/Server/SimpleAuthWebService/GetAuthorizationCookie": true;
		Default:false;
	}
}

Table WUSPcwsSoapActionTable(value)
{
	Switch(value)
	{
		Case "http://www.microsoft.com/SoftwareDistribution/Server/ClientWebService/GetConfig": 
		Case "http://www.microsoft.com/SoftwareDistribution/Server/ClientWebService/GetCookie": 
		Case "http://www.microsoft.com/SoftwareDistribution/Server/ClientWebService/RegisterComputer": 
		Case "http://www.microsoft.com/SoftwareDistribution/Server/ClientWebService/StartCategoryScan": 
		Case "http://www.microsoft.com/SoftwareDistribution/Server/ClientWebService/SyncUpdates": 
		Case "http://www.microsoft.com/SoftwareDistribution/Server/ClientWebService/SyncPrinterCatalog": 
		Case "http://www.microsoft.com/SoftwareDistribution/Server/ClientWebService/RefreshCache": 
		Case "http://www.microsoft.com/SoftwareDistribution/Server/ClientWebService/GetExtendedUpdateInfo": 
		Case "http://www.microsoft.com/SoftwareDistribution/Server/ClientWebService/GetFileLocations": true;
		Default:false;
	}
}

Table WUSPsdSoapActionTable(value)
{
	Switch(value)
	{
		Case "http://www.microsoft.com/SoftwareDistribution/ReportEventBatch": 
		Case "http://www.microsoft.com/SoftwareDistribution/ReportEventBatch2": 
		Case "http://www.microsoft.com/SoftwareDistribution/GetRequiredInventoryType": 
		Case "http://www.microsoft.com/SoftwareDistribution/ReportInventory": 
		Case "http://www.microsoft.com/SoftwareDistribution/GetRollupConfiguration": 
		Case "http://www.microsoft.com/SoftwareDistribution/RollupDownstreamServers": 
		Case "http://www.microsoft.com/SoftwareDistribution/RollupComputers": 
		Case "http://www.microsoft.com/SoftwareDistribution/GetOutOfSyncComputers": 
		Case "http://www.microsoft.com/SoftwareDistribution/RollupComputerStatus": true;
		Default:false;
	}
}
