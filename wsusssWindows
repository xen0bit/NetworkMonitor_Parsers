//#  (c) 2009 CodePlex Foundation
//#
//#  Title:                  Windows Update Services: Server-Server Protocol
//#
//#  Details:                
//#
//#  Microsoft References:   [MS-WSUSSS]: Windows Update Services: Server-Server Protocol Specification
//#
//#  Comments:               
//#
//#  Revision Class and Date:Major, 12/09/2009
//#                          Minor, 3/11/2010
//#
//####

[Property.SoapBodySummary = "WSUSSS Payload"]
[RegisterBefore(SoapBody.DefaultSoapBody, WSUSSS, WSUSSSSoapActionTable(Property.SOAPAction))]
Protocol WSUSSS = Property.WSUSSSSummary
{
	Switch(Property.SOAPAction)
	{
		Case "http://www.microsoft.com/SoftwareDistribution/GetAuthConfig":
			[Property.WSUSSSSummary = this.ToString]
			WSUSSSGetAuthConfig WSUSSSGetAuthConfig;
		Case "http://www.microsoft.com/SoftwareDistribution/Server/DssAuthWebService/GetAuthorizationCookie":
			[Property.WSUSSSSummary = this.ToString]
			WSUSSSGetAuthorizationCookie WSUSSSGetAuthorizationCookie;
		Case "http://www.microsoft.com/SoftwareDistribution/GetCookie":
			[Property.WSUSSSSummary = this.ToString]
			WSUSSSGetCookie WSUSSSGetCookie;
		Case "http://www.microsoft.com/SoftwareDistribution/GetConfigData":
			[Property.WSUSSSSummary = this.ToString]
			WSUSSSGetConfigData WSUSSSGetConfigData;
		Case "http://www.microsoft.com/SoftwareDistribution/GetRevisionIdList":
			[Property.WSUSSSSummary = this.ToString]
			WSUSSSGetRevisionIdList WSUSSSGetRevisionIdList;
		Case "http://www.microsoft.com/SoftwareDistribution/GetUpdateData":
			[Property.WSUSSSSummary = this.ToString]
			WSUSSSGetUpdateData WSUSSSGetUpdateData;
		Case "http://www.microsoft.com/SoftwareDistribution/GetDeployments":
			[Property.WSUSSSSummary = this.ToString]
			WSUSSSGetDeployments WSUSSSGetDeployments;
		Case "http://www.microsoft.com/SoftwareDistribution/DownloadFiles":
			[Property.WSUSSSSummary = this.ToString]
			WSUSSSDownloadFiles WSUSSSDownloadFiles;
		Case "http://www.microsoft.com/SoftwareDistribution/GetRollupConfiguration":
			[Property.WSUSSSSummary = this.ToString]
			WSUSSSGetRollupConfiguration WSUSSSGetRollupConfiguration;
		Case "http://www.microsoft.com/SoftwareDistribution/RollupDownstreamServers":
			[Property.WSUSSSSummary = this.ToString]
			WSUSSSRollupDownstreamServers WSUSSSRollupDownstreamServers;
		Case "http://www.microsoft.com/SoftwareDistribution/RollupComputerStatus":
			[Property.WSUSSSSummary = this.ToString]
			WSUSSSRollupComputerStatus WSUSSSRollupComputerStatus;
		Case "http://www.microsoft.com/SoftwareDistribution/RollupComputers":
			[Property.WSUSSSSummary = this.ToString]
			WSUSSSRollupComputers WSUSSSRollupComputers;
		Case "http://www.microsoft.com/SoftwareDistribution/GetOutOfSyncComputers":
			[Property.WSUSSSSummary = this.ToString]
			WSUSSSGetOutOfSyncComputers WSUSSSGetOutOfSyncComputers;
		Default:
			While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
			{
				XmlElement(true) AnyNode;
			}
	}
	
}

struct WSUSSSGetAuthConfig = FormatString("%s Message", Property.WSUSSSGetAuthConfigSummary)
{
	[Post.Local.WSUSSSGetAuthConfig_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.WSUSSSGetAuthConfig_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetAuthConfigResponse"):
						[Property.WSUSSSGetAuthConfigSummary = "GetAuthConfig Response"]
						WSUSSSsdGetAuthConfigResponseElement GetAuthConfigResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetAuthConfig"):
						[Property.WSUSSSGetAuthConfigSummary = "GetAuthConfig Request"]
						WSUSSSsdGetAuthConfigElement GetAuthConfig;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.WSUSSSGetAuthConfigSummary = "Fault GetAuthConfig Response"]
						SoapFaultElement FaultGetAuthConfigElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WSUSSSGetAuthConfigSummary = "Encrypted GetAuthConfig Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

struct WSUSSSGetCookie = FormatString("%s Message", Property.WSUSSSGetCookieSummary)
{
	[Post.Local.WSUSSSGetCookie_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.WSUSSSGetCookie_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetCookieResponse"):
						[Property.WSUSSSGetCookieSummary = "GetCookie Response"]
						WSUSSSsdGetCookieResponseElement GetCookieResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetCookie"):
						[Property.WSUSSSGetCookieSummary = "GetCookie Request"]
						WSUSSSsdGetCookieElement GetCookie;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.WSUSSSGetCookieSummary = "Fault GetCookie Response"]
						SoapFaultElement FaultGetCookieElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WSUSSSGetCookieSummary = "Encrypted GetCookie Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

struct WSUSSSGetConfigData = FormatString("%s Message", Property.WSUSSSGetConfigDataSummary)
{
	[Post.Local.WSUSSSGetConfigData_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.WSUSSSGetConfigData_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetConfigDataResponse"):
						[Property.WSUSSSGetConfigDataSummary = "GetConfigData Response"]
						WSUSSSsdGetConfigDataResponseElement GetConfigDataResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetConfigData"):
						[Property.WSUSSSGetConfigDataSummary = "GetConfigData Request"]
						WSUSSSsdGetConfigDataElement GetConfigData;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.WSUSSSGetConfigDataSummary = "Fault GetConfigData Response"]
						SoapFaultElement FaultGetConfigDataElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WSUSSSGetConfigDataSummary = "Encrypted GetConfigData Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

struct WSUSSSGetRevisionIdList = FormatString("%s Message", Property.WSUSSSGetRevisionIdListSummary)
{
	[Post.Local.WSUSSSGetRevisionIdList_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.WSUSSSGetRevisionIdList_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetRevisionIdListResponse"):
						[Property.WSUSSSGetRevisionIdListSummary = "GetRevisionIdList Response"]
						WSUSSSsdGetRevisionIdListResponseElement GetRevisionIdListResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetRevisionIdList"):
						[Property.WSUSSSGetRevisionIdListSummary = "GetRevisionIdList Request"]
						WSUSSSsdGetRevisionIdListElement GetRevisionIdList;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.WSUSSSGetRevisionIdListSummary = "Fault GetRevisionIdList Response"]
						SoapFaultElement FaultGetRevisionIdListElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WSUSSSGetRevisionIdListSummary = "Encrypted GetRevisionIdList Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

struct WSUSSSGetUpdateData = FormatString("%s Message", Property.WSUSSSGetUpdateDataSummary)
{
	[Post.Local.WSUSSSGetUpdateData_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.WSUSSSGetUpdateData_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetUpdateDataResponse"):
						[Property.WSUSSSGetUpdateDataSummary = "GetUpdateData Response"]
						WSUSSSsdGetUpdateDataResponseElement GetUpdateDataResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetUpdateData"):
						[Property.WSUSSSGetUpdateDataSummary = "GetUpdateData Request"]
						WSUSSSsdGetUpdateDataElement GetUpdateData;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.WSUSSSGetUpdateDataSummary = "Fault GetUpdateData Response"]
						SoapFaultElement FaultGetUpdateDataElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WSUSSSGetUpdateDataSummary = "Encrypted GetUpdateData Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

struct WSUSSSDownloadFiles = FormatString("%s Message", Property.WSUSSSDownloadFilesSummary)
{
	[Post.Local.WSUSSSDownloadFiles_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.WSUSSSDownloadFiles_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "DownloadFilesResponse"):
						[Property.WSUSSSDownloadFilesSummary = "DownloadFiles Response"]
						WSUSSSsdDownloadFilesResponseElement DownloadFilesResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "DownloadFiles"):
						[Property.WSUSSSDownloadFilesSummary = "DownloadFiles Request"]
						WSUSSSsdDownloadFilesElement DownloadFiles;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.WSUSSSDownloadFilesSummary = "Fault DownloadFiles Response"]
						SoapFaultElement FaultDownloadFilesElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WSUSSSDownloadFilesSummary = "Encrypted DownloadFiles Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

struct WSUSSSGetDeployments = FormatString("%s Message", Property.WSUSSSGetDeploymentsSummary)
{
	[Post.Local.WSUSSSGetDeployments_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.WSUSSSGetDeployments_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetDeploymentsResponse"):
						[Property.WSUSSSGetDeploymentsSummary = "GetDeployments Response"]
						WSUSSSsdGetDeploymentsResponseElement GetDeploymentsResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetDeployments"):
						[Property.WSUSSSGetDeploymentsSummary = "GetDeployments Request"]
						WSUSSSsdGetDeploymentsElement GetDeployments;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.WSUSSSGetDeploymentsSummary = "Fault GetDeployments Response"]
						SoapFaultElement FaultGetDeploymentsElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WSUSSSGetDeploymentsSummary = "Encrypted GetDeployments Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

struct WSUSSSGetAuthorizationCookie = FormatString("%s Message", Property.WSUSSSGetAuthorizationCookieSummary)
{
	[Post.Local.WSUSSSGetAuthorizationCookie_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.WSUSSSGetAuthorizationCookie_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetAuthorizationCookieResponse"):
						[Property.WSUSSSGetAuthorizationCookieSummary = "GetAuthorizationCookie Response"]
						WSUSSSdawGetAuthorizationCookieResponseElement GetAuthorizationCookieResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetAuthorizationCookie"):
						[Property.WSUSSSGetAuthorizationCookieSummary = "GetAuthorizationCookie Request"]
						WSUSSSdawGetAuthorizationCookieElement GetAuthorizationCookie;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.WSUSSSGetAuthorizationCookieSummary = "Fault GetAuthorizationCookie Response"]
						SoapFaultElement FaultGetAuthorizationCookieElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WSUSSSGetAuthorizationCookieSummary = "Encrypted GetAuthorizationCookie Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

//
// Element GetAuthorizationCookie
// Embedded ComplexType 
//
struct WSUSSSdawGetAuthorizationCookieElement = this.STag.ToString
{
	[ Post.Local.GetAuthorizationCookie_IsEmpty = Property.IsXmlEmptyElement ]
	XmlTag("GetAuthorizationCookie") STag;
	
	switch
	{
		case contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "accountName"):
			struct accountName = this.STag.ToString
			{
				[ Post.Local.accountName_IsEmpty = Property.IsXmlEmptyElement ]
				XmlTag("accountName") STag;
				
				switch 
				{
					case !Local.accountName_IsEmpty :
						struct
						{
							StringTerm(Ascii, "<", true, false, false) accountName;
							XmlTag("accountName") ETag;
						}
				}
			}
	}
	
	switch
	{
		case contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "accountGuid"):
			struct accountGuid = this.STag.ToString
			{
				[ Post.Local.accountGuid_IsEmpty = Property.IsXmlEmptyElement ]
				XmlTag("accountGuid") STag;
				
				switch 
				{
					case !Local.accountGuid_IsEmpty :
						struct
						{
							StringTerm(Ascii, "<", true, false, false) accountGuid;
							XmlTag("accountGuid") ETag;
						}
				}
			}
	}
	
	switch
	{
		case contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "programKeys"):
			struct programKeys = this.STag.ToString
			{
				[ Post.Local.programKeys_IsEmpty = Property.IsXmlEmptyElement ]
				XmlTag("programKeys") STag;
				
				switch 
				{
					case !Local.programKeys_IsEmpty :
						struct
						{
							WSUSSSsdArrayOfGuid programKeys;
							XmlTag("programKeys") ETag;
						}
				}
			}
	}
	
	switch 
	{
		case !Local.GetAuthorizationCookie_IsEmpty :
			XmlTag("GetAuthorizationCookie") ETag;
	}
}

//
// Element GetAuthorizationCookieResponse
// Embedded ComplexType 
//
struct WSUSSSdawGetAuthorizationCookieResponseElement = this.STag.ToString
{
	[ Post.Local.GetAuthorizationCookieResponse_IsEmpty = Property.IsXmlEmptyElement ]
	XmlTag("GetAuthorizationCookieResponse") STag;
		
	switch
	{
		case contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetAuthorizationCookieResult"):
			struct GetAuthorizationCookieResult = this.STag.ToString
			{
				[ Post.Local.GetAuthorizationCookieResult_IsEmpty = Property.IsXmlEmptyElement ]
				XmlTag("GetAuthorizationCookieResult") GetAuthorizationCookieResultOpenTag;
				
				switch 
				{
					case !Local.GetAuthorizationCookieResult_IsEmpty :
						struct
						{
							WSUSSSAuthorizationCookie GetAuthorizationCookieResult;
							XmlTag("GetAuthorizationCookieResult") GetAuthorizationCookieResultCloseTag;
						}
				}
			}
	}
	
	switch 
	{
		case !Local.GetAuthorizationCookieResponse_IsEmpty :
			XmlTag("GetAuthorizationCookieResponse") ETag;
	}
}

struct WSUSSSAuthorizationCookie
{
	switch
	{
		case contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "AuthorizationCookie"):
			XmlTag("AuthorizationCookie") AuthorizationCookieOpenTag;
	}
		
	switch
	{
		case contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "PlugInId"):
			struct PlugInId = this.STag.ToString
			{
				[ Post.Local.PlugInId_IsEmpty = Property.IsXmlEmptyElement ]
				XmlTag("PlugInId") STag;
				
				switch 
				{
					case !Local.PlugInId_IsEmpty :
						struct
						{
							StringTerm(Ascii, "<", true, false, false) PlugInId;
							XmlTag("PlugInId") ETag;
						}
				}
			}
	}
	
	switch
	{
		case contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "CookieData"):
			struct CookieData = this.STag.ToString
			{
				[ Post.Local.CookieData_IsEmpty = Property.IsXmlEmptyElement ]
				XmlTag("CookieData") STag;
				
				switch 
				{
					case !Local.CookieData_IsEmpty :
						struct
						{
							StringTerm(Ascii, "<", true, false, false) CookieData;
							XmlTag("CookieData") ETag;
						}
				}
			}
	}
	
	switch
	{
		case contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "/AuthorizationCookie"):
			XmlTag("AuthorizationCookie") UpdateIdentityCloseTag;
	}
}

//
// Element GetAuthConfig
// Embedded ComplexType 
//
struct WSUSSSsdGetAuthConfigElement = this.STag.ToString
{
	[Post.Local.WSUSSSsdGetAuthConfigElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("GetAuthConfig") STag;
	switch
	{
		Case !Local.WSUSSSsdGetAuthConfigElement_IsEmpty:
			struct
			{
				XmlTag("GetAuthConfig") ETag;
			}
	}
}

//
// Element GetAuthConfigResponse
// Embedded ComplexType 
//
struct WSUSSSsdGetAuthConfigResponseElement = this.STag.ToString
{
	[Post.Local.WSUSSSsdGetAuthConfigResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("GetAuthConfigResponse") STag;
	switch
	{
		Case !Local.WSUSSSsdGetAuthConfigResponseElement_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetAuthConfigResult") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct GetAuthConfigResult = this.STag.ToString
						{
							[Post.Local.GetAuthConfigResult_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("GetAuthConfigResult") STag;
							switch
							{
								Case !Local.GetAuthConfigResult_IsEmpty:
									struct
									{
										WSUSSSsdServerAuthConfig GetAuthConfigResult;
										XmlTag("GetAuthConfigResult") ETag;
									}
							}
						}
						
				}
				
				XmlTag("GetAuthConfigResponse") ETag;
			}
	}
}

//
// ComplexType ServerAuthConfig
//
Struct WSUSSSsdServerAuthConfig
{
	struct LastChange = this.LastChange
	{
		[Post.Local.LastChange_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("LastChange") STag;
		switch
		{
			Case !Local.LastChange_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) LastChange;
					XmlTag("LastChange") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "AuthInfo") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct AuthInfo = this.STag.ToString
			{
				[Post.Local.AuthInfo_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("AuthInfo") STag;
				switch
				{
					Case !Local.AuthInfo_IsEmpty:
						struct
						{
							WSUSSSsdArrayOfAuthPlugInInfo AuthInfo;
							XmlTag("AuthInfo") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "AllowedEventIds") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct AllowedEventIds = this.STag.ToString
			{
				[Post.Local.AllowedEventIds_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("AllowedEventIds") STag;
				switch
				{
					Case !Local.AllowedEventIds_IsEmpty:
						struct
						{
							WSUSSSsdArrayOfInt AllowedEventIds;
							XmlTag("AllowedEventIds") ETag;
						}
				}
			}
			
	}
	
}

//
// ComplexType ArrayOfAuthPlugInInfo
//
Struct WSUSSSsdArrayOfAuthPlugInInfo
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "AuthPlugInInfo") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct AuthPlugInInfo = this.STag.ToString
		{
			[Post.Local.AuthPlugInInfo_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("AuthPlugInInfo") STag;
			switch
			{
				Case !Local.AuthPlugInInfo_IsEmpty:
					struct
					{
						WSUSSSsdAuthPlugInInfo AuthPlugInInfo;
						XmlTag("AuthPlugInInfo") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType AuthPlugInInfo
//
Struct WSUSSSsdAuthPlugInInfo
{
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "PlugInID") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct PlugInID = this.PlugInID
			{
				[Post.Local.PlugInID_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("PlugInID") STag;
				switch
				{
					Case !Local.PlugInID_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) PlugInID;
							XmlTag("PlugInID") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ServiceUrl") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct ServiceUrl = this.ServiceUrl
			{
				[Post.Local.ServiceUrl_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("ServiceUrl") STag;
				switch
				{
					Case !Local.ServiceUrl_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) ServiceUrl;
							XmlTag("ServiceUrl") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Parameter") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Parameter = this.Parameter
			{
				[Post.Local.Parameter_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Parameter") STag;
				switch
				{
					Case !Local.Parameter_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) Parameter;
							XmlTag("Parameter") ETag;
						}
				}
			}
			
	}
	
}

//
// ComplexType ArrayOfInt
//
Struct WSUSSSsdArrayOfInt
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "int") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct Int = this.Int
		{
			[Post.Local.Int_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("int") STag;
			switch
			{
				Case !Local.Int_IsEmpty:
					struct
					{
						StringTerm(Property.XMLEncoding, "<", true, false, false) Int;
						XmlTag("int") ETag;
					}
			}
		}
		
	}
}

//
// Element GetCookie
// Embedded ComplexType 
//
struct WSUSSSsdGetCookieElement = this.STag.ToString
{
	[Post.Local.WSUSSSsdGetCookieElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("GetCookie") STag;
	switch
	{
		Case !Local.WSUSSSsdGetCookieElement_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "authCookies") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct AuthCookies = this.STag.ToString
						{
							[Post.Local.AuthCookies_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("authCookies") STag;
							switch
							{
								Case !Local.AuthCookies_IsEmpty:
									struct
									{
										WSUSSSsdArrayOfAuthorizationCookie AuthCookies;
										XmlTag("authCookies") ETag;
									}
							}
						}
						
				}
				
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "oldCookie") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct OldCookie = this.STag.ToString
						{
							[Post.Local.OldCookie_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("oldCookie") STag;
							switch
							{
								Case !Local.OldCookie_IsEmpty:
									struct
									{
										WSUSSSsdCookie OldCookie;
										XmlTag("oldCookie") ETag;
									}
							}
						}
						
				}
				
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "protocolVersion") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct ProtocolVersion = this.ProtocolVersion
						{
							[Post.Local.ProtocolVersion_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("protocolVersion") STag;
							switch
							{
								Case !Local.ProtocolVersion_IsEmpty:
									struct
									{
										StringTerm(Property.XMLEncoding, "<", true, false, false) ProtocolVersion;
										XmlTag("protocolVersion") ETag;
									}
							}
						}
						
				}
				
				XmlTag("GetCookie") ETag;
			}
	}
}

//
// ComplexType ArrayOfAuthorizationCookie
//
Struct WSUSSSsdArrayOfAuthorizationCookie
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "AuthorizationCookie") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct AuthorizationCookie = this.STag.ToString
		{
			[Post.Local.AuthorizationCookie_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("AuthorizationCookie") STag;
			switch
			{
				Case !Local.AuthorizationCookie_IsEmpty:
					struct
					{
						WSUSSSsdAuthorizationCookie AuthorizationCookie;
						XmlTag("AuthorizationCookie") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType AuthorizationCookie
//
Struct WSUSSSsdAuthorizationCookie
{
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "PlugInId") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct PlugInId = this.PlugInId
			{
				[Post.Local.PlugInId_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("PlugInId") STag;
				switch
				{
					Case !Local.PlugInId_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) PlugInId;
							XmlTag("PlugInId") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "CookieData") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct CookieData = this.CookieData
			{
				[Post.Local.CookieData_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("CookieData") STag;
				switch
				{
					Case !Local.CookieData_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) CookieData;
							XmlTag("CookieData") ETag;
						}
				}
			}
			
	}
	
}

//
// ComplexType Cookie
//
Struct WSUSSSsdCookie
{
	struct Expiration = this.Expiration
	{
		[Post.Local.Expiration_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("Expiration") STag;
		switch
		{
			Case !Local.Expiration_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) Expiration;
					XmlTag("Expiration") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct EncryptedData = this.EncryptedData
			{
				[Post.Local.EncryptedData_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("EncryptedData") STag;
				switch
				{
					Case !Local.EncryptedData_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) EncryptedData;
							XmlTag("EncryptedData") ETag;
						}
				}
			}
			
	}
	
}

//
// Element GetCookieResponse
// Embedded ComplexType 
//
struct WSUSSSsdGetCookieResponseElement = this.STag.ToString
{
	[Post.Local.WSUSSSsdGetCookieResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("GetCookieResponse") STag;
	switch
	{
		Case !Local.WSUSSSsdGetCookieResponseElement_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetCookieResult") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct GetCookieResult = this.STag.ToString
						{
							[Post.Local.GetCookieResult_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("GetCookieResult") STag;
							switch
							{
								Case !Local.GetCookieResult_IsEmpty:
									struct
									{
										WSUSSSsdCookie GetCookieResult;
										XmlTag("GetCookieResult") ETag;
									}
							}
						}
						
				}
				
				XmlTag("GetCookieResponse") ETag;
			}
	}
}

//
// Element GetConfigData
// Embedded ComplexType 
//
struct WSUSSSsdGetConfigDataElement = this.STag.ToString
{
	[Post.Local.WSUSSSsdGetConfigDataElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("GetConfigData") STag;
	switch
	{
		Case !Local.WSUSSSsdGetConfigDataElement_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "cookie") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct Cookie = this.STag.ToString
						{
							[Post.Local.Cookie_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("cookie") STag;
							switch
							{
								Case !Local.Cookie_IsEmpty:
									struct
									{
										WSUSSSsdCookie Cookie;
										XmlTag("cookie") ETag;
									}
							}
						}
						
				}
				
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "configAnchor") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct ConfigAnchor = this.ConfigAnchor
						{
							[Post.Local.ConfigAnchor_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("configAnchor") STag;
							switch
							{
								Case !Local.ConfigAnchor_IsEmpty:
									struct
									{
										StringTerm(Property.XMLEncoding, "<", true, false, false) ConfigAnchor;
										XmlTag("configAnchor") ETag;
									}
							}
						}
						
				}
				
				XmlTag("GetConfigData") ETag;
			}
	}
}

//
// Element GetConfigDataResponse
// Embedded ComplexType 
//
struct WSUSSSsdGetConfigDataResponseElement = this.STag.ToString
{
	[Post.Local.WSUSSSsdGetConfigDataResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("GetConfigDataResponse") STag;
	switch
	{
		Case !Local.WSUSSSsdGetConfigDataResponseElement_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetConfigDataResult") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct GetConfigDataResult = this.STag.ToString
						{
							[Post.Local.GetConfigDataResult_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("GetConfigDataResult") STag;
							switch
							{
								Case !Local.GetConfigDataResult_IsEmpty:
									struct
									{
										WSUSSSsdServerSyncConfigData GetConfigDataResult;
										XmlTag("GetConfigDataResult") ETag;
									}
							}
						}
						
				}
				
				XmlTag("GetConfigDataResponse") ETag;
			}
	}
}

//
// ComplexType ServerSyncConfigData
//
Struct WSUSSSsdServerSyncConfigData
{
	struct CatalogOnlySync = this.CatalogOnlySync
	{
		[Post.Local.CatalogOnlySync_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("CatalogOnlySync") STag;
		switch
		{
			Case !Local.CatalogOnlySync_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) CatalogOnlySync;
					XmlTag("CatalogOnlySync") ETag;
				}
		}
	}
	
	struct LazySync = this.LazySync
	{
		[Post.Local.LazySync_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("LazySync") STag;
		switch
		{
			Case !Local.LazySync_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) LazySync;
					XmlTag("LazySync") ETag;
				}
		}
	}
	
	struct ServerHostsPsfFiles = this.ServerHostsPsfFiles
	{
		[Post.Local.ServerHostsPsfFiles_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("ServerHostsPsfFiles") STag;
		switch
		{
			Case !Local.ServerHostsPsfFiles_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) ServerHostsPsfFiles;
					XmlTag("ServerHostsPsfFiles") ETag;
				}
		}
	}
	
	struct MaxNumberOfUpdatesPerRequest = this.MaxNumberOfUpdatesPerRequest
	{
		[Post.Local.MaxNumberOfUpdatesPerRequest_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("MaxNumberOfUpdatesPerRequest") STag;
		switch
		{
			Case !Local.MaxNumberOfUpdatesPerRequest_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) MaxNumberOfUpdatesPerRequest;
					XmlTag("MaxNumberOfUpdatesPerRequest") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "NewConfigAnchor") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct NewConfigAnchor = this.NewConfigAnchor
			{
				[Post.Local.NewConfigAnchor_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("NewConfigAnchor") STag;
				switch
				{
					Case !Local.NewConfigAnchor_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) NewConfigAnchor;
							XmlTag("NewConfigAnchor") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ProtocolVersion") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct ProtocolVersion = this.ProtocolVersion
			{
				[Post.Local.ProtocolVersion_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("ProtocolVersion") STag;
				switch
				{
					Case !Local.ProtocolVersion_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) ProtocolVersion;
							XmlTag("ProtocolVersion") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "LanguageUpdateList") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct LanguageUpdateList = this.STag.ToString
			{
				[Post.Local.LanguageUpdateList_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("LanguageUpdateList") STag;
				switch
				{
					Case !Local.LanguageUpdateList_IsEmpty:
						struct
						{
							WSUSSSsdArrayOfServerSyncLanguageData LanguageUpdateList;
							XmlTag("LanguageUpdateList") ETag;
						}
				}
			}
			
	}
	
}

//
// ComplexType ArrayOfServerSyncLanguageData
//
Struct WSUSSSsdArrayOfServerSyncLanguageData
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ServerSyncLanguageData") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct ServerSyncLanguageData = this.STag.ToString
		{
			[Post.Local.ServerSyncLanguageData_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("ServerSyncLanguageData") STag;
			switch
			{
				Case !Local.ServerSyncLanguageData_IsEmpty:
					struct
					{
						WSUSSSsdServerSyncLanguageData ServerSyncLanguageData;
						XmlTag("ServerSyncLanguageData") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType ServerSyncLanguageData
//
Struct WSUSSSsdServerSyncLanguageData
{
	struct LanguageID = this.LanguageID
	{
		[Post.Local.LanguageID_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("LanguageID") STag;
		switch
		{
			Case !Local.LanguageID_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) LanguageID;
					XmlTag("LanguageID") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ShortLanguage") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct ShortLanguage = this.ShortLanguage
			{
				[Post.Local.ShortLanguage_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("ShortLanguage") STag;
				switch
				{
					Case !Local.ShortLanguage_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) ShortLanguage;
							XmlTag("ShortLanguage") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "LongLanguage") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct LongLanguage = this.LongLanguage
			{
				[Post.Local.LongLanguage_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("LongLanguage") STag;
				switch
				{
					Case !Local.LongLanguage_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) LongLanguage;
							XmlTag("LongLanguage") ETag;
						}
				}
			}
			
	}
	
	struct Enabled = this.Enabled
	{
		[Post.Local.Enabled_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("Enabled") STag;
		switch
		{
			Case !Local.Enabled_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) Enabled;
					XmlTag("Enabled") ETag;
				}
		}
	}
	
}

//
// Element GetRevisionIdList
// Embedded ComplexType 
//
struct WSUSSSsdGetRevisionIdListElement = this.STag.ToString
{
	[Post.Local.WSUSSSsdGetRevisionIdListElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("GetRevisionIdList") STag;
	switch
	{
		Case !Local.WSUSSSsdGetRevisionIdListElement_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "cookie") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct Cookie = this.STag.ToString
						{
							[Post.Local.Cookie_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("cookie") STag;
							switch
							{
								Case !Local.Cookie_IsEmpty:
									struct
									{
										WSUSSSsdCookie Cookie;
										XmlTag("cookie") ETag;
									}
							}
						}
						
				}
				
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "filter") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct Filter = this.STag.ToString
						{
							[Post.Local.Filter_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("filter") STag;
							switch
							{
								Case !Local.Filter_IsEmpty:
									struct
									{
										WSUSSSsdServerSyncFilter Filter;
										XmlTag("filter") ETag;
									}
							}
						}
						
				}
				
				XmlTag("GetRevisionIdList") ETag;
			}
	}
}

//
// ComplexType ServerSyncFilter
//
Struct WSUSSSsdServerSyncFilter
{
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "DssProtocolVersion") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct DssProtocolVersion = this.STag.ToString
			{
				[Post.Local.DssProtocolVersion_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("DssProtocolVersion") STag;
				switch
				{
					Case !Local.DssProtocolVersion_IsEmpty:
						struct
						{
							WSUSSSsdVersion DssProtocolVersion;
							XmlTag("DssProtocolVersion") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Anchor") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Anchor = this.Anchor
			{
				[Post.Local.Anchor_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Anchor") STag;
				switch
				{
					Case !Local.Anchor_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) Anchor;
							XmlTag("Anchor") ETag;
						}
				}
			}
			
	}
	
	struct GetConfig = this.GetConfig
	{
		[Post.Local.GetConfig_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("GetConfig") STag;
		switch
		{
			Case !Local.GetConfig_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) GetConfig;
					XmlTag("GetConfig") ETag;
				}
		}
	}
	
	struct Get63LanguageOnly = this.Get63LanguageOnly
	{
		[Post.Local.Get63LanguageOnly_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("Get63LanguageOnly") STag;
		switch
		{
			Case !Local.Get63LanguageOnly_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) Get63LanguageOnly;
					XmlTag("Get63LanguageOnly") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Categories") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Categories = this.STag.ToString
			{
				[Post.Local.Categories_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Categories") STag;
				switch
				{
					Case !Local.Categories_IsEmpty:
						struct
						{
							WSUSSSsdArrayOfIdAndDelta Categories;
							XmlTag("Categories") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Classifications") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Classifications = this.STag.ToString
			{
				[Post.Local.Classifications_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Classifications") STag;
				switch
				{
					Case !Local.Classifications_IsEmpty:
						struct
						{
							WSUSSSsdArrayOfIdAndDelta Classifications;
							XmlTag("Classifications") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Languages") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Languages = this.STag.ToString
			{
				[Post.Local.Languages_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Languages") STag;
				switch
				{
					Case !Local.Languages_IsEmpty:
						struct
						{
							WSUSSSsdArrayOfLanguageAndDelta Languages;
							XmlTag("Languages") ETag;
						}
				}
			}
			
	}
	
}

//
// ComplexType Version
//
Struct WSUSSSsdVersion
{
}

//
// ComplexType ArrayOfIdAndDelta
//
Struct WSUSSSsdArrayOfIdAndDelta
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "IdAndDelta") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct IdAndDelta = this.STag.ToString
		{
			[Post.Local.IdAndDelta_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("IdAndDelta") STag;
			switch
			{
				Case !Local.IdAndDelta_IsEmpty:
					struct
					{
						WSUSSSsdIdAndDelta IdAndDelta;
						XmlTag("IdAndDelta") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType IdAndDelta
//
Struct WSUSSSsdIdAndDelta
{
	struct Id = this.STag.ToString
	{
		[Post.Local.Id_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("Id") STag;
		switch
		{
			Case !Local.Id_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) Id;
					XmlTag("Id") ETag;
				}
		}
	}
	
	struct Delta = this.Delta
	{
		[Post.Local.Delta_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("Delta") STag;
		switch
		{
			Case !Local.Delta_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) Delta;
					XmlTag("Delta") ETag;
				}
		}
	}
	
}

//
// ComplexType ArrayOfLanguageAndDelta
//
Struct WSUSSSsdArrayOfLanguageAndDelta
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "LanguageAndDelta") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct LanguageAndDelta = this.STag.ToString
		{
			[Post.Local.LanguageAndDelta_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("LanguageAndDelta") STag;
			switch
			{
				Case !Local.LanguageAndDelta_IsEmpty:
					struct
					{
						WSUSSSsdLanguageAndDelta LanguageAndDelta;
						XmlTag("LanguageAndDelta") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType LanguageAndDelta
//
Struct WSUSSSsdLanguageAndDelta
{
	struct Id = this.Id
	{
		[Post.Local.Id_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("Id") STag;
		switch
		{
			Case !Local.Id_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) Id;
					XmlTag("Id") ETag;
				}
		}
	}
	
	struct Delta = this.Delta
	{
		[Post.Local.Delta_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("Delta") STag;
		switch
		{
			Case !Local.Delta_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) Delta;
					XmlTag("Delta") ETag;
				}
		}
	}
	
}

//
// Element GetRevisionIdListResponse
// Embedded ComplexType 
//
struct WSUSSSsdGetRevisionIdListResponseElement = this.STag.ToString
{
	[Post.Local.WSUSSSsdGetRevisionIdListResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("GetRevisionIdListResponse") STag;
	switch
	{
		Case !Local.WSUSSSsdGetRevisionIdListResponseElement_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetRevisionIdListResult") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct GetRevisionIdListResult = this.STag.ToString
						{
							[Post.Local.GetRevisionIdListResult_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("GetRevisionIdListResult") STag;
							switch
							{
								Case !Local.GetRevisionIdListResult_IsEmpty:
									struct
									{
										WSUSSSsdRevisionIdList GetRevisionIdListResult;
										XmlTag("GetRevisionIdListResult") ETag;
									}
							}
						}
						
				}
				
				XmlTag("GetRevisionIdListResponse") ETag;
			}
	}
}

//
// ComplexType RevisionIdList
//
Struct WSUSSSsdRevisionIdList
{
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Anchor") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Anchor = this.Anchor
			{
				[Post.Local.Anchor_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Anchor") STag;
				switch
				{
					Case !Local.Anchor_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) Anchor;
							XmlTag("Anchor") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "NewRevisions") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct NewRevisions = this.STag.ToString
			{
				[Post.Local.NewRevisions_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("NewRevisions") STag;
				switch
				{
					Case !Local.NewRevisions_IsEmpty:
						struct
						{
							WSUSSSsdArrayOfUpdateIdentity NewRevisions;
							XmlTag("NewRevisions") ETag;
						}
				}
			}
			
	}
	
}

//
// ComplexType ArrayOfUpdateIdentity
//
Struct WSUSSSsdArrayOfUpdateIdentity
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "UpdateIdentity") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct UpdateIdentity = this.STag.ToString
		{
			[Post.Local.UpdateIdentity_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("UpdateIdentity") STag;
			switch
			{
				Case !Local.UpdateIdentity_IsEmpty:
					struct
					{
						WSUSSSsdUpdateIdentity UpdateIdentity;
						XmlTag("UpdateIdentity") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType UpdateIdentity
//
Struct WSUSSSsdUpdateIdentity
{
	struct UpdateID = this.STag.ToString
	{
		[Post.Local.UpdateID_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("UpdateID") STag;
		switch
		{
			Case !Local.UpdateID_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) UpdateID;
					XmlTag("UpdateID") ETag;
				}
		}
	}
	
	struct RevisionNumber = this.RevisionNumber
	{
		[Post.Local.RevisionNumber_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("RevisionNumber") STag;
		switch
		{
			Case !Local.RevisionNumber_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) RevisionNumber;
					XmlTag("RevisionNumber") ETag;
				}
		}
	}
	
}

//
// Element GetUpdateData
// Embedded ComplexType 
//
struct WSUSSSsdGetUpdateDataElement = this.STag.ToString
{
	[Post.Local.WSUSSSsdGetUpdateDataElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("GetUpdateData") STag;
	switch
	{
		Case !Local.WSUSSSsdGetUpdateDataElement_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "cookie") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct Cookie = this.STag.ToString
						{
							[Post.Local.Cookie_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("cookie") STag;
							switch
							{
								Case !Local.Cookie_IsEmpty:
									struct
									{
										WSUSSSsdCookie Cookie;
										XmlTag("cookie") ETag;
									}
							}
						}
						
				}
				
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "updateIds") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct UpdateIds = this.STag.ToString
						{
							[Post.Local.UpdateIds_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("updateIds") STag;
							switch
							{
								Case !Local.UpdateIds_IsEmpty:
									struct
									{
										WSUSSSsdArrayOfUpdateIdentity UpdateIds;
										XmlTag("updateIds") ETag;
									}
							}
						}
						
				}
				
				XmlTag("GetUpdateData") ETag;
			}
	}
}

//
// Element GetUpdateDataResponse
// Embedded ComplexType 
//
struct WSUSSSsdGetUpdateDataResponseElement = this.STag.ToString
{
	[Post.Local.WSUSSSsdGetUpdateDataResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("GetUpdateDataResponse") STag;
	switch
	{
		Case !Local.WSUSSSsdGetUpdateDataResponseElement_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetUpdateDataResult") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct GetUpdateDataResult = this.STag.ToString
						{
							[Post.Local.GetUpdateDataResult_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("GetUpdateDataResult") STag;
							switch
							{
								Case !Local.GetUpdateDataResult_IsEmpty:
									struct
									{
										WSUSSSsdServerUpdateData GetUpdateDataResult;
										XmlTag("GetUpdateDataResult") ETag;
									}
							}
						}
						
				}
				
				XmlTag("GetUpdateDataResponse") ETag;
			}
	}
}

//
// ComplexType ServerUpdateData
//
Struct WSUSSSsdServerUpdateData
{
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "updates") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Updates = this.STag.ToString
			{
				[Post.Local.Updates_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("updates") STag;
				switch
				{
					Case !Local.Updates_IsEmpty:
						struct
						{
							WSUSSSsdArrayOfServerSyncUpdateData Updates;
							XmlTag("updates") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "fileUrls") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct FileUrls = this.STag.ToString
			{
				[Post.Local.FileUrls_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("fileUrls") STag;
				switch
				{
					Case !Local.FileUrls_IsEmpty:
						struct
						{
							WSUSSSsdArrayOfServerSyncUrlData FileUrls;
							XmlTag("fileUrls") ETag;
						}
				}
			}
			
	}
	
}

//
// ComplexType ArrayOfServerSyncUpdateData
//
Struct WSUSSSsdArrayOfServerSyncUpdateData
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ServerSyncUpdateData") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct ServerSyncUpdateData = this.STag.ToString
		{
			[Post.Local.ServerSyncUpdateData_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("ServerSyncUpdateData") STag;
			switch
			{
				Case !Local.ServerSyncUpdateData_IsEmpty:
					struct
					{
						WSUSSSsdServerSyncUpdateData ServerSyncUpdateData;
						XmlTag("ServerSyncUpdateData") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType ServerSyncUpdateData
//
Struct WSUSSSsdServerSyncUpdateData
{
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Id") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Id = this.STag.ToString
			{
				[Post.Local.Id_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Id") STag;
				switch
				{
					Case !Local.Id_IsEmpty:
						struct
						{
							WSUSSSsdUpdateIdentity Id;
							XmlTag("Id") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "XmlUpdateBlob") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct XmlUpdateBlob = this.XmlUpdateBlob
			{
				[Post.Local.XmlUpdateBlob_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("XmlUpdateBlob") STag;
				switch
				{
					Case !Local.XmlUpdateBlob_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) XmlUpdateBlob;
							XmlTag("XmlUpdateBlob") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FileDigestList") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct FileDigestList = this.STag.ToString
			{
				[Post.Local.FileDigestList_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("FileDigestList") STag;
				switch
				{
					Case !Local.FileDigestList_IsEmpty:
						struct
						{
							WSUSSSsdArrayOfBase64Binary FileDigestList;
							XmlTag("FileDigestList") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "XmlUpdateBlobCompressed") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct XmlUpdateBlobCompressed = this.XmlUpdateBlobCompressed
			{
				[Post.Local.XmlUpdateBlobCompressed_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("XmlUpdateBlobCompressed") STag;
				switch
				{
					Case !Local.XmlUpdateBlobCompressed_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) XmlUpdateBlobCompressed;
							XmlTag("XmlUpdateBlobCompressed") ETag;
						}
				}
			}
			
	}
	
}

//
// ComplexType ArrayOfBase64Binary
//
Struct WSUSSSsdArrayOfBase64Binary
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "base64Binary") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct Base64Binary = this.Base64Binary
		{
			[Post.Local.Base64Binary_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("base64Binary") STag;
			switch
			{
				Case !Local.Base64Binary_IsEmpty:
					struct
					{
						StringTerm(Property.XMLEncoding, "<", true, false, false) Base64Binary;
						XmlTag("base64Binary") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType ArrayOfServerSyncUrlData
//
Struct WSUSSSsdArrayOfServerSyncUrlData
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ServerSyncUrlData") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct ServerSyncUrlData = this.STag.ToString
		{
			[Post.Local.ServerSyncUrlData_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("ServerSyncUrlData") STag;
			switch
			{
				Case !Local.ServerSyncUrlData_IsEmpty:
					struct
					{
						WSUSSSsdServerSyncUrlData ServerSyncUrlData;
						XmlTag("ServerSyncUrlData") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType ServerSyncUrlData
//
Struct WSUSSSsdServerSyncUrlData
{
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FileDigest") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct FileDigest = this.FileDigest
			{
				[Post.Local.FileDigest_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("FileDigest") STag;
				switch
				{
					Case !Local.FileDigest_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) FileDigest;
							XmlTag("FileDigest") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "MUUrl") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct MUUrl = this.MUUrl
			{
				[Post.Local.MUUrl_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("MUUrl") STag;
				switch
				{
					Case !Local.MUUrl_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) MUUrl;
							XmlTag("MUUrl") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "UssUrl") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct UssUrl = this.UssUrl
			{
				[Post.Local.UssUrl_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("UssUrl") STag;
				switch
				{
					Case !Local.UssUrl_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) UssUrl;
							XmlTag("UssUrl") ETag;
						}
				}
			}
			
	}
	
}

//
// Element DownloadFiles
// Embedded ComplexType 
//
struct WSUSSSsdDownloadFilesElement = this.STag.ToString
{
	[Post.Local.WSUSSSsdDownloadFilesElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("DownloadFiles") STag;
	switch
	{
		Case !Local.WSUSSSsdDownloadFilesElement_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "cookie") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct Cookie = this.STag.ToString
						{
							[Post.Local.Cookie_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("cookie") STag;
							switch
							{
								Case !Local.Cookie_IsEmpty:
									struct
									{
										WSUSSSsdCookie Cookie;
										XmlTag("cookie") ETag;
									}
							}
						}
						
				}
				
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "fileDigestList") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct FileDigestList = this.STag.ToString
						{
							[Post.Local.FileDigestList_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("fileDigestList") STag;
							switch
							{
								Case !Local.FileDigestList_IsEmpty:
									struct
									{
										WSUSSSsdArrayOfBase64Binary FileDigestList;
										XmlTag("fileDigestList") ETag;
									}
							}
						}
						
				}
				
				XmlTag("DownloadFiles") ETag;
			}
	}
}

//
// Element DownloadFilesResponse
// Embedded ComplexType 
//
struct WSUSSSsdDownloadFilesResponseElement = this.STag.ToString
{
	[Post.Local.WSUSSSsdDownloadFilesResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("DownloadFilesResponse") STag;
	switch
	{
		Case !Local.WSUSSSsdDownloadFilesResponseElement_IsEmpty:
			struct
			{
				XmlTag("DownloadFilesResponse") ETag;
			}
	}
}

//
// Element GetDeployments
// Embedded ComplexType 
//
struct WSUSSSsdGetDeploymentsElement = this.STag.ToString
{
	[Post.Local.WSUSSSsdGetDeploymentsElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("GetDeployments") STag;
	switch
	{
		Case !Local.WSUSSSsdGetDeploymentsElement_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "cookie") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct Cookie = this.STag.ToString
						{
							[Post.Local.Cookie_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("cookie") STag;
							switch
							{
								Case !Local.Cookie_IsEmpty:
									struct
									{
										WSUSSSsdCookie Cookie;
										XmlTag("cookie") ETag;
									}
							}
						}
						
				}
				
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "deploymentAnchor") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct DeploymentAnchor = this.DeploymentAnchor
						{
							[Post.Local.DeploymentAnchor_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("deploymentAnchor") STag;
							switch
							{
								Case !Local.DeploymentAnchor_IsEmpty:
									struct
									{
										StringTerm(Property.XMLEncoding, "<", true, false, false) DeploymentAnchor;
										XmlTag("deploymentAnchor") ETag;
									}
							}
						}
						
				}
				
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "syncAnchor") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct SyncAnchor = this.SyncAnchor
						{
							[Post.Local.SyncAnchor_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("syncAnchor") STag;
							switch
							{
								Case !Local.SyncAnchor_IsEmpty:
									struct
									{
										StringTerm(Property.XMLEncoding, "<", true, false, false) SyncAnchor;
										XmlTag("syncAnchor") ETag;
									}
							}
						}
						
				}
				
				XmlTag("GetDeployments") ETag;
			}
	}
}

//
// Element GetDeploymentsResponse
// Embedded ComplexType 
//
struct WSUSSSsdGetDeploymentsResponseElement = this.STag.ToString
{
	[Post.Local.WSUSSSsdGetDeploymentsResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("GetDeploymentsResponse") STag;
	switch
	{
		Case !Local.WSUSSSsdGetDeploymentsResponseElement_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetDeploymentsResult") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct GetDeploymentsResult = this.STag.ToString
						{
							[Post.Local.GetDeploymentsResult_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("GetDeploymentsResult") STag;
							switch
							{
								Case !Local.GetDeploymentsResult_IsEmpty:
									struct
									{
										WSUSSSsdServerSyncDeploymentResult GetDeploymentsResult;
										XmlTag("GetDeploymentsResult") ETag;
									}
							}
						}
						
				}
				
				XmlTag("GetDeploymentsResponse") ETag;
			}
	}
}

//
// ComplexType ServerSyncDeploymentResult
//
Struct WSUSSSsdServerSyncDeploymentResult
{
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Anchor") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Anchor = this.Anchor
			{
				[Post.Local.Anchor_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Anchor") STag;
				switch
				{
					Case !Local.Anchor_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) Anchor;
							XmlTag("Anchor") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Groups") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Groups = this.STag.ToString
			{
				[Post.Local.Groups_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Groups") STag;
				switch
				{
					Case !Local.Groups_IsEmpty:
						struct
						{
							WSUSSSsdArrayOfServerSyncTargetGroup Groups;
							XmlTag("Groups") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Deployments") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Deployments = this.STag.ToString
			{
				[Post.Local.Deployments_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Deployments") STag;
				switch
				{
					Case !Local.Deployments_IsEmpty:
						struct
						{
							WSUSSSsdArrayOfServerSyncDeployment Deployments;
							XmlTag("Deployments") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "DeadDeployments") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct DeadDeployments = this.STag.ToString
			{
				[Post.Local.DeadDeployments_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("DeadDeployments") STag;
				switch
				{
					Case !Local.DeadDeployments_IsEmpty:
						struct
						{
							WSUSSSsdArrayOfGuid DeadDeployments;
							XmlTag("DeadDeployments") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "HiddenUpdates") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct HiddenUpdates = this.STag.ToString
			{
				[Post.Local.HiddenUpdates_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("HiddenUpdates") STag;
				switch
				{
					Case !Local.HiddenUpdates_IsEmpty:
						struct
						{
							WSUSSSsdArrayOfGuid HiddenUpdates;
							XmlTag("HiddenUpdates") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "AcceptedEulas") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct AcceptedEulas = this.STag.ToString
			{
				[Post.Local.AcceptedEulas_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("AcceptedEulas") STag;
				switch
				{
					Case !Local.AcceptedEulas_IsEmpty:
						struct
						{
							WSUSSSsdArrayOfGuid AcceptedEulas;
							XmlTag("AcceptedEulas") ETag;
						}
				}
			}
			
	}
	
}

//
// ComplexType ArrayOfServerSyncTargetGroup
//
Struct WSUSSSsdArrayOfServerSyncTargetGroup
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ServerSyncTargetGroup") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct ServerSyncTargetGroup = this.STag.ToString
		{
			[Post.Local.ServerSyncTargetGroup_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("ServerSyncTargetGroup") STag;
			switch
			{
				Case !Local.ServerSyncTargetGroup_IsEmpty:
					struct
					{
						WSUSSSsdServerSyncTargetGroup ServerSyncTargetGroup;
						XmlTag("ServerSyncTargetGroup") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType ServerSyncTargetGroup
//
Struct WSUSSSsdServerSyncTargetGroup
{
	struct TargetGroupID = this.STag.ToString
	{
		[Post.Local.TargetGroupID_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("TargetGroupID") STag;
		switch
		{
			Case !Local.TargetGroupID_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) TargetGroupID;
					XmlTag("TargetGroupID") ETag;
				}
		}
	}
	
	struct ParentGroupId = this.STag.ToString
	{
		[Post.Local.ParentGroupId_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("ParentGroupId") STag;
		switch
		{
			Case !Local.ParentGroupId_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) ParentGroupId;
					XmlTag("ParentGroupId") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Name") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Name = this.Name
			{
				[Post.Local.Name_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Name") STag;
				switch
				{
					Case !Local.Name_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) Name;
							XmlTag("Name") ETag;
						}
				}
			}
			
	}
	
	struct IsBuiltin = this.IsBuiltin
	{
		[Post.Local.IsBuiltin_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("IsBuiltin") STag;
		switch
		{
			Case !Local.IsBuiltin_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) IsBuiltin;
					XmlTag("IsBuiltin") ETag;
				}
		}
	}
	
}

//
// ComplexType ArrayOfServerSyncDeployment
//
Struct WSUSSSsdArrayOfServerSyncDeployment
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ServerSyncDeployment") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct ServerSyncDeployment = this.STag.ToString
		{
			[Post.Local.ServerSyncDeployment_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("ServerSyncDeployment") STag;
			switch
			{
				Case !Local.ServerSyncDeployment_IsEmpty:
					struct
					{
						WSUSSSsdServerSyncDeployment ServerSyncDeployment;
						XmlTag("ServerSyncDeployment") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType ServerSyncDeployment
//
Struct WSUSSSsdServerSyncDeployment
{
	struct UpdateId = this.STag.ToString
	{
		[Post.Local.UpdateId_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("UpdateId") STag;
		switch
		{
			Case !Local.UpdateId_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) UpdateId;
					XmlTag("UpdateId") ETag;
				}
		}
	}
	
	struct RevisionNumber = this.RevisionNumber
	{
		[Post.Local.RevisionNumber_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("RevisionNumber") STag;
		switch
		{
			Case !Local.RevisionNumber_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) RevisionNumber;
					XmlTag("RevisionNumber") ETag;
				}
		}
	}
	
	struct Action = this.Action
	{
		[Post.Local.Action_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("Action") STag;
		switch
		{
			Case !Local.Action_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) Action;
					XmlTag("Action") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "AdminName") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct AdminName = this.AdminName
			{
				[Post.Local.AdminName_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("AdminName") STag;
				switch
				{
					Case !Local.AdminName_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) AdminName;
							XmlTag("AdminName") ETag;
						}
				}
			}
			
	}
	
	struct Deadline = this.Deadline
	{
		[Post.Local.Deadline_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("Deadline") STag;
		switch
		{
			Case !Local.Deadline_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) Deadline;
					XmlTag("Deadline") ETag;
				}
		}
	}
	
	struct IsAssigned = this.IsAssigned
	{
		[Post.Local.IsAssigned_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("IsAssigned") STag;
		switch
		{
			Case !Local.IsAssigned_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) IsAssigned;
					XmlTag("IsAssigned") ETag;
				}
		}
	}
	
	struct GoLiveTime = this.GoLiveTime
	{
		[Post.Local.GoLiveTime_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("GoLiveTime") STag;
		switch
		{
			Case !Local.GoLiveTime_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) GoLiveTime;
					XmlTag("GoLiveTime") ETag;
				}
		}
	}
	
	struct DeploymentGuid = this.STag.ToString
	{
		[Post.Local.DeploymentGuid_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("DeploymentGuid") STag;
		switch
		{
			Case !Local.DeploymentGuid_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) DeploymentGuid;
					XmlTag("DeploymentGuid") ETag;
				}
		}
	}
	
	struct TargetGroupId = this.STag.ToString
	{
		[Post.Local.TargetGroupId_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("TargetGroupId") STag;
		switch
		{
			Case !Local.TargetGroupId_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) TargetGroupId;
					XmlTag("TargetGroupId") ETag;
				}
		}
	}
	
	struct DownloadPriority = this.DownloadPriority
	{
		[Post.Local.DownloadPriority_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("DownloadPriority") STag;
		switch
		{
			Case !Local.DownloadPriority_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) DownloadPriority;
					XmlTag("DownloadPriority") ETag;
				}
		}
	}
	
}

//
// ComplexType ArrayOfGuid
//
Struct WSUSSSsdArrayOfGuid
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "guid") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct Guid = this.STag.ToString
		{
			[Post.Local.Guid_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("guid") STag;
			switch
			{
				Case !Local.Guid_IsEmpty:
					struct
					{
						StringTerm(Property.XMLEncoding, "<", true, false, false) Guid;
						XmlTag("guid") ETag;
					}
			}
		}
		
	}
}

struct WSUSSSRollupDownstreamServers = FormatString("%s Message", Property.WSUSSSRollupDownstreamServersSummary)
{
	[Post.Local.WSUSSSRollupDownstreamServers_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.WSUSSSRollupDownstreamServers_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RollupDownstreamServersResponse"):
						[Property.WSUSSSRollupDownstreamServersSummary = "RollupDownstreamServers Response"]
						WSUSSSsdRollupDownstreamServersResponseElement RollupDownstreamServersResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RollupDownstreamServers"):
						[Property.WSUSSSRollupDownstreamServersSummary = "RollupDownstreamServers Request"]
						WSUSSSsdRollupDownstreamServersElement RollupDownstreamServers;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.WSUSSSRollupDownstreamServersSummary = "Fault RollupDownstreamServers Response"]
						SoapFaultElement FaultRollupDownstreamServersElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WSUSSSRollupDownstreamServersSummary = "Encrypted RollupDownstreamServers Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

//
// Element RollupDownstreamServersResponse
// Embedded ComplexType 
//
struct WSUSSSsdRollupDownstreamServersResponseElement = this.STag.ToString
{
	[Post.Local.WSUSSSsdRollupDownstreamServersResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("RollupDownstreamServersResponse") STag;
	switch
	{
		Case !Local.WSUSSSsdRollupDownstreamServersResponseElement_IsEmpty:
			struct
			{
				XmlTag("RollupDownstreamServersResponse") ETag;
			}
	}
}

//
// Element RollupDownstreamServers
// Embedded ComplexType 
//
struct WSUSSSsdRollupDownstreamServersElement = this.STag.ToString
{
	[Post.Local.WSUSSSsdRollupDownstreamServersElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("RollupDownstreamServers") STag;
	switch
	{
		Case !Local.WSUSSSsdRollupDownstreamServersElement_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "cookie") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct Cookie = this.STag.ToString
						{
							[Post.Local.Cookie_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("cookie") STag;
							switch
							{
								Case !Local.Cookie_IsEmpty:
									struct
									{
										WSUSSSsdCookie Cookie;
										XmlTag("cookie") ETag;
									}
							}
						}
						
				}
				
				struct ClientTime = this.ClientTime
				{
					[Post.Local.ClientTime_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("clientTime") STag;
					switch
					{
						Case !Local.ClientTime_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) ClientTime;
								XmlTag("clientTime") ETag;
							}
					}
				}
				
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "downstreamServers") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct DownstreamServers = this.STag.ToString
						{
							[Post.Local.DownstreamServers_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("downstreamServers") STag;
							switch
							{
								Case !Local.DownstreamServers_IsEmpty:
									struct
									{
										WSUSSSsdArrayOfDownstreamServerRollupInfo DownstreamServers;
										XmlTag("downstreamServers") ETag;
									}
							}
						}
						
				}
				
				XmlTag("RollupDownstreamServers") ETag;
			}
	}
}

//
// ComplexType ArrayOfDownstreamServerRollupInfo
//
Struct WSUSSSsdArrayOfDownstreamServerRollupInfo
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "DownstreamServerRollupInfo") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct DownstreamServerRollupInfo = this.STag.ToString
		{
			[Post.Local.DownstreamServerRollupInfo_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("DownstreamServerRollupInfo") STag;
			switch
			{
				Case !Local.DownstreamServerRollupInfo_IsEmpty:
					struct
					{
						WSUSSSsdDownstreamServerRollupInfo DownstreamServerRollupInfo;
						XmlTag("DownstreamServerRollupInfo") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType DownstreamServerRollupInfo
//
Struct WSUSSSsdDownstreamServerRollupInfo
{
	struct ServerId = this.STag.ToString
	{
		[Post.Local.ServerId_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("ServerId") STag;
		switch
		{
			Case !Local.ServerId_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) ServerId;
					XmlTag("ServerId") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "FullDomainName") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct FullDomainName = this.FullDomainName
			{
				[Post.Local.FullDomainName_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("FullDomainName") STag;
				switch
				{
					Case !Local.FullDomainName_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) FullDomainName;
							XmlTag("FullDomainName") ETag;
						}
				}
			}
			
	}
	
	struct LastSyncTime = this.LastSyncTime
	{
		[Post.Local.LastSyncTime_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("LastSyncTime") STag;
		switch
		{
			Case !Local.LastSyncTime_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) LastSyncTime;
					XmlTag("LastSyncTime") ETag;
				}
		}
	}
	
	struct ParentServerId = this.STag.ToString
	{
		[Post.Local.ParentServerId_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("ParentServerId") STag;
		switch
		{
			Case !Local.ParentServerId_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) ParentServerId;
					XmlTag("ParentServerId") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Version") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Version = this.Version
			{
				[Post.Local.Version_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Version") STag;
				switch
				{
					Case !Local.Version_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) Version;
							XmlTag("Version") ETag;
						}
				}
			}
			
	}
	
	struct IsReplica = this.IsReplica
	{
		[Post.Local.IsReplica_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("IsReplica") STag;
		switch
		{
			Case !Local.IsReplica_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) IsReplica;
					XmlTag("IsReplica") ETag;
				}
		}
	}
	
	struct LastRollupTime = this.LastRollupTime
	{
		[Post.Local.LastRollupTime_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("LastRollupTime") STag;
		switch
		{
			Case !Local.LastRollupTime_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) LastRollupTime;
					XmlTag("LastRollupTime") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ServerSummary") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct ServerSummary = this.STag.ToString
			{
				[Post.Local.ServerSummary_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("ServerSummary") STag;
				switch
				{
					Case !Local.ServerSummary_IsEmpty:
						struct
						{
							WSUSSSsdDownstreamServerRollupServerSummary ServerSummary;
							XmlTag("ServerSummary") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ClientSummaries") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct ClientSummaries = this.STag.ToString
			{
				[Post.Local.ClientSummaries_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("ClientSummaries") STag;
				switch
				{
					Case !Local.ClientSummaries_IsEmpty:
						struct
						{
							WSUSSSsdArrayOfDownstreamServerRollupClientSummary ClientSummaries;
							XmlTag("ClientSummaries") ETag;
						}
				}
			}
			
	}
	
}

//
// ComplexType DownstreamServerRollupServerSummary
//
Struct WSUSSSsdDownstreamServerRollupServerSummary
{
	struct UpdateCount = this.UpdateCount
	{
		[Post.Local.UpdateCount_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("UpdateCount") STag;
		switch
		{
			Case !Local.UpdateCount_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) UpdateCount;
					XmlTag("UpdateCount") ETag;
				}
		}
	}
	
	struct DeclinedUpdateCount = this.DeclinedUpdateCount
	{
		[Post.Local.DeclinedUpdateCount_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("DeclinedUpdateCount") STag;
		switch
		{
			Case !Local.DeclinedUpdateCount_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) DeclinedUpdateCount;
					XmlTag("DeclinedUpdateCount") ETag;
				}
		}
	}
	
	struct ApprovedUpdateCount = this.ApprovedUpdateCount
	{
		[Post.Local.ApprovedUpdateCount_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("ApprovedUpdateCount") STag;
		switch
		{
			Case !Local.ApprovedUpdateCount_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) ApprovedUpdateCount;
					XmlTag("ApprovedUpdateCount") ETag;
				}
		}
	}
	
	struct NotApprovedUpdateCount = this.NotApprovedUpdateCount
	{
		[Post.Local.NotApprovedUpdateCount_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("NotApprovedUpdateCount") STag;
		switch
		{
			Case !Local.NotApprovedUpdateCount_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) NotApprovedUpdateCount;
					XmlTag("NotApprovedUpdateCount") ETag;
				}
		}
	}
	
	struct UpdatesWithStaleUpdateApprovalsCount = this.UpdatesWithStaleUpdateApprovalsCount
	{
		[Post.Local.UpdatesWithStaleUpdateApprovalsCount_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("UpdatesWithStaleUpdateApprovalsCount") STag;
		switch
		{
			Case !Local.UpdatesWithStaleUpdateApprovalsCount_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) UpdatesWithStaleUpdateApprovalsCount;
					XmlTag("UpdatesWithStaleUpdateApprovalsCount") ETag;
				}
		}
	}
	
	struct ExpiredUpdateCount = this.ExpiredUpdateCount
	{
		[Post.Local.ExpiredUpdateCount_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("ExpiredUpdateCount") STag;
		switch
		{
			Case !Local.ExpiredUpdateCount_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) ExpiredUpdateCount;
					XmlTag("ExpiredUpdateCount") ETag;
				}
		}
	}
	
	struct CriticalOrSecurityUpdatesNotApprovedForInstallCount = this.CriticalOrSecurityUpdatesNotApprovedForInstallCount
	{
		[Post.Local.CriticalOrSecurityUpdatesNotApprovedForInstallCount_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("CriticalOrSecurityUpdatesNotApprovedForInstallCount") STag;
		switch
		{
			Case !Local.CriticalOrSecurityUpdatesNotApprovedForInstallCount_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) CriticalOrSecurityUpdatesNotApprovedForInstallCount;
					XmlTag("CriticalOrSecurityUpdatesNotApprovedForInstallCount") ETag;
				}
		}
	}
	
	struct WsusInfrastructureUpdatesNotApprovedForInstallCount = this.WsusInfrastructureUpdatesNotApprovedForInstallCount
	{
		[Post.Local.WsusInfrastructureUpdatesNotApprovedForInstallCount_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("WsusInfrastructureUpdatesNotApprovedForInstallCount") STag;
		switch
		{
			Case !Local.WsusInfrastructureUpdatesNotApprovedForInstallCount_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) WsusInfrastructureUpdatesNotApprovedForInstallCount;
					XmlTag("WsusInfrastructureUpdatesNotApprovedForInstallCount") ETag;
				}
		}
	}
	
	struct UpdatesWithClientErrorsCount = this.UpdatesWithClientErrorsCount
	{
		[Post.Local.UpdatesWithClientErrorsCount_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("UpdatesWithClientErrorsCount") STag;
		switch
		{
			Case !Local.UpdatesWithClientErrorsCount_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) UpdatesWithClientErrorsCount;
					XmlTag("UpdatesWithClientErrorsCount") ETag;
				}
		}
	}
	
	struct UpdatesWithServerErrorsCount = this.UpdatesWithServerErrorsCount
	{
		[Post.Local.UpdatesWithServerErrorsCount_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("UpdatesWithServerErrorsCount") STag;
		switch
		{
			Case !Local.UpdatesWithServerErrorsCount_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) UpdatesWithServerErrorsCount;
					XmlTag("UpdatesWithServerErrorsCount") ETag;
				}
		}
	}
	
	struct UpdatesNeedingFilesCount = this.UpdatesNeedingFilesCount
	{
		[Post.Local.UpdatesNeedingFilesCount_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("UpdatesNeedingFilesCount") STag;
		switch
		{
			Case !Local.UpdatesNeedingFilesCount_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) UpdatesNeedingFilesCount;
					XmlTag("UpdatesNeedingFilesCount") ETag;
				}
		}
	}
	
	struct UpdatesNeededByComputersCount = this.UpdatesNeededByComputersCount
	{
		[Post.Local.UpdatesNeededByComputersCount_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("UpdatesNeededByComputersCount") STag;
		switch
		{
			Case !Local.UpdatesNeededByComputersCount_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) UpdatesNeededByComputersCount;
					XmlTag("UpdatesNeededByComputersCount") ETag;
				}
		}
	}
	
	struct UpdatesUpToDateCount = this.UpdatesUpToDateCount
	{
		[Post.Local.UpdatesUpToDateCount_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("UpdatesUpToDateCount") STag;
		switch
		{
			Case !Local.UpdatesUpToDateCount_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) UpdatesUpToDateCount;
					XmlTag("UpdatesUpToDateCount") ETag;
				}
		}
	}
	
	struct CustomComputerTargetGroupCount = this.CustomComputerTargetGroupCount
	{
		[Post.Local.CustomComputerTargetGroupCount_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("CustomComputerTargetGroupCount") STag;
		switch
		{
			Case !Local.CustomComputerTargetGroupCount_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) CustomComputerTargetGroupCount;
					XmlTag("CustomComputerTargetGroupCount") ETag;
				}
		}
	}
	
	struct ComputerTargetCount = this.ComputerTargetCount
	{
		[Post.Local.ComputerTargetCount_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("ComputerTargetCount") STag;
		switch
		{
			Case !Local.ComputerTargetCount_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) ComputerTargetCount;
					XmlTag("ComputerTargetCount") ETag;
				}
		}
	}
	
	struct ComputerTargetsNeedingUpdatesCount = this.ComputerTargetsNeedingUpdatesCount
	{
		[Post.Local.ComputerTargetsNeedingUpdatesCount_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("ComputerTargetsNeedingUpdatesCount") STag;
		switch
		{
			Case !Local.ComputerTargetsNeedingUpdatesCount_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) ComputerTargetsNeedingUpdatesCount;
					XmlTag("ComputerTargetsNeedingUpdatesCount") ETag;
				}
		}
	}
	
	struct ComputerTargetsWithUpdateErrorsCount = this.ComputerTargetsWithUpdateErrorsCount
	{
		[Post.Local.ComputerTargetsWithUpdateErrorsCount_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("ComputerTargetsWithUpdateErrorsCount") STag;
		switch
		{
			Case !Local.ComputerTargetsWithUpdateErrorsCount_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) ComputerTargetsWithUpdateErrorsCount;
					XmlTag("ComputerTargetsWithUpdateErrorsCount") ETag;
				}
		}
	}
	
	struct ComputersUpToDateCount = this.ComputersUpToDateCount
	{
		[Post.Local.ComputersUpToDateCount_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("ComputersUpToDateCount") STag;
		switch
		{
			Case !Local.ComputersUpToDateCount_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) ComputersUpToDateCount;
					XmlTag("ComputersUpToDateCount") ETag;
				}
		}
	}
	
}

//
// ComplexType ArrayOfDownstreamServerRollupClientSummary
//
Struct WSUSSSsdArrayOfDownstreamServerRollupClientSummary
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "DownstreamServerRollupClientSummary") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct DownstreamServerRollupClientSummary = this.STag.ToString
		{
			[Post.Local.DownstreamServerRollupClientSummary_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("DownstreamServerRollupClientSummary") STag;
			switch
			{
				Case !Local.DownstreamServerRollupClientSummary_IsEmpty:
					struct
					{
						WSUSSSsdDownstreamServerRollupClientSummary DownstreamServerRollupClientSummary;
						XmlTag("DownstreamServerRollupClientSummary") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType DownstreamServerRollupClientSummary
//
Struct WSUSSSsdDownstreamServerRollupClientSummary
{
	struct OSMajorVersion = this.OSMajorVersion
	{
		[Post.Local.OSMajorVersion_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("OSMajorVersion") STag;
		switch
		{
			Case !Local.OSMajorVersion_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) OSMajorVersion;
					XmlTag("OSMajorVersion") ETag;
				}
		}
	}
	
	struct OSMinorVersion = this.OSMinorVersion
	{
		[Post.Local.OSMinorVersion_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("OSMinorVersion") STag;
		switch
		{
			Case !Local.OSMinorVersion_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) OSMinorVersion;
					XmlTag("OSMinorVersion") ETag;
				}
		}
	}
	
	struct OSBuildNumber = this.OSBuildNumber
	{
		[Post.Local.OSBuildNumber_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("OSBuildNumber") STag;
		switch
		{
			Case !Local.OSBuildNumber_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) OSBuildNumber;
					XmlTag("OSBuildNumber") ETag;
				}
		}
	}
	
	struct OSServicePackMajorNumber = this.OSServicePackMajorNumber
	{
		[Post.Local.OSServicePackMajorNumber_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("OSServicePackMajorNumber") STag;
		switch
		{
			Case !Local.OSServicePackMajorNumber_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) OSServicePackMajorNumber;
					XmlTag("OSServicePackMajorNumber") ETag;
				}
		}
	}
	
	struct OSServicePackMinorNumber = this.OSServicePackMinorNumber
	{
		[Post.Local.OSServicePackMinorNumber_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("OSServicePackMinorNumber") STag;
		switch
		{
			Case !Local.OSServicePackMinorNumber_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) OSServicePackMinorNumber;
					XmlTag("OSServicePackMinorNumber") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "OSLocale") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct OSLocale = this.OSLocale
			{
				[Post.Local.OSLocale_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("OSLocale") STag;
				switch
				{
					Case !Local.OSLocale_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) OSLocale;
							XmlTag("OSLocale") ETag;
						}
				}
			}
			
	}
	
	struct SuiteMask = this.SuiteMask
	{
		[Post.Local.SuiteMask_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("SuiteMask") STag;
		switch
		{
			Case !Local.SuiteMask_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) SuiteMask;
					XmlTag("SuiteMask") ETag;
				}
		}
	}
	
	struct OldProductType = this.OldProductType
	{
		[Post.Local.OldProductType_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("OldProductType") STag;
		switch
		{
			Case !Local.OldProductType_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) OldProductType;
					XmlTag("OldProductType") ETag;
				}
		}
	}
	
	struct NewProductType = this.NewProductType
	{
		[Post.Local.NewProductType_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("NewProductType") STag;
		switch
		{
			Case !Local.NewProductType_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) NewProductType;
					XmlTag("NewProductType") ETag;
				}
		}
	}
	
	struct SystemMetrics = this.SystemMetrics
	{
		[Post.Local.SystemMetrics_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("SystemMetrics") STag;
		switch
		{
			Case !Local.SystemMetrics_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) SystemMetrics;
					XmlTag("SystemMetrics") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ProcessorArchitecture") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct ProcessorArchitecture = this.ProcessorArchitecture
			{
				[Post.Local.ProcessorArchitecture_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("ProcessorArchitecture") STag;
				switch
				{
					Case !Local.ProcessorArchitecture_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) ProcessorArchitecture;
							XmlTag("ProcessorArchitecture") ETag;
						}
				}
			}
			
	}
	
	struct Count = this.Count
	{
		[Post.Local.Count_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("Count") STag;
		switch
		{
			Case !Local.Count_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) Count;
					XmlTag("Count") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ActivitySummaries") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct ActivitySummaries = this.STag.ToString
			{
				[Post.Local.ActivitySummaries_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("ActivitySummaries") STag;
				switch
				{
					Case !Local.ActivitySummaries_IsEmpty:
						struct
						{
							WSUSSSsdArrayOfDownstreamServerRollupClientActivitySummary ActivitySummaries;
							XmlTag("ActivitySummaries") ETag;
						}
				}
			}
			
	}
	
}

//
// ComplexType ArrayOfDownstreamServerRollupClientActivitySummary
//
Struct WSUSSSsdArrayOfDownstreamServerRollupClientActivitySummary
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "DownstreamServerRollupClientActivitySummary") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct DownstreamServerRollupClientActivitySummary = this.STag.ToString
		{
			[Post.Local.DownstreamServerRollupClientActivitySummary_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("DownstreamServerRollupClientActivitySummary") STag;
			switch
			{
				Case !Local.DownstreamServerRollupClientActivitySummary_IsEmpty:
					struct
					{
						WSUSSSsdDownstreamServerRollupClientActivitySummary DownstreamServerRollupClientActivitySummary;
						XmlTag("DownstreamServerRollupClientActivitySummary") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType DownstreamServerRollupClientActivitySummary
//
Struct WSUSSSsdDownstreamServerRollupClientActivitySummary
{
	struct UpdateId = this.STag.ToString
	{
		[Post.Local.UpdateId_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("UpdateId") STag;
		switch
		{
			Case !Local.UpdateId_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) UpdateId;
					XmlTag("UpdateId") ETag;
				}
		}
	}
	
	struct RevisionNumber = this.RevisionNumber
	{
		[Post.Local.RevisionNumber_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("RevisionNumber") STag;
		switch
		{
			Case !Local.RevisionNumber_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) RevisionNumber;
					XmlTag("RevisionNumber") ETag;
				}
		}
	}
	
	struct InstallSuccessCount = this.InstallSuccessCount
	{
		[Post.Local.InstallSuccessCount_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("InstallSuccessCount") STag;
		switch
		{
			Case !Local.InstallSuccessCount_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) InstallSuccessCount;
					XmlTag("InstallSuccessCount") ETag;
				}
		}
	}
	
	struct InstallFailureCount = this.InstallFailureCount
	{
		[Post.Local.InstallFailureCount_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("InstallFailureCount") STag;
		switch
		{
			Case !Local.InstallFailureCount_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) InstallFailureCount;
					XmlTag("InstallFailureCount") ETag;
				}
		}
	}
	
}

struct WSUSSSGetRollupConfiguration = FormatString("%s Message", Property.WSUSSSGetRollupConfigurationSummary)
{
	[Post.Local.WSUSSSGetRollupConfiguration_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.WSUSSSGetRollupConfiguration_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetRollupConfigurationResponse"):
						[Property.WSUSSSGetRollupConfigurationSummary = "GetRollupConfiguration Response"]
						WSUSSSsdGetRollupConfigurationResponseElement GetRollupConfigurationResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetRollupConfiguration"):
						[Property.WSUSSSGetRollupConfigurationSummary = "GetRollupConfiguration Request"]
						WSUSSSsdGetRollupConfigurationElement GetRollupConfiguration;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.WSUSSSGetRollupConfigurationSummary = "Fault GetRollupConfiguration Response"]
						SoapFaultElement FaultGetRollupConfigurationElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WSUSSSGetRollupConfigurationSummary = "Encrypted GetRollupConfiguration Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

//
// Element GetRollupConfiguration
// Embedded ComplexType 
//
struct WSUSSSsdGetRollupConfigurationElement = this.STag.ToString
{
	[Post.Local.WSUSSSsdGetRollupConfigurationElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("GetRollupConfiguration") STag;
	switch
	{
		Case !Local.WSUSSSsdGetRollupConfigurationElement_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "cookie") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct Cookie = this.STag.ToString
						{
							[Post.Local.Cookie_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("cookie") STag;
							switch
							{
								Case !Local.Cookie_IsEmpty:
									struct
									{
										WSUSSSsdCookie Cookie;
										XmlTag("cookie") ETag;
									}
							}
						}
						
				}
				
				XmlTag("GetRollupConfiguration") ETag;
			}
	}
}

//
// Element GetRollupConfigurationResponse
// Embedded ComplexType 
//
struct WSUSSSsdGetRollupConfigurationResponseElement = this.STag.ToString
{
	[Post.Local.WSUSSSsdGetRollupConfigurationResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("GetRollupConfigurationResponse") STag;
	switch
	{
		Case !Local.WSUSSSsdGetRollupConfigurationResponseElement_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetRollupConfigurationResult") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct GetRollupConfigurationResult = this.STag.ToString
						{
							[Post.Local.GetRollupConfigurationResult_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("GetRollupConfigurationResult") STag;
							switch
							{
								Case !Local.GetRollupConfigurationResult_IsEmpty:
									struct
									{
										WSUSSSsdRollupConfiguration GetRollupConfigurationResult;
										XmlTag("GetRollupConfigurationResult") ETag;
									}
							}
						}
						
				}
				
				XmlTag("GetRollupConfigurationResponse") ETag;
			}
	}
}

//
// ComplexType RollupConfiguration
//
Struct WSUSSSsdRollupConfiguration
{
	struct DoDetailedRollup = this.DoDetailedRollup
	{
		[Post.Local.DoDetailedRollup_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("DoDetailedRollup") STag;
		switch
		{
			Case !Local.DoDetailedRollup_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) DoDetailedRollup;
					XmlTag("DoDetailedRollup") ETag;
				}
		}
	}
	
	struct RollupResetGuid = this.STag.ToString
	{
		[Post.Local.RollupResetGuid_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("RollupResetGuid") STag;
		switch
		{
			Case !Local.RollupResetGuid_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) RollupResetGuid;
					XmlTag("RollupResetGuid") ETag;
				}
		}
	}
	
	struct ServerId = this.STag.ToString
	{
		[Post.Local.ServerId_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("ServerId") STag;
		switch
		{
			Case !Local.ServerId_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) ServerId;
					XmlTag("ServerId") ETag;
				}
		}
	}
	
	struct RollupDownstreamServersMaxBatchSize = this.RollupDownstreamServersMaxBatchSize
	{
		[Post.Local.RollupDownstreamServersMaxBatchSize_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("RollupDownstreamServersMaxBatchSize") STag;
		switch
		{
			Case !Local.RollupDownstreamServersMaxBatchSize_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) RollupDownstreamServersMaxBatchSize;
					XmlTag("RollupDownstreamServersMaxBatchSize") ETag;
				}
		}
	}
	
	struct RollupComputersMaxBatchSize = this.RollupComputersMaxBatchSize
	{
		[Post.Local.RollupComputersMaxBatchSize_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("RollupComputersMaxBatchSize") STag;
		switch
		{
			Case !Local.RollupComputersMaxBatchSize_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) RollupComputersMaxBatchSize;
					XmlTag("RollupComputersMaxBatchSize") ETag;
				}
		}
	}
	
	struct GetOutOfSyncComputersMaxBatchSize = this.GetOutOfSyncComputersMaxBatchSize
	{
		[Post.Local.GetOutOfSyncComputersMaxBatchSize_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("GetOutOfSyncComputersMaxBatchSize") STag;
		switch
		{
			Case !Local.GetOutOfSyncComputersMaxBatchSize_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) GetOutOfSyncComputersMaxBatchSize;
					XmlTag("GetOutOfSyncComputersMaxBatchSize") ETag;
				}
		}
	}
	
	struct RollupComputerStatusMaxBatchSize = this.RollupComputerStatusMaxBatchSize
	{
		[Post.Local.RollupComputerStatusMaxBatchSize_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("RollupComputerStatusMaxBatchSize") STag;
		switch
		{
			Case !Local.RollupComputerStatusMaxBatchSize_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) RollupComputerStatusMaxBatchSize;
					XmlTag("RollupComputerStatusMaxBatchSize") ETag;
				}
		}
	}
	
}

struct WSUSSSRollupComputers = FormatString("%s Message", Property.WSUSSSRollupComputersSummary)
{
	[Post.Local.WSUSSSRollupComputers_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.WSUSSSRollupComputers_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RollupComputersResponse"):
						[Property.WSUSSSRollupComputersSummary = "RollupComputers Response"]
						WSUSSSsdRollupComputersResponseElement RollupComputersResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RollupComputers"):
						[Property.WSUSSSRollupComputersSummary = "RollupComputers Request"]
						WSUSSSsdRollupComputersElement RollupComputers;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.WSUSSSRollupComputersSummary = "Fault RollupComputers Response"]
						SoapFaultElement FaultRollupComputersElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WSUSSSRollupComputersSummary = "Encrypted RollupComputers Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

//
// Element RollupComputersResponse
// Embedded ComplexType 
//
struct WSUSSSsdRollupComputersResponseElement = this.STag.ToString
{
	[Post.Local.WSUSSSsdRollupComputersResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("RollupComputersResponse") STag;
	switch
	{
		Case !Local.WSUSSSsdRollupComputersResponseElement_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RollupComputersResult") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct RollupComputersResult = this.STag.ToString
						{
							[Post.Local.RollupComputersResult_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("RollupComputersResult") STag;
							switch
							{
								Case !Local.RollupComputersResult_IsEmpty:
									struct
									{
										WSUSSSsdArrayOfChangedComputer RollupComputersResult;
										XmlTag("RollupComputersResult") ETag;
									}
							}
						}
						
				}
				
				XmlTag("RollupComputersResponse") ETag;
			}
	}
}

//
// ComplexType ArrayOfChangedComputer
//
Struct WSUSSSsdArrayOfChangedComputer
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ChangedComputer") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct ChangedComputer = this.STag.ToString
		{
			[Post.Local.ChangedComputer_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("ChangedComputer") STag;
			switch
			{
				Case !Local.ChangedComputer_IsEmpty:
					XmlTag("ChangedComputer") ETag;
			}
		}
		
	}
}

//
// Element RollupComputers
// Embedded ComplexType 
//
struct WSUSSSsdRollupComputersElement = this.STag.ToString
{
	[Post.Local.WSUSSSsdRollupComputersElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("RollupComputers") STag;
	switch
	{
		Case !Local.WSUSSSsdRollupComputersElement_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "cookie") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct Cookie = this.STag.ToString
						{
							[Post.Local.Cookie_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("cookie") STag;
							switch
							{
								Case !Local.Cookie_IsEmpty:
									struct
									{
										WSUSSSsdCookie Cookie;
										XmlTag("cookie") ETag;
									}
							}
						}
						
				}
				
				struct ClientTime = this.ClientTime
				{
					[Post.Local.ClientTime_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("clientTime") STag;
					switch
					{
						Case !Local.ClientTime_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) ClientTime;
								XmlTag("clientTime") ETag;
							}
					}
				}
				
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "computers") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct Computers = this.STag.ToString
						{
							[Post.Local.Computers_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("computers") STag;
							switch
							{
								Case !Local.Computers_IsEmpty:
									struct
									{
										WSUSSSsdArrayOfComputerRollupInfo Computers;
										XmlTag("computers") ETag;
									}
							}
						}
						
				}
				
				XmlTag("RollupComputers") ETag;
			}
	}
}

//
// ComplexType ArrayOfComputerRollupInfo
//
Struct WSUSSSsdArrayOfComputerRollupInfo
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ComputerRollupInfo") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct ComputerRollupInfo = this.STag.ToString
		{
			[Post.Local.ComputerRollupInfo_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("ComputerRollupInfo") STag;
			switch
			{
				Case !Local.ComputerRollupInfo_IsEmpty:
					struct
					{
						WSUSSSsdComputerRollupInfo ComputerRollupInfo;
						XmlTag("ComputerRollupInfo") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType ComputerRollupInfo
//
Struct WSUSSSsdComputerRollupInfo
{
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Details") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct Details = this.STag.ToString
			{
				[Post.Local.Details_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("Details") STag;
				switch
				{
					Case !Local.Details_IsEmpty:
						struct
						{
							WSUSSSsdComputerRollupDetails Details;
							XmlTag("Details") ETag;
						}
				}
			}
			
	}
	
}

//
// ComplexType ComputerRollupDetails
//
Struct WSUSSSsdComputerRollupDetails
{
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "TargetGroupIdList") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct TargetGroupIdList = this.STag.ToString
			{
				[Post.Local.TargetGroupIdList_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("TargetGroupIdList") STag;
				switch
				{
					Case !Local.TargetGroupIdList_IsEmpty:
						struct
						{
							WSUSSSsdArrayOfGuid TargetGroupIdList;
							XmlTag("TargetGroupIdList") ETag;
						}
				}
			}
			
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RequestedTargetGroupNames") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct RequestedTargetGroupNames = this.STag.ToString
			{
				[Post.Local.RequestedTargetGroupNames_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("RequestedTargetGroupNames") STag;
				switch
				{
					Case !Local.RequestedTargetGroupNames_IsEmpty:
						struct
						{
							WSUSSSsdArrayOfString RequestedTargetGroupNames;
							XmlTag("RequestedTargetGroupNames") ETag;
						}
				}
			}
			
	}
	
}

struct WSUSSSGetOutOfSyncComputers = FormatString("%s Message", Property.WSUSSSGetOutOfSyncComputersSummary)
{
	[Post.Local.WSUSSSGetOutOfSyncComputers_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.WSUSSSGetOutOfSyncComputers_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetOutOfSyncComputersResponse"):
						[Property.WSUSSSGetOutOfSyncComputersSummary = "GetOutOfSyncComputers Response"]
						WSUSSSsdGetOutOfSyncComputersResponseElement GetOutOfSyncComputersResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetOutOfSyncComputers"):
						[Property.WSUSSSGetOutOfSyncComputersSummary = "GetOutOfSyncComputers Request"]
						WSUSSSsdGetOutOfSyncComputersElement GetOutOfSyncComputers;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.WSUSSSGetOutOfSyncComputersSummary = "Fault GetOutOfSyncComputers Response"]
						SoapFaultElement FaultGetOutOfSyncComputersElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WSUSSSGetOutOfSyncComputersSummary = "Encrypted GetOutOfSyncComputers Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

//
// Element GetOutOfSyncComputersResponse
// Embedded ComplexType 
//
struct WSUSSSsdGetOutOfSyncComputersResponseElement = this.STag.ToString
{
	[Post.Local.WSUSSSsdGetOutOfSyncComputersResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("GetOutOfSyncComputersResponse") STag;
	switch
	{
		Case !Local.WSUSSSsdGetOutOfSyncComputersResponseElement_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "GetOutOfSyncComputersResult") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct GetOutOfSyncComputersResult = this.STag.ToString
						{
							[Post.Local.GetOutOfSyncComputersResult_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("GetOutOfSyncComputersResult") STag;
							switch
							{
								Case !Local.GetOutOfSyncComputersResult_IsEmpty:
									struct
									{
										WSUSSSsdArrayOfString GetOutOfSyncComputersResult;
										XmlTag("GetOutOfSyncComputersResult") ETag;
									}
							}
						}
						
				}
				
				XmlTag("GetOutOfSyncComputersResponse") ETag;
			}
	}
}

//
// Element GetOutOfSyncComputers
// Embedded ComplexType 
//
struct WSUSSSsdGetOutOfSyncComputersElement = this.STag.ToString
{
	[Post.Local.WSUSSSsdGetOutOfSyncComputersElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("GetOutOfSyncComputers") STag;
	switch
	{
		Case !Local.WSUSSSsdGetOutOfSyncComputersElement_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "cookie") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct Cookie = this.STag.ToString
						{
							[Post.Local.Cookie_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("cookie") STag;
							switch
							{
								Case !Local.Cookie_IsEmpty:
									struct
									{
										WSUSSSsdCookie Cookie;
										XmlTag("cookie") ETag;
									}
							}
						}
						
				}
				
				struct ParentServerId = this.STag.ToString
				{
					[Post.Local.ParentServerId_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("parentServerId") STag;
					switch
					{
						Case !Local.ParentServerId_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) ParentServerId;
								XmlTag("parentServerId") ETag;
							}
					}
				}
				
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "lastRollupNumbers") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct LastRollupNumbers = this.STag.ToString
						{
							[Post.Local.LastRollupNumbers_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("lastRollupNumbers") STag;
							switch
							{
								Case !Local.LastRollupNumbers_IsEmpty:
									struct
									{
										WSUSSSsdArrayOfComputerLastRollupNumber LastRollupNumbers;
										XmlTag("lastRollupNumbers") ETag;
									}
							}
						}
						
				}
				
				XmlTag("GetOutOfSyncComputers") ETag;
			}
	}
}

//
// ComplexType ArrayOfString
//
Struct WSUSSSsdArrayOfString
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "string") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct String = this.String
		{
			[Post.Local.String_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("string") STag;
			switch
			{
				Case !Local.String_IsEmpty:
					struct
					{
						StringTerm(Property.XMLEncoding, "<", true, false, false) String;
						XmlTag("string") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType ArrayOfComputerLastRollupNumber
//
Struct WSUSSSsdArrayOfComputerLastRollupNumber
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ComputerLastRollupNumber") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct ComputerLastRollupNumber = this.STag.ToString
		{
			[Post.Local.ComputerLastRollupNumber_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("ComputerLastRollupNumber") STag;
			switch
			{
				Case !Local.ComputerLastRollupNumber_IsEmpty:
					struct
					{
						WSUSSSsdComputerLastRollupNumber ComputerLastRollupNumber;
						XmlTag("ComputerLastRollupNumber") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType ComputerLastRollupNumber
//
Struct WSUSSSsdComputerLastRollupNumber
{
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ComputerId") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct ComputerId = this.ComputerId
			{
				[Post.Local.ComputerId_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("ComputerId") STag;
				switch
				{
					Case !Local.ComputerId_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) ComputerId;
							XmlTag("ComputerId") ETag;
						}
				}
			}
			
	}
	
	struct RollupNumber = this.RollupNumber
	{
		[Post.Local.RollupNumber_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("RollupNumber") STag;
		switch
		{
			Case !Local.RollupNumber_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) RollupNumber;
					XmlTag("RollupNumber") ETag;
				}
		}
	}
	
}

struct WSUSSSRollupComputerStatus = FormatString("%s Message", Property.WSUSSSRollupComputerStatusSummary)
{
	[Post.Local.WSUSSSRollupComputerStatus_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("Body") STag;
	switch
	{
		Case !Local.WSUSSSRollupComputerStatus_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RollupComputerStatusResponse"):
						[Property.WSUSSSRollupComputerStatusSummary = "RollupComputerStatus Response"]
						WSUSSSsdRollupComputerStatusResponseElement RollupComputerStatusResponse;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "RollupComputerStatus"):
						[Property.WSUSSSRollupComputerStatusSummary = "RollupComputerStatus Request"]
						WSUSSSsdRollupComputerStatusElement RollupComputerStatus;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "Fault"):
						[Property.WSUSSSRollupComputerStatusSummary = "Fault RollupComputerStatus Response"]
						SoapFaultElement FaultRollupComputerStatusElement;
					Case Contains(StringTerm(FrameData, FrameOffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "EncryptedData"):
						[Property.WSUSSSRollupComputerStatusSummary = "Encrypted RollupComputerStatus Data"]
						XMLENCEncryptedData EncryptedData;
					Default:
						While ElementNodes[String(FrameData, FrameOffset, Property.XMLEncoding, 1) == "<" && String(FrameData, FrameOffset, Property.XMLEncoding, 2) != "</"]
						{
							XmlElement(true) AnyNode;
						}
				}
				
				XmlTag("Body") ETag;
			}
	}
}

//
// Element RollupComputerStatusResponse
// Embedded ComplexType 
//
struct WSUSSSsdRollupComputerStatusResponseElement = this.STag.ToString
{
	[Post.Local.WSUSSSsdRollupComputerStatusResponseElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("RollupComputerStatusResponse") STag;
	switch
	{
		Case !Local.WSUSSSsdRollupComputerStatusResponseElement_IsEmpty:
			struct
			{
				struct RollupComputerStatusResult = this.RollupComputerStatusResult
				{
					[Post.Local.RollupComputerStatusResult_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("RollupComputerStatusResult") STag;
					switch
					{
						Case !Local.RollupComputerStatusResult_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) RollupComputerStatusResult;
								XmlTag("RollupComputerStatusResult") ETag;
							}
					}
				}
				
				XmlTag("RollupComputerStatusResponse") ETag;
			}
	}
}

//
// Element RollupComputerStatus
// Embedded ComplexType 
//
struct WSUSSSsdRollupComputerStatusElement = this.STag.ToString
{
	[Post.Local.WSUSSSsdRollupComputerStatusElement_IsEmpty = Property.IsXmlEmptyElement]
	XmlTag("RollupComputerStatus") STag;
	switch
	{
		Case !Local.WSUSSSsdRollupComputerStatusElement_IsEmpty:
			struct
			{
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "cookie") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct Cookie = this.STag.ToString
						{
							[Post.Local.Cookie_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("cookie") STag;
							switch
							{
								Case !Local.Cookie_IsEmpty:
									struct
									{
										WSUSSSsdCookie Cookie;
										XmlTag("cookie") ETag;
									}
							}
						}
						
				}
				
				struct ClientTime = this.ClientTime
				{
					[Post.Local.ClientTime_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("clientTime") STag;
					switch
					{
						Case !Local.ClientTime_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) ClientTime;
								XmlTag("clientTime") ETag;
							}
					}
				}
				
				struct ParentServerId = this.STag.ToString
				{
					[Post.Local.ParentServerId_IsEmpty = Property.IsXmlEmptyElement]
					XmlTag("parentServerId") STag;
					switch
					{
						Case !Local.ParentServerId_IsEmpty:
							struct
							{
								StringTerm(Property.XMLEncoding, "<", true, false, false) ParentServerId;
								XmlTag("parentServerId") ETag;
							}
					}
				}
				
				Switch
				{
					Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "computers") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
						struct Computers = this.STag.ToString
						{
							[Post.Local.Computers_IsEmpty = Property.IsXmlEmptyElement]
							XmlTag("computers") STag;
							switch
							{
								Case !Local.Computers_IsEmpty:
									struct
									{
										WSUSSSsdArrayOfComputerStatusRollupInfo Computers;
										XmlTag("computers") ETag;
									}
							}
						}
						
				}
				
				XmlTag("RollupComputerStatus") ETag;
			}
	}
}

//
// ComplexType ArrayOfComputerStatusRollupInfo
//
Struct WSUSSSsdArrayOfComputerStatusRollupInfo
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ComputerStatusRollupInfo") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct ComputerStatusRollupInfo = this.STag.ToString
		{
			[Post.Local.ComputerStatusRollupInfo_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("ComputerStatusRollupInfo") STag;
			switch
			{
				Case !Local.ComputerStatusRollupInfo_IsEmpty:
					struct
					{
						WSUSSSsdComputerStatusRollupInfo ComputerStatusRollupInfo;
						XmlTag("ComputerStatusRollupInfo") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType ComputerStatusRollupInfo
//
Struct WSUSSSsdComputerStatusRollupInfo
{
	struct InstanceId = this.STag.ToString
	{
		[Post.Local.InstanceId_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("InstanceId") STag;
		switch
		{
			Case !Local.InstanceId_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) InstanceId;
					XmlTag("InstanceId") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ComputerId") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct ComputerId = this.ComputerId
			{
				[Post.Local.ComputerId_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("ComputerId") STag;
				switch
				{
					Case !Local.ComputerId_IsEmpty:
						struct
						{
							StringTerm(Property.XMLEncoding, "<", true, false, false) ComputerId;
							XmlTag("ComputerId") ETag;
						}
				}
			}
			
	}
	
	struct EffectiveLastDetectionTime = this.EffectiveLastDetectionTime
	{
		[Post.Local.EffectiveLastDetectionTime_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("EffectiveLastDetectionTime") STag;
		switch
		{
			Case !Local.EffectiveLastDetectionTime_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) EffectiveLastDetectionTime;
					XmlTag("EffectiveLastDetectionTime") ETag;
				}
		}
	}
	
	struct RollupNumber = this.RollupNumber
	{
		[Post.Local.RollupNumber_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("RollupNumber") STag;
		switch
		{
			Case !Local.RollupNumber_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) RollupNumber;
					XmlTag("RollupNumber") ETag;
				}
		}
	}
	
	struct IsFullRollup = this.IsFullRollup
	{
		[Post.Local.IsFullRollup_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("IsFullRollup") STag;
		switch
		{
			Case !Local.IsFullRollup_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) IsFullRollup;
					XmlTag("IsFullRollup") ETag;
				}
		}
	}
	
	Switch
	{
		Case Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "UpdateStatus") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</"):
			struct UpdateStatus = this.STag.ToString
			{
				[Post.Local.UpdateStatus_IsEmpty = Property.IsXmlEmptyElement]
				XmlTag("UpdateStatus") STag;
				switch
				{
					Case !Local.UpdateStatus_IsEmpty:
						struct
						{
							WSUSSSsdArrayOfComputerStatusRollupUpdateStatus UpdateStatus;
							XmlTag("UpdateStatus") ETag;
						}
				}
			}
			
	}
	
}

//
// ComplexType ArrayOfComputerStatusRollupUpdateStatus
//
Struct WSUSSSsdArrayOfComputerStatusRollupUpdateStatus
{
	While [Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "ComputerStatusRollupUpdateStatus") && !Contains(StringTerm(Framedata, Frameoffset, Property.XMLEncoding, Property.XMLElementNameTerm, true, false, false), "</")]
	{
		struct ComputerStatusRollupUpdateStatus = this.STag.ToString
		{
			[Post.Local.ComputerStatusRollupUpdateStatus_IsEmpty = Property.IsXmlEmptyElement]
			XmlTag("ComputerStatusRollupUpdateStatus") STag;
			switch
			{
				Case !Local.ComputerStatusRollupUpdateStatus_IsEmpty:
					struct
					{
						WSUSSSsdComputerStatusRollupUpdateStatus ComputerStatusRollupUpdateStatus;
						XmlTag("ComputerStatusRollupUpdateStatus") ETag;
					}
			}
		}
		
	}
}

//
// ComplexType ComputerStatusRollupUpdateStatus
//
Struct WSUSSSsdComputerStatusRollupUpdateStatus
{
	struct UpdateId = this.STag.ToString
	{
		[Post.Local.UpdateId_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("UpdateId") STag;
		switch
		{
			Case !Local.UpdateId_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) UpdateId;
					XmlTag("UpdateId") ETag;
				}
		}
	}
	
	struct SummarizationState = this.SummarizationState
	{
		[Post.Local.SummarizationState_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("SummarizationState") STag;
		switch
		{
			Case !Local.SummarizationState_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) SummarizationState;
					XmlTag("SummarizationState") ETag;
				}
		}
	}
	
	struct LastChangeTime = this.LastChangeTime
	{
		[Post.Local.LastChangeTime_IsEmpty = Property.IsXmlEmptyElement]
		XmlTag("LastChangeTime") STag;
		switch
		{
			Case !Local.LastChangeTime_IsEmpty:
				struct
				{
					StringTerm(Property.XMLEncoding, "<", true, false, false) LastChangeTime;
					XmlTag("LastChangeTime") ETag;
				}
		}
	}
	
}

Table WSUSSSSoapActionTable(value)
{
	Switch(value)
	{
		Case "http://www.microsoft.com/SoftwareDistribution/GetAuthConfig": 
		Case "http://www.microsoft.com/SoftwareDistribution/Server/DssAuthWebService/GetAuthorizationCookie":
		Case "http://www.microsoft.com/SoftwareDistribution/GetCookie": 
		Case "http://www.microsoft.com/SoftwareDistribution/GetConfigData": 
		Case "http://www.microsoft.com/SoftwareDistribution/GetRevisionIdList": 
		Case "http://www.microsoft.com/SoftwareDistribution/GetUpdateData": 
		Case "http://www.microsoft.com/SoftwareDistribution/GetDeployments":
		Case "http://www.microsoft.com/SoftwareDistribution/DownloadFiles": 
		Case "http://www.microsoft.com/SoftwareDistribution/GetRollupConfiguration":
		Case "http://www.microsoft.com/SoftwareDistribution/RollupDownstreamServers":
		Case "http://www.microsoft.com/SoftwareDistribution/RollupComputerStatus":
		Case "http://www.microsoft.com/SoftwareDistribution/RollupComputers":
		Case "http://www.microsoft.com/SoftwareDistribution/GetOutOfSyncComputers":
			 true;
		Default:false;
	}
}